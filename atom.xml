<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>klklkl&#39;s blogs</title>
  
  <subtitle>学习笔记和一些思考</subtitle>
  <link href="https://klklkl10086.github.io/klklkl10086.github.io/atom.xml" rel="self"/>
  
  <link href="https://klklkl10086.github.io/klklkl10086.github.io/"/>
  <updated>2026-01-03T10:19:48.363Z</updated>
  <id>https://klklkl10086.github.io/klklkl10086.github.io/</id>
  
  <author>
    <name>klklkl</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从0实现Transformer</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2025/12/07/%E4%BB%8E0%E5%AE%9E%E7%8E%B0LLM/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2025/12/07/%E4%BB%8E0%E5%AE%9E%E7%8E%B0LLM/</id>
    <published>2025-12-07T13:07:22.000Z</published>
    <updated>2026-01-03T10:19:48.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从0实现transformer">从0实现Transformer</h1><blockquote><p><a href="https://space.bilibili.com/3546611527453161/lists/2386239?type=season">大模型《从零到一》长视频系列</a></p></blockquote><h2 id="基本知识">基本知识</h2><figure><img src="深度学习_0.jpg" alt="深度学习_0" /><figcaption aria-hidden="true">深度学习_0</figcaption></figure><figure><img src="深度学习_1.jpg" alt="深度学习_1" /><figcaption aria-hidden="true">深度学习_1</figcaption></figure><figure><img src="深度学习_2.jpg" alt="深度学习_2" /><figcaption aria-hidden="true">深度学习_2</figcaption></figure><h2 id="代码">代码</h2><blockquote><p>1.实现的是解码器结构的Transformer而非原始论文的encode-decode</p><p>2.和原始论文不太一样,并且存在许多隐含错误</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Decoder-Only  transformer</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> tiktoken</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 超参数</span></span><br><span class="line">batch_size = <span class="number">4</span></span><br><span class="line">context_len = <span class="number">16</span></span><br><span class="line">d_model = <span class="number">64</span>  <span class="comment"># 每个token的维度</span></span><br><span class="line">num_blocks = <span class="number">8</span> <span class="comment">#循环多少次</span></span><br><span class="line">num_heads = <span class="number">4</span> <span class="comment">#分为几个头</span></span><br><span class="line">learning_rate = <span class="number">1e-3</span></span><br><span class="line">dropout = <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line">max_iters = <span class="number">5000</span><span class="comment">#迭代多少次</span></span><br><span class="line">eval_interval = <span class="number">50</span></span><br><span class="line">eval_iters = <span class="number">20</span></span><br><span class="line">device = <span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span></span><br><span class="line">TORCH_SEED = <span class="number">1337</span></span><br><span class="line">torch.manual_seed(TORCH_SEED)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># get dataset</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;/home/lizy/graduate/Transformer_learning/sales_textbook.txt&#x27;</span>):</span><br><span class="line">    url = <span class="string">&#x27;https://huggingface.co/datasets/goendalf666/sales-textbook_for_convincing_and_selling/raw/main/sales_textbook.txt&#x27;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/home/lizy/graduate/Transformer_learning/sales_textbook.txt&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(requests.get(url).content)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/home/lizy/graduate/Transformer_learning/sales_textbook.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    text = f.read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">encoding = tiktoken.get_encoding(<span class="string">&quot;cl100k_base&quot;</span>)</span><br><span class="line">vocab_size = encoding.n_vocab  <span class="comment"># tiktoken的词汇表大小</span></span><br><span class="line"></span><br><span class="line">tokenized_text = encoding.encode(text)</span><br><span class="line"><span class="comment"># max_token_value = tokenized_text.max().item() + 1</span></span><br><span class="line">tokenized_text=torch.tensor(tokenized_text,dtype=torch.long,device=device)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">train_idex = <span class="built_in">int</span>(<span class="built_in">len</span>(tokenized_text) * <span class="number">0.9</span>)</span><br><span class="line">train_data = tokenized_text[:train_idex]</span><br><span class="line">valid_data = tokenized_text[train_idex:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FeedforwardNetwork</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,d_model,d_ff</span>):</span><br><span class="line">        <span class="built_in">super</span>(FeedforwardNetwork,self).__init__()</span><br><span class="line">        self.linear1 = nn.Linear(d_model,d_ff)</span><br><span class="line">        self.ReLU = nn.ReLU()</span><br><span class="line">        self.linear2 = nn.Linear(d_ff,d_model)</span><br><span class="line">        self.dropout = nn.Dropout(dropout)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        x=self.linear1(x)</span><br><span class="line">        x=self.ReLU(x)</span><br><span class="line">        x=self.linear2(x)</span><br><span class="line">        x=self.dropout(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScaledDotProductAttention</span>(nn.Module):  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.Wq = nn.Linear(d_model,d_model//num_heads)</span><br><span class="line">        self.Wk = nn.Linear(d_model,d_model//num_heads)</span><br><span class="line">        self.Wv = nn.Linear(d_model,d_model//num_heads)</span><br><span class="line"></span><br><span class="line">        self.register_buffer(<span class="string">&#x27;mask&#x27;</span>,torch.tril(torch.ones(context_len,context_len)))</span><br><span class="line">        self.dropout = nn.Dropout(dropout)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line"></span><br><span class="line">        B, T, C = x.shape  <span class="comment"># Batch size, Time steps(current context_length), Channels(dimensions)</span></span><br><span class="line">        <span class="keyword">assert</span> T &lt;= context_len</span><br><span class="line">        <span class="keyword">assert</span> C == d_model</span><br><span class="line"></span><br><span class="line">        Q = self.Wq(x)</span><br><span class="line">        K = self.Wk(x)</span><br><span class="line">        V = self.Wv(x)</span><br><span class="line">        <span class="comment">#单头注意力</span></span><br><span class="line">        attention = Q @ K.transpose(-<span class="number">2</span>,-<span class="number">1</span>) / math.sqrt(d_model//num_heads)</span><br><span class="line">        attention = attention.masked_fill(self.mask[:T, :T] == <span class="number">0</span>, <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>))</span><br><span class="line">        attention = F.softmax(attention,dim=-<span class="number">1</span>)</span><br><span class="line">        attention = self.dropout(attention)</span><br><span class="line">        <span class="keyword">return</span> attention @ V  <span class="comment">#signal head output  (B,T,head_dim)</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiHeadAttention</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.heads = nn.ModuleList([ScaledDotProductAttention() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_heads)]) <span class="comment">#多头</span></span><br><span class="line">        self.projection_layer = nn.Linear(d_model,d_model)</span><br><span class="line">        self.dropout = nn.Dropout(dropout)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        heads_output =  [head(x) <span class="keyword">for</span> head <span class="keyword">in</span> self.heads]</span><br><span class="line">        out = torch.cat(heads_output,dim=-<span class="number">1</span>)</span><br><span class="line">        out = self.projection_layer(out)</span><br><span class="line">        out = self.dropout(out)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransformerBlock</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.multi_head_attention_layer = MultiHeadAttention()</span><br><span class="line">        self.ffn = FeedforwardNetwork(d_model,d_model*<span class="number">4</span>)</span><br><span class="line">        self.layer_norm_1=nn.LayerNorm(d_model)</span><br><span class="line">        self.layer_norm_2=nn.LayerNorm(d_model)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        x = x + self.multi_head_attention_layer(x)</span><br><span class="line">        x = self.layer_norm_1(x)</span><br><span class="line">        x = x + self.ffn(x)</span><br><span class="line">        x = self.layer_norm_2(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransformerLanguageModel</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="comment">#self.token_embedding_lookup_table = nn.Embedding(max_token_value+1,d_model)</span></span><br><span class="line">        <span class="comment"># 应该使用tokenizer的实际词汇表大小</span></span><br><span class="line">        self.token_embedding_lookup_table = nn.Embedding(vocab_size, d_model)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        self.transformer_blocks = nn.Sequential(*(</span><br><span class="line">            [TransformerBlock() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_blocks)]</span><br><span class="line">           <span class="comment"># + [nn.LayerNorm(d_model)]#Different from original paper, here we add a final layer norm after all the blocks</span></span><br><span class="line">        ))</span><br><span class="line"></span><br><span class="line">        self.language_model_out_linear_layer = nn.Linear(d_model,vocab_size)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,idx,targets=<span class="literal">None</span></span>):</span><br><span class="line">        B , T = idx.shape</span><br><span class="line"></span><br><span class="line">        position_encoding_lookup_table = torch.zeros(context_len,d_model)</span><br><span class="line">        position = torch.arange(<span class="number">0</span>,context_len,dtype=torch.<span class="built_in">float</span>).unsqueeze(<span class="number">1</span>)</span><br><span class="line">        div_term = torch.exp(torch.arange(<span class="number">0</span>, d_model, <span class="number">2</span>).<span class="built_in">float</span>() * (-math.log(<span class="number">10000.0</span>) / d_model))</span><br><span class="line">        position_encoding_lookup_table[:, <span class="number">0</span>::<span class="number">2</span>] = torch.sin(position * div_term)</span><br><span class="line">        position_encoding_lookup_table[:, <span class="number">1</span>::<span class="number">2</span>] = torch.cos(position * div_term)</span><br><span class="line"></span><br><span class="line">        position_embedding = position_encoding_lookup_table[:T, :].to(device)</span><br><span class="line"></span><br><span class="line">        x = self.token_embedding_lookup_table(idx) + position_embedding</span><br><span class="line">        x = self.transformer_blocks(x)</span><br><span class="line"></span><br><span class="line">        logits = self.language_model_out_linear_layer(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> targets <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            B, T, C = logits.shape</span><br><span class="line">            logits_reshaped = logits.view(B * T, C)</span><br><span class="line">            targets_reshaped = targets.view(B * T)</span><br><span class="line">            loss = F.cross_entropy(<span class="built_in">input</span>=logits_reshaped, target=targets_reshaped)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            loss = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> logits, loss</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">self,idx,max_new_tokens</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        max_new_tokens:表示要生成的新token的数量</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># idx is (B,T) array of indices in the current context</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(max_new_tokens):</span><br><span class="line">            </span><br><span class="line">            idx_crop = idx[:, -context_len:] <span class="comment">#取最后context_len个token</span></span><br><span class="line">        </span><br><span class="line">            logits, loss = self(idx_crop)</span><br><span class="line">            <span class="comment"># Get the last time step from logits where the dimensions of the logits are (B,T,C)</span></span><br><span class="line">            logits_last_timestep = logits[:, -<span class="number">1</span>, :]</span><br><span class="line">            </span><br><span class="line">            probs = F.softmax(<span class="built_in">input</span>=logits_last_timestep, dim=-<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            idx_next = torch.multinomial(<span class="built_in">input</span>=probs, num_samples=<span class="number">1</span>) <span class="comment">#根据模型预测的概率分布，随机选择一个token作为下一个生成的词。</span></span><br><span class="line">            <span class="comment"># Append the sampled indexes idx_next to idx</span></span><br><span class="line">            idx = torch.cat((idx, idx_next), dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> idx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = TransformerLanguageModel()</span><br><span class="line">model = model.to(device)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_batch</span>(<span class="params">split</span>):</span><br><span class="line">    data = train_data <span class="keyword">if</span> split == <span class="string">&#x27;train&#x27;</span> <span class="keyword">else</span> valid_data</span><br><span class="line">    idxs = torch.randint(low=<span class="number">0</span>, high=<span class="built_in">len</span>(data) - context_len, size=(batch_size,))</span><br><span class="line">    x = torch.stack([data[idx:idx + context_len] <span class="keyword">for</span> idx <span class="keyword">in</span> idxs]).to(device)</span><br><span class="line">    y = torch.stack([data[idx + <span class="number">1</span>:idx + context_len + <span class="number">1</span>] <span class="keyword">for</span> idx <span class="keyword">in</span> idxs]).to(device)</span><br><span class="line">    <span class="keyword">return</span> x, y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Calculate loss</span></span><br><span class="line"><span class="meta">@torch.no_grad()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">estimate_loss</span>():</span><br><span class="line">    out = &#123;&#125;</span><br><span class="line">    model.<span class="built_in">eval</span>() <span class="comment"># 用于将模型设置为评估模式</span></span><br><span class="line">    <span class="keyword">for</span> split <span class="keyword">in</span> [<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;valid&#x27;</span>]:</span><br><span class="line">        losses = torch.zeros(eval_iters)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(eval_iters):</span><br><span class="line">            x_batch, y_batch = get_batch(split)</span><br><span class="line">            logits, loss = model(x_batch, y_batch)</span><br><span class="line">            losses[k] = loss.item()</span><br><span class="line">        out[split] = losses.mean()</span><br><span class="line">    model.train()</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练</span></span><br><span class="line">optimizer = torch.optim.AdamW(params=model.parameters(), lr=learning_rate)</span><br><span class="line">tracked_losses = <span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(max_iters):</span><br><span class="line">    <span class="keyword">if</span> step % eval_iters == <span class="number">0</span> <span class="keyword">or</span> step == max_iters - <span class="number">1</span>:</span><br><span class="line">        losses = estimate_loss()</span><br><span class="line">        tracked_losses.append(losses)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Step:&#x27;</span>, step, <span class="string">&#x27;Training Loss:&#x27;</span>, <span class="built_in">round</span>(losses[<span class="string">&#x27;train&#x27;</span>].item(), <span class="number">3</span>), <span class="string">&#x27;Validation Loss:&#x27;</span>,</span><br><span class="line">              <span class="built_in">round</span>(losses[<span class="string">&#x27;valid&#x27;</span>].item(), <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">    xb, yb = get_batch(<span class="string">&#x27;train&#x27;</span>)</span><br><span class="line">    logits, loss = model(xb, yb)</span><br><span class="line">    optimizer.zero_grad(set_to_none=<span class="literal">True</span>)</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save the model state dictionary</span></span><br><span class="line">torch.save(model.state_dict(), <span class="string">&#x27;model-ckpt.pt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate</span></span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line">start = <span class="string">&#x27;The salesperson&#x27;</span></span><br><span class="line">start_ids = encoding.encode(start)</span><br><span class="line">x = (torch.tensor(start_ids, dtype=torch.long, device=device)[<span class="literal">None</span>, ...])</span><br><span class="line">y = model.generate(x, max_new_tokens=<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;---------------&#x27;</span>)</span><br><span class="line"><span class="comment">#print(encoding.decode(y[0].tolist()))</span></span><br><span class="line"><span class="comment">#应对训练轮次过少时生成超出编码表范围的token编码</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    generated_text = encoding.decode(y[<span class="number">0</span>].tolist())</span><br><span class="line"><span class="keyword">except</span> KeyError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;解码时遇到无效token，尝试忽略: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># 忽略无效token</span></span><br><span class="line">    valid_tokens = []</span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> y[<span class="number">0</span>].tolist():</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 检查token是否有效</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= token &lt; vocab_size:</span><br><span class="line">                valid_tokens.append(token)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    generated_text = encoding.decode(valid_tokens)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;---------------&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="post-layernorm-vs-pre-layernorm">Post-LayerNorm vs Pre-LayerNorm</h2><blockquote><p>后来的 Transformer 模型确实普遍从原始的 <strong>Post-LayerNorm</strong> 改为 <strong>Pre-LayerNorm</strong></p></blockquote><h3 id="两种-layernorm-位置对比">两种 LayerNorm 位置对比</h3><p><strong>原始 Transformer（Post-LayerNorm）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原始论文的顺序：子层 → LayerNorm → 残差连接</span></span><br><span class="line">x = x + Sublayer(x)      <span class="comment"># 先计算子层输出</span></span><br><span class="line">x = LayerNorm(x)         <span class="comment"># 再归一化</span></span><br></pre></td></tr></table></figure><p><strong>现代 Transformer（Pre-LayerNorm）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 现代实现的顺序：LayerNorm → 子层 → 残差连接</span></span><br><span class="line">x_norm = LayerNorm(x)    <span class="comment"># 先归一化</span></span><br><span class="line">x = x + Sublayer(x_norm) <span class="comment"># 再计算子层并残差连接</span></span><br></pre></td></tr></table></figure><h3 id="为什么要改为-pre-layernorm">为什么要改为 Pre-LayerNorm？</h3><h4 id="主要原因-1训练稳定性大幅提升"><strong>主要原因 1：训练稳定性大幅提升</strong></h4><p><strong>Post-LayerNorm 的问题：</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 梯度流经的路径：</span></span><br><span class="line">损失 → 层归一化 → 子层 → 输入</span><br><span class="line"><span class="comment"># 梯度必须先通过层归一化，这可能导致：</span></span><br><span class="line"><span class="comment"># 1. 梯度消失/爆炸（尤其深层网络）</span></span><br><span class="line"><span class="comment"># 2. 需要精细的初始化</span></span><br><span class="line"><span class="comment"># 3. 学习率需要小心调整</span></span><br></pre></td></tr></table></figure></p><p><strong>Pre-LayerNorm 的优势：</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 梯度流经的路径：</span></span><br><span class="line">损失 → 子层 → 层归一化 → 输入</span><br><span class="line"><span class="comment"># 梯度直接通过子层，然后才到归一化</span></span><br><span class="line"><span class="comment"># 梯度流动更平滑，训练更稳定</span></span><br></pre></td></tr></table></figure></p><h4 id="主要原因-2收敛速度更快"><strong>主要原因 2：收敛速度更快</strong></h4><p><strong>实际效果对比：</strong> - <strong>Post-LayerNorm</strong>：可能需要更多训练步数才能收敛 - <strong>Pre-LayerNorm</strong>：通常收敛更快，需要的训练步数更少</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在代码中的表现</span></span><br><span class="line"><span class="comment"># Post-LayerNorm 可能需要：</span></span><br><span class="line">num_epochs = <span class="number">100</span>  <span class="comment"># 才能收敛</span></span><br><span class="line">learning_rate = <span class="number">1e-4</span>  <span class="comment"># 需要较小的学习率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pre-LayerNorm 可能只需要：</span></span><br><span class="line">num_epochs = <span class="number">50</span>   <span class="comment"># 更快收敛</span></span><br><span class="line">learning_rate = <span class="number">1e-3</span>  <span class="comment"># 可以使用更大的学习率</span></span><br></pre></td></tr></table></figure><h4 id="主要原因-3梯度传播更直接"><strong>主要原因 3：梯度传播更直接</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Post-LayerNorm 梯度路径：</span><br><span class="line">损失 → LN → Attention/FFN → 输入</span><br><span class="line">      ↓</span><br><span class="line">  梯度先经过LN的缩放操作</span><br><span class="line">  可能放大或缩小梯度值</span><br><span class="line">  </span><br><span class="line">Pre-LayerNorm 梯度路径：</span><br><span class="line">损失 → Attention/FFN → LN → 输入</span><br><span class="line">      ↓</span><br><span class="line">  梯度直接传到子层</span><br><span class="line">  LN只影响前向传播，不影响梯度回传</span><br></pre></td></tr></table></figure><h3 id="数学表达对比"><strong>数学表达对比</strong></h3><p><strong>Post-LayerNorm（原始）：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = LayerNorm(x + Sublayer(x))</span><br></pre></td></tr></table></figure><p><strong>Pre-LayerNorm（现代）：</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = x + Sublayer(LayerNorm(x))</span><br></pre></td></tr></table></figure></p><h3 id="梯度计算对比"><strong>梯度计算对比</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Post-LayerNorm 梯度链式法则：</span></span><br><span class="line">grad = ∂Loss/∂LN × ∂LN/∂Sublayer × ∂Sublayer/∂x</span><br><span class="line"><span class="comment"># LN的导数可能不稳定</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pre-LayerNorm 梯度链式法则：</span></span><br><span class="line">grad = ∂Loss/∂Sublayer × ∂Sublayer/∂LN × ∂LN/∂x</span><br><span class="line"><span class="comment"># 梯度更直接流向子层参数</span></span><br></pre></td></tr></table></figure><h3 id="学习曲线对比"><strong>学习曲线对比</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Post-LayerNorm 可能出现的训练曲线：</span></span><br><span class="line">损失值: [<span class="number">10.0</span>, <span class="number">8.5</span>, <span class="number">7.2</span>, <span class="number">6.8</span>, <span class="number">6.7</span>, <span class="number">6.6</span>, <span class="number">6.5</span>, <span class="number">6.5</span>, ...]  <span class="comment"># 下降缓慢，可能震荡</span></span><br><span class="line"><span class="comment"># 需要较小的学习率，可能需要warmup</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pre-LayerNorm 的训练曲线：</span></span><br><span class="line">损失值: [<span class="number">10.0</span>, <span class="number">5.2</span>, <span class="number">3.1</span>, <span class="number">2.0</span>, <span class="number">1.5</span>, <span class="number">1.2</span>, <span class="number">1.0</span>, <span class="number">0.9</span>, ...]  <span class="comment"># 快速下降，平稳收敛</span></span><br><span class="line"><span class="comment"># 可以使用较大的学习率</span></span><br></pre></td></tr></table></figure><h3 id="代码实现差异"><strong>代码实现差异</strong></h3><p><strong>Post-LayerNorm 需要更谨慎的初始化：</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原始Transformer需要特定的初始化</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_weights</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, nn.Linear):</span><br><span class="line">        nn.init.xavier_uniform_(m.weight, gain=<span class="number">0.02</span>)  <span class="comment"># 需要特定增益</span></span><br></pre></td></tr></table></figure></p><p><strong>Pre-LayerNorm 对初始化不敏感：</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pre-LayerNorm可以使用标准初始化</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_weights</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, nn.Linear):</span><br><span class="line">        nn.init.normal_(m.weight, mean=<span class="number">0.0</span>, std=<span class="number">0.02</span>)  <span class="comment"># 标准初始化即可</span></span><br></pre></td></tr></table></figure></p><h3 id="使用-pre-layernorm-的模型"><strong>使用 Pre-LayerNorm 的模型</strong></h3><ol type="1"><li><strong>GPT 系列</strong>（GPT-2, GPT-3, GPT-4）</li><li><strong>BERT 及其变体</strong></li><li><strong>T5</strong></li><li><strong>RoBERTa</strong></li><li><strong>ALBERT</strong></li><li><strong>大部分现代 Transformer 变体</strong></li></ol><h3 id="使用-post-layernorm-的模型"><strong>使用 Post-LayerNorm 的模型</strong></h3><ol type="1"><li><strong>原始 Transformer</strong>（2017）</li><li><strong>早期实验性模型</strong></li><li><strong>现在基本不再使用</strong></li></ol><h3 id="代码中的体现">代码中的体现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 类似Post-LayerNorm</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransformerBlock</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = x + self.multi_head_attention_layer(x)  <span class="comment"># 先计算</span></span><br><span class="line">        x = self.layer_norm_1(x)                     <span class="comment"># 后归一化</span></span><br><span class="line">        </span><br><span class="line">        x = x + self.ffn(x)                          <span class="comment"># 先计算</span></span><br><span class="line">        x = self.layer_norm_2(x)                     <span class="comment"># 后归一化</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pre-LayerNorm</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransformerBlock</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># 注意力部分</span></span><br><span class="line">        x_norm = self.layer_norm_1(x)                <span class="comment"># 先归一化</span></span><br><span class="line">        attention_out = self.multi_head_attention_layer(x_norm)</span><br><span class="line">        x = x + attention_out                         <span class="comment"># 再残差连接</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 前馈网络部分</span></span><br><span class="line">        x_norm = self.layer_norm_2(x)                <span class="comment"># 先归一化</span></span><br><span class="line">        ffn_out = self.ffn(x_norm)</span><br><span class="line">        x = x + ffn_out                              <span class="comment"># 再残差连接</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p><strong>从 Post-LayerNorm 改为 Pre-LayerNorm 的主要原因：</strong></p><ol type="1"><li><strong>训练稳定性</strong>：Pre-LayerNorm 大大减少了梯度问题</li><li><strong>收敛速度</strong>：训练更快，需要更少的迭代次数</li><li><strong>调参友好</strong>：对初始化和学习率不那么敏感</li><li><strong>扩展性</strong>：更容易训练深层和超大模型</li><li><strong>实际效果</strong>：在几乎所有任务上都表现更好</li></ol><p><strong>简单记忆</strong>：</p><ul><li><strong>Post-LayerNorm</strong>：像"先做事，再整理" - 容易混乱</li><li><strong>Pre-LayerNorm</strong>：像"先整理，再做事" - 更有条理</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;从0实现transformer&quot;&gt;从0实现Transformer&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://space.bilibili.com/3546611527453161/lists/2386239?type=seas</summary>
      
    
    
    
    <category term="研究生补完" scheme="https://klklkl10086.github.io/klklkl10086.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%A1%A5%E5%AE%8C/"/>
    
    
    <category term="深度学习" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Transformer" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/Transformer/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch深度学习实践</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2025/11/27/pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2025/11/27/pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5/</id>
    <published>2025-11-27T14:15:20.000Z</published>
    <updated>2025-12-07T09:18:58.852Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.bilibili.com/video/BV1Y7411d7Ys/?p=3&amp;share_source=copy_web&amp;vd_source=777aaa8a415b68222e598d976e64642c">《PyTorch深度学习实践》完结合集</a></p><p><a href="https://www.bilibili.com/video/BV1hE411t7RN/?p=22&amp;share_source=copy_web&amp;vd_source=777aaa8a415b68222e598d976e64642c">PyTorch深度学习快速入门教程</a></p></blockquote><h1 id="线性模型">线性模型</h1><h2 id="穷举法">穷举法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x_data = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br><span class="line">y_data = [<span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">6.0</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> w*x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loss</span>(<span class="params">x,y</span>):</span><br><span class="line">    y_pred = forward(x)</span><br><span class="line">    <span class="keyword">return</span> (y_pred-y)**<span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">w_list = []</span><br><span class="line">mse_list = []</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> np.arange(<span class="number">0.0</span>,<span class="number">4.1</span>,<span class="number">0.1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;w=&quot;</span>,w)</span><br><span class="line">    l_sum=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x_val,y_val <span class="keyword">in</span> <span class="built_in">zip</span>(x_data,y_data):</span><br><span class="line">        y_pred_val = forward(x_val)</span><br><span class="line">        loss_val = loss(x_val,y_val)</span><br><span class="line">        l_sum+=loss_val</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\t&#x27;</span>,x_val,y_val,y_pred_val,loss_val)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;MSE=&#x27;</span>,l_sum/<span class="number">3</span>)</span><br><span class="line">    w_list.append(w)</span><br><span class="line">    mse_list.append(l_sum/<span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(w_list,mse_list)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">plt.show() </span><br></pre></td></tr></table></figure><pre><code>&lt;IPython.core.display.Javascript object&gt;</code></pre><div id="dfa97de9-b458-411d-8eb9-4a902ee3d358"></div><h2 id="课后作业">课后作业</h2><p>作业题目：实现线性模型（y=wx+b）并输出loss的3D图像。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline  <span class="comment">#告诉Jupyter Notebook在输出单元格中内嵌显示matplotlib绘制的图形，而不是在一个单独的窗口中打开。</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> w*x+b</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loss</span>(<span class="params">x,y</span>):</span><br><span class="line">    y_pred = forward(x)</span><br><span class="line">    <span class="keyword">return</span> (y_pred-y)**<span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设y=3x+2</span></span><br><span class="line">x_data = [<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">3.0</span>]</span><br><span class="line">y_data = [<span class="number">5.0</span>,<span class="number">8.0</span>,<span class="number">11.0</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">w_list=np.arange(<span class="number">0</span>,<span class="number">4.1</span>,<span class="number">0.1</span>)</span><br><span class="line">b_list=np.arange(<span class="number">0</span>,<span class="number">4.1</span>,<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">[w,b]=np.meshgrid(w_list,b_list)<span class="comment">#创建二维网格,w和b均为二维数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#广播机制 计算</span></span><br><span class="line">loss_sum=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x_val,y_val <span class="keyword">in</span> <span class="built_in">zip</span>(x_data,y_data):</span><br><span class="line">    y_pred_val = forward(x_val)</span><br><span class="line">    loss_sum+=loss(x_val,y_val)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(loss_sum)</span><br></pre></td></tr></table></figure><pre><code>[[210.   199.34 188.96 ...   1.76   1.74   2.  ] [205.23 194.69 184.43 ...   1.55   1.65   2.03] [200.52 190.1  179.96 ...   1.4    1.62   2.12] ... [ 70.92  64.82  59.   ...  35.96  40.5   45.32] [ 68.43  62.45  56.75 ...  38.03  42.69  47.63] [ 66.    60.14  54.56 ...  40.16  44.94  50.  ]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>, projection=<span class="string">&#x27;3d&#x27;</span>)  <span class="comment"># 推荐的方法</span></span><br><span class="line">ax.plot_surface(w, b, loss_sum/<span class="number">3</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&quot;w&quot;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">&quot;loss&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure><img src="01_线性模型_15_0.png" alt="png" /><figcaption aria-hidden="true">png</figcaption></figure><h1 id="梯度下降">梯度下降</h1><p>只能找到局部最优,无法确保找到全局最优</p><p>鞍点问题比较重要</p><h2 id="批量梯度下降">批量梯度下降</h2><ol type="1"><li>使用整个训练集计算梯度</li><li>每次迭代稳定但计算量大</li><li>适合小型数据集</li></ol><h2 id="随机梯度下降">随机梯度下降</h2><ol type="1"><li>每次使用单个样本</li><li>收敛快但震荡大</li><li>适合在线学习</li></ol><h2 id="小批量梯度下降">小批量梯度下降</h2><p>上述两种的折中</p><ol type="1"><li>平衡了计算效率和稳定性</li><li>最常用的方法</li><li>batch_size 是重要超参数</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x_data = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br><span class="line">y_data = [<span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">6.0</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w = <span class="number">1.0</span> <span class="comment">#随机初始化权重</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 批量梯度下降 </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> w*x</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cost</span>(<span class="params">xs,ys</span>):</span><br><span class="line">    cost = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(xs,ys):</span><br><span class="line">        cost+=(y-forward(x))**<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> cost/<span class="built_in">len</span>(xs)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gradient</span>(<span class="params">xs,ys</span>):</span><br><span class="line">    grad = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(xs,ys):</span><br><span class="line">        grad+=<span class="number">2</span>*(x*w-y)*x</span><br><span class="line">    <span class="keyword">return</span> grad/<span class="built_in">len</span>(xs)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">epoch_list=[]</span><br><span class="line">cost_list=[]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;predict (before training)&#x27;</span>,<span class="number">4</span>,forward(<span class="number">4</span>))</span><br></pre></td></tr></table></figure><pre><code>predict (before training) 4 4.0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    cost_val = cost(x_data,y_data) <span class="comment">#计算整个批次的平均损失</span></span><br><span class="line">    grad_val = gradient(x_data,y_data)<span class="comment">#计算整个批次的平均梯度</span></span><br><span class="line">    w -=<span class="number">0.01</span>*grad_val</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;epoch:&#x27;</span>, epoch, <span class="string">&#x27;w=&#x27;</span>, w, <span class="string">&#x27;loss=&#x27;</span>, cost_val)</span><br><span class="line">    epoch_list.append(epoch)</span><br><span class="line">    cost_list.append(cost_val)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;predict (after training)&#x27;</span>, <span class="number">4</span>, forward(<span class="number">4</span>))</span><br><span class="line">plt.plot(epoch_list,cost_list)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;cost&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;epoch&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><hr /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#随机梯度下降</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> w*x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loss</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> (y-forward(x))**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gradient</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*x*(w*x-y)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">w=<span class="number">1</span></span><br><span class="line">epoch_list=[]</span><br><span class="line">cost_list=[]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;predict (before training)&#x27;</span>,<span class="number">4</span>,forward(<span class="number">4</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(x_data,y_data):</span><br><span class="line">        y_hat=forward(x)</span><br><span class="line">        loss_val=loss(x,y)</span><br><span class="line">        grad_val=gradient(x,y)</span><br><span class="line">        w-=<span class="number">0.01</span>*grad_val</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\tgrad:&quot;</span>, x, y,grad_val)</span><br><span class="line">    epoch_list.append(epoch)</span><br><span class="line">    cost_list.append(loss_val)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;progress:&quot;</span>,epoch,<span class="string">&quot;w=&quot;</span>,w,<span class="string">&quot;loss=&quot;</span>,loss)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;predict (after training)&#x27;</span>, <span class="number">4</span>, forward(<span class="number">4</span>))</span><br><span class="line">plt.plot(epoch_list,cost_list)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;epoch&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h1 id="反向传播">反向传播</h1><h2 id="tensor类与计算图">Tensor类与计算图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">w = torch.tensor([<span class="number">1.0</span>])</span><br><span class="line">w.requires_grad=<span class="literal">True</span> <span class="comment"># 需要计算梯度</span></span><br><span class="line"><span class="built_in">print</span>(w)</span><br><span class="line"><span class="built_in">print</span>(w.data)</span><br><span class="line"><span class="built_in">print</span>(w.<span class="built_in">type</span>())<span class="comment">#Tensor类</span></span><br><span class="line"><span class="built_in">print</span>(w.data.<span class="built_in">type</span>())<span class="comment">#data也是一个Tensor</span></span><br><span class="line"><span class="built_in">print</span>(w.grad)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(w.grad))</span><br></pre></td></tr></table></figure><pre><code>tensor([1.], requires_grad=True)tensor([1.])torch.FloatTensortorch.FloatTensorNone&lt;class &#39;NoneType&#39;&gt;</code></pre><h2 id="反向传播-1">反向传播</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x_data = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br><span class="line">y_data = [<span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">6.0</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w = torch.tensor([<span class="number">1.0</span>])</span><br><span class="line">w.requires_grad = <span class="literal">True</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> w*x</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loss</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> (y-forward(x))**<span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;predict (before training)&quot;</span>, <span class="number">4</span>, forward(<span class="number">4</span>).item())<span class="comment"># 张量转为数字</span></span><br></pre></td></tr></table></figure><pre><code>predict (before training) 4 4.0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(x_data,y_data):</span><br><span class="line">        l = loss(x,y)<span class="comment">#前向传播</span></span><br><span class="line">        l.backward()<span class="comment">#反向传播</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\tgrad:&#x27;</span>, x, y, w.grad.item())</span><br><span class="line">        w.data = w.data - <span class="number">0.01</span>*w.grad.data</span><br><span class="line">        w.grad.data.zero_()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;progress:&#x27;</span>, epoch, l.item())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;predict (after training)&quot;</span>, <span class="number">4</span>, forward(<span class="number">4</span>).item())</span><br></pre></td></tr></table></figure><h2 id="作业">作业</h2><p>以y = w*x+b 为例子实现反向传播</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">w = torch.Tensor([<span class="number">1.0</span>])</span><br><span class="line">w.requires_grad=<span class="literal">True</span></span><br><span class="line">b = torch.Tensor([<span class="number">0</span>])</span><br><span class="line">b.requires_grad=<span class="literal">True</span></span><br><span class="line"></span><br><span class="line">x_data = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br><span class="line">y_data = [<span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">6.0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> w*x+b</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loss</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> (y-forward(x))**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(x_data,y_data):</span><br><span class="line">        l = loss(x,y)</span><br><span class="line">        l.backward()</span><br><span class="line">        w.data=w.data-<span class="number">0.01</span>*w.grad.data</span><br><span class="line">        b.data=b.data-<span class="number">0.01</span>*b.grad.data</span><br><span class="line">        w.grad.data.zero_()</span><br><span class="line">        b.grad.data.zero_()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;progress:&#x27;</span>, epoch, l.item())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;predict (after training)&quot;</span>, <span class="number">4</span>, forward(<span class="number">4</span>).item())</span><br><span class="line">        </span><br><span class="line">    </span><br></pre></td></tr></table></figure><hr /><p>y=w1x²+w2x+b为例子实现反向传播</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">w1 = torch.Tensor([<span class="number">1.0</span>])</span><br><span class="line">w1.requires_grad=<span class="literal">True</span></span><br><span class="line">w2 = torch.Tensor([<span class="number">1.0</span>])</span><br><span class="line">w2.requires_grad=<span class="literal">True</span></span><br><span class="line">b = torch.Tensor([<span class="number">0</span>])</span><br><span class="line">b.requires_grad=<span class="literal">True</span></span><br><span class="line"></span><br><span class="line">x_data = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br><span class="line">y_data = [<span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">6.0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> w1*x*x+w2*x+b</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loss</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> (y-forward(x))**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(x_data,y_data):</span><br><span class="line">        l = loss(x,y)</span><br><span class="line">        l.backward()</span><br><span class="line">        w1.data=w1.data-<span class="number">0.01</span>*w1.grad.data</span><br><span class="line">        w2.data=w2.data-<span class="number">0.01</span>*w2.grad.data</span><br><span class="line">        b.data=b.data-<span class="number">0.01</span>*b.grad.data</span><br><span class="line">        w1.grad.data.zero_()</span><br><span class="line">        w2.grad.data.zero_()</span><br><span class="line">        b.grad.data.zero_()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;progress:&#x27;</span>, epoch, l.item())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;predict (after training)&quot;</span>, <span class="number">4</span>, forward(<span class="number">4</span>).item())</span><br><span class="line">        </span><br><span class="line">    </span><br></pre></td></tr></table></figure><h1 id="pytorch实现线性回归">Pytorch实现线性回归</h1><h2 id="init与call函数">init与call函数</h2><ol type="1"><li><strong>init</strong>: 类的初始化函数，类似于c++的构造函数</li><li><strong>call</strong>_: 使得类对象具有类似函数的功能。</li></ol><h3 id="init"><strong>init</strong></h3><p>作用：用于初始化模型对象，定义模型的结构和参数。</p><ol type="1"><li>定义网络层：在这里，你声明模型将由哪些层组成（例如，线性层 nn.Linear、卷积层 nn.Conv2d、激活函数 nn.ReLU 等）。</li><li>初始化参数：这些层内部的权重（weights）和偏置（biases）参数会被自动创建并初始化。</li><li>执行必要的设置：调用父类的 <strong>init</strong>() 方法等。</li><li><strong>init</strong> 负责搭建模型的骨架，它回答了"这个模型由哪些部分组成？"的问题。它只会在你创建模型实例时被调用一次。</li></ol><h3 id="call"><strong>call</strong></h3><p>作用:让模型实例能够像函数一样被调用，例如 output = model(input_data)。</p><ol type="1"><li>nn.Module 是所有神经网络单元（neural network modules）的基类,pytorch在nn.Module中，实现了__call__方法，而在__call__方法中调用了forward函数。</li><li>你不需要自己重写 <strong>call</strong> 方法。</li><li>你必须自己定义 forward 方法。 forward 才是真正定义数据如何在前向传播中流动的地方。</li><li><strong>call</strong> 是 forward 的封装器和触发器。永远使用 model(x) 而不是直接调用 model.forward(x)，因为前者能确保 PyTorch 的所有机制（如钩子）正常工作。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyNeuralNetwork</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_size, hidden_size, output_size</span>):</span><br><span class="line">        <span class="built_in">super</span>(MyNeuralNetwork, self).__init__()</span><br><span class="line">        self.layer1 = torch.nn.Linear(input_size, hidden_size)</span><br><span class="line">        self.activation = torch.nn.ReLU()</span><br><span class="line">        self.layer2 = torch.nn.Linear(hidden_size, output_size)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 定义数据的前向传播路径</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># x 是输入数据</span></span><br><span class="line">        x = self.layer1(x)       <span class="comment"># 数据通过第一层</span></span><br><span class="line">        x = self.activation(x)   <span class="comment"># 数据通过激活函数</span></span><br><span class="line">        x = self.layer2(x)       <span class="comment"># 数据通过第二层</span></span><br><span class="line">        <span class="keyword">return</span> x                 <span class="comment"># 返回最终输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用模型</span></span><br><span class="line">model = MyNeuralNetwork(input_size=<span class="number">784</span>, hidden_size=<span class="number">128</span>, output_size=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一些虚拟输入数据 (batch_size=4, feature_size=784)</span></span><br><span class="line">dummy_input = torch.randn(<span class="number">4</span>, <span class="number">784</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据传入模型进行前向传播</span></span><br><span class="line"><span class="comment"># 这里触发了 __call__，进而调用了你定义的 forward 方法</span></span><br><span class="line">output = model(dummy_input)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(output.shape) <span class="comment"># 输出：torch.Size([4, 10])</span></span><br></pre></td></tr></table></figure><pre><code>torch.Size([4, 10])</code></pre><h2 id="nn.module中的api">nn.module中的API</h2><ol type="1"><li>loss.backward()：计算梯度,即进行反向传播。</li><li>optimizer.step()：执行更新（“实施修改”）。</li><li>optimizer.zero_grad()：准备下一次计算（“重置记录”）。</li></ol><h2 id="实现线性回归">实现线性回归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x_data = torch.tensor([[<span class="number">1.0</span>],[<span class="number">2.0</span>],[<span class="number">3.0</span>]])<span class="comment"># 3*1</span></span><br><span class="line">y_data = torch.tensor([[<span class="number">2.0</span>],[<span class="number">4.0</span>],[<span class="number">6.0</span>]])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinearModel</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(LinearModel,self).__init__()<span class="comment">#调用父类 nn.Module 的初始化方法</span></span><br><span class="line">        self.linear = torch.nn.Linear(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        <span class="comment">#创建一个线性层（全连接层）</span></span><br><span class="line">        <span class="comment"># (1,1)是指输入x和输出y的特征维度，这里数据集中的x和y的特征都是1维的</span></span><br><span class="line">        <span class="comment"># 该线性层需要学习的参数是w和b  获取w/b的方式分别是~linear.weight/linear.bias</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        y_pred = self.linear(x)</span><br><span class="line">        <span class="keyword">return</span> y_pred</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">model = LinearModel()</span><br><span class="line"></span><br><span class="line">criterion = torch.nn.MSELoss(reduction=<span class="string">&#x27;sum&#x27;</span>) <span class="comment">#损失函数</span></span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(),lr=<span class="number">0.01</span>)<span class="comment">#优化器</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#训练过程</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    y_pred = model(x_data)</span><br><span class="line">    loss = criterion(y_pred,y_data)</span><br><span class="line">    <span class="built_in">print</span>(epoch,loss.item())</span><br><span class="line"></span><br><span class="line">    loss.backward()       <span class="comment">#计算梯度</span></span><br><span class="line">    optimizer.step()  <span class="comment">#更新w和b的值</span></span><br><span class="line">    optimizer.zero_grad()  <span class="comment">#清空</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;w=&#x27;</span>,model.linear.weight.item())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b=&#x27;</span>,model.linear.bias.item())</span><br><span class="line"></span><br><span class="line">x_test = torch.tensor([[<span class="number">4.0</span>]])</span><br><span class="line">y_test = model(x_test)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;y_pred = &#x27;</span>, y_test.data)</span><br></pre></td></tr></table></figure><h2 id="常用的优化器与损失函数">常用的优化器与损失函数</h2><h3 id="回归任务损失函数">回归任务损失函数</h3><h4 id="mseloss均方误差损失"><strong>MSELoss（均方误差损失）</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基本用法</span></span><br><span class="line">criterion = nn.MSELoss()  <span class="comment"># reduction=&#x27;mean&#x27; 为默认值</span></span><br><span class="line"><span class="comment"># 或者指定 reduction</span></span><br><span class="line">criterion = nn.MSELoss(reduction=<span class="string">&#x27;mean&#x27;</span>)  <span class="comment"># 平均值</span></span><br><span class="line">criterion = nn.MSELoss(reduction=<span class="string">&#x27;sum&#x27;</span>)   <span class="comment"># 求和</span></span><br><span class="line">criterion = nn.MSELoss(reduction=<span class="string">&#x27;none&#x27;</span>)  <span class="comment"># 不聚合，返回每个样本的损失</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">y_pred = torch.tensor([[<span class="number">2.0</span>], [<span class="number">4.0</span>], [<span class="number">6.0</span>], [<span class="number">8.0</span>]])</span><br><span class="line">y_true = torch.tensor([[<span class="number">1.8</span>], [<span class="number">4.2</span>], [<span class="number">5.9</span>], [<span class="number">8.1</span>]])</span><br><span class="line"></span><br><span class="line">loss = criterion(y_pred, y_true)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;MSE Loss: <span class="subst">&#123;loss.item()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数学公式: loss = (1/n) * Σ(y_pred - y_true)²</span></span><br></pre></td></tr></table></figure><h4 id="l1loss平均绝对误差损失"><strong>L1Loss（平均绝对误差损失）</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">criterion = nn.L1Loss()  <span class="comment"># MAE损失</span></span><br><span class="line"><span class="comment"># 可选参数: reduction=&#x27;mean&#x27; | &#x27;sum&#x27; | &#x27;none&#x27;</span></span><br><span class="line"></span><br><span class="line">loss = criterion(y_pred, y_true)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;L1 Loss: <span class="subst">&#123;loss.item()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数学公式: loss = (1/n) * Σ|y_pred - y_true|</span></span><br><span class="line"><span class="comment"># 特点：对异常值不如MSE敏感</span></span><br></pre></td></tr></table></figure><h4 id="smoothl1loss平滑l1损失"><strong>SmoothL1Loss（平滑L1损失）</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">criterion = nn.SmoothL1Loss()</span><br><span class="line"><span class="comment"># 可选参数: reduction=&#x27;mean&#x27; | &#x27;sum&#x27; | &#x27;none&#x27;, beta=1.0</span></span><br><span class="line"></span><br><span class="line">loss = criterion(y_pred, y_true)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Smooth L1 Loss: <span class="subst">&#123;loss.item()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数学公式: </span></span><br><span class="line"><span class="comment"># 如果 |y_pred - y_true| &lt; beta: 0.5 * (y_pred - y_true)² / beta</span></span><br><span class="line"><span class="comment"># 否则: |y_pred - y_true| - 0.5 * beta</span></span><br><span class="line"><span class="comment"># 特点：在0附近更平滑，常用于目标检测（如Faster R-CNN）</span></span><br></pre></td></tr></table></figure><h4 id="huberloss"><strong>HuberLoss</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">criterion = nn.HuberLoss()</span><br><span class="line"><span class="comment"># 可选参数: reduction=&#x27;mean&#x27; | &#x27;sum&#x27; | &#x27;none&#x27;, delta=1.0</span></span><br><span class="line"></span><br><span class="line">loss = criterion(y_pred, y_true)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Huber Loss: <span class="subst">&#123;loss.item()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数学公式与SmoothL1Loss类似，是L1和L2损失的结合</span></span><br></pre></td></tr></table></figure><h3 id="分类任务损失函数">分类任务损失函数</h3><h4 id="bceloss二分类交叉熵损失"><strong>BCELoss（二分类交叉熵损失）</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用于二分类问题，输出需要经过sigmoid激活</span></span><br><span class="line">criterion = nn.BCELoss()</span><br><span class="line"><span class="comment"># 可选参数: reduction=&#x27;mean&#x27; | &#x27;sum&#x27; | &#x27;none&#x27;, weight=None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例（输出经过sigmoid，值在0-1之间）</span></span><br><span class="line">y_pred = torch.tensor([[<span class="number">0.9</span>], [<span class="number">0.1</span>], [<span class="number">0.8</span>], [<span class="number">0.2</span>]])  <span class="comment"># 预测概率</span></span><br><span class="line">y_true = torch.tensor([[<span class="number">1.0</span>], [<span class="number">0.0</span>], [<span class="number">1.0</span>], [<span class="number">0.0</span>]])  <span class="comment"># 真实标签</span></span><br><span class="line"></span><br><span class="line">loss = criterion(y_pred, y_true)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;BCE Loss: <span class="subst">&#123;loss.item()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数学公式: loss = -[y_true * log(y_pred) + (1-y_true) * log(1-y_pred)]</span></span><br></pre></td></tr></table></figure><h4 id="bcewithlogitsloss带logits的bce损失"><strong>BCEWithLogitsLoss（带logits的BCE损失）</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐使用，数值稳定性更好</span></span><br><span class="line">criterion = nn.BCEWithLogitsLoss()</span><br><span class="line"><span class="comment"># 可选参数: reduction=&#x27;mean&#x27; | &#x27;sum&#x27; | &#x27;none&#x27;, weight=None, pos_weight=None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例（输出不需要sigmoid）</span></span><br><span class="line">y_pred_logits = torch.tensor([[<span class="number">2.0</span>], [-<span class="number">2.0</span>], [<span class="number">1.5</span>], [-<span class="number">1.5</span>]])  <span class="comment"># 原始logits</span></span><br><span class="line">y_true = torch.tensor([[<span class="number">1.0</span>], [<span class="number">0.0</span>], [<span class="number">1.0</span>], [<span class="number">0.0</span>]])</span><br><span class="line"></span><br><span class="line">loss = criterion(y_pred_logits, y_true)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;BCEWithLogits Loss: <span class="subst">&#123;loss.item()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pos_weight参数用于处理类别不平衡</span></span><br><span class="line">pos_weight = torch.tensor([<span class="number">3.0</span>])  <span class="comment"># 正样本权重</span></span><br><span class="line">criterion_balanced = nn.BCEWithLogitsLoss(pos_weight=pos_weight)</span><br></pre></td></tr></table></figure><h4 id="crossentropyloss多分类交叉熵损失"><strong>CrossEntropyLoss（多分类交叉熵损失）</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用于多分类问题，输出不需要softmax</span></span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line"><span class="comment"># 可选参数: reduction=&#x27;mean&#x27; | &#x27;sum&#x27; | &#x27;none&#x27;, weight=None, ignore_index=-100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例（3分类问题，4个样本）</span></span><br><span class="line">y_pred = torch.tensor([</span><br><span class="line">    [<span class="number">2.0</span>, <span class="number">1.0</span>, <span class="number">0.1</span>],  <span class="comment"># 预测为第0类</span></span><br><span class="line">    [<span class="number">0.5</span>, <span class="number">2.0</span>, <span class="number">0.3</span>],  <span class="comment"># 预测为第1类  </span></span><br><span class="line">    [<span class="number">0.2</span>, <span class="number">0.1</span>, <span class="number">3.0</span>],  <span class="comment"># 预测为第2类</span></span><br><span class="line">    [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">0.5</span>]   <span class="comment"># 预测为第1类</span></span><br><span class="line">])</span><br><span class="line">y_true = torch.tensor([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>])  <span class="comment"># 真实类别索引</span></span><br><span class="line"></span><br><span class="line">loss = criterion(y_pred, y_true)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;CrossEntropy Loss: <span class="subst">&#123;loss.item()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># weight参数用于处理类别不平衡</span></span><br><span class="line">class_weights = torch.tensor([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">1.0</span>])  <span class="comment"># 第1类的权重为2</span></span><br><span class="line">criterion_weighted = nn.CrossEntropyLoss(weight=class_weights)</span><br></pre></td></tr></table></figure><h4 id="nllloss负对数似然损失"><strong>NLLLoss（负对数似然损失）</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要与LogSoftmax配合使用</span></span><br><span class="line">criterion = nn.NLLLoss()</span><br><span class="line"><span class="comment"># 可选参数: reduction=&#x27;mean&#x27; | &#x27;sum&#x27; | &#x27;none&#x27;, weight=None, ignore_index=-100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例（输出需要先经过LogSoftmax）</span></span><br><span class="line">log_softmax = nn.LogSoftmax(dim=<span class="number">1</span>)</span><br><span class="line">y_pred_log = log_softmax(y_pred)  <span class="comment"># 先取log softmax</span></span><br><span class="line">loss = criterion(y_pred_log, y_true)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;NLL Loss: <span class="subst">&#123;loss.item()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="其他损失函数">其他损失函数</h3><h4 id="cosineembeddingloss余弦相似度损失"><strong>CosineEmbeddingLoss（余弦相似度损失）</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">criterion = nn.CosineEmbeddingLoss()</span><br><span class="line"><span class="comment"># 可选参数: margin=0.0, reduction=&#x27;mean&#x27; | &#x27;sum&#x27; | &#x27;none&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例（用于度量学习、相似度计算）</span></span><br><span class="line">x1 = torch.tensor([[<span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>]])</span><br><span class="line">x2 = torch.tensor([[<span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>]])  <span class="comment"># 相同向量</span></span><br><span class="line">target = torch.tensor([<span class="number">1</span>, <span class="number">1</span>])  <span class="comment"># 1表示相似，-1表示不相似</span></span><br><span class="line"></span><br><span class="line">loss = criterion(x1, x2, target)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Cosine Embedding Loss: <span class="subst">&#123;loss.item()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="tripletmarginloss三元组损失"><strong>TripletMarginLoss（三元组损失）</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">criterion = nn.TripletMarginLoss()</span><br><span class="line"><span class="comment"># 可选参数: margin=1.0, p=2, eps=1e-6, reduction=&#x27;mean&#x27; | &#x27;sum&#x27; | &#x27;none&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例（用于度量学习）</span></span><br><span class="line">anchor = torch.tensor([[<span class="number">1.0</span>, <span class="number">2.0</span>]])</span><br><span class="line">positive = torch.tensor([[<span class="number">1.1</span>, <span class="number">2.1</span>]])  <span class="comment"># 与anchor相似</span></span><br><span class="line">negative = torch.tensor([[<span class="number">5.0</span>, <span class="number">6.0</span>]])  <span class="comment"># 与anchor不相似</span></span><br><span class="line"></span><br><span class="line">loss = criterion(anchor, positive, negative)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Triplet Margin Loss: <span class="subst">&#123;loss.item()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><hr /><h3 id="sgd随机梯度下降">SGD（随机梯度下降）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基本SGD</span></span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 带动量的SGD（推荐）</span></span><br><span class="line">optimizer = optim.SGD(</span><br><span class="line">    model.parameters(), </span><br><span class="line">    lr=<span class="number">0.01</span>, </span><br><span class="line">    momentum=<span class="number">0.9</span>,</span><br><span class="line">    weight_decay=<span class="number">1e-4</span>,  <span class="comment"># L2正则化</span></span><br><span class="line">    nesterov=<span class="literal">False</span>      <span class="comment"># 是否使用Nesterov动量</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">    <span class="keyword">for</span> inputs, targets <span class="keyword">in</span> dataloader:</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        outputs = model(inputs)</span><br><span class="line">        loss = criterion(outputs, targets)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br></pre></td></tr></table></figure><h3 id="adam自适应矩估计">Adam（自适应矩估计）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本Adam</span></span><br><span class="line">optimizer = optim.Adam(model.parameters(), lr=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完整参数Adam</span></span><br><span class="line">optimizer = optim.Adam(</span><br><span class="line">    model.parameters(),</span><br><span class="line">    lr=<span class="number">0.001</span>,           <span class="comment"># 学习率</span></span><br><span class="line">    betas=(<span class="number">0.9</span>, <span class="number">0.999</span>), <span class="comment"># 一阶和二阶矩估计的衰减率</span></span><br><span class="line">    eps=<span class="number">1e-8</span>,           <span class="comment"># 数值稳定性常数</span></span><br><span class="line">    weight_decay=<span class="number">0</span>,     <span class="comment"># L2正则化</span></span><br><span class="line">    amsgrad=<span class="literal">False</span>       <span class="comment"># 是否使用AMSGrad变体</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特点：自适应学习率，通常收敛快，适合大多数情况</span></span><br></pre></td></tr></table></figure><h3 id="adamwadam-with-weight-decay">AdamW（Adam with Weight Decay）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Adam的改进版本，正确处理权重衰减</span></span><br><span class="line">optimizer = optim.AdamW(</span><br><span class="line">    model.parameters(),</span><br><span class="line">    lr=<span class="number">0.001</span>,</span><br><span class="line">    betas=(<span class="number">0.9</span>, <span class="number">0.999</span>),</span><br><span class="line">    eps=<span class="number">1e-8</span>,</span><br><span class="line">    weight_decay=<span class="number">0.01</span>,  <span class="comment"># 真正的权重衰减（不是L2正则化）</span></span><br><span class="line">    amsgrad=<span class="literal">False</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特点：比Adam有更好的泛化能力，推荐使用</span></span><br></pre></td></tr></table></figure><h3 id="rmsprop">RMSprop</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">optimizer = optim.RMSprop(</span><br><span class="line">    model.parameters(),</span><br><span class="line">    lr=<span class="number">0.01</span>,</span><br><span class="line">    alpha=<span class="number">0.99</span>,         <span class="comment"># 平滑常数</span></span><br><span class="line">    eps=<span class="number">1e-8</span>,</span><br><span class="line">    weight_decay=<span class="number">0</span>,</span><br><span class="line">    momentum=<span class="number">0</span>,         <span class="comment"># 动量因子</span></span><br><span class="line">    centered=<span class="literal">False</span>      <span class="comment"># 是否计算中心化的梯度方差</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特点：适合非平稳目标，常用于RNN</span></span><br></pre></td></tr></table></figure><h3 id="adagrad">Adagrad</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">optimizer = optim.Adagrad(</span><br><span class="line">    model.parameters(),</span><br><span class="line">    lr=<span class="number">0.01</span>,</span><br><span class="line">    lr_decay=<span class="number">0</span>,         <span class="comment"># 学习率衰减</span></span><br><span class="line">    weight_decay=<span class="number">0</span>,</span><br><span class="line">    initial_accumulator_value=<span class="number">0</span>,</span><br><span class="line">    eps=<span class="number">1e-10</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特点：自适应学习率，适合稀疏数据</span></span><br></pre></td></tr></table></figure><h3 id="adadelta">Adadelta</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">optimizer = optim.Adadelta(</span><br><span class="line">    model.parameters(),</span><br><span class="line">    lr=<span class="number">1.0</span>,             <span class="comment"># 默认1.0</span></span><br><span class="line">    rho=<span class="number">0.9</span>,            <span class="comment"># 衰减率</span></span><br><span class="line">    eps=<span class="number">1e-6</span>,</span><br><span class="line">    weight_decay=<span class="number">0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特点：不需要手动设置学习率，是Adagrad的改进</span></span><br></pre></td></tr></table></figure><h3 id="adamax">Adamax</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">optimizer = optim.Adamax(</span><br><span class="line">    model.parameters(),</span><br><span class="line">    lr=<span class="number">0.002</span>,</span><br><span class="line">    betas=(<span class="number">0.9</span>, <span class="number">0.999</span>),</span><br><span class="line">    eps=<span class="number">1e-8</span>,</span><br><span class="line">    weight_decay=<span class="number">0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特点：Adam的基于无穷范数的变体</span></span><br></pre></td></tr></table></figure><h3 id="损失函数选择指南">损失函数选择指南：</h3><ul><li><strong>回归任务</strong>: <code>MSELoss</code>, <code>L1Loss</code>, <code>SmoothL1Loss</code></li><li><strong>二分类</strong>: <code>BCEWithLogitsLoss</code>（推荐）, <code>BCELoss</code></li><li><strong>多分类</strong>: <code>CrossEntropyLoss</code></li><li><strong>相似度学习</strong>: <code>CosineEmbeddingLoss</code>, <code>TripletMarginLoss</code></li></ul><h3 id="优化器选择指南">优化器选择指南：</h3><ul><li><strong>推荐默认</strong>: <code>AdamW</code> 或 <code>Adam</code></li><li><strong>需要精细调参</strong>: <code>SGD</code> + momentum</li><li><strong>RNN/LSTM</strong>: <code>RMSprop</code></li><li><strong>稀疏数据</strong>: <code>Adagrad</code></li></ul><h1 id="逻辑回归">逻辑回归</h1><ol type="1"><li>在线性层的后面加上了激活函数(非线性变换)</li><li>解决分类问题</li><li>分类问题一般采用交叉熵作为损失函数,交叉熵越小说明二者越接近,分类越好</li></ol><p><strong>BCELoss 是二分类交叉熵损失，而 CrossEntropyLoss 是交叉熵损失，它更通用，可以同时处理二分类和多分类问题。</strong></p><p><strong>核心区别对比表</strong></p><table><colgroup><col style="width: 11%" /><col style="width: 44%" /><col style="width: 44%" /></colgroup><thead><tr class="header"><th style="text-align: left;">特性</th><th style="text-align: left;">BCELoss</th><th style="text-align: left;">CrossEntropyLoss</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><strong>全称</strong></td><td style="text-align: left;">Binary Cross-Entropy Loss</td><td style="text-align: left;">Cross-Entropy Loss</td></tr><tr class="even"><td style="text-align: left;"><strong>任务类型</strong></td><td style="text-align: left;"><strong>二分类</strong></td><td style="text-align: left;"><strong>多分类</strong>，也可用于二分类</td></tr><tr class="odd"><td style="text-align: left;"><strong>输出层要求</strong></td><td style="text-align: left;">每个类别一个** Sigmoid 函数**</td><td style="text-align: left;">整个输出层一个 <strong>Softmax 函数</strong></td></tr><tr class="even"><td style="text-align: left;"><strong>模型输出含义</strong></td><td style="text-align: left;">每个输出节点是一个<strong>独立的概率</strong>，表示属于该类的可能性。所有节点概率之和不等于1。</td><td style="text-align: left;">所有输出节点经过Softmax，表示一个<strong>概率分布</strong>。所有节点概率之和为1。</td></tr><tr class="odd"><td style="text-align: left;"><strong>标签格式</strong></td><td style="text-align: left;"><strong>浮点数</strong>（Float），通常是0或1。可以是单个值（单标签）或多个值（多标签）。</td><td style="text-align: left;"><strong>整数</strong>（Long），是类别的索引。例如，3分类任务，标签是0, 1, 2。</td></tr><tr class="even"><td style="text-align: left;"><strong>损失计算</strong></td><td style="text-align: left;">对<strong>每个输出节点</strong>分别计算二元交叉熵，然后可以求平均或求和。</td><td style="text-align: left;">将模型输出的<strong>整个分布</strong>与真实标签的 one-hot 编码计算交叉熵。</td></tr><tr class="odd"><td style="text-align: left;"><strong>PyTorch 实现</strong></td><td style="text-align: left;"><code>torch.nn.BCELoss()</code></td><td style="text-align: left;"><code>torch.nn.CrossEntropyLoss()</code></td></tr></tbody></table><hr /><h2 id="bceloss">BCELoss</h2><p>BCELoss 用于<strong>二分类</strong>或<strong>多标签分类</strong>问题。在二分类中，虽然只有一个输出节点（例如，用Sigmoid输出一个概率值），但它也可以有多个输出节点，每个节点代表一个独立的“是/否”问题。</p><p><strong>核心思想</strong>：对输出的<strong>每一个维度（节点）</strong> 都应用一个 Sigmoid 函数，将其压缩到 (0, 1) 区间，然后与目标值（0或1）计算二元交叉熵。</p><p><strong>计算公式（对于单个样本的一个输出节点）</strong>： <code>Loss = - [y * log(p) + (1 - y) * log(1 - p)]</code> 其中 <code>y</code> 是真实标签（0或1），<code>p</code> 是模型预测的概率。</p><p><strong>PyTorch 示例</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设一个3标签的分类问题（多标签分类）</span></span><br><span class="line"><span class="comment"># 模型有3个输出节点，每个节点用Sigmoid激活</span></span><br><span class="line">model_output = torch.tensor([[ <span class="number">0.8</span>, -<span class="number">0.6</span>,  <span class="number">1.2</span>]]) <span class="comment"># 原始logits</span></span><br><span class="line">sigmoid = nn.Sigmoid()</span><br><span class="line">probabilities = sigmoid(model_output) <span class="comment"># 转换为概率，如 [0.69, 0.35, 0.77]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 真实标签：第一个标签为1，第二个为0，第三个为1（可以同时为1）</span></span><br><span class="line">true_labels = torch.tensor([[<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>]])</span><br><span class="line"></span><br><span class="line">criterion = nn.BCELoss()</span><br><span class="line">loss = criterion(probabilities, true_labels)</span><br><span class="line"><span class="built_in">print</span>(loss)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：在使用 <code>nn.BCELoss</code> 之前，<strong>必须</strong>手动使用 Sigmoid 将输出转换为概率。PyTorch 也提供了 <code>nn.BCEWithLogitsLoss</code>，它结合了 Sigmoid 和 BCELoss，数值计算上更稳定，是更推荐的做法。</p><h2 id="crossentropyloss">CrossEntropyLoss</h2><p>CrossEntropyLoss 是深度学习中<strong>最常用</strong>的分类损失函数，主要用于<strong>单标签多分类</strong>问题（一个样本只属于一个类别）。</p><p><strong>核心思想</strong>：对输出的<strong>整个向量</strong>应用 Softmax 函数，将其转换为一个概率分布（所有值之和为1），然后计算这个预测分布与真实分布（one-hot 编码）的交叉熵。</p><p><strong>关键点</strong>：</p><ul><li><strong>内部已包含 Softmax</strong>：你不需要在模型的最后一层显式地添加 Softmax。<code>nn.CrossEntropyLoss</code> 会在内部自动为你计算 Softmax。</li><li><strong>标签是类别索引</strong>：你不需要将标签手动转换为 one-hot 编码，直接提供类别索引（整数）即可。</li></ul><p><strong>计算公式（对于单个样本）</strong>： <code>Loss = - log( p_class )</code> 其中 <code>p_class</code> 是模型预测出的、在<strong>真实类别</strong>上的那个概率。</p><p><strong>PyTorch 示例</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设一个3分类问题</span></span><br><span class="line"><span class="comment"># 模型有3个输出节点，不需要最后一层用Softmax</span></span><br><span class="line">model_output = torch.tensor([[ <span class="number">2.0</span>,  <span class="number">1.0</span>, -<span class="number">0.5</span>]]) <span class="comment"># 原始logits</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 真实标签：这个样本属于第0类（注意是LongTensor，是索引值，不是one-hot）</span></span><br><span class="line">true_label = torch.tensor([<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">loss = criterion(model_output, true_label)</span><br><span class="line"><span class="built_in">print</span>(loss)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面的计算等价于：</span></span><br><span class="line"><span class="comment"># 1. 对model_output做Softmax： [0.70, 0.26, 0.04]</span></span><br><span class="line"><span class="comment"># 2. 取真实类别0对应的概率：0.70</span></span><br><span class="line"><span class="comment"># 3. 计算损失：-log(0.70) ≈ 0.356</span></span><br></pre></td></tr></table></figure><hr /><h2 id="如何选择">如何选择？</h2><ul><li><strong>如果你的问题是标准的单标签多分类</strong>（如图像分类到10个类别、手写数字识别等）：<ul><li><strong>毫不犹豫地使用 <code>CrossEntropyLoss</code></strong>。</li><li>模型最后一层<strong>不要</strong>用任何激活函数（如 Softmax），直接输出 logits。</li></ul></li><li><strong>如果你的问题是二分类或多标签分类</strong>（如判断一张图片中是否同时包含“猫”和“狗”，一个样本可以有多个标签）：<ul><li>使用 <code>BCEWithLogitsLoss</code>（或 <code>BCELoss</code> + 手动Sigmoid）。</li><li>模型的输出节点数等于标签数，每个节点使用 Sigmoid 函数。</li></ul></li><li><strong>如果你的问题是二分类，但想把它当作多分类来处理</strong>：<ul><li>你也可以使用 <code>CrossEntropyLoss</code>，此时模型需要<strong>两个输出节点</strong>（分别对应“类别0”和“类别1”）。</li><li>标签相应地是0或1。</li><li>这种方法与使用 <code>BCEWithLogitsLoss</code> 和一个输出节点在数学上是等价的，但具体实现和数值稳定性上可能有细微差别。通常 <code>BCEWithLogitsLoss</code> 对于二分类更直接。</li></ul></li></ul><h2 id="总结">总结</h2><table><thead><tr class="header"><th style="text-align: left;">场景</th><th style="text-align: left;">推荐损失函数</th><th style="text-align: left;">模型输出层</th><th style="text-align: left;">标签格式</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><strong>多分类（单标签）</strong></td><td style="text-align: left;"><code>CrossEntropyLoss</code></td><td style="text-align: left;">无激活（Raw Logits）</td><td style="text-align: left;">整数索引（如 <code>[0]</code>）</td></tr><tr class="even"><td style="text-align: left;"><strong>二分类/多标签</strong></td><td style="text-align: left;"><code>BCEWithLogitsLoss</code></td><td style="text-align: left;">无激活（Raw Logits）</td><td style="text-align: left;">浮点数（如 <code>[1.0, 0.0, 1.0]</code>）</td></tr></tbody></table><p>核心区别：<strong><code>CrossEntropyLoss</code> 内部用 Softmax 处理整个输出向量，适用于“多选一”；而 <code>BCELoss</code> 对每个输出节点用 Sigmoid，适用于“每个节点独立判断是/否”。</strong></p><h2 id="pytorch实现逻辑回归">pytorch实现逻辑回归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">x_data = torch.Tensor([[<span class="number">1.0</span>], [<span class="number">2.0</span>], [<span class="number">3.0</span>]])</span><br><span class="line">y_data = torch.Tensor([[<span class="number">0</span>], [<span class="number">0</span>], [<span class="number">1</span>]])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LogisticRegressionModel</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(LogisticRegressionModel,self).__init__()</span><br><span class="line">        self.linear = torch.nn.Linear(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        y_pred=torch.sigmoid(self.linear(x))</span><br><span class="line">        <span class="keyword">return</span> y_pred</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = LogisticRegressionModel()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">criterion = torch.nn.BCELoss(size_average= <span class="literal">False</span>)</span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(),lr=<span class="number">0.01</span>)</span><br></pre></td></tr></table></figure><pre><code>d:\Environment\Anaconda3\envs\deep\lib\site-packages\torch\nn\_reduction.py:42: UserWarning: size_average and reduce args will be deprecated, please use reduction=&#39;sum&#39; instead.  warnings.warn(warning.format(ret))</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    y_pred = model(x_data)</span><br><span class="line">    loss = criterion(y_pred,y_data)</span><br><span class="line">    <span class="built_in">print</span>(epoch, loss.item())</span><br><span class="line"></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;w = &#x27;</span>, model.linear.weight.item())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b = &#x27;</span>, model.linear.bias.item())</span><br><span class="line"> </span><br><span class="line">x_test = torch.Tensor([[<span class="number">4.0</span>]])</span><br><span class="line">y_test = model(x_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;y_pred = &#x27;</span>, y_test.data)</span><br></pre></td></tr></table></figure><h1 id="多维特征输入">多维特征输入</h1><ol type="1"><li>本算法中torch.nn.Sigmoid() # 将其看作是网络的一层，而不是简单的函数使用</li></ol><h2 id="np.loadtxt">np.loadtxt</h2><p><code>np.loadtxt</code> 是 NumPy 中用于从文本文件加载数据的函数，特别适合读取结构化的数值数据。</p><h3 id="基本语法">基本语法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.loadtxt(fname, dtype=<span class="built_in">float</span>, delimiter=<span class="literal">None</span>, skiprows=<span class="number">0</span>, usecols=<span class="literal">None</span>, ...)</span><br></pre></td></tr></table></figure><h3 id="主要参数">主要参数</h3><ul><li><strong><code>fname</code></strong>: 文件名或文件对象</li><li><strong><code>dtype</code></strong>: 数据类型，默认为 <code>float</code></li><li><strong><code>delimiter</code></strong>: 分隔符，如 <code>,</code>（CSV）、空格、<code>\t</code>（制表符）</li><li><strong><code>skiprows</code></strong>: 跳过的行数（如标题行）</li><li><strong><code>usecols</code></strong>: 指定要读取的列</li><li><strong><code>unpack</code></strong>: 如果为 True，返回转置后的数组</li></ul><h3 id="使用示例">使用示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 示例3：跳过标题行，指定数据类型</span></span><br><span class="line"><span class="comment"># data_with_header.txt 内容：</span></span><br><span class="line"><span class="comment"># x y z</span></span><br><span class="line"><span class="comment"># 1 2 3</span></span><br><span class="line"><span class="comment"># 4 5 6</span></span><br><span class="line">data_with_header = np.loadtxt(<span class="string">&#x27;data_with_header.txt&#x27;</span>, </span><br><span class="line">                             skiprows=<span class="number">1</span>,  <span class="comment"># 跳过标题行</span></span><br><span class="line">                             dtype=<span class="built_in">int</span>)   <span class="comment"># 指定整数类型</span></span><br><span class="line"><span class="built_in">print</span>(data_with_header)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例4：只读取特定列</span></span><br><span class="line">data_selected = np.loadtxt(<span class="string">&#x27;data.txt&#x27;</span>, usecols=(<span class="number">0</span>, <span class="number">2</span>))  <span class="comment"># 只读取第0和第2列</span></span><br><span class="line"><span class="built_in">print</span>(data_selected)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># [[1. 3.]</span></span><br><span class="line"><span class="comment">#  [4. 6.]</span></span><br><span class="line"><span class="comment">#  [7. 9.]]</span></span><br></pre></td></tr></table></figure><h2 id="torch.from_numpy">torch.from_numpy</h2><p><code>torch.from_numpy</code> 是 PyTorch 中将 NumPy 数组转换为 PyTorch 张量的函数。</p><h3 id="基本语法-1">基本语法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.from_numpy(ndarray) → Tensor</span><br></pre></td></tr></table></figure><h3 id="重要特性">重要特性</h3><ul><li><strong>共享内存</strong>：转换后的张量与原始 NumPy 数组共享内存</li><li><strong>自动类型映射</strong>：保持数据类型对应关系</li><li><strong>单向转换</strong>：只能从 NumPy 到 PyTorch，不能反向</li></ul><h2 id="数据类型映射">数据类型映射</h2><p>NumPy 和 PyTorch 数据类型对应关系：</p><table><thead><tr class="header"><th style="text-align: center;">NumPy dtype</th><th style="text-align: center;">PyTorch dtype</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>np.float32</code></td><td style="text-align: center;"><code>torch.float32</code></td></tr><tr class="even"><td style="text-align: center;"><code>np.float64</code></td><td style="text-align: center;"><code>torch.float64</code></td></tr><tr class="odd"><td style="text-align: center;"><code>np.int32</code></td><td style="text-align: center;"><code>torch.int32</code></td></tr><tr class="even"><td style="text-align: center;"><code>np.int64</code></td><td style="text-align: center;"><code>torch.int64</code></td></tr><tr class="odd"><td style="text-align: center;"><code>np.bool_</code></td><td style="text-align: center;"><code>torch.bool</code></td></tr></tbody></table><h2 id="实际工作流程示例">实际工作流程示例</h2><p>典型的从文件加载数据到 PyTorch 的流程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤1：使用 np.loadtxt 从文件加载数据</span></span><br><span class="line"><span class="comment"># 假设我们有一个CSV文件，包含特征和标签</span></span><br><span class="line"><span class="comment"># 格式：特征1,特征2,特征3,标签</span></span><br><span class="line">data_np = np.loadtxt(<span class="string">&#x27;dataset.csv&#x27;</span>, delimiter=<span class="string">&#x27;,&#x27;</span>, skiprows=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤2：分离特征和标签</span></span><br><span class="line">features_np = data_np[:, :-<span class="number">1</span>]  <span class="comment"># 所有行，除了最后一列</span></span><br><span class="line">labels_np = data_np[:, -<span class="number">1</span>]     <span class="comment"># 所有行，只取最后一列</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤3：转换为 PyTorch 张量</span></span><br><span class="line">features_tensor = torch.from_numpy(features_np).<span class="built_in">float</span>()  <span class="comment"># 特征通常是浮点数</span></span><br><span class="line">labels_tensor = torch.from_numpy(labels_np).long()       <span class="comment"># 分类标签需要long类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;特征张量形状: <span class="subst">&#123;features_tensor.shape&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;标签张量形状: <span class="subst">&#123;labels_tensor.shape&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤4：用于模型训练</span></span><br><span class="line">model = nn.Linear(features_tensor.shape[<span class="number">1</span>], <span class="number">3</span>)  <span class="comment"># 假设3分类</span></span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练循环示例</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    outputs = model(features_tensor)</span><br><span class="line">    loss = criterion(outputs, labels_tensor)</span><br><span class="line">    </span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br></pre></td></tr></table></figure><h2 id="注意事项">注意事项</h2><h3 id="内存共享的优缺点">内存共享的优缺点</h3><p><strong>优点</strong>：</p><ul><li>内存高效，不需要复制数据</li><li>转换速度快</li></ul><p><strong>缺点</strong>：</p><ul><li>意外的相互影响</li><li>需要小心处理原地操作</li></ul><h3 id="断开内存共享">断开内存共享</h3><p>如果需要独立的张量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np_array = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">torch_tensor = torch.from_numpy(np_array).clone()  <span class="comment"># 创建副本，断开共享</span></span><br></pre></td></tr></table></figure><h2 id="总结-1">总结</h2><ul><li><strong><code>np.loadtxt</code></strong>：从文本文件加载结构化数据到 NumPy 数组</li><li><strong><code>torch.from_numpy</code></strong>：将 NumPy 数组转换为 PyTorch 张量（共享内存）</li><li><strong>典型流程</strong>：文件 → <code>np.loadtxt</code> → NumPy 数组 → <code>torch.from_numpy</code> → PyTorch 张量 → 模型训练</li></ul><p>这两个函数构成了数据科学和深度学习项目中数据加载和预处理的基础环节。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xy = np.loadtxt(<span class="string">&#x27;diabetes.csv.gz&#x27;</span>,delimiter=<span class="string">&#x27;,&#x27;</span>,dtype=np.float32)</span><br><span class="line"><span class="comment">#设置分隔符为逗号  转换为float32类型</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x_data = torch.from_numpy(xy[:,:-<span class="number">1</span>])</span><br><span class="line">y_data = torch.from_numpy(xy[:,[-<span class="number">1</span>]])<span class="comment">#保持二维形状</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Model,self).__init__()</span><br><span class="line">        self.linear1 = torch.nn.Linear(<span class="number">8</span>,<span class="number">6</span>)</span><br><span class="line">        self.linear2 = torch.nn.Linear(<span class="number">6</span>,<span class="number">4</span>)</span><br><span class="line">        self.linear3 = torch.nn.Linear(<span class="number">4</span>,<span class="number">1</span>)</span><br><span class="line">        self.sigmiod = torch.nn.Sigmoid()<span class="comment"># 将其看作是网络的一层，而不是简单的函数使用</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        x=self.sigmiod(self.linear1(x))</span><br><span class="line">        x=self.sigmiod(self.linear2(x))</span><br><span class="line">        x=self.sigmiod(self.linear3(x))</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model = Model()</span><br><span class="line">criterion = torch.nn.BCELoss(reduction=<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(),lr=<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">epoch_list = []</span><br><span class="line">loss_list = []</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    y_pred = model(x_data)</span><br><span class="line">    loss = criterion(y_pred, y_data)</span><br><span class="line">    <span class="built_in">print</span>(epoch, loss.item())</span><br><span class="line">    epoch_list.append(epoch)</span><br><span class="line">    loss_list.append(loss.item())</span><br><span class="line"> </span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    loss.backward()</span><br><span class="line"> </span><br><span class="line">    optimizer.step()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">plt.plot(epoch_list, loss_list)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;loss&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;epoch&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><pre><code>0 0.7483602762222291 0.73870348930358892 0.72995090484619143 0.72202050685882574 0.71483707427978525 0.7083318233489996 0.70244145393371587 0.69710850715637218 0.69228047132492079 0.687909662723541310 0.683952748775482211 0.680370330810546912 0.677126765251159713 0.674189805984497114 0.6715300083160415 0.669121086597442616 0.666939079761505117 0.664962232112884518 0.663170993328094519 0.661547720432281520 0.66007637977600121 0.658742487430572522 0.657533109188079823 0.656436383724212624 0.655441522598266625 0.654538989067077626 0.653720140457153327 0.65297693014144928 0.652302563190460229 0.651690125465393130 0.651134133338928231 0.650629281997680732 0.65017062425613433 0.649754047393798834 0.649375438690185535 0.649031519889831536 0.648718774318695137 0.64843457937240638 0.648176193237304739 0.647941172122955340 0.647727489471435541 0.647533059120178242 0.647356212139129643 0.647195339202880944 0.647048890590667745 0.6469156146049546 0.646794199943542547 0.646683752536773748 0.646583139896392849 0.646491467952728350 0.64640796184539851 0.646331846714019852 0.646262407302856453 0.646199226379394554 0.64614152908325255 0.646088957786560156 0.646040976047515957 0.64599716663360658 0.645957171916961759 0.645920693874359160 0.645887374877929761 0.645856976509094262 0.645829141139984163 0.645803630352020364 0.645780324935913165 0.645758926868438766 0.645739436149597267 0.645721554756164668 0.645705044269561869 0.645690023899078470 0.645676255226135371 0.645663559436798172 0.645651817321777373 0.645641088485717874 0.645631253719329875 0.645622074604034476 0.645613610744476377 0.645605862140655578 0.645598649978637779 0.645592033863067680 0.64558583498001181 0.645580053329467882 0.645574808120727583 0.645569801330566484 0.645565152168273985 0.645560801029205386 0.645556688308715887 0.645552992820739788 0.645549356937408489 0.64554601907730190 0.645542800426483291 0.645539760589599692 0.645536899566650493 0.645534276962280394 0.645531654357910295 0.645529270172119196 0.645526885986328197 0.645524621009826798 0.645522534847259599 0.6455204486846924</code></pre><p>[png](06_%E5%A4%9A%E7%BB%B4%E7%89%B9%E5%BE%81_files/06_%E5%A4%9A%E7%BB%B4%E7%89%B9%E5%BE%81_8_1.png</p><h1 id="加载数据集">加载数据集</h1><h2 id="dataset数据集">Dataset（数据集）</h2><p><code>Dataset</code> 是一个抽象类，用来表示数据集。我们需要继承这个类并实现几个关键方法来创建自定义数据集。</p><h3 id="核心方法">核心方法</h3><ul><li><code>__init__()</code>: 初始化数据集（如读取文件、设置路径等）</li><li><code>__len__()</code>: 返回数据集的大小</li><li><code>__getitem__()</code>: 根据索引返回一个样本</li></ul><h3 id="基本示例">基本示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义数据集类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, csv_file, transform=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化数据集</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            csv_file: 数据文件的路径</span></span><br><span class="line"><span class="string">            transform: 数据预处理变换</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.data_frame = pd.read_csv(csv_file)</span><br><span class="line">        self.transform = transform</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回数据集大小&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.data_frame)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;根据索引返回样本&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> torch.is_tensor(idx):</span><br><span class="line">            idx = idx.tolist()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取特征和标签</span></span><br><span class="line">        features = self.data_frame.iloc[idx, :-<span class="number">1</span>].values.astype(np.float32)</span><br><span class="line">        label = self.data_frame.iloc[idx, -<span class="number">1</span>].astype(np.int64)</span><br><span class="line">        </span><br><span class="line">        sample = &#123;<span class="string">&#x27;features&#x27;</span>: features, <span class="string">&#x27;label&#x27;</span>: label&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 应用变换（如果有）</span></span><br><span class="line">        <span class="keyword">if</span> self.transform:</span><br><span class="line">            sample = self.transform(sample)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> sample</span><br></pre></td></tr></table></figure><h3 id="更简单的示例">更简单的示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.x)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        <span class="keyword">return</span> self.x[idx], self.y[idx]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">x_data = torch.randn(<span class="number">100</span>, <span class="number">5</span>)  <span class="comment"># 100个样本，每个5个特征</span></span><br><span class="line">y_data = torch.randint(<span class="number">0</span>, <span class="number">3</span>, (<span class="number">100</span>,))  <span class="comment"># 100个标签，3分类</span></span><br><span class="line"></span><br><span class="line">dataset = SimpleDataset(x_data, y_data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;数据集大小: <span class="subst">&#123;<span class="built_in">len</span>(dataset)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;第一个样本: <span class="subst">&#123;dataset[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="dataloader数据加载器">DataLoader（数据加载器）</h2><p><code>DataLoader</code> 是一个迭代器，提供以下功能：</p><ul><li><strong>批量处理</strong> (batching)</li><li><strong>数据打乱</strong> (shuffling)</li><li><strong>多进程加载</strong> (multiprocessing)</li></ul><h3 id="主要参数-1">主要参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataLoader(dataset, batch_size=<span class="number">1</span>, shuffle=<span class="literal">False</span>, num_workers=<span class="number">0</span>, ...)</span><br></pre></td></tr></table></figure><ul><li><code>dataset</code>: 要加载的数据集</li><li><code>batch_size</code>: 每个批次的样本数</li><li><code>shuffle</code>: 是否在每个epoch打乱数据</li><li><code>num_workers</code>: 用于数据加载的子进程数</li><li><code>drop_last</code>: 如果数据集大小不能被batch_size整除，是否丢弃最后一个不完整的batch</li></ul><h3 id="使用示例-1">使用示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建DataLoader</span></span><br><span class="line">dataloader = DataLoader(</span><br><span class="line">    dataset=dataset,      <span class="comment"># 上面创建的数据集</span></span><br><span class="line">    batch_size=<span class="number">32</span>,        <span class="comment"># 每批32个样本</span></span><br><span class="line">    shuffle=<span class="literal">True</span>,         <span class="comment"># 训练时打乱数据</span></span><br><span class="line">    num_workers=<span class="number">2</span>,        <span class="comment"># 使用2个子进程加载数据</span></span><br><span class="line">    drop_last=<span class="literal">False</span>       <span class="comment"># 不丢弃最后一个不完整的batch</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历DataLoader</span></span><br><span class="line"><span class="keyword">for</span> batch_idx, (features, labels) <span class="keyword">in</span> <span class="built_in">enumerate</span>(dataloader):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Batch <span class="subst">&#123;batch_idx&#125;</span>:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;  特征形状: <span class="subst">&#123;features.shape&#125;</span>&quot;</span>)  <span class="comment"># torch.Size([32, 5])</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;  标签形状: <span class="subst">&#123;labels.shape&#125;</span>&quot;</span>)    <span class="comment"># torch.Size([32])</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> batch_idx == <span class="number">2</span>:  <span class="comment"># 只显示前3个batch</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="总结-2">总结</h2><ul><li><strong>Dataset</strong>：定义如何访问数据，实现 <code>__len__</code> 和 <code>__getitem__</code> 方法</li><li><strong>DataLoader</strong>：批量加载数据，提供打乱、并行加载等功能</li><li><strong>核心优势</strong>：代码模块化、内存高效、支持并行处理</li><li><strong>典型流程</strong>：创建 Dataset → 创建 DataLoader → 在训练循环中迭代</li></ul><p>这种设计使得数据加载与模型训练解耦，大大提高了代码的可读性和可维护性。</p><ol type="1"><li>需要mini_batch 就需要import DataSet和DataLoader</li><li>继承DataSet的类需要重写init，getitem,len魔法函数。分别是为了加载数据集，获取数据索引，获取数据总量。</li><li>DataLoader对数据集先打乱(shuffle)，然后划分成mini_batch。</li></ol><h2 id="代码示例">代码示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DiabetesDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,filepath</span>):</span><br><span class="line">        xy = np.loadtxt(filepath,delimiter=<span class="string">&#x27;,&#x27;</span>,dtype=np.float32)</span><br><span class="line">        self.<span class="built_in">len</span> = xy.shape[<span class="number">0</span>]</span><br><span class="line">        self.x_data=torch.from_numpy(xy[:,:-<span class="number">1</span>])</span><br><span class="line">        self.y_data=torch.from_numpy(xy[:,[-<span class="number">1</span>]])</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self,index</span>):</span><br><span class="line">        <span class="keyword">return</span> self.x_data[index],self.y_data[index] <span class="comment">#返回元祖</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">len</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataset=DiabetesDataset(<span class="string">&#x27;diabetes.csv.gz&#x27;</span>)</span><br><span class="line">train_loader = DataLoader(dataset=dataset,batch_size=<span class="number">32</span>,shuffle=<span class="literal">True</span>,num_workers=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Model,self).__init__()</span><br><span class="line">        self.linear1 = torch.nn.Linear(<span class="number">8</span>,<span class="number">6</span>)</span><br><span class="line">        self.linear2 = torch.nn.Linear(<span class="number">6</span>,<span class="number">4</span>)</span><br><span class="line">        self.linear3 = torch.nn.Linear(<span class="number">4</span>,<span class="number">1</span>)</span><br><span class="line">        self.sigmiod = torch.nn.Sigmoid()<span class="comment"># 将其看作是网络的一层，而不是简单的函数使用</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        x=self.sigmiod(self.linear1(x))</span><br><span class="line">        x=self.sigmiod(self.linear2(x))</span><br><span class="line">        x=self.sigmiod(self.linear3(x))</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">model = Model()</span><br><span class="line">criterion = torch.nn.BCELoss(reduction=<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(),lr=<span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        <span class="keyword">for</span> i,data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader,<span class="number">0</span>):<span class="comment">#train_loader 是先shuffle后mini_batch 会调用 Dataset 的 __getitem__ 方法来获取每个样本，然后将它们组合成批次。</span></span><br><span class="line">            inputs,labels = data <span class="comment">#返回一个元组，包含两个元素：索引and数据 即一批(batch)数据</span></span><br><span class="line"></span><br><span class="line">            y_pred = model(inputs)</span><br><span class="line">            loss = criterion(y_pred, labels)</span><br><span class="line">            <span class="built_in">print</span>(epoch, i, loss.item())</span><br><span class="line"> </span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            loss.backward()</span><br><span class="line"> </span><br><span class="line">            optimizer.step()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br></pre></td></tr></table></figure><h1 id="多分类问题">多分类问题</h1><p>在实践中，我们通常：</p><ol type="1"><li>对模型的原始输出（logits）应用 Softmax 得到概率分布</li><li>然后计算 交叉熵 损失</li></ol><p>CrossEntropyLoss = LogSoftmax + NLLLoss。也就是说使用CrossEntropyLoss最后一层(线性层)是不需要做其他变化的；使用NLLLoss之前，需要对最后一层(线性层)先进行SoftMax处理，再进行log操作。</p><h2 id="手写数字识别为例">手写数字识别为例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">64</span></span><br><span class="line">transform = transforms.Compose([transforms.ToTensor(),transforms.Normalize((<span class="number">0.1307</span>,),(<span class="number">0.3081</span>,))])</span><br><span class="line"><span class="comment">#transforms.Compose 用于将多个变换组合在一起，按顺序执行。</span></span><br><span class="line"><span class="comment">#transforms.ToTensor()将 PIL 图像或 numpy 数组转换为 PyTorch 张量</span></span><br><span class="line"><span class="comment"># ToTensor 的转换过程</span></span><br><span class="line"><span class="comment"># 原始图像是 28x28 的灰度图，像素值 0-255</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换前：PIL.Image 或 numpy.ndarray</span></span><br><span class="line"><span class="comment"># 形状：H x W x C (28, 28, 1) </span></span><br><span class="line"><span class="comment"># 数值范围：0-255 (uint8)</span></span><br><span class="line"><span class="comment"># 转换后：torch.Tensor</span></span><br><span class="line"><span class="comment"># 形状：C x H x W (1, 28, 28) - PyTorch 要求的通道优先格式</span></span><br><span class="line"><span class="comment"># 数值范围：0.0-1.0 (float32)</span></span><br><span class="line"><span class="comment"># transforms.Normalize((0.1307,), (0.3081,))对张量进行标准化（归一化），使用指定的均值和标准差。</span></span><br><span class="line"><span class="comment"># (0.1307, 0.3081) 是 MNIST 数据集的全局统计值，通过对整个训练集计算得到：</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">train_dataset = datasets.MNIST(root=<span class="string">&#x27;./dataset/mniset&#x27;</span>,train=<span class="literal">True</span>,download=<span class="literal">True</span>,transform=transform)</span><br><span class="line">train_loader = DataLoader(train_dataset,shuffle=<span class="literal">True</span>,batch_size=batch_size)</span><br><span class="line">test_dataset = datasets.MNIST(root=<span class="string">&#x27;./dataset/mniset&#x27;</span>,train=<span class="literal">False</span>,download=<span class="literal">True</span>,transform=transform)</span><br><span class="line">test_loader = DataLoader(test_dataset,shuffle=<span class="literal">True</span>,batch_size=batch_size)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Net,self).__init__()</span><br><span class="line">        self.l1 = torch.nn.Linear(<span class="number">784</span>,<span class="number">512</span>)</span><br><span class="line">        self.l2 = torch.nn.Linear(<span class="number">512</span>,<span class="number">256</span>)</span><br><span class="line">        self.l3 = torch.nn.Linear(<span class="number">256</span>,<span class="number">128</span>)</span><br><span class="line">        self.l4 = torch.nn.Linear(<span class="number">128</span>,<span class="number">64</span>)</span><br><span class="line">        self.l5 = torch.nn.Linear(<span class="number">64</span>,<span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        x = x.view(-<span class="number">1</span>,<span class="number">784</span>)</span><br><span class="line">        x = F.relu(self.l1(x))</span><br><span class="line">        x = F.relu(self.l2(x))</span><br><span class="line">        x = F.relu(self.l3(x))</span><br><span class="line">        x = F.relu(self.l4(x))</span><br><span class="line">        <span class="keyword">return</span> self.l5(x)  <span class="comment">#最后一层不激活</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model = Net()</span><br><span class="line">criterion = torch.nn.CrossEntropyLoss()</span><br><span class="line">optimizer = optim.SGD(model.parameters(),lr=<span class="number">0.01</span>,momentum=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">epoch</span>):</span><br><span class="line">    running_loss=<span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> batch_idx,data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        inputs,targets = data</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        outputs = model(inputs)</span><br><span class="line">        loss = criterion(outputs,targets)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        running_loss+=loss.item()</span><br><span class="line">        <span class="keyword">if</span> batch_idx % <span class="number">300</span> == <span class="number">299</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;[%d, %5d] loss: %.3f&#x27;</span> % (epoch+<span class="number">1</span>, batch_idx+<span class="number">1</span>, running_loss/<span class="number">300</span>))</span><br><span class="line">            running_loss = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="comment">#with torch.no_grad(): 创建一个上下文管理器，在这个上下文中的所有操作都不会计算梯度。</span></span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> test_loader:</span><br><span class="line">            images,labels = data</span><br><span class="line">            outputs = model(images)</span><br><span class="line">            _,predicted = torch.<span class="built_in">max</span>(outputs.data,dim=<span class="number">1</span>)</span><br><span class="line">            <span class="comment">#dim=1 即每一行求max</span></span><br><span class="line">            total +=labels.size(<span class="number">0</span>)</span><br><span class="line">            correct+=(predicted==labels).<span class="built_in">sum</span>().item()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;accuracy on test set: %d %% &#x27;</span> % (<span class="number">100</span>*correct/total))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        train(epoch)</span><br><span class="line">        test()</span><br></pre></td></tr></table></figure><h1 id="cnn卷积神经网络">CNN卷积神经网络</h1><ol type="1"><li>一个卷积核的通道数量等于输入数据的通道数</li><li>卷积核的数目等于输出数据的通道数</li></ol><figure><img src="image-20251207170314211.png" alt="image-20251207170314211" /><figcaption aria-hidden="true">image-20251207170314211</figcaption></figure><figure><img src="image-20251207170451727.png" alt="image-20251207170451727" /><figcaption aria-hidden="true">image-20251207170451727</figcaption></figure><figure><img src="image-20251207170629400.png" alt="image-20251207170629400" /><figcaption aria-hidden="true">image-20251207170629400</figcaption></figure><figure><img src="image-2.png" alt="image-2" /><figcaption aria-hidden="true">image-2</figcaption></figure><p><img src="image-4.png" alt="image-4" /><img src="image-3.png" alt="image-3" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">corr2d</span>(<span class="params">X, K</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算二维互相关运算。&quot;&quot;&quot;</span></span><br><span class="line">    h, w = K.shape</span><br><span class="line">    Y = torch.zeros((X.shape[<span class="number">0</span>] - h + <span class="number">1</span>, X.shape[<span class="number">1</span>] - w + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">1</span>]):</span><br><span class="line">            Y[i, j] = (X[i:i + h, j:j + w] * K).<span class="built_in">sum</span>()</span><br><span class="line">    <span class="keyword">return</span> Y</span><br><span class="line"><span class="comment">#实现二维卷积层</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Conv2D</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, kernel_size</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.weight = nn.Parameter(torch.rand(kernel_size))</span><br><span class="line">        self.bias = nn.Parameter(torch.zeros(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> corr2d(x, self.weight) + self.bias</span><br></pre></td></tr></table></figure><h2 id="填充和步幅">填充和步幅</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在所有侧边填充1个像素</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">comp_conv2d</span>(<span class="params">conv2d, X</span>):</span><br><span class="line">    X = X.reshape((<span class="number">1</span>, <span class="number">1</span>) + X.shape)</span><br><span class="line">    Y = conv2d(X)</span><br><span class="line">    <span class="keyword">return</span> Y.reshape(Y.shape[<span class="number">2</span>:])<span class="comment">#卷积层nn.Conv2d的输入要求是4D张量</span></span><br><span class="line"></span><br><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)<span class="comment">#输入通道数 输出通道数 核大小3*3 填充为1</span></span><br><span class="line">X = torch.rand(size=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#填充不同的高度和宽度</span></span><br><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=(<span class="number">5</span>, <span class="number">3</span>), padding=(<span class="number">2</span>, <span class="number">1</span>))<span class="comment">#输入通道数 输出通道数 核大小5*3 填充为上下各为2 左右各为1</span></span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=(<span class="number">3</span>, <span class="number">5</span>), padding=(<span class="number">0</span>, <span class="number">1</span>), stride=(<span class="number">3</span>, <span class="number">4</span>))<span class="comment">#stride规定了步幅,左右3上下4</span></span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br></pre></td></tr></table></figure><h2 id="池化">池化</h2><p>卷积对位置敏感,因此引入池化提供一定的平移不变性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pool2d</span>(<span class="params">X, pool_size, mode=<span class="string">&#x27;max&#x27;</span></span>):</span><br><span class="line">    p_h, p_w = pool_size</span><br><span class="line">    Y = torch.zeros((X.shape[<span class="number">0</span>] - p_h + <span class="number">1</span>, X.shape[<span class="number">1</span>] - p_w + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">if</span> mode == <span class="string">&#x27;max&#x27;</span>:</span><br><span class="line">                Y[i, j] = X[i:i + p_h, j:j + p_w].<span class="built_in">max</span>()</span><br><span class="line">            <span class="keyword">elif</span> mode == <span class="string">&#x27;avg&#x27;</span>:</span><br><span class="line">                Y[i, j] = X[i:i + p_h, j:j + p_w].mean()</span><br><span class="line">    <span class="keyword">return</span> Y</span><br><span class="line">X = torch.tensor([[<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>], [<span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>]])</span><br><span class="line">pool2d(X, (<span class="number">2</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>深度学习框架中的池化层的步幅与池化窗口的大小相同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X = torch.arange(<span class="number">16</span>, dtype=torch.float32).reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d(<span class="number">3</span>)</span><br><span class="line">pool2d(X)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d((<span class="number">2</span>, <span class="number">3</span>), padding=(<span class="number">1</span>, <span class="number">1</span>), stride=(<span class="number">2</span>, <span class="number">3</span>))<span class="comment">#手动设定大小 填充  步幅</span></span><br><span class="line">pool2d(X)</span><br></pre></td></tr></table></figure><h1 id="pytorch知识">Pytorch知识</h1><h2 id="sequential">sequential</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1Y7411d7Ys/?p=3&amp;amp;share_source=copy_web&amp;amp;vd_source=777aaa8a415b68222e598d976</summary>
      
    
    
    
    <category term="研究生补完" scheme="https://klklkl10086.github.io/klklkl10086.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%A1%A5%E5%AE%8C/"/>
    
    
    <category term="深度学习" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Pytorch" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>cuda编程入门</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2025/11/18/cuda%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2025/11/18/cuda%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</id>
    <published>2025-11-18T12:46:44.000Z</published>
    <updated>2025-11-27T14:16:41.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cuda编程入门">CUDA编程入门</h1><blockquote><p><a href="https://leetgpu.com/">在线cuda编程网站</a></p></blockquote><h1 id="基础知识">基础知识</h1><h2 id="nvidia-smi指令">nvidia-smi指令</h2><figure><img src="image-20251118210332910.png" alt="image-20251118210332910" /><figcaption aria-hidden="true">image-20251118210332910</figcaption></figure><p>更多的命令问ai吧~</p><h2 id="从cpp到cuda编程">从cpp到cuda编程</h2><p>一般的程序:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hello.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//不能使用cout</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ hello.cpp -o hello</span><br><span class="line">./hello</span><br></pre></td></tr></table></figure><p>nvcc:</p><ul><li>安装cuda即可使用nvcc</li><li>nvcc支持纯c++代码编译</li><li>编译扩展名为.cu的cuda文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvcc hello.cu -o hello</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hello.cu</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//不能使用cout</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@autodl-container-6bc24a9b46-e72ce521:~/cudacode/2.1lesson<span class="comment"># nvcc hello.cu -o hellocu</span></span><br><span class="line">root@autodl-container-6bc24a9b46-e72ce521:~/cudacode/2.1lesson<span class="comment"># ./hellocu</span></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure><h2 id="核函数">核函数</h2><blockquote><p><strong>核函数</strong> 是在GPU上并行执行的函数。它是CUDA编程模型的核心，允许你将计算任务分解成成千上万个并行线程，从而利用GPU的大规模并行计算能力。</p></blockquote><ol type="1"><li><strong>执行位置</strong>：在GPU上并行执行,具有异步性。</li><li><strong>并行方式</strong>：通过大量线程以“单指令多线程”的模式并行执行。</li><li><strong>调用方式</strong>：由CPU（主机）调用，但运行在GPU（设备）上。</li><li><strong>返回类型</strong>：必须返回 <code>void</code>。</li><li>只能访问GPU内存</li><li>不行使用变长参数 静态变量 函数指针</li><li>不支持c++的iostream</li></ol><h3 id="定义">定义</h3><p>使用 <code>__global__</code> 关键字来声明一个函数为核函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 __global__ 关键字定义核函数</span></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">myKernel</span><span class="params">(<span class="type">int</span> *array, <span class="type">int</span> value)</span> </span>&#123;<span class="comment">//global和void可以互换位置</span></span><br><span class="line">    <span class="comment">// 计算当前线程的全局索引</span></span><br><span class="line">    <span class="type">int</span> idx = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line">    <span class="comment">// 每个线程对数组中不同的元素进行操作</span></span><br><span class="line">    array[idx] += value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>执行空间说明符</code>:</p><ul><li><code>__global__</code>：在GPU上执行，<strong>由CPU调用</strong>。这是我们定义核函数时使用的。</li><li><code>__device__</code>：在GPU上执行，<strong>由GPU调用</strong>（通常是从其他 <code>__device__</code> 函数或核函数中调用）。</li><li><code>__host__</code>：在CPU上执行，由CPU调用（就是普通的C++函数）。可以同时使用 <code>__host__ __device__</code>，使得该函数既能被CPU调用，也能被GPU编译。</li></ul><p><strong>cuda程序编写流程</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">主机代码</span><br><span class="line">核函数调用</span><br><span class="line">主机代码</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用">调用</h3><p>调用核函数时，需要使用特殊的尖括号语法 <code>&lt;&lt;&lt; ... &gt;&gt;&gt;</code> 来指定<strong>执行配置</strong>，即如何组织线程来执行这个核函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">hello_from_gpu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from gpu\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在主机(CPU)代码中调用核函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">//执行配置 &lt;&lt;&lt;网格大小, 块大小, 动态共享内存大小(可选), 流(可选)&gt;&gt;&gt;</span></span><br><span class="line">    hello_from_gpu&lt;&lt;&lt;<span class="number">1</span>,<span class="number">1</span>&gt;&gt;&gt;();<span class="comment">//1个线程块 块中有1个线程</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cudaDeviceSynchronize</span>();<span class="comment">//同步函数,等待gpu执行完毕,主机与gpu的同步</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>线程 线程块 网格</code></p><ul><li><strong>线程</strong>：最基本的执行单元。</li><li><strong>线程块</strong>：一组线程的集合。<ul><li>一个块内的线程可以：<ul><li>通过<strong>共享内存</strong>高效地交换数据。</li><li>使用 <code>__syncthreads()</code> 函数进行同步。</li></ul></li><li>线程块之间是<strong>相互独立</strong>的。它们可以以<strong>任何顺序</strong>、在<strong>任何SM（流多处理器）</strong> 上执行。</li><li>一个线程块的执行不应依赖于另一个线程块的结果。这是CUDA编程模型的一个基本假设。</li></ul></li><li><strong>网格</strong>：所有线程块的集合。一个核函数启动的所有线程块构成一个网格。</li></ul><h2 id="cuda线程模型">CUDA线程模型</h2><h3 id="线程模型结构">线程模型结构</h3><figure><img src="kts7mm1vzn.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><blockquote><p>CUDA线程模型是一个<strong>分层的并行编程模型</strong>，它将并行任务分解为多个层次，从粗粒度到细粒度依次是： <strong>网格(grid) → 线程块(block) → 线程束 → 线程</strong></p></blockquote><p><code>线程</code>:最基本的执行单元</p><ul><li>每个线程是独立的执行路径</li><li>执行相同的核函数代码，但处理不同的数据</li><li>有自己的程序计数器、寄存器组和本地内存</li></ul><p><code>线程块</code>:协作的线程组</p><ul><li><strong>共享内存</strong>：块内所有线程共享一块快速片上内存</li><li><strong>同步能力</strong>：通过 <code>__syncthreads()</code> 实现块内线程同步</li><li><strong>独立性</strong>：不同线程块之间相互独立，可以乱序执行</li><li><strong>维度</strong>：可以是1D、2D或3D布局</li></ul><p><code>网格</code>: 完整的执行单元</p><ul><li>包含所有执行<strong>同一核函数</strong>的线程块</li><li>当核函数启动时，就定义了一个网格</li><li>网格中的线程块被调度到不同的SM上执行</li></ul><p><strong>注意</strong>:</p><ul><li>线程分块是逻辑划分,物理上线程不分块</li><li>配置线程: &lt;&lt;&lt;网格大小,线程块大小&gt;&gt;&gt;</li><li>最大允许线程块大小1024</li><li>最大允许网格大小<span class="math inline">\(2^{32}-1\)</span>(针对一维网格)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">hello_from_gpu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from gpu\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hello_from_gpu&lt;&lt;&lt;<span class="number">2</span>,<span class="number">4</span>&gt;&gt;&gt;();<span class="comment">//2线程块  一个块里有4个线程</span></span><br><span class="line">    <span class="built_in">cudaDeviceSynchronize</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@autodl-container-6bc24a9b46-e72ce521:~/cudacode/2.3lesson<span class="comment"># nvcc ex1.cu -o ex1</span></span><br><span class="line">root@autodl-container-6bc24a9b46-e72ce521:~/cudacode/2.3lesson<span class="comment"># ./ex1</span></span><br><span class="line">Hello from gpu</span><br><span class="line">Hello from gpu</span><br><span class="line">Hello from gpu</span><br><span class="line">Hello from gpu</span><br><span class="line">Hello from gpu</span><br><span class="line">Hello from gpu</span><br><span class="line">Hello from gpu</span><br><span class="line">Hello from gpu</span><br></pre></td></tr></table></figure><h3 id="一维线程模型">一维线程模型</h3><ol type="1"><li>每个线程在<code>核函数</code>中都有一个<strong>唯一的身份标识</strong></li><li>每个线程的唯一标识由&lt;&lt;&lt;grid_size,block_size&gt;&gt;&gt;确定,grid_size,block_size保存在内建变量(build-in variable) <strong>目前考虑的是一维情况</strong><ul><li>gridDim.x : 该数值等于执行配置中变量grid_size的值</li><li>blockDim.x : 该数值等于执行配置中变量block_size的值</li></ul></li><li>线程索引保存为内建变量<ul><li>blockIdx.x : 该变量指定一个线程在一个网格中的线程块索引值,范围为0~gridDim.x-1</li><li>threadIdx.x : 该变量指定一个线程在一个线程块中的线程索引值,范围为0~blockDim.x-1</li></ul></li></ol><figure><img src="image-20251119182816235.png" alt="image-20251119182816235" /><figcaption aria-hidden="true">image-20251119182816235</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一维网格和块 计算线程索引</span></span><br><span class="line"><span class="type">int</span> idx = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line"><span class="comment">//在上述例子中,idx的范围为0~7</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">hello_from_gpu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> bid = blockIdx.x;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> tid = threadIdx.x;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> id = bid*blockDim.x+tid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from block %d and thread %d, global id %d\n&quot;</span>,bid,tid,id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hello_from_gpu&lt;&lt;&lt;<span class="number">2</span>,<span class="number">4</span>&gt;&gt;&gt;();<span class="comment">//2线程块  一个块里有4个线程</span></span><br><span class="line">    <span class="built_in">cudaDeviceSynchronize</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@autodl-container-6bc24a9b46-e72ce521:~/cudacode/2.3lesson<span class="comment"># nvcc ex1.cu -o ex1</span></span><br><span class="line">root@autodl-container-6bc24a9b46-e72ce521:~/cudacode/2.3lesson<span class="comment"># ./ex1</span></span><br><span class="line">Hello from block 1 and thread 0, global <span class="built_in">id</span> 4</span><br><span class="line">Hello from block 1 and thread 1, global <span class="built_in">id</span> 5</span><br><span class="line">Hello from block 1 and thread 2, global <span class="built_in">id</span> 6</span><br><span class="line">Hello from block 1 and thread 3, global <span class="built_in">id</span> 7</span><br><span class="line">Hello from block 0 and thread 0, global <span class="built_in">id</span> 0</span><br><span class="line">Hello from block 0 and thread 1, global <span class="built_in">id</span> 1</span><br><span class="line">Hello from block 0 and thread 2, global <span class="built_in">id</span> 2</span><br><span class="line">Hello from block 0 and thread 3, global <span class="built_in">id</span> 3</span><br></pre></td></tr></table></figure><h3 id="多维线程">多维线程</h3><figure><img src="image-20251119184229406.png" alt="image-20251119184229406" /><figcaption aria-hidden="true">image-20251119184229406</figcaption></figure><figure><img src="image-20251119184244577.png" alt="image-20251119184244577" /><figcaption aria-hidden="true">image-20251119184244577</figcaption></figure><figure><img src="image-20251119184425543.png" alt="image-20251119184425543" /><figcaption aria-hidden="true">image-20251119184425543</figcaption></figure><figure><img src="image-20251119184524180.png" alt="image-20251119184524180" /><figcaption aria-hidden="true">image-20251119184524180</figcaption></figure><figure><img src="image-20251119185219189.png" alt="image-20251119185219189" /><figcaption aria-hidden="true">image-20251119185219189</figcaption></figure><p><strong>网格和线程块的限制条件</strong>:</p><figure><img src="image-20251119185323653.png" alt="image-20251119185323653" /><figcaption aria-hidden="true">image-20251119185323653</figcaption></figure><h3 id="线程全局索引计算方式">线程全局索引计算方式</h3><h4 id="线程全局索引">线程全局索引</h4><p><strong>一维网格 一维线程块:</strong></p><figure><img src="image-20251119185717207.png" alt="image-20251119185717207" /><figcaption aria-hidden="true">image-20251119185717207</figcaption></figure><p><strong>二维网格 二维线程块:</strong> <img src="image-20251119191022263.png" alt="image-20251119191022263" /></p><p><strong>三维网格 三维线程块:</strong></p><figure><img src="image-20251119191154297.png" alt="image-20251119191154297" /><figcaption aria-hidden="true">image-20251119191154297</figcaption></figure><h3 id="nvcc编译流程和gpu计算能力">NVCC编译流程和GPU计算能力</h3><h4 id="nvcc编译流程">NVCC编译流程</h4><blockquote><p>NVCC（NVIDIA CUDA Compiler）的编译流程分为多个阶段，主要处理主机端（Host，CPU）代码和设备端（Device，GPU）代码的混合编译。</p></blockquote><figure><img src="image-20251119205631454.png" alt="image-20251119205631454" /><figcaption aria-hidden="true">image-20251119205631454</figcaption></figure><figure><img src="cuda-compilation-from-cu-to-executable.png" alt="CUDA Compilation Trajectory" /><figcaption aria-hidden="true">CUDA Compilation Trajectory</figcaption></figure><h3 id="ptx">PTX</h3><blockquote><p>PTX（Parallel Thread Execution）是CUDA平台为基于 GPU的通用计算而定义的虚拟机和指令集</p></blockquote><ul><li><strong>虚拟指令集</strong>：不直接对应具体GPU硬件，而是抽象中间表示</li><li><strong>跨架构兼容</strong>：可在不同代际的NVIDIA GPU上运行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CUDA源码 (.cu) </span><br><span class="line">    ↓ NVCC编译</span><br><span class="line">PTX代码 (.<span class="built_in">ptx</span>)           ← 跨架构中间表示</span><br><span class="line">    ↓ GPU驱动JIT编译  </span><br><span class="line">具体架构SASS代码          ← 特定GPU机器码</span><br><span class="line">    ↓ GPU执行</span><br></pre></td></tr></table></figure><ol type="1"><li>nvcc编译命令总是使用两个体系结构:一个是虚拟的中间体系结构，另一个是实际的GPU体系结构</li><li>虚拟架构更像是对应用所需的GPU功能的声明</li><li>虚拟架构应该尽可能选择低----适配更多实际GPU</li><li>真实架构应该尽可能选择高----充分发挥GPU性能</li><li>虚拟架构应低于真实架构</li></ol><h3 id="gpu架构和计算能力">GPU架构和计算能力</h3><figure><img src="image-20251119210546435.png" alt="image-20251119210546435" /><figcaption aria-hidden="true">image-20251119210546435</figcaption></figure><p>并非GPU 的计算能力越高，性能就越高</p><h3 id="cuda程序兼容性问题">CUDA程序兼容性问题</h3><h4 id="虚拟架构计算能力">虚拟架构计算能力</h4><figure><img src="image-20251119212759966.png" alt="image-20251119212759966" /><figcaption aria-hidden="true">image-20251119212759966</figcaption></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nvcc helloworld.cu –o helloworld -<span class="built_in">arch</span>=compute_61</span><br><span class="line"><span class="comment">#编译出的可执行文件helloworld可以在计算能力&gt;=6.1的GPU上面执行，在计算能力小于6.1的GPU则不能执行。</span></span><br></pre></td></tr></table></figure><h4 id="真实架构计算能力">真实架构计算能力</h4><figure><img src="image-20251119213013409.png" alt="image-20251119213013409" /><figcaption aria-hidden="true">image-20251119213013409</figcaption></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nvcc helloworld.cu –o helloworld -<span class="built_in">arch</span>=compute_61 -code=sm_60</span><br><span class="line"><span class="comment">#指定的真实架构能力为6.0虚拟架构为6.1违反(3)</span></span><br></pre></td></tr></table></figure><h4 id="多个gpu版本编译">多个GPU版本编译</h4><figure><img src="image-20251119213142292.png" alt="image-20251119213142292" /><figcaption aria-hidden="true">image-20251119213142292</figcaption></figure><h4 id="nvcc即时编译">NVCC即时编译</h4><ol type="1"><li><p>在运行可执行文件时，从保留的PTX代码临时编译出cubin文件</p></li><li><p>在可执行文件中保留PTX代码，nvcc编译指令指定所保留的PTX代码虚拟架构:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-gencode <span class="built_in">arch</span>=compute_XY ,code=compute_XY</span><br><span class="line"><span class="comment">#两个计算能力都是虚拟架构计算能力</span></span><br><span class="line"><span class="comment">#两个虚拟架构计算能力必须一致</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="nvcc编译默认计算能力">NVCC编译默认计算能力</h4><p>不同版本CUDA编译器在编译CUDA代码时，都有一个默认计算能力</p><figure><img src="image-20251119213458783.png" alt="image-20251119213458783" /><figcaption aria-hidden="true">image-20251119213458783</figcaption></figure><h1 id="cuda编程简单实践">CUDA编程简单实践</h1><h2 id="cuda矩阵加法运算程序">CUDA矩阵加法运算程序</h2><h3 id="cuda程序基本框架">CUDA程序基本框架</h3><figure><img src="image-20251119214814450.png" alt="image-20251119214814450" /><figcaption aria-hidden="true">image-20251119214814450</figcaption></figure><h4 id="设置gpu设备">设置GPU设备</h4><p><strong>获取GPU数量:</strong></p><figure><img src="image-20251119214943840.png" alt="image-20251119214943840" /><figcaption aria-hidden="true">image-20251119214943840</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> iDeviceCount = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cudaGetDeviceCount</span>(&amp;iDeviceCount);</span><br></pre></td></tr></table></figure><p><strong>设置GPU执行时使用的设备</strong>:</p><figure><img src="image-20251119215012498.png" alt="image-20251119215012498" /><figcaption aria-hidden="true">image-20251119215012498</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> iDev = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cudaSetDevice</span>(iDev)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//检查计算机GPU的数量</span></span><br><span class="line">    <span class="type">int</span> iDeviceCount=<span class="number">0</span>;</span><br><span class="line">    cudaError_t error = <span class="built_in">cudaGetDeviceCount</span>(&amp;iDeviceCount);</span><br><span class="line">    <span class="keyword">if</span>(error!= cudaSuccess || iDeviceCount ==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NO CUDA campatable GPU found\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The count of GPUs is %d \n&quot;</span>,iDeviceCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置执行</span></span><br><span class="line">    <span class="type">int</span> iDev = <span class="number">0</span>;</span><br><span class="line">    error = <span class="built_in">cudaSetDevice</span>(iDev);</span><br><span class="line">    <span class="keyword">if</span>(error!=cudaSuccess)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to set GPU 0 for computing.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;set GPU 0 for computing.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存管理">内存管理</h3><blockquote><p>CUDA通过内存分配 数据传递 内存初始化 内存释放进行内存管理</p></blockquote><figure><img src="image-20251119215530502.png" alt="image-20251119215530502" /><figcaption aria-hidden="true">image-20251119215530502</figcaption></figure><h4 id="内存分配">内存分配</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__host__ __device__ cudaError_t <span class="title">cudaMalloc</span><span class="params">(<span class="type">void</span>** devPtr, <span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>devPtr</code>: 指向设备内存指针的指针。函数会将分配的设备内存地址存储在这个指针中。</li><li><code>size</code>: 要分配的内存大小（以字节为单位）。</li><li>返回 <code>cudaError_t</code> 类型值，表示函数执行的状态。如果成功，返回 <code>cudaSuccess</code></li></ul><p>使用 cudaMalloc 分配的内存必须使用 cudaFree 来释放。</p><h4 id="数据拷贝">数据拷贝</h4><p><code>cudaMemcpy</code> 用于在<strong>主机内存</strong>和<strong>设备内存</strong>之间复制数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__host__ cudaError_t <span class="title">cudaMemcpy</span><span class="params">(<span class="type">void</span>* dst, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">size_t</span> count, cudaMemcpyKind kind)</span></span></span><br></pre></td></tr></table></figure><ul><li><code>dst</code>: 目标内存地址</li><li><code>src</code>: 源内存地址</li><li><code>count</code>: 要复制的字节数</li><li><code>kind</code>: 复制方向，指定数据是从主机到设备，还是从设备到主机等。这是一个枚举类型，主要取值有：<ul><li><code>cudaMemcpyHostToHost</code>： 主机 → 主机</li><li><code>cudaMemcpyHostToDevice</code>： 主机 → 设备</li><li><code>cudaMemcpyDeviceToHost</code>： 设备 → 主机</li><li><code>cudaMemcpyDeviceToDevice</code>： 设备 → 设备</li><li><code>cudaMemcpyDefault</code>： 根据指针地址自动判断方向（默认方式只允许在支持统一虚拟寻址的系统上使用）</li></ul></li></ul><h4 id="内存初始化">内存初始化</h4><p><code>cudaMemset</code> 用于设置设备内存的值，功能类似于标准 C 的 <code>memset</code> 函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__host__ cudaError_t <span class="title">cudaMemset</span><span class="params">(<span class="type">void</span>* devPtr, <span class="type">int</span> value, <span class="type">size_t</span> count)</span></span></span><br></pre></td></tr></table></figure><ul><li><code>devPtr</code>: 指向设备内存的指针</li><li><code>value</code>: 要设置的值（以字节为单位设置）</li><li><code>count</code>: 要设置的字节数</li></ul><p><code>cudaMemset</code> 是按<strong>字节</strong>操作的，这与标准 <code>memset</code> 一致。这对于初始化 <code>char</code> 数组或清零内存非常有用，但对于设置非字节类型的特定值（如将所有 <code>int</code> 设置为 <code>1</code>）则不方便。</p><h4 id="内存释放">内存释放</h4><p><code>cudaFree</code> 用于释放由 <code>cudaMalloc</code>、<code>cudaMallocManaged</code> 等函数分配的<strong>设备内存</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__host__ __device__ cudaError_t <span class="title">cudaFree</span><span class="params">(<span class="type">void</span>* devPtr)</span></span></span><br></pre></td></tr></table></figure><ul><li><p><code>devPtr</code>: 指向要释放的设备内存的指针</p></li><li><p>只能释放由 CUDA 内存分配函数分配的内存。</p></li><li><p>试图释放无效的指针或已经释放的指针会导致未定义行为（通常是运行时错误）。</p></li><li><p>在主机程序退出前释放所有分配的设备内存是一个好习惯，但现代 CUDA 驱动在程序结束时也会自动清理。</p></li></ul><h3 id="自定义设备函数">自定义设备函数</h3><p><code>设备函数（device function）</code></p><ul><li>定义只能执行在GPU设备上的函数为设备函数</li><li>设备函数只能被核函数或其他设备函数调用</li><li>设备函数用device修饰</li></ul><p><code>核函数（kernel function）</code></p><ul><li>用global修饰的函数称为核函数，一般由主机调用，在设备中执行</li><li>global 修饰符既不能和host同时使用，也不可与device 同时使用</li></ul><p><code>主机函数（host function）</code></p><ul><li>主机端的普通 C++ 函数可用 <strong>host</strong> 修饰</li><li>对于主机端的函数， __host__修饰符可省略</li><li>可以用 <strong>host</strong> 和 <strong>device</strong> 同时修饰一个函数减少冗余代码。编译器会针对主机 和设备分别编译该函数。</li></ul><h3 id="一维矩阵加法">一维矩阵加法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">addFromGPU</span><span class="params">(<span class="type">float</span> *A ,<span class="type">float</span> *B ,<span class="type">float</span> *C,<span class="type">const</span> <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> bid = blockIdx.x;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> tid = threadIdx.x;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> id = tid+bid*blockDim.x;</span><br><span class="line"></span><br><span class="line">    C[id]=A[id]+B[id];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialData</span><span class="params">(<span class="type">float</span> *addr,<span class="type">int</span> elemCount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;elemCount;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        addr[i]=(<span class="type">float</span>)(<span class="built_in">rand</span>()&amp; <span class="number">0xff</span>) / <span class="number">10.f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setGPU</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.检查计算机GPU的数量</span></span><br><span class="line">    <span class="type">int</span> iDeviceCount=<span class="number">0</span>;</span><br><span class="line">    cudaError_t error = <span class="built_in">cudaGetDeviceCount</span>(&amp;iDeviceCount);</span><br><span class="line">    <span class="keyword">if</span>(error!= cudaSuccess || iDeviceCount ==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NO CUDA campatable GPU found\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The count of GPUs is %d \n&quot;</span>,iDeviceCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.设置执行</span></span><br><span class="line">    <span class="type">int</span> iDev = <span class="number">0</span>;</span><br><span class="line">    error = <span class="built_in">cudaSetDevice</span>(iDev);</span><br><span class="line">    <span class="keyword">if</span>(error!=cudaSuccess)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to set GPU 0 for computing.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;set GPU 0 for computing.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 1.设置GPU设备</span></span><br><span class="line">   <span class="built_in">setGPU</span>();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.分配主机内存和设备内存,并初始化</span></span><br><span class="line">   <span class="type">int</span> iElemCount = <span class="number">512</span>;        <span class="comment">//一个矩阵的元素数目</span></span><br><span class="line">   <span class="type">size_t</span> stBytesCount = iElemCount * <span class="built_in">sizeof</span>(<span class="type">float</span>); <span class="comment">//字节数</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//(1)分配主机内存并初始化</span></span><br><span class="line">    <span class="type">float</span> *fpHost_A,*fpHost_B,*fpHost_C;</span><br><span class="line">    fpHost_A = (<span class="type">float</span>*) <span class="built_in">malloc</span>(stBytesCount);</span><br><span class="line">    fpHost_B = (<span class="type">float</span>*) <span class="built_in">malloc</span>(stBytesCount);</span><br><span class="line">    fpHost_C = (<span class="type">float</span>*) <span class="built_in">malloc</span>(stBytesCount);</span><br><span class="line">    <span class="keyword">if</span>(fpHost_A!=<span class="literal">NULL</span>&amp;&amp;fpHost_B!=<span class="literal">NULL</span>&amp;&amp;fpHost_C!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//主机内存初始化为0</span></span><br><span class="line">        <span class="built_in">memset</span>(fpHost_A,<span class="number">0</span>,stBytesCount);</span><br><span class="line">        <span class="built_in">memset</span>(fpHost_B,<span class="number">0</span>,stBytesCount);</span><br><span class="line">        <span class="built_in">memset</span>(fpHost_C,<span class="number">0</span>,stBytesCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fail to allocate host memory!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// (2)分配设备内存 并初始化</span></span><br><span class="line">    <span class="type">float</span> *fpDevice_A,*fpDevice_B,*fpDevice_C;</span><br><span class="line">    <span class="built_in">cudaMalloc</span>((<span class="type">float</span>**)&amp;fpDevice_A,stBytesCount);</span><br><span class="line">    <span class="built_in">cudaMalloc</span>((<span class="type">float</span>**)&amp;fpDevice_B,stBytesCount);</span><br><span class="line">    <span class="built_in">cudaMalloc</span>((<span class="type">float</span>**)&amp;fpDevice_C,stBytesCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fpDevice_A != <span class="literal">NULL</span> &amp;&amp; fpDevice_B != <span class="literal">NULL</span> &amp;&amp; fpDevice_C != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cudaMemset</span>(fpDevice_A,<span class="number">0</span>,stBytesCount);</span><br><span class="line">        <span class="built_in">cudaMemset</span>(fpDevice_B,<span class="number">0</span>,stBytesCount);</span><br><span class="line">        <span class="built_in">cudaMemset</span>(fpDevice_C,<span class="number">0</span>,stBytesCount);</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to allocate memory\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(fpHost_A);</span><br><span class="line">        <span class="built_in">free</span>(fpHost_B);</span><br><span class="line">        <span class="built_in">free</span>(fpHost_C);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.初始化主机中的数据</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="number">666</span>);</span><br><span class="line">    <span class="built_in">initialData</span>(fpHost_A,iElemCount);</span><br><span class="line">    <span class="built_in">initialData</span>(fpHost_B,iElemCount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.从主机复制数据到设备</span></span><br><span class="line">    <span class="built_in">cudaMemcpy</span>(fpDevice_A,fpHost_A,stBytesCount,cudaMemcpyHostToDevice);</span><br><span class="line">    <span class="built_in">cudaMemcpy</span>(fpDevice_B,fpHost_B,stBytesCount,cudaMemcpyHostToDevice);</span><br><span class="line">    <span class="built_in">cudaMemcpy</span>(fpDevice_C,fpHost_C,stBytesCount,cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.调用核函数在设备上计算</span></span><br><span class="line">    <span class="function">dim3 <span class="title">block</span><span class="params">(<span class="number">32</span>)</span></span>;</span><br><span class="line">    <span class="function">dim3 <span class="title">grid</span><span class="params">(iElemCount/<span class="number">32</span>)</span></span>;<span class="comment">//保证每个线程负责一个数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    addFromGPU&lt;&lt;&lt;grid,block&gt;&gt;&gt;(fpDevice_A,fpDevice_B,fpDevice_C,iElemCount);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//cudaDeviceSynchronize();//保证GPU执行完之后再执行以下语句</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.将计算得到的数据从设备传给主机</span></span><br><span class="line">    <span class="built_in">cudaMemcpy</span>(fpHost_C,fpDevice_C,stBytesCount,cudaMemcpyDeviceToHost);</span><br><span class="line">    <span class="comment">//隐式保证GPU执行完之后再执行 ,因此可以省略cudaDeviceSynchronize();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;idx=%2d\tmatrix_A:%.2f\tmatrix_B:%.2f\tresult=%.2f\n&quot;</span>, i+<span class="number">1</span>, fpHost_A[i], fpHost_B[i], fpHost_C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7.释放主机与设备内存</span></span><br><span class="line">    <span class="built_in">free</span>(fpHost_A);</span><br><span class="line">    <span class="built_in">free</span>(fpHost_B);</span><br><span class="line">    <span class="built_in">free</span>(fpHost_C);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cudaFree</span>(fpDevice_A);</span><br><span class="line">    <span class="built_in">cudaFree</span>(fpDevice_B);</span><br><span class="line">    <span class="built_in">cudaFree</span>(fpDevice_C);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cudaDeviceReset</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tips:</p><ol type="1"><li><p>上述代码人为设置一个线程可以负责一个数据,但当数据个数由512变化为513时,<code>dim3 grid(iElemCount/32);</code>就无法保证一个线程负责一个数据,因此要改为<code>dim3 grid((iElemCount + block.x - 1) / 32);</code>,即向上取整,此时线程个数会多于矩阵元素个数,因此在GPU上的运算函数要附加if条件。</p></li><li><p>上述核函数可以拆分为核函数调用设备函数的形式</p></li><li><p>结合上述两条,修改后的代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__device__  <span class="type">float</span> <span class="title">add</span><span class="params">(<span class="type">const</span> <span class="type">float</span> x,<span class="type">const</span> <span class="type">float</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">addFromGPU</span><span class="params">(<span class="type">float</span> *A ,<span class="type">float</span> *B ,<span class="type">float</span> *C,<span class="type">const</span> <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> bid = blockIdx.x;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> tid = threadIdx.x;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> id = tid+bid*blockDim.x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(id&gt;=N) <span class="keyword">return</span> ;</span><br><span class="line">    C[id]=<span class="built_in">add</span>(A[id],B[id]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialData</span><span class="params">(<span class="type">float</span> *addr,<span class="type">int</span> elemCount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;elemCount;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        addr[i]=(<span class="type">float</span>)(<span class="built_in">rand</span>()&amp; <span class="number">0xff</span>) / <span class="number">10.f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setGPU</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.检查计算机GPU的数量</span></span><br><span class="line">    <span class="type">int</span> iDeviceCount=<span class="number">0</span>;</span><br><span class="line">    cudaError_t error = <span class="built_in">cudaGetDeviceCount</span>(&amp;iDeviceCount);</span><br><span class="line">    <span class="keyword">if</span>(error!= cudaSuccess || iDeviceCount ==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NO CUDA campatable GPU found\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The count of GPUs is %d \n&quot;</span>,iDeviceCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.设置执行</span></span><br><span class="line">    <span class="type">int</span> iDev = <span class="number">0</span>;</span><br><span class="line">    error = <span class="built_in">cudaSetDevice</span>(iDev);</span><br><span class="line">    <span class="keyword">if</span>(error!=cudaSuccess)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to set GPU 0 for computing.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;set GPU 0 for computing.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 1.设置GPU设备</span></span><br><span class="line">   <span class="built_in">setGPU</span>();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.分配主机内存和设备内存,并初始化</span></span><br><span class="line">   <span class="type">int</span> iElemCount = <span class="number">513</span>;        <span class="comment">//一个矩阵的元素数目</span></span><br><span class="line">   <span class="type">size_t</span> stBytesCount = iElemCount * <span class="built_in">sizeof</span>(<span class="type">float</span>); <span class="comment">//字节数</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//(1)分配主机内存并初始化</span></span><br><span class="line">    <span class="type">float</span> *fpHost_A,*fpHost_B,*fpHost_C;</span><br><span class="line">    fpHost_A = (<span class="type">float</span>*) <span class="built_in">malloc</span>(stBytesCount);</span><br><span class="line">    fpHost_B = (<span class="type">float</span>*) <span class="built_in">malloc</span>(stBytesCount);</span><br><span class="line">    fpHost_C = (<span class="type">float</span>*) <span class="built_in">malloc</span>(stBytesCount);</span><br><span class="line">    <span class="keyword">if</span>(fpHost_A!=<span class="literal">NULL</span>&amp;&amp;fpHost_B!=<span class="literal">NULL</span>&amp;&amp;fpHost_C!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//主机内存初始化为0</span></span><br><span class="line">        <span class="built_in">memset</span>(fpHost_A,<span class="number">0</span>,stBytesCount);</span><br><span class="line">        <span class="built_in">memset</span>(fpHost_B,<span class="number">0</span>,stBytesCount);</span><br><span class="line">        <span class="built_in">memset</span>(fpHost_C,<span class="number">0</span>,stBytesCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fail to allocate host memory!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// (2)分配设备内存 并初始化</span></span><br><span class="line">    <span class="type">float</span> *fpDevice_A,*fpDevice_B,*fpDevice_C;</span><br><span class="line">    <span class="built_in">cudaMalloc</span>((<span class="type">float</span>**)&amp;fpDevice_A,stBytesCount);</span><br><span class="line">    <span class="built_in">cudaMalloc</span>((<span class="type">float</span>**)&amp;fpDevice_B,stBytesCount);</span><br><span class="line">    <span class="built_in">cudaMalloc</span>((<span class="type">float</span>**)&amp;fpDevice_C,stBytesCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fpDevice_A != <span class="literal">NULL</span> &amp;&amp; fpDevice_B != <span class="literal">NULL</span> &amp;&amp; fpDevice_C != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cudaMemset</span>(fpDevice_A,<span class="number">0</span>,stBytesCount);</span><br><span class="line">        <span class="built_in">cudaMemset</span>(fpDevice_B,<span class="number">0</span>,stBytesCount);</span><br><span class="line">        <span class="built_in">cudaMemset</span>(fpDevice_C,<span class="number">0</span>,stBytesCount);</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to allocate memory\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(fpHost_A);</span><br><span class="line">        <span class="built_in">free</span>(fpHost_B);</span><br><span class="line">        <span class="built_in">free</span>(fpHost_C);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.初始化主机中的数据</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="number">666</span>);</span><br><span class="line">    <span class="built_in">initialData</span>(fpHost_A,iElemCount);</span><br><span class="line">    <span class="built_in">initialData</span>(fpHost_B,iElemCount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.从主机复制数据到设备</span></span><br><span class="line">    <span class="built_in">cudaMemcpy</span>(fpDevice_A,fpHost_A,stBytesCount,cudaMemcpyHostToDevice);</span><br><span class="line">    <span class="built_in">cudaMemcpy</span>(fpDevice_B,fpHost_B,stBytesCount,cudaMemcpyHostToDevice);</span><br><span class="line">    <span class="built_in">cudaMemcpy</span>(fpDevice_C,fpHost_C,stBytesCount,cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.调用核函数在设备上计算</span></span><br><span class="line">    <span class="function">dim3 <span class="title">block</span><span class="params">(<span class="number">32</span>)</span></span>;</span><br><span class="line">    <span class="function">dim3 <span class="title">grid</span><span class="params">((iElemCount<span class="number">-1</span>+block.x)/block.x)</span></span>;<span class="comment">//保证每个线程负责一个数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    addFromGPU&lt;&lt;&lt;grid,block&gt;&gt;&gt;(fpDevice_A,fpDevice_B,fpDevice_C,iElemCount);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.将计算得到的数据从设备传给主机</span></span><br><span class="line">    <span class="built_in">cudaMemcpy</span>(fpHost_C,fpDevice_C,stBytesCount,cudaMemcpyDeviceToHost);<span class="comment">//隐式保证GPU执行完之后再执行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;idx=%2d\tmatrix_A:%.2f\tmatrix_B:%.2f\tresult=%.2f\n&quot;</span>, i+<span class="number">1</span>, fpHost_A[i], fpHost_B[i], fpHost_C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7.释放主机与设备内存</span></span><br><span class="line">    <span class="built_in">free</span>(fpHost_A);</span><br><span class="line">    <span class="built_in">free</span>(fpHost_B);</span><br><span class="line">    <span class="built_in">free</span>(fpHost_C);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cudaFree</span>(fpDevice_A);</span><br><span class="line">    <span class="built_in">cudaFree</span>(fpDevice_B);</span><br><span class="line">    <span class="built_in">cudaFree</span>(fpDevice_C);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cudaDeviceReset</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="cuda常用api">CUDA常用API</h2><h3 id="错误检测">错误检测</h3><h3 id="计时">计时</h3><h3 id="查询gpu信息">查询GPU信息</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cuda编程入门&quot;&gt;CUDA编程入门&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetgpu.com/&quot;&gt;在线cuda编程网站&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;基础知识&quot;&gt;基础知识&lt;/h1&gt;</summary>
      
    
    
    
    <category term="研究生补完" scheme="https://klklkl10086.github.io/klklkl10086.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%A1%A5%E5%AE%8C/"/>
    
    
    <category term="CPP" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/CPP/"/>
    
    <category term="CUDA" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/CUDA/"/>
    
  </entry>
  
  <entry>
    <title>javaSE</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2025/10/01/java%E5%9F%BA%E7%A1%80/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2025/10/01/java%E5%9F%BA%E7%A1%80/</id>
    <published>2025-10-01T14:43:52.000Z</published>
    <updated>2025-10-10T14:09:15.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java">JAVA</h1><blockquote><p>有两大类核心技术:</p><ul><li>javaSE:普通的桌面应用 控制台</li><li>javaEE:开发网站</li></ul></blockquote><h2 id="基本认识">基本认识</h2><h3 id="jdk-vs-jre">JDK vs JRE</h3><blockquote><p><strong>JDK（Java Development Kit）</strong></p><p><strong>作用</strong>：JDK 是用于开发 Java 程序的工具包，它不仅包含 JRE，还包含编译和调试工具。</p><p><strong>组成</strong>：</p><ul><li><strong>JRE</strong>：包含执行 Java 应用程序所需的所有环境。</li><li><strong>编译器（javac）</strong>：将 Java 源代码编译为字节码（<code>.class</code> 文件）。</li><li><strong>工具（如调试器、解释器）</strong>：用于开发、编译、打包和调试 Java 程序的工具。</li><li><strong>库</strong>：提供用于开发应用程序的标准 Java 类库。</li></ul><p><strong>总结</strong>：JDK 是一个完整的开发工具包，适合开发人员使用，允许编写、编译、调试和运行 Java 程序。</p></blockquote><blockquote><h3 id="jrejava-runtime-environment"><strong>JRE（Java Runtime Environment）</strong></h3><ul><li><strong>作用</strong>：JRE 是运行 Java 程序所需的环境，它提供了执行 Java 应用程序的基础环境，但不包括编译器等开发工具。</li><li>组成：<ul><li><strong>Java 虚拟机（JVM）</strong>：用于执行 Java 字节码的虚拟机。</li><li><strong>类库</strong>：支持 Java 程序运行的核心库（标准类库，如 Java API）。</li><li><strong>其他资源</strong>：如支持图形界面的类,运行工具等。</li></ul></li></ul><p><strong>总结</strong>：JRE 是一个运行环境，只适合运行现有的 Java 应用程序，而不适合用于开发。</p></blockquote><h3 id="结构">结构</h3><blockquote><p><code>project --&gt;  module --&gt; package --&gt; class</code></p></blockquote><h3 id="字节码文件">字节码文件</h3><blockquote><p>字节码文件（bytecode file）是源代码编译后生成的一种中间代码文件，它是一种低级的、与平台无关的代码表示形式。字节码文件通常无法直接由计算机硬件执行，但可以被特定的虚拟机（如 Java 虚拟机 JVM 或 Python 的解释器）读取和执行。</p></blockquote><h2 id="基础语法">基础语法</h2><h3 id="字面量">字面量</h3><figure><img src="image-20251003182720834.png" alt="image-20251003182720834" /><figcaption aria-hidden="true">image-20251003182720834</figcaption></figure><h3 id="基本数据类型">基本数据类型</h3><figure><img src="image-20251003184829445.png" alt="image-20251003184829445" /><figcaption aria-hidden="true">image-20251003184829445</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">999999999999L</span>;</span><br><span class="line"><span class="comment">//定义long类型,要在数值后面加上L,大小写都可以,但大写方便</span></span><br><span class="line"><span class="type">float</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">999999999999.099F</span>;</span><br><span class="line"><span class="comment">//定义float类型,要在数值后面加上F,大小写都可以,但大写方便</span></span><br></pre></td></tr></table></figure><h3 id="运算符">运算符</h3><figure><img src="image-20251003191135450.png" alt="image-20251003191135450" /><figcaption aria-hidden="true">image-20251003191135450</figcaption></figure><h3 id="输入输出">输入输出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;first try&quot;</span>);<span class="comment">//打印完换行</span></span><br><span class="line">System.out.print(<span class="string">&quot;first try&quot;</span>);  <span class="comment">//打印完不换行</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">//创建扫描仪对象</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> input.nextInt();<span class="comment">//接收int型输入</span></span><br><span class="line"><span class="type">float</span> f=input.nextFloat();<span class="comment">//float</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> String.format(<span class="string">&quot;%.2f&quot;</span>,f);<span class="comment">//格式化控制</span></span><br><span class="line">System.out.printf(<span class="string">&quot;%.2f&quot;</span>,f);</span><br></pre></td></tr></table></figure><p><code>Scanner</code> 是一个类，<em>它位于 <code>java.util</code> 包中</em>。<code>Scanner</code> 类用于从各种输入源读取数据，比如从控制台、文件、字符串等读取用户输入或数据。</p><p><strong>常用的 <code>Scanner</code> 方法</strong></p><p><code>Scanner</code> 类提供了多种方法来读取不同类型的数据，包括 <code>next()</code> 系列方法和 <code>hasNext()</code> 系列方法。以下是一些常用方法：</p><ol type="1"><li><p><strong>nextLine()</strong></p><ul><li>读取整行的字符串输入，直到检测到换行符（Enter）。</li><li>示例： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">System.out.println(<span class="string">&quot;You entered: &quot;</span> + line);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>next()</strong></p><ul><li>读取一个字符串，以空格或换行符作为分隔符，读取到第一个空格前的数据。</li><li>示例： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">System.out.println(<span class="string">&quot;First word: &quot;</span> + word);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>nextInt()</strong></p><ul><li>读取一个整数类型的数据。</li><li>示例： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">System.out.println(<span class="string">&quot;You entered number: &quot;</span> + number);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>nextDouble()</strong></p><ul><li>读取一个双精度浮点类型的数据。</li><li>示例： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">double</span> <span class="variable">num</span> <span class="operator">=</span> scanner.nextDouble();</span><br><span class="line">System.out.println(<span class="string">&quot;You entered double: &quot;</span> + num);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>hasNext()</strong></p><ul><li>判断是否还有下一个输入项（通常用于循环读取）。</li><li>示例： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">    System.out.println(scanner.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>hasNextInt()</strong></p><ul><li>判断下一个输入项是否为整数类型。</li><li>示例： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="keyword">if</span> (scanner.hasNextInt()) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">    System.out.println(<span class="string">&quot;You entered an integer: &quot;</span> + num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>hasNextDouble()</strong></p><ul><li>判断下一个输入项是否为双精度浮点类型。</li></ul></li><li><p><strong>useDelimiter(String pattern)</strong></p><ul><li>设置扫描器的分隔符，默认是空格，可以通过这个方法来设置自定义的分隔符。</li><li>示例： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="string">&quot;apple,banana,orange&quot;</span>);</span><br><span class="line">scanner.useDelimiter(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">    System.out.println(scanner.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="选择结构">选择结构</h3><p><code>if结构</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line"><span class="keyword">if</span>(score&gt;=<span class="number">60</span>)</span><br><span class="line">   System.out.println(<span class="string">&quot;pass!&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   System.out.println(<span class="string">&quot;fail!&quot;</span>);</span><br><span class="line"><span class="comment">/*多重if-else*/</span></span><br><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line"><span class="keyword">if</span>(score&lt;<span class="number">60</span>)</span><br><span class="line">   System.out.println(<span class="string">&quot;go out!&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(score&lt;<span class="number">90</span>)</span><br><span class="line">    System.out.println(<span class="string">&quot;good job!&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    System.out.println(<span class="string">&quot;wonderful job!&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>switch选择结构</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Monday&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Tuesday&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Wednesday&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Thursday&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Friday&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Weekend&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>switch</code> 语句的条件只能是整数、枚举、字符或字符串等有限的数据类型，无法处理更复杂的条件表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(num)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;一&quot;</span>);</span><br><span class="line">                <span class="comment">//可以省略break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span> -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;二&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span> -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;三&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;NULL&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="循环结构">循环结构</h3><p><code>for循环</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>while循环</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>do-while循环</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i &lt; <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>break</code></strong>：立即退出整个循环，跳到循环后面的代码继续执行。</p><p><strong><code>continue</code></strong>：跳过当前循环的剩余部分，直接进行下一次循环判断</p><p>tips:<code>随机数 Random</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line">------------------------------------</span><br><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span>  r.nextInt(<span class="number">100</span>);<span class="comment">//[0,100)</span></span><br></pre></td></tr></table></figure><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Random.html">java Random</a></p><h2 id="基本知识">基本知识</h2><h3 id="数组">数组</h3><p>Java 中的数组是用于存储固定大小的相同类型元素的集合。数组中的每个元素都通过索引访问，并且索引从 <code>0</code> 开始。</p><h4 id="数组声明">数组声明</h4><p>在 Java 中，声明一个数组的方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法1：数据类型[] 数组名;</span></span><br><span class="line"><span class="type">int</span>[] array1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法2：数据类型 数组名[];</span></span><br><span class="line"><span class="type">int</span> array2[];</span><br></pre></td></tr></table></figure><p>两种方式都可以声明数组，不过第一种更常见。</p><h4 id="数组初始化">数组初始化</h4><p>数组声明后可以通过两种方式初始化：<strong>静态初始化</strong>和<strong>动态初始化</strong>。</p><ol type="1"><li><p><strong>静态初始化</strong>：在声明时直接给定数组的初始值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  <span class="comment">// 静态初始化，长度为5</span></span><br></pre></td></tr></table></figure></li><li><p><strong>动态初始化</strong>：先指定数组的长度，再赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];  <span class="comment">// 动态初始化，创建长度为5的数组</span></span><br><span class="line">array[<span class="number">0</span>] = <span class="number">1</span>;              <span class="comment">// 为第一个元素赋值</span></span><br><span class="line">array[<span class="number">1</span>] = <span class="number">2</span>;              <span class="comment">// 为第二个元素赋值</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="访问数组元素">访问数组元素</h4><p>数组中的每个元素通过<strong>索引</strong>来访问，索引从 <code>0</code> 开始。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">System.out.println(array[<span class="number">0</span>]);  <span class="comment">// 输出：10</span></span><br><span class="line">System.out.println(array[<span class="number">4</span>]);  <span class="comment">// 输出：50</span></span><br></pre></td></tr></table></figure><p>注意：访问越界的索引会抛出 <code>ArrayIndexOutOfBoundsException</code> 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(array[<span class="number">5</span>]);  <span class="comment">// 抛出异常：ArrayIndexOutOfBoundsException</span></span><br></pre></td></tr></table></figure><h4 id="数组的长度">数组的长度</h4><p>可以通过 <code>.length</code> 属性获取数组的长度（即数组中元素的个数），这是数组的一个<strong>固定</strong>属性，不会改变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;Array length: &quot;</span> + array.length);  <span class="comment">// 输出：3</span></span><br></pre></td></tr></table></figure><h4 id="多维数组">多维数组</h4><p>Java 中支持多维数组，最常用的是<strong>二维数组</strong>，它可以看作是一个数组的数组。二维数组的声明和初始化方式如下：</p><p><strong>声明二维数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] matrix;  <span class="comment">// 声明一个二维数组</span></span><br></pre></td></tr></table></figure><p><strong>初始化二维数组</strong></p><ol type="1"><li><p><strong>动态初始化二维数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] matrix = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">4</span>];  <span class="comment">// 创建一个3行4列的二维数组</span></span><br></pre></td></tr></table></figure></li><li><p><strong>静态初始化二维数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] matrix = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,</span><br><span class="line">    &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p><strong>访问二维数组的元素</strong></p><p>二维数组的元素通过两次索引访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(matrix[<span class="number">0</span>][<span class="number">0</span>]);  <span class="comment">// 输出：1</span></span><br><span class="line">System.out.println(matrix[<span class="number">2</span>][<span class="number">3</span>]);  <span class="comment">// 输出：12</span></span><br></pre></td></tr></table></figure><h4 id="非规则数组稀疏数组">非规则数组（稀疏数组）</h4><p>在 Java 中，可以创建“非规则”的二维数组，即每一行的列数不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] irregularArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][];</span><br><span class="line">irregularArray[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];  <span class="comment">// 第一行有2个元素</span></span><br><span class="line">irregularArray[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];  <span class="comment">// 第二行有4个元素</span></span><br><span class="line">irregularArray[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];  <span class="comment">// 第三行有3个元素</span></span><br></pre></td></tr></table></figure><figure><img src="image-20251006194220847.png" alt="image-20251006194220847" /><figcaption aria-hidden="true">image-20251006194220847</figcaption></figure><h4 id="拷贝">拷贝</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> [] arr1 = &#123;<span class="number">11</span>,<span class="number">22</span>&#125;;</span><br><span class="line"><span class="type">int</span> [] arr2 = arr1;</span><br><span class="line"><span class="comment">//此时arr1与arr2指向了同一个地址空间</span></span><br></pre></td></tr></table></figure><p><code>System.arraycopy()</code></p><p>Java 提供了 <code>System.arraycopy()</code> 方法来复制数组的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] sourceArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] destArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">System.arraycopy(sourceArray, <span class="number">0</span>, destArray, <span class="number">0</span>, sourceArray.length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : destArray) &#123;</span><br><span class="line">    System.out.println(i);  <span class="comment">// 输出：1 2 3 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Arrays.copyOf()</code></p><p><code>java.util.Arrays</code> 类提供了 <code>copyOf</code> 方法来复制数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] newArray = Arrays.copyOf(sourceArray, sourceArray.length);</span><br></pre></td></tr></table></figure><h4 id="排序">排序</h4><p>Java 提供了内置的 <code>Arrays.sort()</code> 方法，可以快速对数组进行排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">Arrays.sort(array);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : array) &#123;</span><br><span class="line">    System.out.println(i);  <span class="comment">// 输出：1 2 3 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历">遍历</h4><p><strong>使用 <code>for</code> 循环遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    System.out.println(array[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 <code>for-each</code> 循环遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> value : array) &#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法">方法</h3><p>即c++中的函数</p><p>public static 返回值类型 方法名 (参数){</p><p>​ return 返回值;</p><p>}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.无返回值 无参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">double</span> [] arr = &#123;<span class="number">1.1</span>,<span class="number">2.2</span>,<span class="number">3.3</span>,<span class="number">4.4</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)</span><br><span class="line">  &#123;</span><br><span class="line">      System.out.println(arr[i]);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.无返回值 有参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">  System.out.println(a+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.有返回值 有参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法之间不能嵌套</p><h4 id="方法的重载">方法的重载</h4><ul><li>在<strong>同一个类中</strong>,定义了多个<strong>同名的方法</strong>,这些方法具有同种功能</li><li>每个方法有<strong>不同的参数类型</strong>或<strong>参数个数</strong>,这些方法构成了重载(<strong>与返回值无关</strong>)</li></ul><p>参数不同:个数 类型 顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;<span class="comment">//同一个类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">short</span> a,<span class="type">short</span> b)</span><span class="comment">//重载</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a==b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span><span class="comment">//重载</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a==b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span><span class="comment">//重载</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a==b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面向对象基础">面向对象基础</h2><h3 id="类与对象">类与对象</h3><p><strong>类的定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    String brand;</span><br><span class="line">    <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;System.out.println(<span class="string">&quot;calling!&quot;</span>);&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playGame</span><span class="params">()</span>&#123;System.out.println(<span class="string">&quot;playing!&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        p.brand = <span class="string">&quot;xiaomi&quot;</span>;</span><br><span class="line">        p.price = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        p.call();</span><br><span class="line">        p.playGame();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>javabean类</code></p><ul><li>在此类中不写main方法</li><li>之前编写main方法的类叫做测试类,在测试类中穿件javabean类的对象并赋值调用</li></ul><p>在实际开发中:</p><ul><li>类名的首字母大写,驼峰模式</li><li>建议一个文件定义一个class类</li></ul><p><code>封装</code>:面向对象的三大特征之一,告诉我们如何正确设计对象的属性和方法。</p><p><code>private</code>关键字:</p><ul><li>权限修饰符</li><li>可以修饰成员(成员变量和成员方法)</li><li>被private修饰的成员只能在本类中访问,可以针对每一个私有化成员变量提供set和get方法</li></ul><p><code>this</code>关键字:</p><ul><li>当成员变量与局部变量重名时,就近原则,可以使用this代指成员变量</li><li>代表方法调用者的地址值</li></ul><h4 id="构造方法">构造方法</h4><ul><li>方法名与类名相同</li><li>没有返回值类型,连void也不写</li><li>没有具体返回值,不可以写return</li><li>构造方法可以重载</li><li>创造对象的时候由虚拟机自动调用给成员变量初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空参构造</span></span><br><span class="line"><span class="comment">//如果不写构造函数,虚拟机会自动生成一个空参构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Phone</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Phone</span><span class="params">(String brand , <span class="type">double</span> price)</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.brand=brand;</span><br><span class="line">   <span class="built_in">this</span>.price=price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般上述二者都写</p><figure><img src="image-20251006202532742.png" alt="image-20251006202532742" /><figcaption aria-hidden="true">image-20251006202532742</figcaption></figure><h2 id="字符串string">字符串String</h2><blockquote><p>java.lang.String,由于java.lang是java的核心包,所以使用不需要导包</p></blockquote><ul><li>Java程序中的所有字符串文字都为此类的对象</li><li>字符串不可以改变,它们的值在创建后不能被更改</li></ul><h3 id="创建string对象">创建String对象</h3><ul><li>直接赋值<ul><li>当使用双引号直接赋值的时候,系统会检查<strong>串池(string table)</strong>中是否存在,不存在才创建新的,存在就复用,节约内存</li></ul></li><li>new关键字<ul><li>在堆内存开辟空间</li><li><img src="image-20251008213820187.png" title="fig:" alt="image-20251008213820187" /></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接赋值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;aaaaa&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建空白字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据传入的字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaaaaa&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据字符数组</span></span><br><span class="line"><span class="type">char</span>[] chs =&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;b&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">String</span>(chs);</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据字节数组</span></span><br><span class="line"><span class="type">byte</span>[] bytes=&#123;<span class="number">98</span>,<span class="number">97</span>,<span class="number">96</span>,<span class="number">95</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);</span><br></pre></td></tr></table></figure><h3 id="字符串比较">字符串比较</h3><p><code>==</code>比较原理:</p><ul><li>基本数据类型:比较的是具体数据值 eg:int</li><li>引用数据类型:比较的是地址值 eg:String</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//boolean equals方法(要比较的字符串)  完全一样结果才是true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">res1</span> <span class="operator">=</span> s1.equals(s2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//boolean equalsIgnoreCase(要比较的字符串) 忽略大小写的比较</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">res2</span> <span class="operator">=</span> s2.equalsIgnoreCase(s2);</span><br></pre></td></tr></table></figure><h3 id="字符串遍历">字符串遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> index)</span>;<span class="comment">//根据索引返回字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>;<span class="comment">//返回此字符串的长度 字符串对象.length()</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;01234&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.print(str.charAt(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串截取">字符串截取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex,<span class="type">int</span> endIndex)</span>;<span class="comment">//[beginIndex,endIndex)返回值才是截取的小串</span></span><br><span class="line"></span><br><span class="line">String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex)</span>;<span class="comment">//截取到末尾</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">subPhoneNum</span><span class="params">(String num)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> num.substring(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        res+=<span class="string">&quot;****&quot;</span>;</span><br><span class="line">        res+=num.substring(<span class="number">7</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="字符串替换">字符串替换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">replace</span><span class="params">(旧值,新值)</span></span><br></pre></td></tr></table></figure><figure><img src="image-20251010213458961.png" alt="image-20251010213458961" /><figcaption aria-hidden="true">image-20251010213458961</figcaption></figure><h2 id="stringbuilder">StringBuilder</h2><blockquote><p>可以看成一个容器,创建之后里面的内容是可变的,可以提高字符串的操作效率</p></blockquote><p>打印StringBuilder对象不再是地址值,而是属性</p><h3 id="构造方法-1">构造方法</h3><table><colgroup><col style="width: 25%" /><col style="width: 20%" /><col style="width: 42%" /><col style="width: 12%" /></colgroup><thead><tr class="header"><th>方法名</th><th>功能说明</th><th>示例代码</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>StringBuilder()</code></td><td>创建空的 <code>StringBuilder</code></td><td><code>StringBuilder sb = new StringBuilder();</code></td><td>默认容量16</td></tr><tr class="even"><td><code>StringBuilder(String str)</code></td><td>用字符串初始化</td><td><code>StringBuilder sb = new  StringBuilder("Hello");</code></td><td>内容为 "Hello"</td></tr><tr class="odd"><td><code>StringBuilder(int capacity)</code></td><td>指定初始容量</td><td><code>StringBuilder sb = new StringBuilder(100);</code></td><td>初始容量100</td></tr></tbody></table><h3 id="常用方法">常用方法</h3><figure><img src="image-20251010213926706.png" alt="image-20251010213926706" /><figcaption aria-hidden="true">image-20251010213926706</figcaption></figure>]]></content>
    
    
    <summary type="html">java入门笔记</summary>
    
    
    
    <category term="后端" scheme="https://klklkl10086.github.io/klklkl10086.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="javaSE" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/javaSE/"/>
    
  </entry>
  
  <entry>
    <title>c++11--thread库介绍</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2025/10/01/cpp11-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2025/10/01/cpp11-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2025-10-01T06:51:33.000Z</published>
    <updated>2025-11-27T14:16:51.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cpp11--多线程">cpp11--多线程</h1><h2 id="创建线程">创建线程</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHelloWorld</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Hello world&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">thread1</span><span class="params">(printHelloWorld)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这个时候会报错,因为主线程先于子线程结束</p><h2 id="join函数">join()函数</h2><p>强制主线程等待子线程结束后再结束</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHelloWorld</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Hello world&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">thread1</span><span class="params">(printHelloWorld)</span></span>;</span><br><span class="line">    <span class="comment">//2.主程序等待线程执行完毕</span></span><br><span class="line">    thread1.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="detach函数">detach()函数</h2><p>分离线程,即使主线程先于子线程结束也不会报错,此时子线程在后台运行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHelloWorld</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Hello world&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">thread1</span><span class="params">(printHelloWorld)</span></span>;</span><br><span class="line">    <span class="comment">//2.分离线程,即使主线程先于子线程结束也不会报错</span></span><br><span class="line">    thread1.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="joinable函数">joinable()函数</h2><p>判断是否可以调用join()函数或者detach()函数,返回布尔值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHelloWorld</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Hello world&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">thread1</span><span class="params">(printHelloWorld)</span></span>;</span><br><span class="line">    <span class="comment">//2.判断能否调用join函数</span></span><br><span class="line">    <span class="type">bool</span> isJoin = thread1.<span class="built_in">joinable</span>();</span><br><span class="line">    <span class="keyword">if</span>(isJoin)</span><br><span class="line">    &#123;</span><br><span class="line">        thread1.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="互斥量">互斥量</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">std::mutex mtx;<span class="comment">//初始化锁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">mtx.<span class="built_in">lock</span>();<span class="comment">//加锁</span></span><br><span class="line">a++;</span><br><span class="line">mtx.<span class="built_in">unlock</span>();<span class="comment">//解锁</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line">std::cout&lt;&lt;a&lt;&lt;std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>线程安全</code>:多线程的程序每一次运行的结构和单线程的结构始终是一样的,那么线程就是安全的</p><h2 id="互斥量死锁">互斥量死锁</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">std::mutex m1,m2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">m1.<span class="built_in">lock</span>();</span><br><span class="line">m2.<span class="built_in">lock</span>();</span><br><span class="line">m1.<span class="built_in">unlock</span>();</span><br><span class="line">m2.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">m2.<span class="built_in">lock</span>();</span><br><span class="line">m1.<span class="built_in">lock</span>();</span><br><span class="line">m1.<span class="built_in">unlock</span>();</span><br><span class="line">m2.<span class="built_in">unlock</span>();</span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(func_1)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(func_2)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;over&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lock_guard与unique_lock">lock_guard与unique_lock</h2><p><code>Rall</code>原则:</p><ul><li><strong>构造时</strong>：自动获取互斥锁。</li><li><strong>析构时</strong>：自动释放互斥锁。 这意味着即使代码块中发生异常，锁也能被安全释放，避免了资源泄漏和死锁。</li></ul><blockquote><p>C++11 中的 <code>std::lock_guard</code> 和 <code>std::unique_lock</code>。它们是实现 RAII（资源获取即初始化）来管理互斥锁的两种重要工具，能有效防止死锁并简化代码。</p></blockquote><h3 id="stdlock_guard">std::lock_guard</h3><p><code>std::lock_guard</code> 是一个轻量级的、不可拷贝的 RAII 包装器，功能简单直接。</p><p>特点:</p><ol type="1"><li><strong>简单且高效</strong>：开销小，只提供最基本的 RAII 风格锁管理。</li><li><strong>不可手动操作</strong>：一旦创建，就不能主动 <code>lock</code> 或 <code>unlock</code>，其生命周期完全由作用域控制。</li><li><strong>不支持延迟锁定</strong>：构造时必须立即获得锁。</li><li><strong>不可复制和移动</strong>:通过禁用拷贝构造和等于号实现</li></ol><p>适用于在<strong>某个明确的作用域(局部作用域)</strong>内需要持有锁，且在此作用域内不需要手动释放或重新获取锁的简单情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="type">int</span> shared_data=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10000</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(mtx)</span></span>;</span><br><span class="line"><span class="comment">//自动调用构造函数加锁</span></span><br><span class="line">shared_data++;</span><br><span class="line"><span class="comment">//自动调用析构函数解锁</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line">std::cout&lt;&lt;shared_data&lt;&lt;std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="stdunique_lock">std::unique_lock</h3><p><code>std::unique_lock</code> 是一个功能更全面、更灵活的 RAII 包装器。它包含了 <code>lock_guard</code> 的所有功能，并提供了额外的控制能力。</p><p><strong>特点:</strong></p><ol type="1"><li><strong>灵活性高</strong>：支持延迟锁定、手动解锁、条件变量等复杂场景。</li><li><strong>可手动操作</strong>：可以在生命周期内主动调用 <code>lock()</code> 和 <code>unlock()</code>。</li><li><strong>支持所有权转移</strong>：可以通过 <code>std::move</code> 转移锁的所有权（但不能复制）。</li><li><strong>支持多种锁定策略</strong>：在构造时可以通过参数指定锁定行为。</li></ol><p><strong>锁定策略</strong>:</p><ul><li><code>std::defer_lock</code>：不立即加锁，稍后手动加锁。</li><li><code>std::try_to_lock</code>：尝试获取锁，但不阻塞。</li><li><code>std::try_lock_for</code>: 阻塞并等待一定的时间</li><li><code>std::adopt_lock</code>：假设调用线程已经持有该互斥锁。</li></ul><p>适用于所有需要锁的场景，尤其是在以下复杂情况：</p><ul><li>需要与 <code>std::condition_variable</code> 配合使用。</li><li>需要手动释放锁（例如，在长时间操作的中间阶段）。</li><li>需要尝试获取锁或延迟获取锁。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">std::timed_mutex mtx;</span><br><span class="line"><span class="type">int</span> shared_data=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10000</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">std::unique_lock&lt;std::timed_mutex&gt;<span class="built_in">lg</span>(mtx,std::defer_lock);<span class="comment">//延迟加锁</span></span><br><span class="line">lg.<span class="built_in">try_lock_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"><span class="comment">//阻塞并等待5秒,若5秒后加锁失败会直接返回</span></span><br><span class="line">shared_data++;</span><br><span class="line"><span class="comment">//自动调用析构函数解锁</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line">std::cout&lt;&lt;shared_data&lt;&lt;std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">std::timed_mutex mtx;</span><br><span class="line"><span class="type">int</span> shared_data=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">std::unique_lock&lt;std::timed_mutex&gt;<span class="built_in">lg</span>(mtx,std::defer_lock);<span class="comment">//延迟加锁</span></span><br><span class="line"><span class="keyword">if</span>(lg.<span class="built_in">try_lock_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)))</span><br><span class="line"><span class="comment">//如果获取不到就阻塞并等待2秒,若2秒后加锁失败直接返回</span></span><br><span class="line">&#123;</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">4</span>));</span><br><span class="line">shared_data++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自动调用析构函数解锁</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line">std::cout&lt;&lt;shared_data&lt;&lt;std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="stdcall_once与其使用场景">std::call_once与其使用场景</h2><blockquote><p>单例设计模式:用于确保某个类只能创建一个实例,如日志类</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Log</span>()&#123;&#125;<span class="comment">//默认构造函数</span></span><br><span class="line"><span class="built_in">Log</span>(<span class="type">const</span> Log&amp; log) = <span class="keyword">delete</span>;<span class="comment">//禁止拷贝构造</span></span><br><span class="line">Log&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Log&amp; log) = <span class="keyword">delete</span>;<span class="comment">//禁止赋值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> Log&amp; <span class="title">GetInstance</span><span class="params">()</span></span>&#123;<span class="comment">//static 方法：可以通过类名直接调用，无需实例</span></span><br><span class="line"><span class="comment">//局部静态变量：在第一次调用时创建，程序结束时销毁</span></span><br><span class="line">            <span class="type">static</span> Log log;<span class="comment">//懒汉模式</span></span><br><span class="line"><span class="keyword">return</span> log;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintLog</span><span class="params">(std::string msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout&lt;&lt;msg&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Log</span>()&#123;&#125;<span class="comment">//默认构造函数</span></span><br><span class="line"><span class="built_in">Log</span>(<span class="type">const</span> Log&amp; log) = <span class="keyword">delete</span>;<span class="comment">//禁止拷贝构造</span></span><br><span class="line">Log&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Log&amp; log) = <span class="keyword">delete</span>;<span class="comment">//禁止赋值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> Log&amp; <span class="title">GetInstance</span><span class="params">()</span></span>&#123;<span class="comment">//static 方法：可以通过类名直接调用，无需实例</span></span><br><span class="line"><span class="comment">//局部静态变量：在第一次调用时创建，程序结束时销毁</span></span><br><span class="line">            <span class="type">static</span> Log* log=<span class="literal">nullptr</span>;<span class="comment">//饿汉模式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!log) log = <span class="keyword">new</span> Log;</span><br><span class="line"><span class="keyword">return</span> *log;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintLog</span><span class="params">(std::string msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout&lt;&lt;msg&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>多线程情况下会出现一下情况:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Log</span>()&#123;&#125;<span class="comment">//默认构造函数</span></span><br><span class="line"><span class="built_in">Log</span>(<span class="type">const</span> Log&amp; log) = <span class="keyword">delete</span>;<span class="comment">//禁止拷贝构造</span></span><br><span class="line">Log&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Log&amp; log) = <span class="keyword">delete</span>;<span class="comment">//禁止赋值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> Log&amp; <span class="title">GetInstance</span><span class="params">()</span></span>&#123;<span class="comment">//static 方法：可以通过类名直接调用，无需实例</span></span><br><span class="line"><span class="type">static</span> Log* log=<span class="literal">nullptr</span>;<span class="comment">//饿汉模式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!log) log = <span class="keyword">new</span> Log;</span><br><span class="line"><span class="keyword">return</span> *log;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintLog</span><span class="params">(std::string msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout&lt;&lt;__TIME__&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;msg&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Log::<span class="built_in">GetInstance</span>().<span class="built_in">PrintLog</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;<span class="comment">//t1  t2的并行会导致创建两个单例</span></span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了保证单例,使用<code>std::call_once</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Callable, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_once</span><span class="params">(std::once_flag&amp; flag, Callable&amp;&amp; func, Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure><ol type="1"><li><strong>线程安全</strong>：保证在多线程环境下，函数只被执行一次</li><li><strong>高效</strong>：内部使用原子操作和锁，性能较好</li><li><strong>异常安全</strong>：如果函数抛出异常，不算执行完成，其他线程会重试</li><li>只能在线程中使用</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> Log* log;  <span class="comment">// 静态成员声明</span></span><br><span class="line">    <span class="type">static</span> std::once_flag once;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Log</span>()&#123;&#125;<span class="comment">//默认构造函数</span></span><br><span class="line"><span class="built_in">Log</span>(<span class="type">const</span> Log&amp; log) = <span class="keyword">delete</span>;<span class="comment">//禁止拷贝构造</span></span><br><span class="line">Log&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Log&amp; log) = <span class="keyword">delete</span>;<span class="comment">//禁止赋值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> Log&amp; <span class="title">GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 使用 call_once 确保只初始化一次</span></span><br><span class="line">        std::<span class="built_in">call_once</span>(once, init);</span><br><span class="line">        <span class="keyword">return</span> *log;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintLog</span><span class="params">(std::string msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout&lt;&lt;__TIME__&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;msg&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            log = <span class="keyword">new</span> Log;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 静态成员定义</span></span><br><span class="line">Log* Log::log = <span class="literal">nullptr</span>;</span><br><span class="line">std::once_flag Log::once;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Log::<span class="built_in">GetInstance</span>().<span class="built_in">PrintLog</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">补足一下cpp的知识</summary>
    
    
    
    <category term="研究生补完" scheme="https://klklkl10086.github.io/klklkl10086.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%A1%A5%E5%AE%8C/"/>
    
    
    <category term="CPP" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/CPP/"/>
    
    <category term="thread" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>编译原理复习笔记</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2025/05/13/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2025/05/13/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2025-05-13T05:45:42.000Z</published>
    <updated>2025-05-27T13:39:13.356Z</updated>
    
    <content type="html"><![CDATA[<p>大题题型:</p><p>词法分析:</p><ul><li>DFA化简</li><li>NFA-&gt;DFA</li><li>正则表达式&lt;---&gt;自动机</li></ul><h1 id="编译原理复习笔记">编译原理复习笔记</h1><figure><img src="image-20250513134720348.png" alt="image-20250513134720348" /><figcaption aria-hidden="true">image-20250513134720348</figcaption></figure><h2 id="绪论">绪论</h2><p><strong>编译程序</strong>也叫编译器，是一种具有翻译功能的程序，其作用是将某种高级语言编写的程序翻译成语义等价的低级语言程序。</p><figure><img src="image-20250513135934992.png" alt="image-20250513135934992" /><figcaption aria-hidden="true">image-20250513135934992</figcaption></figure><p><strong>解释程序：</strong> 其作用是将源程序<strong>逐条语句地</strong>翻译成<strong>目标指令序列</strong>，并且是<strong>边翻译边执行</strong>，当翻译完成时，目标程序的执行也随之完成。可见，<strong>解释程序不会生成目标程序</strong>。</p><p><strong>转换方式：</strong> 编译程序的开发代价是很昂贵的。 在<u>已有A语言的编译程序的前提下</u>，若想为B语言开发编译程序，可首先考虑能否利用A语言的编译程序。即首先将B语言程序转换成等价的A语言程序，然后再利用A语言的编译程序将其翻译成目标程序。</p><figure><img src="image-20250513140318774.png" alt="image-20250513140318774" /><figcaption aria-hidden="true">image-20250513140318774</figcaption></figure><p>高级语言的翻译程序称为编译程序(Compiler)或解释程序(Interpreter)，对应的实现方式分别为编译方式或解释方式。偶尔还会采用转换方式。</p><figure><img src="image-20250513140144243.png" alt="image-20250513140144243" /><figcaption aria-hidden="true">image-20250513140144243</figcaption></figure><h3 id="编译程序的逻辑结构">编译程序的逻辑结构</h3><figure><img src="image-20250513140412414.png" alt="image-20250513140412414" /><figcaption aria-hidden="true">image-20250513140412414</figcaption></figure><blockquote><p><strong>词法分析</strong>：<strong>识别</strong>由字符组成的<strong>高级语言程序中的单词</strong>，并将其转化成一种内部表示（Token）的形式，同时检查是否存在<strong>词法错误。</strong></p></blockquote><figure><img src="image-20250513140919335.png" alt="image-20250513140919335" /><figcaption aria-hidden="true">image-20250513140919335</figcaption></figure><blockquote><p><strong>语法分析</strong>：根据语言定义的<strong>语法规则</strong>来检验程序中<strong>是否存在语法错误</strong>。</p></blockquote><figure><img src="image-20250513141041210.png" alt="image-20250513141041210" /><figcaption aria-hidden="true">image-20250513141041210</figcaption></figure><blockquote><p><strong>语义分析</strong>：检查源程序有无语义错误，为代码生成阶段收集类型信息。</p></blockquote><figure><img src="image-20250513141136272.png" alt="image-20250513141136272" /><figcaption aria-hidden="true">image-20250513141136272</figcaption></figure><blockquote><p><strong>中间代码生成</strong>： 将<strong>源程序</strong>转换成一种称为中间代码的内部表示形式，<strong>便于优化和移植。</strong></p><p>不是编译程序的必经阶段！<strong>不考虑优化和移植时</strong>，可以不生成中间代码直接生成目标代码</p></blockquote><figure><img src="image-20250513141223712.png" alt="image-20250513141223712" /><figcaption aria-hidden="true">image-20250513141223712</figcaption></figure><blockquote><p><strong>中间代码优化：变换或改造中间代码，使生成的目标代码更为高效，即节省时间和空间。</strong>和<strong>程序算法的高效无关</strong>，更多的是<strong>针对于程序具体运行时的内部优化</strong>，尤其针对有特殊要求的编译器。</p><p>不是编译程序的必经阶段，当对目标代码的运行效率要求较高时，才考虑进行中间代码的优化，优化要付出代价，优化时要考虑性价比。</p></blockquote><figure><img src="image-20250513141341634.png" alt="image-20250513141341634" /><figcaption aria-hidden="true">image-20250513141341634</figcaption></figure><blockquote><p><strong>目标代码生成：</strong>将<strong>中间代码变换为特定机器上的机器指令代码</strong>或<strong>汇编指令代码</strong>。</p></blockquote><figure><img src="image-20250513141417130.png" alt="image-20250513141417130" /><figcaption aria-hidden="true">image-20250513141417130</figcaption></figure><blockquote><p>此外，编译过程还有两部分工作贯穿始终：</p><p><strong>错误处理</strong>：当编译阶段有错误出现时，由<strong>相应的错误处理模块</strong>给出解决方案，使得编译器能够继续进行下去。</p><p><strong>表格管理：</strong>为了合理的管理（构造、查找、更新……）表格（符号表、类型信息表……），<strong>设立一些专门子程序称为表格管理程序。</strong></p></blockquote><figure><img src="image-20250513141520236.png" alt="image-20250513141520236" /><figcaption aria-hidden="true">image-20250513141520236</figcaption></figure><h3 id="编译程序的开发">编译程序的开发</h3><ol type="1"><li><p>用机器语言编写编译程序</p></li><li><p>自展法</p><figure><img src="image-20250513141722453.png" alt="image-20250513141722453" /><figcaption aria-hidden="true">image-20250513141722453</figcaption></figure></li><li><p>移植法</p><figure><img src="image-20250513141739991.png" alt="image-20250513141739991" /><figcaption aria-hidden="true">image-20250513141739991</figcaption></figure></li><li><p>转换法(预处理法):C++</p></li><li><p>自动生成(工具法):利用Flex, Yacc,LLGen, Bison等工具自动生成词法分析器、语法分析器，从而减少编译程序开发的工作量</p></li></ol><h4 id="编译程序的分遍">编译程序的分遍</h4><blockquote><p>所谓“遍”就是对<strong>源程序或源程序的中间表示形式从头到尾扫描一次</strong>，并作加工处理，<strong>生成新的中间结果或目标程序</strong> ；</p><p>分遍就是对源程序或源程序的<strong>中间表示形式从头到尾扫描几次</strong>。</p></blockquote><h2 id="词法分析">词法分析</h2><blockquote><p>词法分析程序,是编译程序的一部分，是整个编译过程的第一步工作。</p></blockquote><p><strong>作用: </strong> 分离单词---&gt;生成Token------&gt;检查词法错误</p><ol type="1"><li>扫描源程序的字符序列</li><li>按照源语言的<strong>词法规则识别出各类单词</strong></li><li>产生用于<strong>语法分析的Token序列</strong></li><li><strong>词法错误检查</strong></li></ol><p><strong>单词</strong>： 是具有独立含义的最小的语义单位.（抽象的）</p><p><strong>Token</strong>: 单词的具体表示（具体的--数据结构）</p><ul><li>Token中应包含的信息没有统一的规定，可有不同的设计</li><li>通常包含两类信息&lt;单词类别，单词内容&gt; 或者&lt;行号，单词类别，单词内容&gt;</li></ul><figure><img src="image-20250513143223927.png" alt="image-20250513143223927" /><figcaption aria-hidden="true">image-20250513143223927</figcaption></figure><h3 id="工作过程">工作过程</h3><p>在词法分析之前，编译器要进行编译预处理工作：宏替换，文件包含，条件编译</p><figure><img src="image-20250513143316944.png" alt="image-20250513143316944" /><figcaption aria-hidden="true">image-20250513143316944</figcaption></figure><h3 id="单词类型">单词类型</h3><figure><img src="image-20250513143344232.png" alt="image-20250513143344232" /><figcaption aria-hidden="true">image-20250513143344232</figcaption></figure><p><strong>保留字</strong>： 保留字一般是由语言系统自身定义的,通常是由字母组成的字符串。如C语言中的int, if, for, do等等。保留字在语言中具有特定的意义，是<strong>编译程序识别各类语法成分的依据</strong> 。</p><p><strong>标识符</strong>： 用来标识程序中<strong>各个对象的名称</strong>.通常它们<strong>由用户定义</strong>，用来表示<strong>变量名、常量名、数组名、函数名和结构体域名等</strong>。</p><p><strong>常量：</strong> 主要包括整型常量、实型常量、字符常量、字符串常量、布尔类型常量等。</p><p><strong>特殊符号</strong>： 包括运算符、界限符和控制符（格式符）。</p><figure><img src="image-20250513143943479.png" alt="image-20250513143943479" /><figcaption aria-hidden="true">image-20250513143943479</figcaption></figure><h3 id="单词的描述与识别">单词的描述与识别</h3><ul><li>正则表达式（描述单词）</li><li>自动机 （识别、描述单词）</li></ul><h3 id="正则表达式">正则表达式</h3><h4 id="基本概念">基本概念</h4><ul><li>字母表：字母表是元素的<strong>非空有穷集合</strong>,字母表中的<strong>一个元素</strong>称为该字母表的一个<strong>字母</strong>（letter） ,也可叫做符号（symbol）或者字符(character)。<ul><li>字母表有时也称为符号表,通常用∑ 表示。<br /></li><li><img src="image-20250513144608593.png" title="fig:" alt="image-20250513144608593" /></li></ul></li><li>符号串:由<strong>字母表中的符号</strong>组成的任何<strong>有穷序列</strong>称为字母表上的符号串。一般用<span class="math inline">\(\alpha, \beta,...,x,y,z\)</span>表示<ul><li><span class="math inline">\(\epsilon\)</span>表示空串。 对任一字母表∑ ，都有<span class="math inline">\(\epsilon\)</span>是∑ 上的符号串<br /></li></ul></li><li>符号串连接:设<span class="math inline">\(\alpha\)</span>和<span class="math inline">\(\beta\)</span>均是字母表∑ 上的符号串， <span class="math inline">\(\alpha\)</span>和<span class="math inline">\(\beta\)</span>的连接是<strong>把<span class="math inline">\(\beta\)</span>的所有符号顺次地接在<span class="math inline">\(\alpha\)</span>的所有符号之后所得到的符号串</strong>。记为: <span class="math inline">\(\alpha \cdot \beta\)</span>， <span class="math inline">\(\cdot\)</span>可省略，即<span class="math inline">\(\alpha \beta\)</span>。<br /></li><li><strong>符号串</strong>的方幂:设<span class="math inline">\(\alpha\)</span>是字母表∑ 上的符号串，<strong>把<span class="math inline">\(\alpha\)</span>自身连接n次得到的符号串</strong><span class="math inline">\(\alpha\alpha\alpha \cdots \alpha\)</span> (n个<span class="math inline">\(\alpha\)</span>) ，称作符号串<span class="math inline">\(\alpha\)</span>的n次幂，记作 <span class="math inline">\(\alpha ^{n}\)</span> 。 特别的:<span class="math inline">\(\alpha ^{0} = \epsilon\)</span></li><li>符号串集合:若集合A中的<strong>所有<u>元素</u>都是某字母表∑ 上的符号串</strong>，则称A为该字母表上的<strong>符号串集合</strong>。一般用A,B,C表示。<ul><li>注意:空集∅不等于空串集<span class="math inline">\(\{\epsilon \}\)</span></li></ul></li><li><strong>符号串集</strong>的乘积: 设A、 B 是两个符号串集合， AB表示A与B的乘积，具体定义为：AB = { xy | ( x∈A ) ∧ ( y∈B )}<ul><li>AB!=BA</li><li>∅A = A∅ = ∅， 其中∅表示空集<br /></li><li><span class="math inline">\(\{\epsilon \}\)</span>A = A<span class="math inline">\(\{\epsilon \}\)</span> = A</li></ul></li><li><strong>符号串</strong>集合的方幂:设A为符号串的集合， 则称<span class="math inline">\(A^{i}\)</span>为符号串集Ａ的方幂。 具体定义如下：<ul><li><span class="math inline">\(A^{0}=\{\epsilon\}\)</span><br /></li><li><span class="math inline">\(A^{1}=A\)</span></li><li><span class="math inline">\(A^{2}=AA\)</span></li><li><span class="math inline">\(A^{n}=AAAA\cdots A\)</span>(n个)</li></ul></li><li>符号串集合的正闭包<span class="math inline">\(A^{+}\)</span>:设A是符号串集合，则称<span class="math inline">\(A^{+}\)</span>是符号串集合A的正闭包 $A<sup>{+}=A</sup>1∪A<sup>2∪A</sup>3 …∪A^n… $</li><li>符号串集合的星闭包<span class="math inline">\(A^*\)</span>:设A是符号串集合，则称A*是符号串集合A的星闭包 A*$=A<sup>0∪A</sup>1∪A<sup>2∪A</sup>3 …∪A^n… $<ul><li>A* = <span class="math inline">\(A^0\)</span>∪<span class="math inline">\(A^+\)</span></li></ul></li></ul><h4 id="正则表达式的定义">正则表达式的定义</h4><figure><img src="image-20250514101814150.png" alt="image-20250514101814150" /><figcaption aria-hidden="true">image-20250514101814150</figcaption></figure><ul><li>正则表达式的语义函数:给正则表达式赋予一种语义解释的函数。</li><li>不同的语义解释会使得正则表达式具有不同的语义，其操作结果也会不同。</li><li>在词法分析中，为了用正则表达式描述单词，我们用语义函数为<strong>正则表达式和字符串集合</strong>建立一种映射关系，使得正则表达式的语义被解释成字符串集合。<br /></li><li>在词法分析中，正则表达式e根据语义函数解释所得到的<strong>符号串集合</strong>称为正则表达式e的<strong>正则集。</strong></li></ul><figure><img src="image-20250514102612669.png" alt="image-20250514102612669" /><figcaption aria-hidden="true">image-20250514102612669</figcaption></figure><figure><img src="image-20250514102646979.png" alt="image-20250514102646979" /><figcaption aria-hidden="true">image-20250514102646979</figcaption></figure><figure><img src="image-20250514102843482.png" alt="image-20250514102843482" /><figcaption aria-hidden="true">image-20250514102843482</figcaption></figure><h4 id="局限性">局限性</h4><figure><img src="image-20250514103003382.png" alt="image-20250514103003382" /><figcaption aria-hidden="true">image-20250514103003382</figcaption></figure><h3 id="dfa确定有限自动机">DFA确定有限自动机</h3><figure><img src="image-20250514103305251.png" alt="image-20250514103305251" /><figcaption aria-hidden="true">image-20250514103305251</figcaption></figure><h4 id="确定性的体现">确定性的体现</h4><ol type="1"><li><strong>初始状态唯一</strong></li><li>状态转换函数f是一个<strong>单值函数</strong>，也就是说，对任何状态S和输入符号a，f(S,a)唯一地确定了下一个状态，即<strong>至多确定一个状态</strong></li><li>转换边上不能标<span class="math inline">\(\epsilon\)</span>即<strong>不接受没有任何输入就进行状态转换</strong>的情况</li></ol><figure><img src="image-20250514103530831.png" alt="image-20250514103530831" /><figcaption aria-hidden="true">image-20250514103530831</figcaption></figure><h4 id="dfa的表示状态转换矩阵">DFA的表示——状态转换矩阵</h4><figure><img src="image-20250514103601807.png" alt="image-20250514103601807" /><figcaption aria-hidden="true">image-20250514103601807</figcaption></figure><figure><img src="image-20250514103628721.png" alt="image-20250514103628721" /><figcaption aria-hidden="true">image-20250514103628721</figcaption></figure><h4 id="dfa的表示状态转换图">DFA的表示——状态转换图</h4><p>用有向图表示自动机</p><figure><img src="image-20250514103728940.png" alt="image-20250514103728940" /><figcaption aria-hidden="true">image-20250514103728940</figcaption></figure><figure><img src="image-20250514103738424.png" alt="image-20250514103738424" /><figcaption aria-hidden="true">image-20250514103738424</figcaption></figure><figure><img src="image-20250514103754671.png" alt="image-20250514103754671" /><figcaption aria-hidden="true">image-20250514103754671</figcaption></figure><figure><img src="image-20250514103840361.png" alt="image-20250514103840361" /><figcaption aria-hidden="true">image-20250514103840361</figcaption></figure><h4 id="dfa接受的串">DFA接受的串</h4><figure><img src="image-20250514104506827.png" alt="image-20250514104506827" /><figcaption aria-hidden="true">image-20250514104506827</figcaption></figure><figure><img src="image-20250514104617857.png" alt="image-20250514104617857" /><figcaption aria-hidden="true">image-20250514104617857</figcaption></figure><h4 id="自动机的实现">自动机的实现</h4><ul><li>直接转换法 ：每个状态对应一个带标号的switch语句，转向边对应goto语句。<br /></li><li>状态转换矩阵 ：自动机存储在矩阵中，状态比较多，每次都去查表，跳转</li></ul><figure><img src="image-20250514104714771.png" alt="image-20250514104714771" /><figcaption aria-hidden="true">image-20250514104714771</figcaption></figure><figure><img src="image-20250514104725603.png" alt="image-20250514104725603" /><figcaption aria-hidden="true">image-20250514104725603</figcaption></figure><figure><img src="image-20250514105024072.png" alt="image-20250514105024072" /><figcaption aria-hidden="true">image-20250514105024072</figcaption></figure><h4 id="自动机等价">自动机等价</h4><p>对于两个DFA <span class="math inline">\(M_1\)</span>和<span class="math inline">\(M_2\)</span>，若有L(M1)=L(M2)则称M1和M2等价</p><figure><img src="image-20250514105216221.png" alt="image-20250514105216221" /><figcaption aria-hidden="true">image-20250514105216221</figcaption></figure><h3 id="nfa">NFA</h3><h4 id="定义与dfa对比">定义(与DFA对比)</h4><figure><img src="image-20250521175528250.png" alt="image-20250521175528250" /><figcaption aria-hidden="true">image-20250521175528250</figcaption></figure><figure><img src="image-20250521175554221.png" alt="image-20250521175554221" /><figcaption aria-hidden="true">image-20250521175554221</figcaption></figure><h4 id="接受的语言">接受的语言</h4><figure><img src="image-20250521175640750.png" alt="image-20250521175640750" /><figcaption aria-hidden="true">image-20250521175640750</figcaption></figure><figure><img src="image-20250521175649976.png" alt="image-20250521175649976" /><figcaption aria-hidden="true">image-20250521175649976</figcaption></figure><h3 id="自动机等价-1">自动机等价</h3><figure><img src="image-20250521175751125.png" alt="image-20250521175751125" /><figcaption aria-hidden="true">image-20250521175751125</figcaption></figure><h3 id="nfa----dfa">NFA----&gt;DFA</h3><figure><img src="image-20250521175901791.png" alt="image-20250521175901791" /><figcaption aria-hidden="true">image-20250521175901791</figcaption></figure><figure><img src="image-20250521175910531.png" alt="image-20250521175910531" /><figcaption aria-hidden="true">image-20250521175910531</figcaption></figure><figure><img src="image-20250521175916547.png" alt="image-20250521175916547" /><figcaption aria-hidden="true">image-20250521175916547</figcaption></figure><figure><img src="image-20250521175922251.png" alt="image-20250521175922251" /><figcaption aria-hidden="true">image-20250521175922251</figcaption></figure><h3 id="自动机最小化">自动机最小化</h3><p>基础定义:</p><ul><li>等价状态:设DFA M 的两个状态S1和S2 , 如果对任意输入的 符号串x，从S1和S2出发，总是都到达接受状态或拒绝 状态中，则称S1和S2是等价的。</li><li>无关状态:设S是DFA M的一个状态， 若：<ul><li>从开始状态无到S的通路</li><li>或</li><li>S到任意终止状态无通路 则称S为M的无关状态</li></ul></li></ul><figure><img src="image-20250521180128337.png" alt="image-20250521180128337" /><figcaption aria-hidden="true">image-20250521180128337</figcaption></figure><h4 id="最简自动机">最简自动机</h4><p><strong>任意DNF的最简自动机是唯一的</strong></p><figure><img src="image-20250521180210719.png" alt="image-20250521180210719" /><figcaption aria-hidden="true">image-20250521180210719</figcaption></figure><h4 id="算法">算法</h4><figure><img src="image-20250521180225419.png" alt="image-20250521180225419" /><figcaption aria-hidden="true">image-20250521180225419</figcaption></figure><figure><img src="image-20250521180241566.png" alt="image-20250521180241566" /><figcaption aria-hidden="true">image-20250521180241566</figcaption></figure><figure><img src="image-20250521180253961.png" alt="image-20250521180253961" /><figcaption aria-hidden="true">image-20250521180253961</figcaption></figure><figure><img src="image-20250521180305124.png" alt="image-20250521180305124" /><figcaption aria-hidden="true">image-20250521180305124</figcaption></figure><figure><img src="image-20250521180311900.png" alt="image-20250521180311900" /><figcaption aria-hidden="true">image-20250521180311900</figcaption></figure><figure><img src="image-20250521180349536.png" alt="image-20250521180349536" /><figcaption aria-hidden="true">image-20250521180349536</figcaption></figure><figure><img src="image-20250521180403717.png" alt="image-20250521180403717" /><figcaption aria-hidden="true">image-20250521180403717</figcaption></figure><h3 id="自动机---正则表达式">自动机&lt;---&gt;正则表达式</h3><h4 id="正则表达式-----自动机">正则表达式-----&gt;自动机</h4><figure><img src="image-20250521180609844.png" alt="image-20250521180609844" /><figcaption aria-hidden="true">image-20250521180609844</figcaption></figure><figure><img src="image-20250521180636823.png" alt="image-20250521180636823" /><figcaption aria-hidden="true">image-20250521180636823</figcaption></figure><figure><img src="image-20250521180644939.png" alt="image-20250521180644939" /><figcaption aria-hidden="true">image-20250521180644939</figcaption></figure><figure><img src="image-20250521180701400.png" alt="image-20250521180701400" /><figcaption aria-hidden="true">image-20250521180701400</figcaption></figure><h4 id="自动机-----正则表达式">自动机-----&gt;正则表达式</h4><figure><img src="image-20250521180839869.png" alt="image-20250521180839869" /><figcaption aria-hidden="true">image-20250521180839869</figcaption></figure><figure><img src="image-20250521180917081.png" alt="image-20250521180917081" /><figcaption aria-hidden="true">image-20250521180917081</figcaption></figure><figure><img src="image-20250521180924359.png" alt="image-20250521180924359" /><figcaption aria-hidden="true">image-20250521180924359</figcaption></figure><figure><img src="image-20250521180938740.png" alt="image-20250521180938740" /><figcaption aria-hidden="true">image-20250521180938740</figcaption></figure><figure><img src="image-20250521180956018.png" alt="image-20250521180956018" /><figcaption aria-hidden="true">image-20250521180956018</figcaption></figure><h3 id="词法分析器">词法分析器</h3><figure><img src="image-20250521182037836.png" alt="image-20250521182037836" /><figcaption aria-hidden="true">image-20250521182037836</figcaption></figure><h4 id="接口">接口</h4><ul><li>词法分析作为独立的一遍<ul><li>词法分析程序的输出放在一个中间文件中， 语法分析程序从该文件读取Token</li><li><img src="image-20250521182114389.png" title="fig:" alt="image-20250521182114389" /></li></ul></li><li>词法分析作为语法分析的子程序<ul><li>每当语法分析程序需要单词时，就调用词法分析程序，使之输出一个Token供语法分析使用</li><li><img src="image-20250521182146430.png" title="fig:" alt="image-20250521182146430" /></li></ul></li></ul><h4 id="单词的种别">单词的种别</h4><figure><img src="image-20250521182220669.png" alt="image-20250521182220669" /><figcaption aria-hidden="true">image-20250521182220669</figcaption></figure><h4 id="token结构">token结构</h4><figure><img src="image-20250521182300601.png" alt="image-20250521182300601" /><figcaption aria-hidden="true">image-20250521182300601</figcaption></figure><figure><img src="image-20250521182333846.png" alt="image-20250521182333846" /><figcaption aria-hidden="true">image-20250521182333846</figcaption></figure><h4 id="工作过程-1">工作过程</h4><figure><img src="image-20250521182401993.png" alt="image-20250521182401993" /><figcaption aria-hidden="true">image-20250521182401993</figcaption></figure><ul><li>单词的DFA描述及实现</li><li>针对不同的单词生成对应的Token</li></ul><h2 id="语法分析">语法分析</h2><p>语法分析的基本任务是在词法分析识别出单词序列的基础上，分析判断程序的语法结构是否符合语言的语法规则</p><p>语言的语法结构用<strong>上下文无关文法</strong>来描述，因此语法分析程序的任务是按照上下文无关文法的产生式 ，判断整个单词序列是否构成语法上正确的程序</p><ul><li>自顶向下</li><li>自底向上</li></ul><h3 id="文法和语言">文法和语言</h3><p>文法(Grammar)是程序语言的生成系统。用文法可 精确定义一个语言，并依据文法构造出识别该语言的自动机。</p><p>程序语言的词法可用正则文法（正则表达式，有限自动机）描述，语法可用上下文无关文法描述，语义可用上下文有关文法描述。</p><figure><img src="/image-20250527212137736.png" alt="image-20250527212137736" /><figcaption aria-hidden="true">image-20250527212137736</figcaption></figure><figure><img src="/image-20250527212452797.png" alt="image-20250527212452797" /><figcaption aria-hidden="true">image-20250527212452797</figcaption></figure><figure><img src="/image-20250527212559442.png" alt="image-20250527212559442" /><figcaption aria-hidden="true">image-20250527212559442</figcaption></figure><figure><img src="/image-20250527212609144.png" alt="image-20250527212609144" /><figcaption aria-hidden="true">image-20250527212609144</figcaption></figure><figure><img src="/image-20250527212718231.png" alt="image-20250527212718231" /><figcaption aria-hidden="true">image-20250527212718231</figcaption></figure><figure><img src="/image-20250527212743597.png" alt="image-20250527212743597" /><figcaption aria-hidden="true">image-20250527212743597</figcaption></figure><h3 id="文法的分类">文法的分类</h3><figure><img src="/image-20250527212841909.png" alt="image-20250527212841909" /><figcaption aria-hidden="true">image-20250527212841909</figcaption></figure><figure><img src="/image-20250527212856413.png" alt="image-20250527212856413" /><figcaption aria-hidden="true">image-20250527212856413</figcaption></figure><figure><img src="/image-20250527212907785.png" alt="image-20250527212907785" /><figcaption aria-hidden="true">image-20250527212907785</figcaption></figure><blockquote><p>在编译技术中通常用3型文法（正则文法）来 描述高级程序设计语言的词法部分，2型文法（上 下文无关文法）描述的程序设计语言的语法结构， 比如描述算术表达式，描述各种语句等等。</p></blockquote><h3 id="文法的基本概念">文法的基本概念</h3><figure><img src="/image-20250527213055544.png" alt="image-20250527213055544" /><figcaption aria-hidden="true">image-20250527213055544</figcaption></figure><figure><img src="/image-20250527213103916.png" alt="image-20250527213103916" /><figcaption aria-hidden="true">image-20250527213103916</figcaption></figure><ul><li>最右推导又称规范推导，规范推导产生的句型称为规范句型</li><li>规范推导的逆过程称为规范归约（最左归约）</li></ul><figure><img src="/image-20250527213130335.png" alt="image-20250527213130335" /><figcaption aria-hidden="true">image-20250527213130335</figcaption></figure><p><strong>（若文法无二义性）一个句型的简单短语不一定唯一， 但句柄一定唯一</strong></p><h3 id="语法树">语法树</h3><p>语法树以图形化的方式把句子分解成各个组成部分，与符号的先后推导顺序无关，即语法树涵盖 了一个句型的所有可能的推导过程。</p><figure><img src="/image-20250527213312164.png" alt="image-20250527213312164" /><figcaption aria-hidden="true">image-20250527213312164</figcaption></figure><figure><img src="/image-20250527213333804.png" alt="image-20250527213333804" /><figcaption aria-hidden="true">image-20250527213333804</figcaption></figure><figure><img src="/image-20250527213402170.png" alt="image-20250527213402170" /><figcaption aria-hidden="true">image-20250527213402170</figcaption></figure><figure><img src="/image-20250527213409253.png" alt="image-20250527213409253" /><figcaption aria-hidden="true">image-20250527213409253</figcaption></figure><h3 id="二义性文法">二义性文法</h3><p>对一个文法G，如果<strong>至少存在一个句子</strong>，<strong>有两棵 （或两棵以上）不同的语法树</strong>，则称该句子是 二义性的。包含有二义性句子的文法称为二义 性文法，否则，该文法是无二义性的</p><figure><img src="/image-20250527213445373.png" alt="image-20250527213445373" /><figcaption aria-hidden="true">image-20250527213445373</figcaption></figure><h4 id="二义性的判定">二义性的判定</h4><figure><img src="/image-20250527213516712.png" alt="image-20250527213516712" /><figcaption aria-hidden="true">image-20250527213516712</figcaption></figure><figure><img src="/image-20250527213537722.png" alt="image-20250527213537722" /><figcaption aria-hidden="true">image-20250527213537722</figcaption></figure><h3 id="文法的等价变换">文法的等价变换</h3><ul><li>提取左公共前缀</li><li>消除直接左递归</li><li>消除简介左递归</li></ul><h4 id="提取左公共前缀">提取左公共前缀</h4><figure><img src="/image-20250527213700841.png" alt="image-20250527213700841" /><figcaption aria-hidden="true">image-20250527213700841</figcaption></figure><figure><img src="/image-20250527213707407.png" alt="image-20250527213707407" /><figcaption aria-hidden="true">image-20250527213707407</figcaption></figure><h4 id="消除直接左递归">消除直接左递归</h4><figure><img src="/image-20250527213744632.png" alt="image-20250527213744632" /><figcaption aria-hidden="true">image-20250527213744632</figcaption></figure><figure><img src="/image-20250527213801300.png" alt="image-20250527213801300" /><figcaption aria-hidden="true">image-20250527213801300</figcaption></figure><figure><img src="/image-20250527213811678.png" alt="image-20250527213811678" /><figcaption aria-hidden="true">image-20250527213811678</figcaption></figure><h4 id="消除间接左递归">消除间接左递归</h4><figure><img src="/image-20250527213901449.png" alt="image-20250527213901449" /><figcaption aria-hidden="true">image-20250527213901449</figcaption></figure><figure><img src="/image-20250527213910531.png" alt="image-20250527213910531" /><figcaption aria-hidden="true">image-20250527213910531</figcaption></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大题题型:&lt;/p&gt;
&lt;p&gt;词法分析:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DFA化简&lt;/li&gt;
&lt;li&gt;NFA-&amp;gt;DFA&lt;/li&gt;
&lt;li&gt;正则表达式&amp;lt;---&amp;gt;自动机&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;编译原理复习笔记&quot;&gt;编译原理复习笔记&lt;/h1&gt;</summary>
      
    
    
    
    
    <category term="class" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/class/"/>
    
  </entry>
  
  <entry>
    <title>计网简答题</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2024/12/23/%E8%AE%A1%E7%BD%91%E7%AE%80%E7%AD%94%E9%A2%98/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2024/12/23/%E8%AE%A1%E7%BD%91%E7%AE%80%E7%AD%94%E9%A2%98/</id>
    <published>2024-12-23T07:53:14.000Z</published>
    <updated>2025-03-29T05:43:34.530Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ch01">CH01</h2><h3 id="两种描述因特网的方式">两种描述“因特网”的方式：</h3><ol type="1"><li>描述构成因特网的<strong>具体构成</strong>，包括基本硬件和软件组件；<br /></li><li>描述为基础设施向分布式应用程序提供的<strong>服务</strong>。</li></ol><h3 id="两种最主要类型的分组交换机">两种最主要类型的分组交换机：</h3><ul><li><strong>路由器 (routers)</strong>：用于核心网；<br /></li><li><strong>链路层交换机 (switches)</strong>：用于接入网。</li></ul><h3 id="套接字接口">套接字接口</h3><p>一套发送程序必须遵循的规则集合，规定了运行在一个<strong>端系统上的应用程序</strong>如何请求因特网基础设施向运行在另一个<strong>端系统上的特定目的程序</strong>交付数据的方式。</p><h3 id="网络协议-network-protocols">网络协议 (network protocols)</h3><p>协议定义了在两个或多个通信实体之间交换的<strong>报文格式和顺序</strong>，以及报文发送和接收及其他事件所采取的<strong>动作</strong>。<br />特点：<br />- 通信双方交换报文，而不是语句；<br />- 通信实体是设备。</p><h3 id="网络结构的划分">网络结构的划分</h3><ol type="1"><li><strong>网络边缘</strong>：主机/端系统、应用程序；<br /></li><li><strong>接入网络</strong>：将端系统物理连接到其边缘路由器的网络,有线或者无线通信链路。</li><li><strong>网络核心</strong>：是由分组交换机和链路构成的网状网络。</li></ol><h3 id="接入网-access-networks">接入网 (Access networks)</h3><p>将端系统物理连接到其边缘路由器的网络。</p><ul><li><strong>边缘路由器</strong>：是端系统到任何远程端系统路径上的第一台路由器。</li></ul><h3 id="数据传输方式">数据传输方式</h3><ol type="1"><li><p><strong>电路交换</strong>：在端系统间通信过程中，创 建电路时就预留了端系统间沿路径通信所需要的全部资 源(缓存、链路传输速率)，并会话期间<strong>独占</strong>这些资源</p><ul><li><strong>频分复用</strong>(FDM):链路的<strong>频谱</strong>由跨该链路的所有连接共享，为每条经过的电路分配一个划分的子频段</li><li><strong>时分复用</strong>（TDM）: 通信时间被划分为固定期间的帧，每个帧又被划分为固定数量的时隙，网络中 建立电路时在各段链路上的每个通信周期(时域)指定一个专用时隙，该时隙用于传输该电路连接的数据。</li></ul><p><strong>电路交换缺点</strong>:</p><ul><li>电路交换因为在静默期（slient period）专用电路空闲导致浪费。</li><li>创建端到端的电路和预留资源是复杂的，需要复杂的信令和协 调沿路径的交换机操作</li></ul></li><li><p><strong>分组交换</strong>：将要传送的数据分成一个个单位（分组）。</p><ul><li>分组从一个路由器传到相邻路由器（hop），一段段传输至目标端；<br /></li><li>每段采用链路的最大传输能力（带宽）。</li></ul></li></ol><h3 id="分组交换-vs.-电路交换">分组交换 vs. 电路交换</h3><ul><li>分组交换网不适合实时服务(如电话和视频会议)，因为排队时 延导致端到端时延可变、不可预测。</li><li>分组交换网提供了比电路交换好的带宽共享,比电路交换更简单、 更有效、实现成本低</li><li>分组交换网适合于对突发式数据传输 :资源共享 , 简单，不必建立呼叫 但是过度使用会造成网络拥塞：分组延时和丢失,对可靠地数据传输需要协议来约束：拥塞控制</li></ul><h3 id="物理媒介">物理媒介</h3><p>分类:</p><ul><li>引导型</li><li>非引导型</li></ul><p>双绞线:</p><ul><li>两根绝缘的铜线以规则的螺旋状绞合起来，为减少临近类似 的双绞线的电气干扰</li><li>在一些特殊的环境下，如化工厂附近，使用外面包裹保护层 的屏蔽双绞线，但质地较硬，不利于布线。</li><li>大多数情况下，使用无屏蔽双绞线 UTP，广泛用于计算机网 络局域网组网中，灵活易布线，性价比高</li></ul><p>同轴电缆</p><ul><li>由于外层屏蔽层的作用，具有很好的抗干扰性，适于高速率传输</li></ul><p>光纤</p><ul><li>高传输速率</li><li>长距离传输，100km，光缆信号衰减极低，很难窃听</li><li>低误码率,不受电磁干扰</li><li>这些特性使其适用于长途引导型媒体，特别是跨海链路。</li></ul><p>无线电信道</p><ul><li>优点：穿墙、长距离、移动 连接</li><li>缺点：性能依赖于传播环境 和传播距离</li><li>同步卫星 近地卫星</li></ul><hr /><h3 id="分组交换">分组交换</h3><ul><li>以分组为单位<strong>存储-转发</strong>方式</li><li>存储转发传输(store-and-forward transmission): 是指在分组交换机能够开始向输出链路传输该分组的第一个比特之前，必须 接收到整个分组</li></ul><hr /><h3 id="产生时延和分组丢失的原因"><strong>产生时延和分组丢失的原因:</strong></h3><ul><li>分组到达链路的速率超过了链路输出的能力</li><li>分组等待排到队头被传输</li></ul><p><strong>最大吞吐量</strong>:一台路由器能够转发分组的<strong>最大</strong>速率</p><p><strong>瓶颈链路</strong>:端到端路径上，限制端到端吞吐的链路</p><p>服务( Service)：低层实体向上层实体提供它们之间的通信的能力</p><p><strong>服务与协议的区别</strong> :</p><ul><li>服务(Service)：低层实体向上层实体提供它们之间的通信的能力，是通过原语(primitive)来操作的，垂直</li><li>协议(protocol) ：<strong>对等层实体</strong>(peer entity)之间在相互通信的过程中，需要遵循的规则的集合，水平</li></ul><p><strong>服务与协议的联系 :</strong></p><ul><li>本层协议的实现要靠下层提供的服务来实现</li><li>本层实体通过协议为上层提供更高级的服务</li></ul><h3 id="分层的体系结构">分层的体系结构</h3><ul><li>网络设计者以<strong>分层</strong>的方式<strong>组织协议</strong>，以及<strong>实现协议</strong>的网络硬件和软件:</li><li>每一层向它的上一层提供服务（service）。</li><li>每层通过执行该层的某些动作或直接使用下层服务来提供服务。</li><li>一个协议层能够使用软件、硬件或两者的结合来实现。<ul><li>应用层协议几乎用软件实现；</li><li>物理层、数据链路层协议通常在网络接口卡(硬件)实现;</li><li>网络层协议通常由软、硬件混合实现.</li></ul></li><li>第n层协议分布在网络的端系统、分组交换机和其它组件</li></ul><p><strong>分层的原因:</strong></p><ul><li>结构化分层易于定义和实现</li><li>模块化,易于维护和升级</li></ul><p><strong>分层的潜在缺点</strong>：</p><ul><li>功能可能在多层冗余，如差错检验；</li><li>某层功能可能调用其它层提供的信息，分层不彻底.</li></ul><figure><img src="image-20241214221427100.png" alt="image-20241214221427100" /><figcaption aria-hidden="true">image-20241214221427100</figcaption></figure><table><thead><tr class="header"><th>协议</th><th>任务</th><th>信息单位</th><th></th></tr></thead><tbody><tr class="odd"><td>应用层</td><td>HTTP SMTP FTP DNS</td><td><strong>端系统</strong>之间</td><td>报文</td></tr><tr class="even"><td>传输层</td><td>TCP UDP</td><td><strong>应用程序端点</strong>之间传送应用层报文</td><td>报文段</td></tr><tr class="odd"><td>网络层</td><td>IP 路由选择协议</td><td><strong>主机</strong>之间</td><td>数据报</td></tr><tr class="even"><td>链路层</td><td>链路层协议 DOCSIS PPP</td><td>整个<strong>帧</strong>从一个<strong>节点</strong>到下一个节点</td><td>帧</td></tr><tr class="odd"><td>物理层</td><td>与实际传输媒体相关</td><td>一个个<strong>比特</strong>从一个<strong>节点</strong>到下一个节点</td><td>比特</td></tr></tbody></table><hr /><h2 id="ch02-应用层">CH02 应用层</h2><h3 id="客户-服务器体系结构">1. 客户-服务器体系结构</h3><ul><li><strong>服务器</strong>：<ul><li>一直运行；<br /></li><li>固定的IP地址和周知的端口号；<br /></li><li>可扩展性：通过服务器场或数据中心进行扩展，但扩展性差。</li></ul></li><li><strong>客户端</strong>：<ul><li>主动与服务器通信；<br /></li><li>与互联网有间歇性的连接；<br /></li><li>可能使用动态IP地址；<br /></li><li>不直接与其它客户端通信。</li></ul></li></ul><h3 id="p2p结构">2. P2P结构</h3><ul><li>无需一直运行的服务器；<br /></li><li>任意端系统之间可以通信；<br /></li><li>每个节点既是客户端又是服务器；<br /></li><li>新节点带来服务能力同时也增加服务请求；<br /></li><li>主机连接间歇性且IP地址可能变化；<br /></li><li>难以管理，面临安全性、性能、可靠性挑战。</li></ul><h3 id="应用程序开发者控制范围">3. 应用程序开发者控制范围</h3><ul><li><strong>应用层端</strong>：对套接字的所有控制；<br /></li><li><strong>传输层端</strong>：仅限于：<ol type="1"><li>选择传输层协议；<br /></li><li>设置最大缓存和报文长度等参数。</li></ol></li></ul><h3 id="应用层协议总结">4. 应用层协议总结</h3><table><thead><tr class="header"><th>应用层协议</th><th>传输层协议</th><th>备注</th></tr></thead><tbody><tr class="odd"><td>HTTP</td><td>TCP 默认持久连接</td><td>ASCII码</td></tr><tr class="even"><td>SMTP</td><td>TCP 持久连接</td><td>7位 ASCII码</td></tr><tr class="odd"><td>DNS</td><td>UDP</td><td></td></tr></tbody></table><h3 id="http连接类型对比">5. HTTP连接类型对比</h3><ul><li><strong>非持续连接</strong>：<ul><li>一个对象对应一个TCP连接；<br /></li><li>下载多个对象需要多个TCP连接；<br /></li><li>HTTP/1.0 使用非持久连接。</li></ul></li><li><strong>持续连接</strong>：<ul><li>多个对象在一个TCP连接上传输；<br /></li><li>HTTP/1.1 默认使用持续连接。</li></ul></li></ul><p>HTTP 默认使用持续连接，可配置为非持续连接。</p><hr /><h3 id="使用web缓存的原因">6. 使用Web缓存的原因</h3><ol type="1"><li>降低客户端的请求响应时间；<br /></li><li>减少机构内部网络与Internet接入链路上的流量；<br /></li><li>互联网广泛采用缓存，使较弱的ICP也能有效提供内容。</li></ol><h3 id="smtp-vs-http">7. SMTP VS HTTP</h3><ul><li><strong>HTTP</strong>：拉取 (pull)<br /></li><li><strong>SMTP</strong>：推送 (push)<br /></li><li>二者均为ASCII形式的命令/响应交互，带有状态码；<br /></li><li><strong>HTTP</strong>：每个对象封装在各自响应报文中；<br /></li><li><strong>SMTP</strong>：多个对象包含在一个报文中。</li></ul><hr /><h3 id="dns提供的服务">8. DNS提供的服务</h3><ol type="1"><li>主机名到IP地址的转换；<br /></li><li>主机别名 (Host aliasing)：映射 alias names 到规范主机名或IP；<br /></li><li>邮件服务器别名 (Mail server aliasing)：映射邮件服务器别名到规范主机名或IP；<br /></li><li>负载均衡 (Load distribution)：DNS服务器响应IP集合并循环排列以分散请求。</li></ol><h3 id="分布式dns设计的原因">9. 分布式DNS设计的原因</h3><ol type="1"><li>单点故障：集中服务器宕机会导致因特网瘫痪；<br /></li><li>通信容量：单个DNS服务器无法处理所有查询；<br /></li><li>远距离通信：存在时延、拥塞问题；<br /></li><li>维护困难：中央数据库过于庞大且需频繁更新。</li></ol><hr /><h3 id="dns层次数据库">10. DNS层次数据库</h3><ol type="1"><li><strong>根服务器</strong>：提供TLD服务器的IP地址；<br /></li><li><strong>顶级域 (TLD) DNS服务器</strong>：提供权威DNS服务器的IP地址；<br /></li><li><strong>权威DNS服务器</strong>：存储公共可访问主机的DNS记录，映射主机名到IP。</li></ol><hr /><figure><img src="2288178-20221107000827927-251643069.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><blockquote><ul><li>用户代理：允许用户阅读、回复、转发、保存和撰写报文。</li><li>邮件服务器：发送和接收邮件，同时还要向发件人报告邮件传送的结果。</li><li>简单邮件传输协议：是一个推协议，用在发送方邮件服务器和接收方服务器之间。</li><li>过程：从发送方的用户代理开始，传输到发送方的邮件服务器，再传输到接收方的邮件服务器，然后在这里被分发到接收方的邮箱中。</li></ul></blockquote><figure><img src="2288178-20221107195300596-1752266272.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><blockquote><ul><li>原因<ul><li>大大减少对客户请求的响应时间</li><li>大大减少一个机构的接入链路到因特网的通信量，降低费用</li><li>大大减低因特网上的 <strong>Web</strong> 流量，改善了所有应用的性能</li></ul></li><li>工作步骤<ul><li>浏览器发送到 <strong>Web</strong> 缓存器的 <strong>TCP</strong> 连接，并发送一个 <strong>HTTP</strong> 请求</li><li><strong>Web</strong> 缓存器检查是否存储本地对象副本，如果有，则用 <strong>HTTP</strong> 响应返回对象</li><li>如果没有对象，则打开与对象初始服务器的 <strong>TCP</strong> 连接，发送 <strong>HTTP</strong> 请求，初始服务器收到请求之后返回对象</li><li><strong>Web</strong> 缓存器收到对象之后在本地存储空间存储一份副本，同时保存最后修改日期 <strong>Last-Modified</strong>首部行，向客户浏览器用 HTTP 响应返回对象副本。</li></ul></li></ul></blockquote><figure><img src="2288178-20221107195815912-1081754629.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><blockquote><p>主机向本地 DNS 服务器查询，如果主机所询问的本地 DNS 服务器不知道被查询的域名的 IP 地址，那么本地域名服务器就以DNS客户的身份，向根 DNS 服务器继续发出查询请求报文，而不是让主机自己进行下一步查询。根 DNS 服务器也不知道被查询的域名的 IP 地址，作为 DNS 客户向 TLD DNS 服务器继续发送查询请求报文。TLD DNS 服务器继续向权威 DNS 服务器发送查询报文，获得查询域名的 IP 地址之后，依次返回 TLD DNS 服务器，根 DNS 服务器，本地 DNS 服务器，最后返回请求主机。</p></blockquote><figure><img src="2288178-20221107200849932-1496101482.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><blockquote><p>请求主机与本地 DNS 服务器之间是递归查询，其他交互都是迭代查询。请求主机首先向它的本地 DNS 服务器发送一个 DNS 查询报文。该查询报文含有被转换的主机名。本地 DNS 服务器将该报文转发到根 DNS 服务器。该根 DNS 服务器向本地 DNS 服务器返回相应 TLD 的 IP 地址列表。本地 DNS 服务器再次向这些 TLD 服务器之一发送查询报文。TLD 服务器用权威 DNS 服务器的 IP 地址响应。最后，本地 DNS 服务器直接向该权威 DNS 服务器重发查询报文，权威 DNS 服务器用目标主机 IP 地址响应。</p></blockquote><h2 id="ch03-传输层">CH03 传输层</h2><p>1.传输层的作用</p><ul><li>传输层为运行在不同主机上的应用进程提供<strong>逻辑通信</strong>。</li><li>将网络层在两个端系统之间的交付服务扩展到运行在 两个<strong>不同端系统上的应用层进程</strong>之间的交付服务。</li><li>并解决两个对等通信实体如何在尽力而为（会丢失或 损坏数据）的因特网上进行<strong>可靠的通信</strong>。</li></ul><p>传输协议运行<strong>在端系统</strong></p><p>多路分解与多路复用 : 将由网络层提供的<strong>主机到主机</strong>的交付服务延伸到运行在主机上的<strong>应用程序</strong>,提供<strong>进程到进程</strong>的交付服务</p><ul><li>在<strong>发送方</strong>主机<strong>多路复用</strong>:从多个套接字接收来自多个进程的报文，根据套接字对应的IP地址和端口号等信息对报文段用头部加以封装 (该头部信息用于以后的解复用)</li><li>在<strong>接收方</strong>主机<strong>多路解复用</strong>:根据报文段的头部信息中的IP地址和端口号将接收到的报文段发给正确的套接字(和对应的应用进程)</li></ul><p><strong>多路复用工作原理</strong></p><ul><li>主机收到IP数据报<ul><li>每个数据报有<strong>源IP地址</strong>和<strong>目标IP地址</strong></li><li>每个<strong>数据报</strong>承载一个<strong>传输层报文段</strong></li><li>每个<strong>报文段</strong>有一个<strong>源端口号</strong>和 <strong>目标端口号</strong> (特定应用有著名的端口号)</li></ul></li><li>主机联合使用<strong>IP地址和端口号</strong>将报 文段发送给合适的<strong>套接字</strong></li></ul><p><strong>为什么要有UDP?</strong></p><ul><li>不建立连接 （会增加延时 ）</li><li>简单：在发送端和接收端没有连接状态</li><li>报文段的头部很小(开销小)</li><li>无拥塞控制和流量控制： UDP可以尽可能快的发送报文段</li><li>应用-&gt;传输的速率= 主机-&gt;网络的速率</li></ul><p><strong>为什么UDP提供了差错检验，而有些链路层协议也提供了差错检验功能？</strong></p><ul><li>不能确保源端和目的端之间所有的链路都提供差错检验。</li><li>不能确保报文段在某个路由器内存中存储时不出错。</li><li>UDP提供差错检验，但对差错没有恢复功能。</li></ul><p>通用的流水线协议,根据差错的恢复方式不同:</p><p>回退N步(GBN):全部重传 累计确认</p><p>选择重传(SR): 选择重传 单独确认</p><p>GBD优缺点:<strong>优缺点</strong></p><p>优点:</p><ul><li>接收方简单，不需要缓存任何失序的数据片，不需 要设置缓存。</li></ul><p>缺点：</p><ul><li>发送方需要设置缓存已发送但未确认的数据片，并维护 窗口的上下边界和nextseqnum。</li><li>由于失序而丢弃一个正确的数据片后，随后可能需要更 多的重传，包括之前删除的正确的失序数据片。</li><li>当窗口长度和带宽时延积很大时，单个数据片的错误就 能引起GBN重传大量数据片！导致传输效率大大降低</li></ul><h3 id="gbn-vs.-sr">GBN vs. SR</h3><table><colgroup><col style="width: 9%" /><col style="width: 45%" /><col style="width: 45%" /></colgroup><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">GBN</th><th style="text-align: center;">SR</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">发送窗口大小</td><td style="text-align: center;">(1,2k−1]</td><td style="text-align: center;">(1,2k−1]</td></tr><tr class="even"><td style="text-align: center;">接收窗口大小</td><td style="text-align: center;"><strong>=1</strong>,接收方只能顺序接收 发送方:一旦一个分组没有发成功， 如：0,1,2,3,4 ; 假如1未成功，234都发送出去 了，要返回1再发送；GB1</td><td style="text-align: center;"><strong>&gt;1</strong>,接收方可以乱序接收 发送方发送0,1,2,3,4， 一旦1未成功，2,3,4,已发送， 无需重 发，选择性发送1</td></tr><tr class="odd"><td style="text-align: center;">确认</td><td style="text-align: center;">累计确认</td><td style="text-align: center;">选择确认</td></tr><tr class="even"><td style="text-align: center;">定时器</td><td style="text-align: center;">发送端拥有对最老的未确认分组的定时器 当定时器到时时，重 传所有未确认分组</td><td style="text-align: center;">发送方为每个未确认的分组保持一个定时器 当超时定时器到时，只是 重发到时的未确认分组</td></tr></tbody></table><figure><img src="2288178-20221110113450520-1286991947.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><blockquote><ul><li><p>第一步：客户端的 <code>TCP</code> 首先向服务器端的 <code>TCP</code> 发送一个 <code>SYN</code> 报文段。该报文段中不包含应用层数据，但在首部中设置 SYN 标志位为 <code>1</code>，随机选择一个初始序号 <code>client_isn</code> 放置在报文段的序号字段中。该报文段被封装在一个 <code>IP</code> 数据报中发送给服务器</p></li><li><p>第二步：服务器提取出 <code>SYN</code> 报文段，分配缓存和变量，向客户 <code>TCP</code> 发送 <code>SYNACK</code> 报文段。在首部中设置 <code>SYN</code> 标志为 <code>1</code> ，确认号设置为 <code>client_isn + 1</code>，选择初始序号 <code>server_isn</code> 设置到序号字段中</p></li><li><p>第三步：客户收到 <code>SYNACK</code> 报文段之后，分配缓存和变量，发送报文，对服务器的允许连接报文段进行确认。因为链接已建立了，设置 SYN 标志为 0</p></li><li><p>三次握手才可以阻止重复历史连接的初始化（主要原因）而两次握手会存在这个问题</p></li><li><p>三次握手才可以同步双方的初始序列号 两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</p></li><li><p>三次握手才可以避免资源浪费 两次握手会造成消息滞留情况下，服务器重复接受无用的连接请求 <code>SYN</code> 报文，而造成重复分配资源。</p></li></ul></blockquote><p><strong>TCP与UDP的区别</strong></p><p>TCP是面向连接的，UDP是无连接的 TCP是可靠的，UDP是不可靠的 TCP是面向字节流的，UDP是面向数据报文的 TCP只支持点对点通信，UDP支持一对一，一对多，多对多 TCP报文首部20个字节，UDP首部8个字节 TCP有拥塞控制机制，UDP没有 TCP协议下双方发送接受缓冲区都有，UDP并无实际意义上的发送缓冲区，但是存在接受缓冲区</p><figure><img src="2288178-20221110114252631-1066341407.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><blockquote><p>作用：标识一台主机上的应用进程</p><p>位数长度：16 比特</p><p>周知端口号：0 — 1023 全局分配（静态分配）</p><p>周知端口号的作用：固定保留分配给诸如 HTTP 和 FTP 之类的周知应用层协议来使用</p><p>自由端口号：1024 — 65535</p><p>管理及分配方式：本地分配（动态连接）。这些端口号一般不固定分配给某个服务，也就是说许多服务都可以使用这些端口。只要运行的程序向系统提出访问网络的申请，那么系统就可以从这些端口号中分配一个供该程序使用。即进程需要访问传输层服务时，向本地操作系统提出申请，操作系统返回本地唯一的端口号，进程再通过合适的系统调用，将自己和该端口连接起来（绑定）</p></blockquote><figure><img src="2288178-20221110120643389-1137810509.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><blockquote><figure><img src="2288178-20221108203834857-592392539.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure></blockquote><p>超时触发重传存在的问题之一是超时周期可能相对较长。当一个报文段丢失时, 这种长超时周期迫使发送方延迟重传丢失的分组，因而增加了端到端时延。<strong>解决方法便是快速重传</strong>,如果TCP发送方接收到对相同数据的<strong>3个冗余ACK</strong>,它 把这当作一种指示，说明跟在这个已被确认过3次的报文段之后的报文段已经丢失。一旦收到3个冗余ACK, TCP就执行快速重传,即 在该报文段的<strong>定时器过期</strong>之前<strong>重传</strong>丢失的报文段。</p><p>流量控制：是一个<strong>速度匹配</strong>服务，使得<strong>发送方速率与接收方速率</strong>向匹配， 不至于导致接收方缓存溢出</p><p>拥塞控制：因IP网络拥塞而限制发送方的发送速率。</p><h2 id="ch04-ch05网络层">CH04 CH05网络层</h2><p>因特网中所有主机和交换设备都有网络层功能</p><p><strong>路由选择和转发的主要区别是什么？</strong></p><blockquote><p>转发是指将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地动作。转发发生的时间尺度很短，因此通常用硬件来实现。</p><p>路由选择是指确定分组从源到目的地所采取的端到端路径的网络范围处理过程。路由选择发生的时间尺度长很多，因此通常用软件来实现。</p></blockquote><p><strong>什么是HOL阻塞？它出现在哪个端口？</strong></p><blockquote><p>HOL阻塞是<strong>线路前部阻塞</strong>，即在一个输入队列中排队的分组必须等待通过交换结构发送（即使输出端口是空闲的），因为它被位于线路前部的另一个分组所阻塞。</p><p>出现在输入端口。</p></blockquote><p><strong>比较对照 IPv4和IPv6首部字段，它们有相同的字段吗？</strong></p><blockquote><p>IPv6相比IPv4去掉了片偏移字段，IPv6不允许分片</p><p>IPv6去掉了首部校验和，因为因特网重的运输层和数据链路层协议已经执行了校验操作</p><p>IPv6去掉了选项字段，这样就保证了IPv6头部是40字节定长</p><p>IPv6多出了流的概念，因此多了一个流标签字段。</p><p>剩下IPv6头部中的字段如版本号，流量类型等字段都和IPv4里的字段有着类似的含义。如流量类型类似于IPv4中的服务类型字段，两者都有数据包长度这个字段，等等。</p></blockquote><p><strong>比较和对照链路状态和距离矢量这两种路由算法。</strong></p><blockquote><p>在 <code>DV</code> 算法中，每个节点仅与它的直接相连的邻居交谈，但它为其邻居提供了从它自己到网络中（它所知道的）所有其他节点的最低开销估计。路由器以<strong>迭代、分布式的</strong>方式计算出最低开销路径。没有节点拥有关于所有网络链路开销的完整信息。</p><p><code>LS</code> 算法需要全局信息，因此当在每台路由器中实现时，每个节点与所有其他节点通信，但仅告诉它们与它直接相连链路的开销。用<strong>完整的、全局的</strong>网络知识计算出从源到目的地之间的最低开销路径。该算法以<strong>所有</strong>节点之间的连通性以及所有链路的开销为输入。</p><ul><li><strong>报文复杂性</strong>：<code>LS</code> 算法要求每个节点都知道网络中每条链路的开销。这就要求发送 <code>O(|N||E|)</code> 个报文。<code>DV</code> 算法要求在每次迭代时，在两个直接相连邻居之间交换报文。<code>DV</code> 算法仅当在新的链路开销导致与该链路相连节点的最低开销路径发生改变时，才传播已改变的链路开销。</li><li><strong>收敛速度</strong>：LS 算法的实现是一个要求 <code>O(|N||E|)</code> 个报文的 <code>O(|N|^2)</code> 算法。DV 算法收敛速度较慢，且在收敛时会遇到路由选择环路，还会遭遇无穷计数问题。</li><li><strong>健壮性</strong>：在 LS 算法下，路由计算在某种情况下是分离的，提供了一定程度的健壮性。在 DV 算法下，一个节点可以向任意或所有目的节点通告其不正确的最低开销路径，一个不正确的节点计算值会扩散到整个网络。</li><li><img src="2288178-20221113000533452-1390500049.png" title="fig:" alt="img" /></li></ul></blockquote><p><strong>路由器四个组件是什么？画图阐述作用</strong></p><p>输入端口、输出端口、交换结构、路由处理器（调度机制）</p><figure><img src="247f1b8df38ac1b4edea605cefa21865.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="e3ec191bdda4d35a7cd7e19626ba12ef.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="db040eb1bc16245ca23fec271884414d.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="a85c63c8c2e587abe66d36128edf5460.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>简述DHCP客户服务器交互的4个步骤？</strong> DHCP（Dynamic Host Configuration Protocol）：动态主机配置协议。是一种高效的IP地址分配方法，</p><ol type="1"><li>发现阶段：即DHCP客户机寻找DHCP服务器的阶段。DHCP客户机以广播方式发送信息来寻找DHCP服务器，只有DHCP服务器才会做出响应。</li><li>提供阶段：即DHCP服务器提供IP地址的阶段。服务器从尚未出租的IP地址中挑选一个分配给DHCP客户机。</li><li>选择阶段：即DHCP客户机选择某台DHCP服务器提供的IP地址的阶段。</li><li>确认阶段：即DHCP服务器确认所提供的IP地址的阶段。</li></ol><blockquote><p><strong>简述流量控制与拥塞控制的区别？</strong> 拥塞控制是为了避免网络资源耗尽的问题，通过拥塞窗口实现（它的发展对因特网整个有好处，有全局性） 流量控制是着眼于TCP传输的本质要求，它目的是解决发送方和接收方速率不匹配的问题，通过滑动窗口实现（控制已发送但未被ACK的包的数量）</p></blockquote><p><strong>IPv6相对于IPv4主要的变化:</strong></p><ul><li><strong>扩大的地址容量</strong>。IPv6将IP地址长度 从32比特增加到128比特</li><li>简化高效的40字节首部,<strong>40字节定长首部</strong>允许路由器更快地处理IP数据报</li><li>流标签</li><li><strong>不允许分片</strong>,中间路由器不允许对分组进行分片，如果收 到了过大的分组不能转发到输出链路上只需要将其<strong>丢弃</strong>，<strong>分组的分片和重新装配只能在源/目的端进行</strong></li><li><strong>取消校验和</strong> checksum: 传输层和数据链路层都有这个功能，而且由于TTL字段的存在导致校验和在每个路由器需要重新计算再 写入，影响了路由器的快速转发</li><li>选项 options: 没有完全取消，如果需要可在“下一个首部”字段 中指出</li><li>ICMPv6: ICMP的新版本<ul><li>附加了报文类型, e.g. “Packet Too Big”</li><li>多播组管理功能</li></ul></li></ul><p><strong>路由选择算法的分类</strong></p><ol type="1"><li>算法是集中式还是分散式来划分<ul><li>集中式路由选择算法: 所有的路由器拥有完整的拓扑和边的代价的信息 eg : “link state”</li><li>分散式路由选择算法:<ul><li>路由器只知道与它有<strong>物理连接关系</strong>的<strong>邻居路由器</strong>，和到相应邻居路由器的代价值</li><li>迭代式地与邻居交换路由信息、 计算路由信息 “distance vector”</li></ul></li></ul></li><li>静态或者动态<ul><li>静态路由选择算法:路由随时间变化缓慢,通常是人工-进行调整（如人为手工编辑一条链路开销）</li><li>动态路由选择算法:路由变化很快,周期性更新,响应拓扑和开销变化</li></ul></li></ol><h2 id="ch06-链路层">CH06 链路层</h2><blockquote><p>为什么在链路层和传输层都实现了可靠性:</p><p>一般化的链路层服务，不是所有的链路层都提供这些服务 一个特定的链路层只是提供其中一部分的服务</p></blockquote><blockquote><p>为什么要在采用无线链路的网络上，链路层做可靠数据传输工作 ；还要在传输层做端到端的可靠性工作？</p><p>原因：出错率高，如果在链路层不做差错控制工作，漏出去的错误比较高；到了上层如果需要可靠控制的数据传输代价会很大</p></blockquote><p><strong>链路层协议能够向网络层提供哪些可能的服务？在这些链路层服务中，哪些在IP中有对应的服务? 哪些在TCP中有对应的服务？</strong></p><blockquote><p>链路层能够向网络层提供的服务有：成帧，链路接入，可靠传送，流量控制，纠错，检错，全双工传输等。</p><p>其中，在 IP 中有的服务是：成帧，检错。</p><p>在 TCP 有的服务是：成帧，可靠传送，流量控制，检错以及全双工传输。</p></blockquote><p><strong>多路访问(MAC)协议划分为3种类型:</strong></p><ul><li>信道划分协议<ul><li>把信道划分成小片（时间、频率、编码）</li><li>分配片给每个节点专用</li></ul></li><li>随机接入协议<ul><li>信道不划分，允许碰撞</li><li>碰撞后恢复</li></ul></li><li>轮流协议<ul><li>节点依次轮流</li><li>但是有很多数据传输的节点可以获得较长的信道使用权</li></ul></li></ul><p><strong>简述地址解析协议ARP的作用及作用范围？</strong> 地址解析协议（Address Resolution Protocol,ARP）：发送主机中的APR模块将取在相同局域网上的任何IP地址作为输入，然后返回相应的MAC地址</p><p>ARP只为在同一个子网上的主机和路由器接口解析IP地址</p><p><strong>简述交换机与路由器的异同？</strong></p><p>相同点： 1. 都可用来交换网络设备 2. 都是用来扩展网络的</p><p>不同点： 1. 工作层次不同 交换机工作在数据链路层 而路由器工作在网络层 2. 数据转发所依据的对象不同 交换机利用MAC地址确定转发数据的目的地址 路由器则是利用IP地址来确定数据转发的地址</p><h3 id="ch-07">CH 07</h3><ul><li><p><strong>路径损耗</strong>：电磁波在穿过物体时强度将减弱。即使在自由空间中，信号仍将扩散，这使得信号强度随着发送方和接收方距离的增加而减弱。</p></li><li><p><strong>多径传播</strong>：当电磁波的一部分受物体和地面反射，在发送方和接收方之间走了不同长度的路径，则会出现多径传播。这使得接收方收到的信号变得模糊。位于发送方和接收方之间的移动物体可导致多径传播随时间而改变。</p></li><li><p><strong>隐藏终端问题</strong>：即使 <code>A</code> 和 <code>C</code> 的传输确实是在目的地 <code>B</code> 发生干扰，环境的物理阻拦（大山、建筑）也可能会妨碍 <code>A</code> 和<code>C</code> 互相听到对方的传输。</p></li><li><p><strong>衰减</strong>：<code>A</code> 和 <code>C</code> 所处的位置使得它们的信号强度不足以使它们相互检测到对方的传输，然而它们的传输足以强到在站点 B 处相互干扰。</p></li><li><p>与基站关联的主机通常被称为以<strong>基础设施模式</strong>运行。因为所有传统的网络服务（如地址分配和路由选择）都由网络向通过基站相连的主机提供。</p></li><li><p><strong>被动扫描</strong>：扫描信道和监听信标帧的过程。</p></li><li><p><strong>主动扫描</strong>：通过向位于无线主机范围内的所有 <code>AP</code> 广播探测帧完成的。AP 用一个探测响应帧应答探测请求帧。无线主机则能够在响应的 AP 中选择某 AP 与之相关联。</p></li></ul><figure><img src="image-20241222114918980.png" alt="image-20241222114918980" /><figcaption aria-hidden="true">image-20241222114918980</figcaption></figure><ul><li><p>尽管以太网 和802. 11都使用载波侦听随机接入，但这两种MAC协议</p><p>有重要的区别:</p><ul><li>首先，802. 11 使用<strong>碰撞避免</strong>而非碰撞检测。</li><li>其次，由于无线信道相对较高的误比特率，802. 11 使用<strong>链路层确认/重传（ARQ）方案</strong>,（不同于以太网)。</li></ul></li><li><p>802.11 MAC协议并未实现碰撞检测。这主要由两个重要的原因所致:</p><ul><li>检测碰撞的能力要求站点具有同时发送（站点自己的信号）和接收（检测其他站 点是否也在发送）的能力。因为在802. 11适配器上，接收信号的强度通常远远小 于发送信号的强度，制造具有检测碰撞能力的硬件代价较大。</li><li>更重要的是，即使适配器可以同时发送和监听信号（并且假设它一旦侦听到信道 忙就放弃发送），适配器也会由于隐藏终端问题和衰减问题而无法检测到所有的碰 撞</li></ul></li></ul><p>在以太网的 CSMA/CD 的多路访问协议下，一旦侦听到信道空闲，站点开始发送。然而，使用 CSMA/CA, 该站点在倒计数时抑制传输，即使它侦听到该信道空闲也是如此。<strong>为什么 CSMA/CD 和 CSMA/CA 采用了不同的方法？</strong></p><ul><li>在 CSMA/CD 中碰撞不是一个严重的问题，因为两个站点检测到碰撞后等都会放弃它们的发送，从而避免了由于碰撞而造成的该帧剩余部分的无用发送。</li><li>在 802.11 中，并<strong>不检测碰撞和放弃发送</strong>，遭受碰撞的帧仍将被完全传输。因此要<strong>尽可能避免碰撞</strong>。如果两个站点侦听到信道忙，它们都将立即进入随机回退，希望选取一个不同的回退值。如果这些值的确不同，一旦信道空闲，其中的一个站点将在另一个之前发送，并且“失败站点”将会听到“胜利站点”的信号，冻结它的计数器，并且在胜利站点完成传输之前一直抑制传输，避免了高代价的碰撞。</li><li>使用 802.11 仍然可能出现碰撞的情况：1️⃣ 两个站点可能相互是隐藏的；2️⃣ 两者可能选择了非常靠近的随机回退值</li></ul><p>802.11 使用<strong>链路层确认/重传</strong>（ARQ）</p><p>目的站点收到一个通过 CRC 校验的帧后，它等待一个被称为<strong>短帧间间隔（SIFS）</strong>的一小段时间，然后发挥一个确认帧。如果发送站点在给定的时间内未收到确认帧，它假定出现了错误并重传该帧，使用 <code>CSMA/CA</code> 协议访问该信道 。如果在若干固定次重传后仍未收到确认，发送站点将放弃发送并丢弃该帧。</p><figure><img src="image-20241222115409912.png" alt="image-20241222115409912" /><figcaption aria-hidden="true">image-20241222115409912</figcaption></figure><ol type="1"><li>如果某站点最初监听到信道空闲，它将在一个被称为<strong>分布式帧间间隔（DIFS）</strong>的段时间段后发送该帧。</li><li>否则，该站点选取一个随机回退值并且在侦听信道<strong>空闲时递减该值</strong>。当侦听到信道忙时，计数值保持不变。</li><li>当计数值减为 0 时（只可能发生在信道被侦听为空闲时），该站点发送整个数据帧并等待确认。</li><li>如果收到确认，发送站点知道它的帧已被目的站正确接收了。如果该站点要发送另一个帧，它将从第二步开始 <code>CSMA/CA</code> 协议。如果未收到确认，发送站点将重新进入第二步中的回退阶段，并从一个更大的范围内选取随机值。</li></ol><p><strong>为什么隐藏终端会导致出现问题?</strong></p><p>假设站点H1正在传输一个帧，并且 在H1传输的中途，站点H2要向AP发送一个帧。由于H2未听到来自H1的传输，它将首先等待一个DIFS间隔，然后发送该帧，导致产生了一个碰撞。从而在H1和H2的整个发送阶段，信道都被浪费了。</p><p>为了避免这一问题，<code>IEEE 802.11协议</code>允许站点使用一个<code>短请求发送(Request to Send, RTS)控制帧</code>和一个<code>短允许发送 (Clear to Send, CTS)控制帧</code>来<code>预约</code>对信道的访问</p><p>当发送方要发送一个data帧 时，它能够首先向AP发送一个RTS帧, 指示传输DATA帧和确认(ACK)帧需要的总时间。当AP收到RTS帧后，它<code>广播</code>一个<code>CTS帧</code>作为响应。该CTS帧有两个目的：给发送方明确的发送许可，也指示其 他站点在预约期内不要发送。</p><ul><li><strong>归属网络</strong>：在一个网络环境中，一个移动节点（智能手机）的永久居所被称为<strong>归属网络</strong>。</li><li><strong>归属代理</strong>：在归属网络中代表移动节点执行移动管理功能的实体叫<strong>归属代理</strong>。</li><li><strong>外部网络</strong>：移动节点当前所在网络叫作<strong>外部网络</strong>或<strong>被访网络</strong>。</li><li><strong>外部代理</strong>：在外部网络中帮助移动节点做移动管理功能的实体称为<strong>外部代理</strong>。<strong>外部代理的作用之一是为移动节点创建一个所谓的转交地址（COA），该 COA 的网络部分与外部网络的网络部分相匹配</strong> ，外部代理的<strong>第二个作用就是告诉归属代理，该移动节点在它的（外部代理的）网络中且具有给定的COA</strong></li><li><strong>通信者(</strong>correspondent)：就是希 望与该移动节点通信的实体</li></ul><h3 id="间接路由选择">间接路由选择</h3><p><a href="https://klklkl10086.github.io/2024/12/09/计算机网络/image-20241222152312902.png"><img src="image-20241222152312902.png" alt="image-20241222152312902" /></a>image-20241222152312902</p><p>通信者只是将数据报寻址到移动节点的固定地址，并将数据报发送到网络 中去，完全不知道移动节点是在归属网络中还是正在访问某个外部网络，因此<strong>移动性对于通信者来说是完全透明的</strong>。这些数据报就像平常一样首先导向移动节点的归属网络。</p><p><a href="https://klklkl10086.github.io/2024/12/09/计算机网络/image-20241222152451449.png"><img src="image-20241222152451449.png" alt="image-20241222152451449" /></a></p><h3 id="直接路由选择">直接路由选择</h3><p><code>三角路由选择问题 (triangle routing problem)</code>该问题是指即使在通信者与移动节点之间存在一条更有效的路由，发往移动节点的数据报也要先发给归属代理，然后再发送到外部网络。</p><ul><li><strong>间接路由选择会引起三角路由选择问题</strong></li><li>直接路由选择克服了三角路由选择的低效问题，但却是以增加复杂性为代价的。</li></ul><p><a href="https://klklkl10086.github.io/2024/12/09/计算机网络/image-20241222152633038.png"><img src="image-20241222152633038.png" alt="image-20241222152633038" /></a></p><ul><li>通信者所在网络中的一个<code>通信者代理</code>先知道该移动节点的COA,这可以通过让通信者代理向归属代理<strong>询问</strong>得知，这里假设与间接路由选择情况类似，移动节点具有一个在<strong>归属代理注册过的最新的 COA</strong>，与移动节点可以执行外部代理的功能相类似，通信者本身也可能执行通信者代理的功能。在图中显示为步骤1和步骤2。</li><li>通信者代理然后将数据报直接通过<code>隧道技术</code>发往移动节点的COA,这与归属代理使用的隧道技术相类似，参见图中步骤3 和步骤4。</li></ul><hr /><p><strong>锚外部代理:</strong>我们将首次发现移动节点的外部网络中的外部代理标识为<code>锚外部代理</code></p><ul><li>当移动节点到达一个新外部网络后,移动节点向新的外部代理注册(步骤3)</li><li><strong>新外部代理向锚外部代理提供移动节点的新COA</strong> （步骤4）。</li><li>当锚外部代理收到一个发往已经离开的移动节点的封装数据报后，它可以使用新的COA重新封装数据报并将其转发给该移动节点（步骤5）。</li><li>如果移动节点其后又移到另一个外部网络中，在该被访网络中的外部代理随后将与锚外部代理联系，以便建立到该新外部网络的转发。</li></ul><p><a href="https://klklkl10086.github.io/2024/12/09/计算机网络/image-20241222152902343.png"><img src="image-20241222152902343.png" alt="image-20241222152902343" /></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ch01&quot;&gt;CH01&lt;/h2&gt;
&lt;h3 id=&quot;两种描述因特网的方式&quot;&gt;两种描述“因特网”的方式：&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;描述构成因特网的&lt;strong&gt;具体构成&lt;/strong&gt;，包括基本硬件和软件组件；&lt;br /&gt;
&lt;/li&gt;</summary>
      
    
    
    
    <category term="class" scheme="https://klklkl10086.github.io/klklkl10086.github.io/categories/class/"/>
    
    
    <category term="计算机网络" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>《计算机网络》复习笔记</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2024/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2024/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2024-12-09T02:07:01.000Z</published>
    <updated>2024-12-25T02:37:49.213Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络概述">计算机网络概述</h1><p><strong>计算机网络</strong>:简称网络，由若干节点(node，计算机、集线器、交换机、路由器)和连接这些节点的链路(link)组成</p><p><strong>互联网</strong>：网络间通过路由器连接起来，组成覆盖范围更大 的计算机网络，也称为“网络的网络 network of networks ”</p><p><strong>因特网</strong>：特指当前全球最大的、开放的、由众多网络相互 连接而成的互联网，采用TCP/IP协议族作为通信规则，前身是美国的APARNET</p><p><strong>两种描述“因特网”的方式</strong>：</p><ol type="1"><li>描述构成因特网的<strong>具体构成</strong>，基本硬件和软件组件；</li><li>描述为基础设施向分布式应用程序提供的<strong>服务</strong>。</li></ol><h2 id="具体构成">具体构成</h2><p>计算设备统称为 <strong>主机(端系统)</strong> 如:传统的桌面PC、 工作站、 服务器 • 非传统的因特网设备如便携机、智 能手机、平板电脑、电视、游戏机、 温度调节装置、家用电器、手表、眼 镜、汽车、运输控制系统.</p><h3 id="通信链路">通信链路</h3><p>有多种不同类型的<strong>物理媒体</strong>： Fiber光纤, copper同轴电缆, radio 无线电频谱, satellite卫星</p><p><strong>衡量链路性能的指标</strong>:</p><ul><li>传输速率 transmission rate: 比特/秒、bit/s、bps</li><li>带宽 bandwidth</li></ul><h3 id="分组交换机">分组交换机</h3><p><strong>分组 packet</strong>： 当一台端系统向另 一台端系统发送数据时，发送端系统将数据分段，每段加上首部 字节。</p><p><strong>路径 path 或 route</strong>：一个分组所经历的一系列<strong>通信链路</strong>和<strong>分组交换机</strong>。</p><p>两种最主要类型的分组交换机</p><ul><li><strong>路由器</strong> routers，用于核心网；</li><li><strong>链路层交换机</strong> switches，用于 接入网</li></ul><h3 id="因特网服务提供商-isp">因特网服务提供商 ISP</h3><ul><li>住宅区ISP、公司ISP、大学ISP、 WiFi ISP、蜂窝数据ISP</li><li>提供不同种类的网络接入，住宅宽带接入DSL、高速局域网接入、 移动无线接入</li></ul><ol type="1"><li>较高层ISP通过高速光纤链路和高速路由器组成；</li><li>较低层ISP通过国家的、国际的较 高层ISP互联到因特网</li><li>无论高层还是低层ISP都独立管理</li></ol><h3 id="协议protocols">协议protocols</h3><p>在网络上控制信息的发送 接收</p><p>e.g. TCP, IP, HTTP, Skype, 802.1</p><h2 id="服务描述">服务描述</h2><p>从为应用程序提供服务的基础设施的角度描述因特网。</p><h3 id="套接字接口-socket-interface">套接字接口 socket interface</h3><p>一 套发送程序必须遵循的规则集合， 规定了运行在一个<strong>端系统上的应用程</strong>序请求因特网基础设施向 行在另一个<strong>端系统上的特定目的程序</strong>交付数据的方式</p><h3 id="网络协议-network-protocols">网络协议 network protocols</h3><p>协议定义了在两个或多个通信实体之间交换的<strong>报文格式和顺序</strong>，以及报文发送和/或 接收及其他事件所采取的<strong>动作</strong></p><ul><li>通信双方交换报文，而不是语句</li><li>通信实体是设备</li></ul><h2 id="网络结构">网络结构</h2><p>网络结构可以分为:</p><ul><li>网络边缘:主机/端系统,应用程序</li><li>接入网络:有线或者无线通信链路</li><li>网络核心:互连着的路由器 , 网络的网络</li></ul><h2 id="接入网络">接入网络</h2><p><strong>接入网 Access networks</strong>：将端系统物理连接到其边缘路由器的网络。</p><p><strong>边缘路由器</strong>:是端系统到任何远程端系统的路径上的第一台路由器</p><p><strong>怎样将端系统和边缘路由器连接？</strong></p><ul><li>住宅接入网络</li><li>单位接入网络 （学校、公 司）</li><li>无线接入网络</li></ul><h3 id="家庭接入网">家庭接入网</h3><p>宽带住宅接入有两种流行方式：数字用户线 DSL和电缆。</p><p><strong>数字用户线 DSL</strong>:双绞线</p><p><strong>电缆</strong>:</p><ul><li>由于外层屏蔽层 的作用，具有很 好的抗干扰性， 适于高速率传输</li><li>利用现有的有线电视基础设施</li></ul><p><strong>光纤入户:</strong></p><p><strong>其他方式:</strong></p><ul><li>卫星接入光纤到户:超过1Mbps的速率接入。</li><li>传统电话线的拨号接入： 与DSL类似，56Kbps的速率</li></ul><h3 id="企业接入网">企业接入网</h3><p>使用局域网LAN将多个端接系统连接到边缘路由器，用户设备 位于几十米范围内</p><p>多使用基于IEEE802.11技术的无线LAN接入，也称Wifi</p><p>企业网接入方式广泛应用于家庭，设备价格低廉</p><h3 id="广域无线接入网">广域无线接入网</h3><p>Iphone、安卓等智能手机使用蜂窝网络的无线基础设施（基 站）来接入因特网，发送和接收分组。</p><h3 id="物理媒介">物理媒介</h3><p><strong>physical medium 物理媒体</strong>：通过传播电信号或光脉冲来发送bit</p><p><strong>guided media 引导型媒体</strong>: signals propagate in solid media: copper, fiber, coax</p><p><strong>unguided media 非引导型媒体</strong>: signals propagate freely, e.g. radio</p><p><strong>物理链路的实际成本与组网的其它成本相比是比较小的,特别是安装物理链路的劳动力成本</strong></p><p><strong>双绞线:</strong></p><ul><li>两根绝缘的铜线以规则的螺旋状绞合起来，为减少临近类似 的双绞线的电气干扰</li><li>大多数情况下，使用无屏蔽双绞线 UTP，广泛用于计算机网 络局域网组网中，灵活易布线，性价比高</li></ul><p><strong>同轴电缆</strong></p><ul><li>由于外层屏蔽层的作用，具有很好的抗干扰性，适于高速 率传输</li></ul><p><strong>光纤</strong></p><p><strong>光脉冲</strong></p><ul><li>高传输速率</li><li>长距离传输，100km，光缆信号衰减极低，很难窃听</li><li>低误码率,不受电磁干扰</li><li>这些特性使其适用于长途引导型媒体，特别是跨海链路。</li></ul><p><strong>无线电信道</strong></p><p>优点：穿墙、长距离、移动 连接 缺点：性能依赖于传播环境 和传播距离</p><h2 id="网络核心">网络核心</h2><p>因特网核心是由分组交换机和链路构成的网状网络。</p><p>端系统彼此间想要交换的是报 文(message)，包含控制信息和 数据，但其长度往往超出因特 网转发的长度限制。</p><p><strong>数据怎样通过网络进行传输？</strong></p><ul><li><strong>电路交换</strong>：为每个呼叫预留一条 <strong>专有电路</strong>：如电话网</li><li><strong>分组交换</strong>：将要传送的数据分成一个个单位(分组)<ul><li>将分组从一个路由器传到相邻路由器（hop），一段段最终从源端传到目标端</li><li>每段：采用链路的最大传输能力（ 带宽 )</li></ul></li></ul><h3 id="分组交换">分组交换</h3><ul><li>以分组为单位<strong>存储-转发</strong>方式</li><li>存储转发传输(store-and-forward transmission): 是指在分组交换机能够开始向输出链路传输该分组的第一个比特之前，必须 接收到整个分组</li><li>$ = $,L是分组长度,R是传输速率</li></ul><blockquote><ol type="1"><li><strong>通过由N条速率均为R的链路组成的路径（源和目的端之间有N-1台路由器），从源到目的地发送一个分组， 端到端的时延是</strong>$N  $</li><li><strong>P个分组经过N条链路序列的端到端时延</strong>: <span class="math inline">\((N+P-1) \cdot \frac{L}{R}\)</span></li></ol></blockquote><p><strong>排队时延</strong></p><p>每台分组交换机有多条链路与之相连，对于每条链路分组交 换机设置一个<strong>输出缓存</strong>output buffer，也称为输出队列</p><p>排队时延取决于队列长度，即网络的拥塞程度.</p><p>缓存空间大小有限，当分组到达时缓存已满，将出现分组丢 失(即丢包)packet loss的现象:或丢弃新到达的分组, 或丢弃队列中已排队的分组(通常是优先级低)</p><h3 id="电路交换">电路交换</h3><p>在端系统间通信过程中，创 建电路时就预留了端系统间沿路径通信所需要的全部资 源(缓存、链路传输速率)，并会话期间<strong>独占</strong>这些资源</p><p>分组交换网中资源不是预留的，会话期间需要的资源可 能需要等待</p><p>电路交换分配专用链路的两种方式: <strong>频分复用</strong>和<strong>时分复用</strong></p><p><strong>频分复用</strong>(FDM):链路的<strong>频谱</strong>由跨该链路的所有连接共享，为每条经过的电路分配一个划分的子频段</p><p>​ 频段的宽度称为带宽 bandwidth</p><p>​ <img src="image-20241210213849851.png" alt="image-20241210213849851" /></p><p><strong>时分复用</strong>（TDM）: 通信时间被划分为固定期间的帧，每个帧又被划分为固定数量的时隙，网络中 建立电路时在各段链路上的每个通信周期(时域)指定一个专用时隙，该时隙用于传输该电路连接的数据。</p><figure><img src="image-20241210213941677.png" alt="image-20241210213941677" /><figcaption aria-hidden="true">image-20241210213941677</figcaption></figure><p><strong>TDM中电路的传输速率等于帧速率乘以一个时隙的比特数.</strong></p><ul><li>例如，链路每秒传8000帧，每个时隙有8比特，则<strong>每条电路</strong>的传输速率为64Kbps</li></ul><p><strong>电路交换缺点</strong>:</p><ul><li>电路交换因为在静默期（slient period）专用电路空闲导致浪费。</li><li>创建端到端的电路和预留资源是复杂的，需要复杂的信令和协 调沿路径的交换机操作。 （RSVP资源预留协议</li></ul><figure><img src="image-20241210214210049.png" alt="image-20241210214210049" /><figcaption aria-hidden="true">image-20241210214210049</figcaption></figure><h3 id="分组交换-vs.-电路交">分组交换 vs. 电路交</h3><ul><li><p>分组交换网不适合实时服务(如电话和视频会议)，因为排队时 延导致端到端时延可变、不可预测。</p></li><li><p>分组交换网提供了比电路交换好的带宽共享,比电路交换更简单、 更有效、实现成本低</p></li><li><p>分组交换网适合于对突发式数据传输 :资源共享 , 简单，不必建立呼叫 但是过度使用会造成网络拥塞：分组延时和丢失,对可靠地数据传输需要协议来约束：拥塞控制</p></li></ul><h2 id="互联网络结构">互联网络结构</h2><p>松散的层次模型</p><p>中心：第一层ISP,国家/国际覆盖，速率极高 直接与其他第一层ISP相连 与大量的第二层ISP和其他客户网络相连</p><p>第二层ISP: 更小些的 (通常是区域性的) ISP 与一个或多个第一层ISPs，也可能与其他第二层ISP</p><p>第三层ISP与其他本地ISP 接入网 (与端系统最近)</p><h3 id="isp之间的连接">ISP之间的连接</h3><ul><li><strong>存在点PoP（Point of Presence）</strong>：存在于除底层（接入ISP）外的所有层次，是提供商网络中的一个或若干个路由器群组，客户网络通过提供商的租用高速链路将它的路由器之一连接到PoP的路由器之一。</li><li><strong>多宿（multi-home）</strong>：除第一层ISP外，任何ISP可以与两个或多 个提供商ISP连接。 当一个ISP多宿时，若提供商ISP之一故障时，仍能传输分组。</li><li>客户ISP根据与提供商ISP交换的通信流量来付费。</li><li><strong>对等</strong>：位于相同等级结构层次的临近一对ISP可以直接连接在 一起，它们之间的所有直接相互流量，不通过上游ISP转输， 彼此间互不付费。</li><li><strong>因特网交换点（Internet Exchange Point，IXP）</strong>:是一个汇合点， 多个ISP能够在这里一起对等，通常位于独立建筑物内。</li></ul><figure><img src="image-20241214214154806.png" alt="image-20241214214154806" /><figcaption aria-hidden="true">image-20241214214154806</figcaption></figure><h2 id="分组延时丢失和吞吐量">分组延时、丢失和吞吐量</h2><p><strong>产生时延和分组丢失的原因:</strong></p><ul><li>分组到达链路的速率超过了链路输出的能力</li><li>分组等待排到队头被传输</li></ul><p><strong>最大吞吐量</strong>:一台路由器能够转发分组的<strong>最大</strong>速率。</p><h3 id="时延构成">时延构成</h3><p><strong>时延类型</strong></p><figure><img src="image-20241214214649422.png" alt="时延类型" /><figcaption aria-hidden="true">时延类型</figcaption></figure><ul><li><strong>节点处理时延：</strong><ul><li>检查 bit级差错</li><li>检查分组首部和决定将分组导向何处</li></ul></li><li><strong>传输时延</strong> ：将分组所有比特发射到链路上所需的时间<ul><li><span class="math inline">\(R\)</span>是链路带宽(bps) <span class="math inline">\(L\)</span>是分组长度(bits) ，将分组发送到链路上的时间为 <span class="math inline">\(L/R\)</span></li><li>存储转发延时</li></ul></li><li><strong>传播时延：</strong> 每个比特从链路起点到下一 路由器传播所需要的时间<ul><li><span class="math inline">\(d\)</span> = 物理链路的长度, $ s$ = 在媒体上的传播速度 (<span class="math inline">\(~2 \cdot 10^8 m/sec\)</span>) 传播延时 = <span class="math inline">\(d/s\)</span></li><li>链路的传播速率取决于链路的物理媒体 （ 光纤、双绞线） ，略小于光速。</li></ul></li><li><strong>排队时延</strong>：在输出链路上等待传输的时间<ul><li>依赖于路由器的拥塞程度</li></ul></li></ul><p><strong>节点时延</strong> <span class="math display">\[d_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}\]</span></p><ul><li><span class="math inline">\(d_{proc}\)</span> = 处理延时<ul><li>通常是微秒数量级或更少</li></ul></li><li><span class="math inline">\(d_{queue}\)</span> = 排队延时<ul><li>取决于拥塞程度</li></ul></li><li>$ d_{trans}$ = 传输延时<ul><li>= <span class="math inline">\(L/R\)</span>, 对低速率的链路而言很大（如拨号），通常为微秒级 到毫秒级</li></ul></li><li>$ d_{prop} $= 传播延时<ul><li>几微秒到几百毫秒</li></ul></li></ul><h3 id="排队时延和丢包">排队时延和丢包</h3><ul><li>节点时延的构成成分中，最复杂的是排队时延</li><li>与其它3种时延不同的是，排队时延对每个分组可能是不 同的，即每个分组需要的排队时间不同</li><li>表征排队时延时，通常使用<strong>统计量</strong>，如:<ul><li>平均排队时延、排队时延的方差、排队时延超过某特定值的概率</li></ul></li><li>排队时延的大小取决于：</li><li>流量到达队列的速度、链路的传输速率、到达流量的性质（周期性的、突发的）</li></ul><figure><img src="image-20241214220005807.png" alt="流量强度" /><figcaption aria-hidden="true">流量强度</figcaption></figure><p><strong>丢包</strong></p><ul><li>通常路由器内的队列容量是有限的，不能容纳所有到达的分组排队。</li><li>队列容量取决于路由器的设计和成本。</li><li>因此：</li><li>随着流量强度接近于1，排队时延并不是真的趋于无穷大,只是量级发生了变化；</li><li>队列满了的时候，路由器将丢弃（drop）到达的分组或优先级低的分组，此时将产生丢包（lost）。</li><li><strong>分组的丢失比例随着流量强度增加而增加。</strong></li><li>丢失的分组可能由前一个节点重传，或基于端到端的重传 原则重传</li></ul><h3 id="端到端时延">端到端时延</h3><figure><img src="image-20241214220359892.png" alt="image-20241214220359892" /><figcaption aria-hidden="true">image-20241214220359892</figcaption></figure><h3 id="吞吐量">吞吐量</h3><blockquote><p>端到端单位时间内传输的数据量</p></blockquote><p>吞吐量是衡量计算机网络性能的另一个重要指标。</p><p><strong>瓶颈链路</strong>:端到端路径上，限制端到端吞吐的链路</p><figure><img src="image-20241214220531031.png" alt="image-20241214220531031" /><figcaption aria-hidden="true">image-20241214220531031</figcaption></figure><figure><img src="image-20241214220617499.png" alt="image-20241214220617499" /><figcaption aria-hidden="true">image-20241214220617499</figcaption></figure><h2 id="协议层次">协议层次</h2><ul><li>服务( Service)：低层实体向上层实体提供它们之间的通信的能力<ul><li>服务用户(service user)</li><li>服务提供者(service provider )</li></ul></li><li>原语(primitive)：上层使用下层服务的形式，高层使用低层提供的服务，以及低层向高层提供服务都是通过服务访问原语来进行交互的---<strong>形式</strong></li><li>服务访问点 SAP (Services Access Point) ：上层使用下层提供的服务通过层间的接口—<strong>地点</strong><ul><li>例子:邮箱</li><li>地址(address)：下层的一个实体支撑着上层的多个实体， SAP有标志不同上层实体的作用</li><li>可以有不同的实现，队列</li><li>例子:传输层的SAP: 端口(port)</li></ul></li></ul><p><strong>服务与协议的区别</strong> :</p><ul><li>服务(Service)：低层实体向上层实体提供它们之间的通信的能力，是通过原语(primitive)来操作的，垂直</li><li>协议(protocol) ：<strong>对等层实体</strong>(peer entity)之间在相互通信的过程中，需要遵循的规则的集合，水平</li></ul><p><strong>服务与协议的联系 :</strong></p><ul><li>本层协议的实现要靠下层提供的服务来实现</li><li>本层实体通过协议为上层提供更高级的服务</li></ul><h3 id="分层的体系结构">分层的体系结构</h3><ul><li>网络设计者以<strong>分层</strong>的方式<strong>组织协议</strong>，以及<strong>实现协议</strong>的网络硬件和软件:</li><li>每一层向它的上一层提供服务（service）。</li><li>每层通过执行该层的某些动作或直接使用下层服务来提供服务。</li><li>一个协议层能够使用软件、硬件或两者的结合来实现。<ul><li>应用层协议几乎用软件实现；</li><li>物理层、数据链路层协议通常在网络接口卡(硬件)实现;</li><li>网络层协议通常由软、硬件混合实现.</li></ul></li><li>第n层协议分布在网络的端系统、分组交换机和其它组件</li></ul><p><strong>分层的原因:</strong></p><ul><li>结构化分层易于定义和实现</li><li>模块化,易于维护和升级</li></ul><p><strong>分层的潜在缺点</strong>：</p><ul><li>功能可能在多层冗余，如差错检验；</li><li>某层功能可能调用其它层提供的信息，分层不彻底.</li></ul><h3 id="internet-协议栈">Internet 协议栈</h3><p>协议栈：各层所有协议的集合</p><figure><img src="image-20241214221427100.png" alt="image-20241214221427100" /><figcaption aria-hidden="true">image-20241214221427100</figcaption></figure><figure><img src="image-20241214221445098.png" alt="image-20241214221445098" /><figcaption aria-hidden="true">image-20241214221445098</figcaption></figure><table><thead><tr class="header"><th></th><th>协议</th><th>任务</th><th>信息单位</th></tr></thead><tbody><tr class="odd"><td>应用层</td><td>HTTP SMTP FTP DNS</td><td><strong>端系统</strong>之间</td><td>报文</td></tr><tr class="even"><td>传输层</td><td>TCP UDP</td><td><strong>应用程序端点</strong>之间传送应用层报文</td><td>报文段</td></tr><tr class="odd"><td>网络层</td><td>IP 路由选择协议</td><td><strong>主机</strong>之间</td><td>数据报</td></tr><tr class="even"><td>链路层</td><td>链路层协议 DOCSIS PPP</td><td>整个<strong>帧</strong>从一个<strong>节点</strong>到下一个节点</td><td>帧</td></tr><tr class="odd"><td>物理层</td><td>与实际传输媒体相关</td><td>一个个<strong>比特</strong>从一个<strong>节点</strong>到下一个节点</td><td>比特</td></tr></tbody></table><h3 id="isoosi">ISO/OSI</h3><figure><img src="image-20241214221526455.png" alt="image-20241214221526455" /><figcaption aria-hidden="true">image-20241214221526455</figcaption></figure><p>TCP/IP协议栈中,将表示层放入了应用层,session放进了传输层</p><h1 id="应用层">应用层</h1><p>网络核心中没有应用层软件,<strong>网络核心没有应用层功能</strong>,<strong>网络应用只在端系统上存在</strong></p><h2 id="应用层协议原理">应用层协议原理</h2><h3 id="网络应用体系结构">网络应用体系结构</h3><ol type="1"><li>从应用程序开发者的角度看，网络体系结构是固定的 ，并为应用程序提供了特定的服务集合。</li><li>应用程序体系结构由应用程序研发者设计，规定了如何在端系统上组织该应用程序</li></ol><p>当前主流的两种:</p><ul><li><strong>客户-服务器</strong>体系结构</li><li><strong>对等(P2P)</strong>体系结构</li></ul><p><strong>客户-服务器体系结构</strong></p><p><strong>服务器</strong>: 服务于来自许多其他称为客户的主机的请求。</p><ul><li>一直运行</li><li>固定的IP地址和周知的端口号（约定）</li><li>扩展性：服务器场<ul><li>数据中心进行扩展</li><li>扩展性差</li></ul></li></ul><p><strong>客户端:</strong></p><ul><li>主动与服务器通信</li><li>与互联网有间歇性的连接</li><li>可能是动态IP 地址</li><li>不直接与其它客户端通信</li></ul><p>例如:Web FTP 电子邮件</p><p><strong>P2P结构</strong></p><ul><li>（几乎）没有一直运行的服务 器</li><li>任意端系统之间可以进行通信</li><li>每一个节点既是客户端又是服 务器</li><li>自扩展性-新peer节点带来新的服务能力，当然也带来新的服务请求</li><li>参与的主机间歇性连接且可以改变IP地址</li><li>难以管理</li><li>面临安全性、性能、可靠性挑 战</li></ul><p>例子: Gnutella，迅雷</p><p>适用于流量密集型应用,如文件共享,下载,视频会议</p><h3 id="进程通信">进程通信</h3><p>在构建网络应用程序前，还需要对运行在多个<strong>端系统上的程序</strong>是如何互相通信的情况有一个基本了解。</p><p>进行通信的实际上是<strong>进程(process)</strong>而不是程序。</p><ul><li>在同一个主机内，使用 <strong>进程间通信机制</strong> 通信（ 操作系统定义）</li><li>在两个不同端系统上的进程，通过跨越计算机网络交换报文（message）而相互通信。</li></ul><p><strong>[客户和服务器进程]</strong></p><p>对每对通信进程, 我们通常将这两个进程之一标识为<strong>客户</strong>（client）,而另一个进程标识为<strong>服务器</strong>（serve)。</p><p>在一对进程之间的通信会话场景中，发起通信（即在该会话开始时发起与其他进程的联系）的进程被标识为客户，在会话开始时等待联系的进程是服务器。</p><p>对于Web而言，浏览器是一个客户进程，Web服务器是一台服务器进程。对于P2P文件 共享，下载文件的对等方标识为客户，上载文件的对等方标识为服务器。</p><p>一个进程可能既是客户又是服务器</p><figure><img src="image-20241215195325691.png" alt="image-20241215195325691" /><figcaption aria-hidden="true">image-20241215195325691</figcaption></figure><p><strong>[套接字]</strong></p><p>进程通过一个称为套接字（socket）的软件接口向网络发送报文和从网络接收报文。</p><figure><img src="image-20241215195117150.png" alt="image-20241215195117150" /><figcaption aria-hidden="true">image-20241215195117150</figcaption></figure><p>套接字，是同一台主机内应用层与传输层之间的接口 ，也称为应用程序和网络之间的应用程序编程接口API。</p><p>应用程序开发者可以控制套接字在<strong>应用层端</strong>的一切， 对于套接字在<strong>传输层端</strong>的控制<strong>仅限于</strong>：</p><ol type="1"><li>选择传输层协议；</li><li>设定几个传输层参数，如最大缓存和最大报文⻓度等</li></ol><h3 id="进程寻址">进程寻址</h3><p>在一台主机上运行的进程为了向在另一台主机上运行的进程发送分组，接收进程需要有一个地址。为了标识该接收进程，需要定义两种信息：</p><ul><li>主机的地址,主机由其<strong>IP地址(IP address)</strong>标识</li><li>在目的主机中指定接收进程的标识符:<strong>端口号</strong></li></ul><p>一个进程：用IP+port标示</p><p>本质上，一对主机进程之间的通信由2个端节点构成</p><h3 id="可供应用程序使用的运输服务">可供应用程序使用的运输服务</h3><p>当开发一个应用时，必须选择一种可用的<strong>运输层协议</strong></p><p>通过研究这些可用的 运输层协议所提供的服务，选择一个最能为你的应用需求提供恰当服务的协议。</p><p>大体能够从四个方面对应用程序服务要求进行分类：<strong>可靠数据传输(正确,不丢失)、吞吐量、定时和安全性</strong>。</p><figure><img src="image-20241215195908318.png" alt="image-20241215195908318" /><figcaption aria-hidden="true">image-20241215195908318</figcaption></figure><h3 id="因特网提供的运输服务">因特网提供的运输服务</h3><p>因特网为应用程序提供 两个运输层协议，即<strong>UDP和TCP</strong>。当你（作为一个软件开发者）为因特网创建一个新的应用时，首先要做出的决定是，<strong>选择UDP还是选择TCP</strong></p><p><strong>TCP服务:</strong></p><ul><li>面向连接服务</li><li>可靠数据传输服务:无差错 按序 无丢失 无冗余</li><li>拥塞控制机制</li><li>流量控制</li><li>但是不提供加密</li></ul><p><strong>UDP服务</strong>:UDP是一种不提供不必要服务的轻量级运输协议，它仅提供<strong>最小服务</strong></p><ul><li>不可靠数据传输</li><li>无连接服务</li><li>不提供可靠性 流量控制拥塞控制 定时 吞吐量保证 安全性</li></ul><figure><img src="image-20241215201516696.png" alt="image-20241215201516696" /><figcaption aria-hidden="true">image-20241215201516696</figcaption></figure><figure><img src="image-20241215201544812.png" alt="image-20241215201544812" /><figcaption aria-hidden="true">image-20241215201544812</figcaption></figure><figure><img src="image-20241215201342712.png" alt="image-20241215201342712" /><figcaption aria-hidden="true">image-20241215201342712</figcaption></figure><ul><li>因特网能够为时延敏感的应用提供满意的服务，但是并不提供任何定时或带宽的保证</li><li>因特网电话等容丢失应用喜欢UDP，但是防火墙经常配置成阻挡UDP流量，所以用TCP做备份</li></ul><h3 id="应用层协议">应用层协议</h3><p>应用层协议（application-layer protocol）定义了运行在不同端系统上的应用程序进程<strong>如何相互传递报文</strong>。特别是应用层协议定义了 ：</p><ul><li>交换的报文类型，例如请求报文和响应报文。</li><li>各种报文类型的语法，如报文中的各个字段及这些字段是如何描述的。</li><li>字段的语义，即这些字段中的信息的含义。</li><li>确定一个进程何时以及如何发送报文，对报文进行响应的规则</li></ul><p>可以分为:</p><ul><li>公域协议</li><li>专用协议</li></ul><h2 id="web和http">Web和HTTP</h2><p><strong>Web的基本介绍</strong></p><p>Web使用了客户 -服务器应用程序体系结构</p><figure><img src="image-20241215204314556.png" alt="image-20241215204314556" /><figcaption aria-hidden="true">image-20241215204314556</figcaption></figure><h3 id="http">HTTP</h3><blockquote><p>Web的应用层协议是超文本传输协议（HyperText Transfer Protocol, HTTP）,它是Web 的核心</p></blockquote><p>HTTP由两个程序实现：一个客户程序和一个服务器程序。客户程序和服务器程序运行在不同的端系统中，通过交换 HTTP报文进行会话。</p><p>Web 浏览器（Web browser）实现 了 HTTP 的客 户端,Web服 务器（Web server）实现了 HTTP的服务器端，它用于存储Web对象，每个对象由URL寻 址。</p><ul><li>HTTP使用TCP:<ul><li>客户发起一个与服务器的 TCP连接 (建立套接字) ， 端口号为 80</li><li>服务器接受客户的TCP连接</li><li>在浏览器(HTTP客户端) 与 Web服务器(HTTP服 务器 server)交换HTTP报文 (应用层协议报文)</li><li>TCP连接关闭</li></ul></li><li>HTTP是无状态的,服务器并不维护关于客户的任何信息</li></ul><h3 id="http连接类型">HTTP连接类型</h3><p><strong>[往返时间]</strong></p><blockquote><p>该时间是指一个短分组从客户到服务器然后再返回客户所花费的时间。RTT包括<strong>分组传播时延</strong>、分组在中间路由器和交换机上的<strong>排队时延</strong>以及<strong>分组处理时延</strong></p></blockquote><ul><li><p>非持续连接</p><ul><li>最多只有一个对象在 TCP连接上发送</li><li>下载多个对象需要多个TCP连接</li><li>HTTP/1.0使用非持 久连接</li></ul><figure><img src="image-20241215205827065.png" alt="image-20241215205827065" /><figcaption aria-hidden="true">image-20241215205827065</figcaption></figure><figure><img src="image-20241215205845301.png" alt="image-20241215205845301" /><figcaption aria-hidden="true">image-20241215205845301</figcaption></figure><figure><img src="image-20241215205948191.png" alt="image-20241215205948191" /><figcaption aria-hidden="true">image-20241215205948191</figcaption></figure></li><li><p>持续连接</p><ul><li>多个对象可以在一个 （在客户端和服务器之间的）TCP连接上传输</li><li>HTTP/1.1 默认使用 持续连接</li></ul></li></ul><p>HTTP在<strong>默认方式下使用持续连接</strong>，如果需要也可以配置为非持续连接。</p><figure><img src="image-20241215210141066.png" alt="image-20241215210141066" /><figcaption aria-hidden="true">image-20241215210141066</figcaption></figure><h3 id="http报文格式">HTTP报文格式</h3><ul><li>请求报文</li><li>响应报文</li></ul><p><strong>[HTTP请求报文]</strong></p><p><strong>ASCII文本书写 人类可读的格式</strong></p><figure><img src="image-20241215210414715.png" alt="HTTP请求报文格式" /><figcaption aria-hidden="true">HTTP请求报文格式</figcaption></figure><p>例如:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> /index.html HTTP/<span class="number">1.1</span>\r\n </span><br><span class="line">Host: www-net.cs.umass.edu\r\n              </span><br><span class="line">User-Agent: Firefox/<span class="number">3.6</span>.<span class="number">10</span>\r\n </span><br><span class="line">Accept: text/html,application/xhtml+xml\r\n </span><br><span class="line">Accept-Language: en-us,en;q=<span class="number">0.5</span>\r\n </span><br><span class="line">Accept-Encoding: gzip,deflate\r\n </span><br><span class="line">Accept-Charset: ISO-<span class="number">8859</span>-<span class="number">1</span>,utf-<span class="number">8</span>;q=<span class="number">0.7</span>\r\n </span><br><span class="line">Keep-Alive: <span class="number">115</span>\r\n </span><br><span class="line">Connection: keep-alive\r\n </span><br><span class="line">\r\n </span><br></pre></td></tr></table></figure><p><strong>提交表单输入的方式</strong>:</p><p>POST:包含在实体主体 (entity body )中的 输入被提交到服务器</p><p>URL:使用GET方法,输入通过请求行的 URL字段上载</p><p><strong>Method 类型:</strong></p><p><strong>HTTP/1.0:</strong></p><ul><li>GET:表单数据添加在URL末尾</li><li>POST:表单数据放在实体字段中</li><li>HEAD:只发送响应报文，而不返回请求对象，用 于应用程序的调试追踪。</li></ul><p><strong>HTTP/1.1:</strong></p><ul><li>GET</li><li>POST</li><li>HEAD</li><li>PUT:将实体主体中的文件上载到URL字段规定的路径</li><li>DELETE:删除URL字段规定的文件</li></ul><p><strong>[HTTP响应报文]</strong></p><figure><img src="image-20241215211202441.png" alt="HTTP响应报文" /><figcaption aria-hidden="true">HTTP响应报文</figcaption></figure><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK\r\n </span><br><span class="line">Date: Sun, <span class="number">26</span> Sep <span class="number">2010</span> <span class="number">20</span>:<span class="number">09</span>:<span class="number">20</span> GMT\r\n </span><br><span class="line">Server: Apache/<span class="number">2.0</span>.<span class="number">52</span> (CentOS)\r\n </span><br><span class="line">Last-Modified: Tue, <span class="number">30</span> Oct <span class="number">2007</span> <span class="number">17</span>:<span class="number">00</span>:<span class="number">02</span></span><br><span class="line"> GMT\r\n </span><br><span class="line">ETag: <span class="string">&quot;17dc6-a5c-bf716880&quot;</span>\r\n </span><br><span class="line">Accept-Ranges: bytes\r\n </span><br><span class="line">Content-Length: <span class="number">2652</span>\r\n </span><br><span class="line">Keep-Alive: timeout=<span class="number">10</span>, max=<span class="number">100</span>\r\n </span><br><span class="line">Connection: Keep-Alive\r\n </span><br><span class="line">Content-Type: text/html;</span><br><span class="line"> charset=ISO-<span class="number">8859</span>-<span class="number">1</span>\r\n </span><br><span class="line">\r\n </span><br><span class="line"><span class="keyword">data</span> <span class="keyword">data</span> <span class="keyword">data</span> <span class="keyword">data</span> <span class="keyword">data</span> ... </span><br></pre></td></tr></table></figure><figure><img src="image-20241215211135240.png" alt="响应状态码" /><figcaption aria-hidden="true">响应状态码</figcaption></figure><h3 id="用户-服务器状态cookies">用户-服务器状态：cookies</h3><p>HTTP是无状态的，但是很多应用中服务器希望识别用户身份进一步提供服务。</p><p><strong>[组成]</strong></p><ul><li>在HTTP<strong>响应报文</strong>中有 一个cookie的首部行</li><li>在HTTP<strong>请求报文</strong>含有 一个cookie的首部行</li><li>在<strong>用户</strong>端系统中保留有 一个cookie文件，由用户的浏览器管理</li><li>在<strong>Web站点</strong>有一个<strong>后端数据库</strong></li></ul><figure><img src="image-20241215211755501.png" alt="image-20241215211755501" /><figcaption aria-hidden="true">image-20241215211755501</figcaption></figure><figure><img src="image-20241215211836861.png" alt="image-20241215211836861" /><figcaption aria-hidden="true">image-20241215211836861</figcaption></figure><h3 id="web缓存代理服务器">Web缓存(代理服务器)</h3><p>Web缓存的存储空间中保存最近请求过的对象的副本,不访问原始服务器，就满足客户的请求</p><figure><img src="image-20241215212031137.png" alt="image-20241215212031137" /><figcaption aria-hidden="true">image-20241215212031137</figcaption></figure><p>为什么要使用Web缓存 ？</p><ul><li>降低客户端的请求响应时间</li><li>可以大大减少一个机构内部网络与Internent接入链路上的流量</li><li>互联网大量采用了缓存： 可以使较弱的ICP也能够 有效提供内容</li></ul><h3 id="条件get方法">条件GET方法</h3><p>如果缓存器中的对象拷贝是最新的，就不要发送对象(由缓存器通过发送一个条件GET执行最新检查)</p><figure><img src="image-20241215212543651.png" alt="image-20241215212543651" /><figcaption aria-hidden="true">image-20241215212543651</figcaption></figure><h2 id="电子邮件">电子邮件</h2><p>主要组成部分：用户代理（user agent）、邮件服务器（mail server）和简单邮件传输协议（Simple Mail Transfer Protocol, SMTP）</p><figure><img src="image-20241215214930367.png" alt="image-20241215214930367" /><figcaption aria-hidden="true">image-20241215214930367</figcaption></figure><p><strong>邮件服务器:邮件服务器形成了电子邮件体系结构的核心</strong></p><ul><li><strong>邮箱</strong>中管理和维护发送给用户的邮件</li><li><strong>输出报文队列</strong>保持待发送邮件报文</li></ul><p><strong>邮件服务器之间的SMTP协议</strong> ：发送email报文</p><ul><li>客户：发送方邮件服务器</li><li>服务器：接收端邮件服务器</li></ul><p>SMTP是因特网电子邮件中<strong>主要</strong>的应用层协议。它使用TCP可靠数据传输服务</p><h3 id="smtp简单邮件传输协议">SMTP简单邮件传输协议</h3><ul><li>使用<strong>TCP</strong>在客户端和服务器之间传送报文，端口号为25</li><li><strong>直接传输</strong>：从发送方服务器到接收方服务器(无论多远都是直接传输,SMTP 一般不使用中间邮件服务器发送邮件，即使这两个 邮件服务器位于地球的两端也是这样。邮件并不在中间的某个邮件服务器存留。)</li><li>传输的3个阶段<ul><li>握手</li><li>传输报文</li><li>关闭</li></ul></li><li>命令/响应交互<ul><li>命令：ASCII文本</li><li>响应：状态码和状态信息</li></ul></li><li><strong>报文必须为7位ASCII码</strong></li><li>SMTP使用<strong>持久连接</strong></li></ul><figure><img src="image-20241215215436959.png" alt="image-20241215215436959" /><figcaption aria-hidden="true">image-20241215215436959</figcaption></figure><p><strong>vs. HTTP</strong></p><ul><li>HTTP：拉（pull）</li><li>SMTP：推（push）</li><li>二者都是ASCII形式的命令/ 响应交互、状态码</li><li>HTTP：每个对象封装在各自的响应报文中</li><li>SMTP：多个对象包含在一个报文中</li></ul><p><strong>邮件报文格式</strong></p><figure><img src="image-20241215215624390.png" alt="image-20241215215624390" /><figcaption aria-hidden="true">image-20241215215624390</figcaption></figure><h3 id="邮件访问协议">邮件访问协议</h3><blockquote><p><strong>从服务器访问邮件</strong></p></blockquote><blockquote><p>典型的用户通常在本地PC上运行一个用户代理程序，而它访问存储在总是保持开机的共享邮件服务器上的邮箱。该邮件服务器与其他用户共享，并且通常由用户的ISP进行维护 （如大学或公司）。</p></blockquote><figure><img src="image-20241215215917387.png" alt="image-20241215215917387" /><figcaption aria-hidden="true">image-20241215215917387</figcaption></figure><ul><li>POP:邮局访问协议<ul><li>用户身份确认 (代理&lt;--&gt;服务器) 并下载</li></ul></li><li>IMAP :Internet邮件访问协议<ul><li>更多特性 (更复杂)</li><li>在服务器上处理存储的报文</li></ul></li><li>HTTP:<ul><li>方便</li></ul></li></ul><p><strong>[POP协议]</strong></p><p>POP3按照三个阶段进行工作：特许（authorization）、事务处理以及更新</p><figure><img src="image-20241215220250939.png" alt="image-20241215220250939" /><figcaption aria-hidden="true">image-20241215220250939</figcaption></figure><p><strong>上述过程中的dele是标记删除,只有执行quit退出后才会真正删除</strong></p><figure><img src="image-20241215220447769.png" alt="image-20241215220447769" /><figcaption aria-hidden="true">image-20241215220447769</figcaption></figure><h2 id="dns域名系统">DNS:域名系统</h2><p>识别主机有两种方式，通过<strong>主机名</strong>或者<strong>IP地址</strong>,我们需要一种能进行<strong>主机名到IP地址转换</strong>的目录服务,即域名系统</p><blockquote><p>DNS是：</p><ol type="1"><li>一个由分层的DNS服务器（DNS server）实现的<strong>分布式数据库</strong>；</li><li>一个使得主机能够查询分布式数据库的<strong>应用层协议</strong>。</li></ol></blockquote><p>DNS协议运行在UDP之上,使用53号端口</p><h3 id="dns服务">DNS服务</h3><ul><li>主机名到IP地址的转换</li><li>主机别名（host aliasing）:调用DNS获得alias names（更好记）对应的规范主机名或IP</li><li>邮件服务器别名（mail server aliasing） :电子邮件应用程序调用DNS获得邮件服务器别名对应的规范主机名或IP地址</li><li>负载均衡（load distribution）:当用户发出对某繁忙站点域名的DNS请求时，DNS服务器用整个IP集合响应并每次都循环这个集合，用户向集合里IP地址排在前面的服务器发送请求。</li></ul><h3 id="dns工作机理">DNS工作机理</h3><p><strong>转换过程:</strong></p><ol type="1"><li>用户主机上的应用程序需要将一个主机名转换为IP地址；</li><li>用户主机调用DNS客户端，并指明需要转换的主机名；</li><li>用户主机DNS客户端向网络发送一个DNS查询报文；</li><li>经过若干秒到若干毫秒的时延，用户主机DNS客户端收到一 个回答报文，回答报文中保护映射结果；</li><li>DNS客户端将映射结果传递到调用DNS的应用程序。</li></ol><p><strong>为什么DNS不设计为一个服务器这样的集中式设计,而采用分布式的设计?</strong></p><ul><li>单点故障，集中服务器坏因特网瘫痪</li><li>通信容量，单个DNS服务器不能处理所有DNS查询</li><li>远距离通信，存在严重的时延，拥塞、 低速</li><li>维护，中央数据库将过于庞大，而且它还不得不为解决每个新添加的主机而频繁更新</li></ul><p>因此,DNS设计为<strong>分布式的层次数据库</strong></p><figure><img src="image-20241216202121549.png" alt="image-20241216202121549" /><figcaption aria-hidden="true">image-20241216202121549</figcaption></figure><ul><li><strong>根服务器</strong>:根名字服务器提供TLD服务器的IP地址</li><li><strong>顶级域(TLD)DNS服务器</strong>: TLD服务器提供了权威DNS服务器的IP地址</li><li><strong>权威DNS服务器</strong>:因特网上具有公共可访问主机的组织机构必须提供公共可访问的DNS记录，将公共可访问主机名映射为IP</li></ul><p><strong>[本地DNS服务器]</strong></p><p>严格说来，一个 本地DNS服务器并<strong>不属于</strong>该服务器的层次结构</p><p>每个ISP都有一台本地DNS服务器（也叫默认名字服务器）,主机的本地DNS服务器通常“邻近”本主机。</p><p>当主机发岀 DNS请求时，该请求被发往本地DNS服务器，它起着代理的作用，并将该请求转发到DNS服务器层次结构中</p><p><strong>[名字解析过程]</strong></p><ul><li>迭代查询</li><li>递归查询</li></ul><p><strong>迭代查询</strong>:</p><figure><img src="image-20241216204655119.png" alt="image-20241216204655119" /><figcaption aria-hidden="true">image-20241216204655119</figcaption></figure><p><strong>递归查询:</strong> <img src="image-20241216204719639.png" alt="image-20241216204719639" /></p><h3 id="dns缓存">DNS缓存</h3><blockquote><p>在一个请求链中，当某DNS 服务器接收一个DNS回答(例如，包含某主机名到IP地址的映射)时，它能将映射缓存在本地存储器中</p></blockquote><p>由于主机和主机名与IP地址间的映射并不是永久的，DNS服务器在一段时间后(通常设置为两天)将丢弃缓存的信息。</p><p>TLD servers IP address typically cached in local name servers thus root name servers not often visited</p><h3 id="dns记录">DNS记录</h3><blockquote><p>共同实现DNS分布式数据库的所有DNS服务器存储了资源记录(Resource Record, RR), RR提供了主机名到IP地址的映射。每个DNS回答报文包含了一条或多条资源记 录。</p></blockquote><p>RR是四元组:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RR format: (<span class="keyword">name</span>, value, type, ttl)</span><br></pre></td></tr></table></figure><ol type="1"><li><strong>TTL:该记录的生存时间，它决定了资源记录应当从缓存中删除的时间。</strong></li><li><strong>Name和Value的值取决于Type</strong>:</li></ol><table><thead><tr class="header"><th style="text-align: center;">Type取值</th><th style="text-align: center;">Name取值</th><th style="text-align: center;">Value取值</th><th>例子</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">A</td><td style="text-align: center;">主机</td><td style="text-align: center;">IP地址</td><td>(Tayl. bar. foo. com, 145. 37.93. 126, A)</td></tr><tr class="even"><td style="text-align: center;">CNAME</td><td style="text-align: center;">规范名字的别名</td><td style="text-align: center;">规范名字</td><td>(foo.com, relay1. bar. foo. com, CNAME)</td></tr><tr class="odd"><td style="text-align: center;">NS</td><td style="text-align: center;">域名</td><td style="text-align: center;">该域名的权威服务器的域名</td><td>(foo.com, dns.foo.com, NS)</td></tr><tr class="even"><td style="text-align: center;">MX</td><td style="text-align: center;"></td><td style="text-align: center;">name对应的邮件服务器的名字</td><td>(foo.com, mail. bar. foo. com, MX)</td></tr></tbody></table><p>值得注意的是，通过使用MX记录，<strong>一个公司的邮件服务器和其他服务器(如它的Web服务器)可以使用相同的别名</strong>。为了获得邮件服务器的规范主机名，DNS客户应当请求一条MX记录；而为了获得其他服务器的规范主机名，DNS客户应当请求CNAME记录。</p><ul><li>如果当前DNS是收到的请求中所请求主机名的权威DNS服务器，或者缓存中有所请求主机名的A记录，则返回一条A记录；</li><li>如果当前DNS服务器不是所请求主机名的权威DNS服务器， 则返回一条NS记录提供所请求主机的域及其权威DNS服务器主机名，同时再返回一条A记录包含该权威DNS服务器的IP地址</li></ul><h3 id="dns报文">DNS报文</h3><p>只有查询和回答报文,并且格式相同</p><figure><img src="image-20241216210203915.png" alt="image-20241216210203915" /><figcaption aria-hidden="true">image-20241216210203915</figcaption></figure><p>标识符:16位数,用于标识该查询。</p><p>flag标志:查询/应答 希望递归 递归可用 应答为权威</p><h3 id="在dns数据库中插入记录">在DNS数据库中插入记录</h3><figure><img src="image-20241216210652604.png" alt="image-20241216210652604" /><figcaption aria-hidden="true">image-20241216210652604</figcaption></figure><figure><img src="image-20241216210811952.png" alt="image-20241216210811952" /><figcaption aria-hidden="true">image-20241216210811952</figcaption></figure><h1 id="传输层">传输层</h1><ul><li>传输层为运行在<strong>不同主机</strong>上的<strong>应用进程</strong>提供直接的通信服务。</li><li>将网络层在两个端系统之间的交付服务扩展到运行在 两个<strong>不同端系统上的应用层进程</strong>之间的交付服务。</li><li>并解决两个对等通信实体如何在尽力而为（会丢失或 损坏数据）的因特网上进行<strong>可靠的通信</strong>。</li><li>控制运输层实体的传输速率以避免网络中的拥塞，或从拥塞中恢复过来</li></ul><h2 id="概述和传输层服务">概述和传输层服务</h2><p>传输层为运行在不同主机上的应用进程提供<strong>逻辑通信</strong></p><blockquote><p>逻辑通信:应用进程使用传输层提供的逻辑通信功能发送报文,无需考虑承载这些报文的物理基础设施</p></blockquote><p>传输协议运行<strong>在端系统</strong>:</p><ul><li>发送方：将应用层的报文分成报文段，然后传递给网络层</li><li>接收方：将报文段重组成报文，然后传递给应用层</li></ul><p>有多个传输层协议可供应用选择 如Internet: TCP和UDP</p><figure><img src="image-20241218092357878.png" alt="image-20241218092357878" /><figcaption aria-hidden="true">image-20241218092357878</figcaption></figure><h3 id="传输层-vs.-网络层">传输层 vs. 网络层</h3><ul><li>网络层服务：<strong>主机</strong>之间的<strong>逻辑通信</strong></li><li>传输层服务：<strong>进程</strong>间的<strong>逻辑通信</strong><ul><li>依赖于网络层的服务(延时、带宽)</li><li>并对网络层的服务进行增强 (数据丢失、顺序混乱、 加密)</li></ul></li></ul><p>有些服务是可以加强的：不可靠 -&gt; 可靠,安全 . 但有些服务是不可以被加强的：带宽，延迟</p><h3 id="多路分解与多路复用">多路分解与多路复用</h3><blockquote><p>多路分解与多路复用 : 将由网络层提供的<strong>主机到主机</strong>的交付服务延伸到运行在主机上的<strong>应用程序</strong>,提供<strong>进程到进程</strong>的交付服务</p></blockquote><ul><li><p>通过套接字实现,一个进程有一个或多个套接字,相当于从网络向进程传递数据或者从进程向网络传递数据的门户</p></li><li><p>每个传输层报文段中都包含套接字的标识符字段(端口号),在发送端填入源和目的端口号,在接收端提取</p><ul><li><p>在<strong>发送方</strong>主机<strong>多路复用</strong>:从多个套接字接收来自多个进程的报文，根据套接字对应的IP地址和端口号等信息对报文段用头部加以封装 (该头部信息用于以后的解复用)</p></li><li><p>在<strong>接收方</strong>主机<strong>多路解复用</strong>:根据报文段的头部信息中的IP地址和端口号将接收到的报文段发给正确的套接字(和对应的应用进程)</p></li></ul></li></ul><p><strong>多路复用工作原理</strong></p><ul><li>主机收到<strong>IP数据报</strong><ul><li>每个数据报有<strong>源IP地址</strong>和<strong>目标IP地址</strong></li><li>每个<strong>数据报</strong>承载一个<strong>传输层报文段</strong></li><li>每个<strong>报文段</strong>有一个<strong>源端口号</strong>和 <strong>目标端口号</strong> (特定应用有著名的端口号)</li></ul></li><li>主机联合使用<strong>IP地址和端口号</strong>将报 文段发送给合适的<strong>套接字</strong></li></ul><figure><img src="image-20241218094342788.png" alt="image-20241218094342788" /><figcaption aria-hidden="true">image-20241218094342788</figcaption></figure><p><strong>端口号</strong></p><blockquote><p>16位二进制数,范围:0~65535</p><ul><li>0~1023是众所周知端口号；</li><li>1024~5000是临时端口号，分给客户端;</li><li>大于5000的服务器端留用，支持并发。</li></ul></blockquote><p><strong>如何标识一对网络通信进程</strong></p><p>用<strong>五元组</strong>来标识因特网上彼此通信的<strong>一对网络通信</strong>进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;TCP or UDP，源端口号，源IP地址，目的端口号，目的IP地址&gt;</span><br></pre></td></tr></table></figure><ol type="1"><li>TCP还是UDP？在开发网络应用程序时就已由程序人员确定</li><li>客户端发起通信时，要创建套接字，并指明创建TCP套接字还是UDP套接字，并请求分配<strong>源端口号</strong>。</li><li>套接字在形成报文段时，要封装<strong>源端口号</strong>和<strong>目的端口号</strong>，然后调用TCP或UDP服务，完成传输层功能，并将报文段传给网络层。</li><li>报文段到达<strong>网络层</strong>后，添加<strong>源IP地址</strong>、<strong>目的IP地址</strong>等字段，形成分组</li></ol><h3 id="无连接udp的多路复用">无连接(UDP)的多路复用</h3><p>在<strong>接收端</strong>，<strong>UDP套接字用二元组标识</strong> (目标IP地址、目标端口号)</p><p>主机收到UDP报文段： 检查报文段的目标端口号 , 用该端口号将报文段定位给套接字</p><p>如果两个不同源IP地址/源端口号的数据报，但是有相同的目标IP地址和端口号，则被定位到相同的套接字</p><figure><img src="image-20241218100059270.png" alt="image-20241218100059270" /><figcaption aria-hidden="true">image-20241218100059270</figcaption></figure><h3 id="面向连接tcp的多路复用">面向连接(TCP)的多路复用</h3><ul><li>接收端TCP套接字:四元组本地标识： <strong>源IP地址 源端口号 目的IP地址 目的端口号</strong> , 接收主机用这四个值来将数据报定位到合适的套接字</li><li>服务器能够在<strong>一个TCP 端口</strong>上同时支持<strong>多个 TCP套接字</strong>: 每个套接字由其四元组标识（有不同的源IP和源 PORT）</li></ul><p>Web服务器对每个连接客户端有不同的套接字, 非持久连接对每个请求有不同的套接字</p><figure><img src="image-20241218100046626.png" alt="image-20241218100046626" /><figcaption aria-hidden="true">image-20241218100046626</figcaption></figure><h2 id="无连接传输udp">无连接传输:UDP</h2><p>UDP只提供了<strong>复用/分解</strong> 和<strong>少量差错检验</strong>功能。(除了复用/分解功能及少量的差错检测外，它几乎没有对IP增加别的东西。)</p><p>UDP是尽力而为的服务,报文段可能会<strong>丢失 、乱序</strong></p><p><strong>无连接:</strong></p><ul><li>UDP发送端和接收端之间没有握手</li><li>每个UDP报文段都被独立地处理(每个UDP报文段都独立存在，发送方不会等待接收方的确认，也不跟踪连接状态。接收方接收到数据后，不会知道这些数据是由同一源发送的、也不会了解这些数据是属于同一应用会话的。)</li></ul><p>TCP服务由于拥塞控制限速、建立连接的时延开销、维护连接状态需要缓存参数等资源、首部开销大等原因并不适合所有应用。</p><p>UDP被用于: 流媒体（丢失不敏感， 速率敏感、应用可控制 、传输速率）, DNS , SNMP</p><h3 id="udp报文">UDP报文</h3><figure><img src="image-20241218102933247.png" alt="image-20241218102933247" /><figcaption aria-hidden="true">image-20241218102933247</figcaption></figure><p><strong>为什么要有UDP?</strong></p><ul><li>不建立连接 （会增加延时 ）</li><li>简单：在发送端和接收端没有连接状态</li><li>报文段的头部很小(开销小)</li><li>无拥塞控制和流量控制： UDP可以尽可能快的发送报文段</li><li>应用-&gt;传输的速率= 主机-&gt;网络的速率</li></ul><p><strong>UDP校验和</strong></p><blockquote><p>检测在被传输报文段中的差错 (如比特反转)</p></blockquote><p>发送方:</p><ul><li>将报文段的内容视为16 比特的整数</li><li>校验和：报文段的加法和取反 （1的补运算）</li><li>发送方将校验和放在 UDP的校验和字段</li></ul><p>接收方:</p><ul><li>计算接收到的报文段的校验和</li><li>检查计算出的校验和与校验和字段的内容是否相等：<ul><li>不相等–--检测到差错</li><li>相等–--没有检测到差错 ，但也许还是有差错 • 残存错误</li></ul></li></ul><figure><img src="image-20241218103324060.png" alt="image-20241218103324060" /><figcaption aria-hidden="true">image-20241218103324060</figcaption></figure><p><strong>为什么UDP提供了差错检验，而有些链路层协议也提供了差错检验功能？</strong></p><ul><li>不能确保源端和目的端之间所有的链路都提供差错检验。</li><li>不能确保报文段在某个路由器内存中存储时不出错。</li><li>UDP提供差错检验，但对差错没有恢复功能。</li></ul><h2 id="可靠数据传输rdt原理">可靠数据传输(rdt)原理</h2><h3 id="rdt1.0在可靠信道上的可靠数据传输">Rdt1.0:在可靠信道上的可靠数据传输</h3><blockquote><p>前提:</p><p>下层的信道是完全可靠的:</p><ul><li>没有比特出错</li><li>没有分组丢失</li></ul></blockquote><figure><img src="image-20241218104519486.png" alt="image-20241218104519486" /><figcaption aria-hidden="true">image-20241218104519486</figcaption></figure><figure><img src="image-20241218104946106.png" alt="image-20241218104946106" /><figcaption aria-hidden="true">image-20241218104946106</figcaption></figure><h3 id="rdt2.0具有比特差错的信道">Rdt2.0:具有比特差错的信道</h3><blockquote><p>下层信道可能会出错：将分组中的比特翻转 : 用校验和来检测比特差错</p><p>会出现比特差错， 但报文段不丢失、不乱序</p></blockquote><p><strong>怎样从差错中恢复:</strong></p><ul><li>确认(ACK)：接收方显式地告诉发送方分组已被正确接收</li><li>否定确认( NAK): 接收方显式地告诉发送方分组发生了差错<ul><li>发送方收到NAK后，发送方重传分组</li></ul></li></ul><figure><img src="image-20241218105442915.png" alt="image-20241218105442915" /><figcaption aria-hidden="true">image-20241218105442915</figcaption></figure><p><strong>rdt2.0称为停等协议</strong>:发送方发送一个分组， 然后等待接收方的应答</p><p>rdt2.0新机制:</p><ul><li>差错检测</li><li>从接收方到发送方的控制信息(ACK,NAK)</li></ul><figure><img src="image-20241218105657205.png" alt="image-20241218105657205" /><figcaption aria-hidden="true">image-20241218105657205</figcaption></figure><p><strong>缺陷:</strong></p><p>如果ACK/NAK出错,发送方却不知道发生了什么,发送方若重传会造成冗余,若什么都不做会造成死锁</p><p><strong>应对重复的措施</strong>:----&gt;<strong>rdt2.1</strong></p><ul><li>发送方在每个分组中加 入序号</li><li>如果ACK/NAK出错，发送方重传当前分组</li><li>接收方丢弃（不发给上层）重复分组</li></ul><h3 id="rdt2.1">Rdt2.1</h3><blockquote><p>在2.0的基础上给分组加入了序号</p></blockquote><p><strong>发送方：</strong></p><ul><li>在分组中加入序列号</li><li>两个序列号（0，1）就 足够了</li><li>一次只发送一个未经确认的分组</li><li>必须检测ACK/NAK是否出错（需要EDC : Error Detection Code错误检测码）</li><li>状态数变成了两倍</li><li>必须记住当前分组的序列号为0还是1</li></ul><p><strong>接收方：</strong></p><ul><li>必须检测接收到的分组是否是<strong>重复</strong>的</li><li>状态会指示希望接收到的分组的序号为0还是1</li><li>接收方并不知道发送方是否正确接受到ACK/NAK,不会继续设计确认的确认,不然就没完没了</li></ul><figure><img src="image-20241218110037342.png" alt="image-20241218110037342" /><figcaption aria-hidden="true">image-20241218110037342</figcaption></figure><figure><img src="image-20241218110128306.png" alt="image-20241218110128306" /><figcaption aria-hidden="true">image-20241218110128306</figcaption></figure><figure><img src="image-20241218110144763.png" alt="image-20241218110144763" /><figcaption aria-hidden="true">image-20241218110144763</figcaption></figure><h3 id="rdt2.2无nak的协议">Rdt2.2:无NAK的协议</h3><blockquote><ul><li>功能同rdt2.1，但只使用ACK(ack 要编号）</li><li>接收方对<strong>最后正确接收</strong>的分组发ACK，以替代NAK<ul><li>接收方必须<strong>显式地</strong>包含被正确接收分组的序号</li></ul></li><li>当收到<strong>重复的ACK</strong>（如：再次收到ack0）时，发送方与收到NAK采取相同的动作：<strong>重传当前分组</strong></li><li>为后面的一次发送多个数据单位做一个准备<ul><li>一次能够发送多个</li><li>每一个的应答都有：ACK，NAK；麻烦</li><li>使用对前一个数据单位的ACK，代替本数据单位的NAK</li><li>确认信息减少一半，协议处理简单</li></ul></li></ul></blockquote><figure><img src="image-20241218111223662.png" alt="image-20241218111223662" /><figcaption aria-hidden="true">image-20241218111223662</figcaption></figure><figure><img src="image-20241218111245711.png" alt="image-20241218111245711" /><figcaption aria-hidden="true">image-20241218111245711</figcaption></figure><figure><img src="image-20241218111313677.png" alt="image-20241218111313677" /><figcaption aria-hidden="true">image-20241218111313677</figcaption></figure><h3 id="rdt3.0具有比特差错和分组丢失的信道">Rdt3.0:具有比特差错和分组丢失的信道</h3><blockquote><p>假设:</p><p>下层信道可能会丢失分组（数据 或ACK）</p><p>方法:</p><p>发送方等待ACK一段合理的时间,发送端超时重传：如果到时没有收到ACK-&gt;重传</p><p>需要一个倒计数定时器</p><p>方法存在的问题:</p><p>如果分组（或ACK ）只是被延迟了, 重传将会导致数据重复，但利用序列号已经可以处理这 个问题 ,那么接收方必须指明被正确接收的序列号</p></blockquote><figure><img src="image-20241218111710449.png" alt="image-20241218111710449" /><figcaption aria-hidden="true">image-20241218111710449</figcaption></figure><figure><img src="image-20241218111757806.png" alt="image-20241218111757806" /><figcaption aria-hidden="true">image-20241218111757806</figcaption></figure><ul><li>过早超时（延迟的ACK）也能够正常工作；但是效率较低，一半 的分组和确认是重复的；</li><li>设置一个合理的超时时间也是比较重要的；</li></ul><p><strong>性能</strong></p><figure><img src="image-20241218112151691.png" alt="image-20241218112151691" /><figcaption aria-hidden="true">image-20241218112151691</figcaption></figure><figure><img src="image-20241218112217273.png" alt="image-20241218112217273" /><figcaption aria-hidden="true">image-20241218112217273</figcaption></figure><figure><img src="image-20241218112327914.png" alt="image-20241218112327914" /><figcaption aria-hidden="true">image-20241218112327914</figcaption></figure><h3 id="流水线可靠传输协议">流水线可靠传输协议</h3><blockquote><p>流水线：允许发送方在未得到对方确认的情况下一次发送多个</p><ul><li>必须增加序号的范围:用多个bit表示分组的序号</li><li>在发送方/接收方要有缓冲区<ul><li>发送方缓冲：未得到确认，可能需要重传；</li><li>接收方缓存：<ul><li>上层用户取用数据的速率 ≠ 接收到的数据速率；</li><li>接收到的数据可能乱序，排序交付（可靠）</li></ul></li></ul></li></ul></blockquote><p>通用的流水线协议,根据差错的恢复方式不同:</p><p>回退N步(GBN):全部重传 累计确认</p><p>选择重传(SR): 选择重传 单独确认</p><h3 id="gbn滑动窗口协议">GBN:滑动窗口协议</h3><p><strong>发送缓冲区</strong></p><ul><li>形式：内存中的一个区域，落入缓冲区的分组<strong>可以发送</strong></li><li>功能：用于存放已发送，但是没有得到确认的分组(<strong>滑动窗口</strong>)</li><li>必要性：需要重发时可用</li></ul><p><strong>发送缓冲区的大小</strong>：一次最多可以发送多少个未经确认的分组</p><ul><li>停止等待协议=1</li><li>流水线协议&gt;1，合理的值，不能很大，链路利用率不能够超100%</li></ul><p><strong>发送缓冲区中的分组</strong></p><ul><li>未发送的：落入发送缓冲区的分组，可以连续发送出去；</li><li>已经发送出去的、等待对方确认的分组：发送缓冲区的分组只有得到确认才能删除</li></ul><p><strong>发送方:</strong></p><figure><img src="image-20241218162004733.png" alt="image-20241218162004733" /><figcaption aria-hidden="true">image-20241218162004733</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">［0, base - 1 ］段内的序号对应于已经发送并被确认的分组。</span><br><span class="line">［base, nextseqnum - 1 ］段内对应已经发送但未被确认的分组。</span><br><span class="line">［nextseqnum, base +N- 1 ］段内的序号能用于那些要被立即发送的分组</span><br><span class="line">大于或等于base + N的序号是不能使用的，直到当前流水线中未被确认的分组（特别是序号为base的分组）已得到确认为止</span><br></pre></td></tr></table></figure><ul><li>序号：k-bit seq # in pkt header。 k比特长度二进制数。</li><li>序号空间：可使用的序号范围，为<span class="math inline">\([0, 2^k-1]\)</span> 序号循环使用。</li><li>基序号(base)：最早已发送但未确认的数据片的序号。</li><li>下一个待发送序号(nextseqnum)：也称为<strong>最小未使用</strong>的序号。</li><li>窗口“ window ” ：发送缓冲区的一个范围,<strong>能被发送但还未确认的分组</strong>的许可序号范围。发送窗口的最大值&lt;=发送缓冲区的值</li><li>窗口长度N：窗口内序号的个数。 窗口尺寸:<span class="math inline">\((1,2^k-1]\)</span> ,k为序号的位数</li><li>GBN协议也被称为滑动窗口协议</li></ul><figure><img src="image-20241218163501491.png" alt="image-20241218163501491" /><figcaption aria-hidden="true">image-20241218163501491</figcaption></figure><p><strong>发送窗口的移动</strong>:</p><p>base移动向后移动:</p><ul><li>条件：收到老分组的确认</li><li>移动的极限：不能够超过nextsqnum</li></ul><p><strong>接收窗口</strong></p><ul><li>接收窗口用于控制哪些分组可以接收</li><li>只有收到的分组序号落入接收窗口内才允许接收 ,若序号在接收窗口之外，则丢弃；</li><li>GBN协议的接收窗口尺寸Wr=1，则只能顺序接收</li></ul><p><strong>滑动</strong>：</p><ul><li>只有接受窗口内要求的数据包到来才移动</li></ul><p><strong>发送确认</strong>：</p><ul><li>接收窗口尺寸=1 ； 发送连续收到的最大的分组确认（累计确认） （GBN）</li><li>接收窗口尺寸&gt;1 ； 收到分组，发送那个分组的确认（非累计确认)（SR协议）</li></ul><figure><img src="image-20241218164113789.png" alt="image-20241218164113789" /><figcaption aria-hidden="true">image-20241218164113789</figcaption></figure><p><strong>优缺点</strong></p><p>优点:</p><ul><li>接收方简单，不需要缓存任何失序的数据片，不需 要设置缓存。</li></ul><p>缺点：</p><ul><li>发送方需要设置缓存已发送但未确认的数据片，并维护 窗口的上下边界和nextseqnum。</li><li>由于失序而丢弃一个正确的数据片后，随后可能需要更 多的重传，包括之前删除的正确的失序数据片。</li><li>当窗口长度和带宽时延积很大时，单个数据片的错误就 能引起GBN重传大量数据片！导致传输效率大大降低。</li></ul><h3 id="选择重传sr">选择重传（SR）</h3><p><strong>发送窗口：</strong></p><figure><img src="image-20241218165254370.png" alt="image-20241218165254370" /><figcaption aria-hidden="true">image-20241218165254370</figcaption></figure><p><strong>发送窗口长度:范围在<span class="math inline">\((1,2^{k-1}]\)</span></strong></p><p><strong>发送窗口的移动</strong>:</p><p>base移动向后移动:</p><ul><li>条件：收到老分组的确认</li><li>移动的极限：不能够超过nextsqnum</li></ul><figure><img src="image-20241218170430234.png" alt="image-20241218170430234" /><figcaption aria-hidden="true">image-20241218170430234</figcaption></figure><p><strong>接受窗口:</strong></p><figure><img src="image-20241218170321635.png" alt="image-20241218170321635" /><figcaption aria-hidden="true">image-20241218170321635</figcaption></figure><ul><li>接收窗口用于控制哪些分组可以接收</li><li>只有收到的分组序号落入接收窗口内才允许接收 ,若序号在接收窗口之外，则丢弃；</li><li>SR的接受窗口尺寸&gt;1可以乱序接受</li></ul><p><strong>接受窗口滑动</strong>：</p><ul><li>低序号的分组到来，接收窗口移动</li><li>只有接受窗口内要求的数据包到来才移动</li><li>高序号分组乱序到，缓存但不交付（因为要实现rdt，不允许失序），不滑动</li></ul><figure><img src="image-20241218170649125.png" alt="image-20241218170649125" /><figcaption aria-hidden="true">image-20241218170649125</figcaption></figure><p>接收方<strong>发送确认</strong>：</p><ul><li>接收窗口尺寸&gt;1 ； 收到分组，发送那个分组的确认（非累计确认)</li></ul><figure><img src="image-20241218170851213.png" alt="image-20241218170851213" /><figcaption aria-hidden="true">image-20241218170851213</figcaption></figure><h3 id="gbn-vs.-sr">GBN vs. SR</h3><table><colgroup><col style="width: 9%" /><col style="width: 45%" /><col style="width: 45%" /></colgroup><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">GBN</th><th style="text-align: center;">SR</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">发送窗口大小</td><td style="text-align: center;">$(1,2^k- 1] $</td><td style="text-align: center;"><span class="math inline">\((1,2^{k-1}]\)</span></td></tr><tr class="even"><td style="text-align: center;">接收窗口大小</td><td style="text-align: center;"><strong>=1</strong>,接收方只能顺序接收<br />发送方:一旦一个分组没有发成功，<br />如：0,1,2,3,4 ; 假如1未成功，234都发送出去 <br />了，要返回1再发送；GB1</td><td style="text-align: center;"><strong>&gt;1</strong>,接收方可以乱序接收<br />发送方发送0,1,2,3,4，<br />一旦1未成功，2,3,4,已发送，<br />无需重 发，选择性发送1</td></tr><tr class="odd"><td style="text-align: center;">确认</td><td style="text-align: center;">累计确认</td><td style="text-align: center;">选择确认</td></tr><tr class="even"><td style="text-align: center;">定时器</td><td style="text-align: center;">发送端拥有对最老的未确认分组的定时器<br />当定时器到时时，重 传所有未确认分组</td><td style="text-align: center;">发送方为每个未确认的分组保持一个定时器<br />当超时定时器到时，只是 重发到时的未确认分组</td></tr></tbody></table><h2 id="面向连接的传输tcp">面向连接的传输:TCP</h2><ul><li>点对点：一个发送方、一个接收方</li><li>可靠的、按顺序的<strong>字节流</strong>，没有报文边界</li><li>管道化（流水线），TCP拥塞控制和流量控制设置窗口大小</li><li>有发送和接收缓存</li><li>全双工数据</li><li>面向连接</li><li>有流量控制，发送方不会淹没接收</li><li>逻辑连接，其共同状态仅保留在两个通信端系统的TCP程序中，TCP协议只在端系统中运行</li><li><strong>累计确认</strong></li></ul><p><strong>TCP建立连接的过程称为三次握手</strong></p><ol type="1"><li>客户端首先发出一个建立TCP连接的特殊TCP报文段；</li><li>服务器用另一个特殊的TCP报文段来响应；</li><li>客户端再用第三个特殊TCP报文段作为对服务器响应报文的响应 ，同时可以承载有效载荷（即应用层数据）。</li></ol><p><strong>TCP传输数据的过程：</strong> 客户进程将要传输的数据流交给发送端套接字，然后数据流将开始由TCP控制，TCP将数据流引导到连接的发送缓存（三次握手时设置）里。 然后TCP将不时地从发送缓存里取出一块数据递交到网络层传输，每次从缓存取出放入报文段的<strong>数据量</strong>受<strong>最大报文段长度MSS</strong>限制注意到MSS是 指在报文段里<strong>应用层数据的最大长度</strong>，而不是指包括首部的TCP报文段的最大长度。</p><blockquote><p>MSS通常根据最初确定的由本地发送主机发送的<strong>最大链路层帧长度</strong>（即所谓的最大传输单元(MTU））来设置。设置该MSS要保证<strong>一个TCP 报文段（当封装在一个IP数据报中）加上TCP/IP首部长度（通常40字节）将适合单个链路层帧</strong>。以太网和PPP链路层协议都具有1500字节的MTU,因此MSS的<strong>典型值为1460 字节</strong>。</p></blockquote><p>TCP为每块客户数据配上一个TCP首部，从而形成多个TCP报文段（TCP segment）。 这些报文段被下传给网络层，网络层将其分别封装在网络层IP数据报中。然后这些IP数据报被发送到网络中。</p><p><strong>TCP接受数据过程：</strong></p><p>当TCP在另一端接收到一个报文段后，该报文段的数据就被放入该 TCP连接的接收缓存中，应用程序从此缓存中读取数据流。</p><h3 id="报文段">报文段</h3><figure><img src="image-20241218195546375.png" alt="image-20241218195546375" /><figcaption aria-hidden="true">image-20241218195546375</figcaption></figure><p><strong>序号和确认号</strong></p><p>TCP把数据看成一个无结构的、有序的字节流。序号是建立在<strong>传送的字节流</strong>之上，而不是建立在传送的报文段的序列之上。—个报文段的序号是该<strong>报文段首字节</strong>的<strong>字节流编号</strong></p><blockquote><p>如：假设主机A上的一个进程想通过一条TCP连接向主机B上的一个进程发送一 个数据流。主机A中的TCP将隐式地对数据流中的每一个字节编号。假定数据流由一个 包含500 000字节的文件组成，其MSS为1000字节，数据流的首字节编号是0。该TCP将为该数据流构建500个报文段。给第一个报文段分配序号0,第二个报文 段分配序号1000,第三个报文段分配序号2000,以此类推。每一个序号被填入到相应TCP 报文段首部的序号字段中。</p></blockquote><figure><img src="image-20241218195739741.png" alt="image-20241218195739741" /><figcaption aria-hidden="true">image-20241218195739741</figcaption></figure><p>TCP是全双工的, 因此主机A在向主机B发送数据的同时，也接收来自主机B的数据,从主机B到达的每个报文段中都有一个序号用于从B流向A的数据。主机A填充进报文段的<strong>确认号是主机A期望从主机B收到的下一字节的序号</strong>。</p><blockquote><p>假设主机A已收到了来自主机B的编号为0 ~535的所有字节，同时假设它打算发送一个报文段给主机B。主机A等待主机B的数据流中字节536及之后的所有 字节。所以主机A就会在它发往主机B的报文段的确认号字段中填上536。累计确认,</p></blockquote><ul><li>TCP采用累计确认的方式</li><li>TCP采取捎带应答：TCP对客户到服务器的数据的确认，被装载在一个服务器到客户的数据报文段中， 即使最后一个报文段里没有数据仍然有序号，报文格式需要</li><li>接收方如何处理乱序的报文段：没有规定</li></ul><h3 id="tcp往返延时和超时">TCP往返延时和超时</h3><blockquote><p>TCP采用超时/重传机制来处理报文段的丢失问题。</p><p>显然，超时间隔必须大于该连接的往返时间（RTT）否则会造成不 必要的重传,太长：对报文段丢失反应太慢，消极</p></blockquote><p><strong>估计往返时间RTT</strong></p><blockquote><p>在任意时刻，仅为一个<strong>已发送的但目前尚未被确认</strong>的报文段估计SampleRTT,从而产生一个接近每个RTT的新SampleRTT值。另外，TCP决不为<strong>已被重传的报文段</strong>计算SampleRTT；它仅为传输一次的报文段测量SampleRTT</p></blockquote><p>为了估计一个典型的RTT,自然要采取某种对SampleRTT取平均的办法。TCP维持一个SampleRTT均值 （称为EstimatedRTT）一旦获得一个新SampleRTT时，TCP就会根据下列公式来更新<code>EstimatedRTT</code> <span class="math display">\[EstimatedRTT = (1 - a) * EstimatedRTT + a * SampleRTT ，a 一般取 0.125\]</span> EstimatedRTT是一个SampleRTT值的加权平均值,这种平均被称为<strong>指数加权移动平均</strong></p><p><code>RTT偏差(DevRTT)</code> <strong>用于估算SampleRTT 一般会偏离EstimatedRTT的程度：</strong> <span class="math display">\[DevRTT = (1 - \beta) * DevRTT + \beta* |SampleRTT - EstimatedRTT|，\beta 一般取 0.25\]</span></p><p><code>设置超时TimeoutInterval</code></p><p>EstimtedRTT + 安全边界时间,若EstimatedRTT变化大 (方差大)那就采用 较大的安全边界时间 <span class="math display">\[TimeoutInterval = EstimatedRTT + 4 * DevRTT\]</span> 推荐的初始Timeoutinterval值为1秒</p><h3 id="tcp可靠数据传输">TCP:可靠数据传输</h3><ul><li>TCP在IP不可靠服务的基础上 建立了可靠数据传输:无损坏、 无间隙、非冗余、按序<ul><li>管道化的报文段</li><li>累计确认</li><li>单个重传定时器,定时器管理的开销很大</li><li>没有规定是否可以接受乱序</li></ul></li><li>通过以下事件触发<strong>重传</strong><ul><li>超时（<strong>只重发那个最早的未确认段</strong>：SR)</li><li>重复的确认,连续3个冗余ACK</li></ul></li></ul><figure><img src="image-20241218202351615.png" alt="image-20241218202351615" /><figcaption aria-hidden="true">image-20241218202351615</figcaption></figure><figure><img src="image-20241218203617974.png" alt="image-20241218203617974" /><figcaption aria-hidden="true">image-20241218203617974</figcaption></figure><ul><li>对于右图:当超时事件发生时，主机A重传序号92的第一个报文段，并重启定时器。只要第二个报文段的ACK在新的超时发生以前到达，则第二个报文段将不会被重传。</li><li>对顺序收到的最高字节确认</li></ul><figure><img src="image-20241218203821356.png" alt="image-20241218203821356" /><figcaption aria-hidden="true">image-20241218203821356</figcaption></figure><figure><img src="image-20241218204153435.png" alt="image-20241218204153435" /><figcaption aria-hidden="true">image-20241218204153435</figcaption></figure><h3 id="tcp快速重传">TCP快速重传</h3><blockquote><p>超时触发重传存在的问题之一是超时周期可能相对较长。当一个报文段丢失时, 这种长超时周期迫使发送方延迟重传丢失的分组，因而增加了端到端时延。<strong>解决方法便是快速重传</strong></p></blockquote><figure><img src="image-20241218203951089.png" alt="image-20241218203951089" /><figcaption aria-hidden="true">image-20241218203951089</figcaption></figure><p>如果TCP发送方接收到对相同数据的<strong>3个冗余ACK</strong>,它 把这当作一种指示，说明跟在这个已被确认过3次的报文段之后的报文段已经丢失。一旦收到3个冗余ACK, TCP就执行快速重传,即 在该报文段的<strong>定时器过期</strong>之前<strong>重传</strong>丢失的报文段。</p><h3 id="流量控制">流量控制</h3><blockquote><p>流量控制：是一个<strong>速度匹配</strong>服务，使得<strong>发送方速率与接收方速率</strong>向匹配， 不至于导致接收方缓存溢出</p><p>拥塞控制：因IP网络拥塞而限制发送方的发送速率。</p></blockquote><figure><img src="image-20241218205254802.png" alt="image-20241218205254802" /><figcaption aria-hidden="true">image-20241218205254802</figcaption></figure><figure><img src="image-20241218205435689.png" alt="image-20241218205435689" /><figcaption aria-hidden="true">image-20241218205435689</figcaption></figure><ul><li>主机 B 把当前 <code>rwnd</code> 值放入它发送给主机 A 的报文段接收窗口字段中，通知主机 A 它在该连接的缓存中还有多少可用空间</li><li>主机 A 需要保证 <code>LastByteSend - LastByteAcked &lt;= rwnd</code>，控制主机 A 已发送未确认的数据量在 <code>rwnd</code> 之内</li><li>特殊情况：当主机 B <code>rwnd = 0</code> ，且通知主机 A 之后，假设主机 B 之后没有任何数据发送给主机 A，则主机 A 被阻塞，它认为主机 B 的 <code>rwnd</code> 一直为 0，即主机 B <code>rwnd</code> 非 0 的信息无法通知给主机 A。为了解决这个问题， TCP 规范中要求 当主机 B 的接收窗口为 0 时，主机 A 继续发送只有一个字节数据的报文段。这些报文段将会被接收方确认。最终缓存将开始清空，并且确认报文里将包含一个非 0 的 <code>rwnd</code> 值。</li></ul><h3 id="tcp连接管理">TCP连接管理</h3><p>在正式交换数据之前，发送方和接收方握手建立通信关系:</p><ul><li>同意建立连接（每一方都知道对方愿意建立连接）</li><li>同意连接参数</li></ul><figure><img src="image-20241218205550448.png" alt="image-20241218205550448" /><figcaption aria-hidden="true">image-20241218205550448</figcaption></figure><figure><img src="image-20241218205825927.png" alt="image-20241218205825927" /><figcaption aria-hidden="true">image-20241218205825927</figcaption></figure><p><strong>三次握手建立连接</strong></p><figure><img src="image-20241218210123442.png" alt="image-20241218210123442" /><figcaption aria-hidden="true">image-20241218210123442</figcaption></figure><ol type="1"><li>客户端的TCP首先向服务器端的TCP发送一个特殊的TCP报文段。该报文段中不包含应用层数据.报文段的首部中的一个标志位 （即SYN比特）被置为1,并且客户端会随机地选择一个初始序号,并将此编号放置于该起始的TCP SYN 报文段的序号字段中,这个特殊报文段被称为SYN报文段</li><li>服务器会从该数据报中提取出TCP SYN报文段，为该TCP连接分配<strong>TCP缓存和变量</strong>，并向该客户TCP发送<strong>允许连接</strong>的报文段。这个允许连接的报文段也不包含应用层数据,SYN比特被置为1,该TCP报文段 首部的确认号字段被置为client _ isn + 1,服务器选择自己的初始序号,并将其放置到TCP报文段首部的序号字段中。该允许连接的报 文段被称为SYNACK报文段</li><li>在收到SYNACK报文段后，客户也要给该连接分配缓存和变量。客户主机则向服务器发送另外一个报文段；这最后一个报文段对服务器的允许连接的报文段进行了确认（该客户通过将值server_isn + 1放置到TCP报文段首部的确认字段中来完成此项工作）。因为连接已经建立了，所以该SYN比特被置为0。该三次 握手的第三个阶段可以在报文段负载中携带客户到服务器的数据。</li></ol><p><strong>四次挥手关闭连接</strong></p><figure><img src="image-20241218210729991.png" alt="image-20241218210729991" /><figcaption aria-hidden="true">image-20241218210729991</figcaption></figure><ul><li>第一步：客户 TCP 向服务器进程发送一个特殊 TCP 报文段，在首部中设置 <code>FIN</code> 标志 为 <code>1</code></li><li>第二步：服务器发送回一个确认报文段</li><li>第三步：服务器发送终止报文段，在首部中设置 <code>FIN</code> 标志 为 <code>1</code></li><li>第四步：客户对服务器的终止报文段进行确认</li></ul><h3 id="拥塞控制原理">拥塞控制原理</h3><p>原因：发送方发送速度过快，网络来不及处理</p><p>拥塞的表现:</p><ul><li>分组丢失 (路由器缓冲区溢出)</li><li>分组经历比较长的延迟(在路由器的队列中排队)</li></ul><p>代价:</p><ul><li>为了达到一个有效输出，网络需要做更多的工作（重传）</li><li>没有必要的重传，链路中包括了多个分组的拷贝</li><li>当分组丢失时，任何“关于这个分组的上游传输能力” 都被浪费了</li></ul><p>拥塞控制方法:</p><figure><img src="image-20241218211714742.png" alt="image-20241218211714742" /><figcaption aria-hidden="true">image-20241218211714742</figcaption></figure><h1 id="网络层数据平面">网络层:数据平面</h1><figure><img src="image-20241219103014047.png" alt="image-20241219103014047" /><figcaption aria-hidden="true">image-20241219103014047</figcaption></figure><figure><img src="image-20241219113403807.png" alt="image-20241219113403807" /><figcaption aria-hidden="true">image-20241219113403807</figcaption></figure><h2 id="概述">概述</h2><ul><li>因特网中所有主机和交换设备都有网络层功能。</li><li>网络层解决如何实现<strong>主机到主机</strong>的通信,在发送主机和接收主机对之间传送段（segment）。</li><li>将网络层分为<strong>数据平面</strong>和<strong>控制平面</strong>:<ul><li><strong>数据平面</strong>，<strong>每台路由器</strong>的功能，决定达到路由器输入链路的数据报如何<strong>转发</strong>到该路由器的输出链路之一。<strong>硬件完成,纳秒级</strong><ul><li>IP转发，基于数据报携带的目的地址；</li><li>通用转发，使用数据报首部的几个不同域值执行转发</li></ul></li><li>控制平面，也是<strong>每台路由器或集中服务器</strong>的功能，控制数据报沿着源主机到目的主机的端到端路径中路由器之间的<strong>路由方式</strong>,<strong>软件完成,毫秒级</strong><ul><li>传统方法:路由选择算法，<strong>OSPF</strong>、<strong>BGP</strong></li><li>软件定义的网络SDN，控制平面置于一台远程控制器</li></ul></li></ul></li><li>网络层的功能就是转发和路由</li></ul><h3 id="网络服务模型">网络服务模型</h3><blockquote><p>定义了分组在发送与接收端之间的端到端传输特性</p></blockquote><p>因特网的网络层只提供了单一的服务，称为<strong>尽力而为</strong>服务,即:传送的分组既不能保证以它们发送的顺序被接收，也不能保证它们最终交付；既不能保证端到端时延，也不能保证有最小的带宽</p><h2 id="路由器组成">路由器组成</h2><blockquote><ul><li><strong>分组交换机</strong>：指一台通用分组交换设备，根据分组首部字段中的值，从输入链路接口到输出链路接口转移分组，是<strong>第三层设备</strong>。</li><li><strong>路由器</strong>：基于网络层数据报（分组）的首部字段做 出转发决定，是第<strong>三层设备</strong>。</li><li><strong>链路层交换机</strong>：基于<strong>链路层</strong>帧的首部字段做出转发决定，是<strong>第二层设备</strong>。</li></ul></blockquote><p><strong>通用路由器的体系结构包含四个组件：输入端口、交换结构、输出端口、路由选择处理器</strong></p><figure><img src="image-20241219104147119.png" alt="image-20241219104147119" /><figcaption aria-hidden="true">image-20241219104147119</figcaption></figure><h3 id="输入端口">输入端口</h3><figure><img src="image-20241219104537377.png" alt="image-20241219104537377" /><figcaption aria-hidden="true">image-20241219104537377</figcaption></figure><ul><li>绿色框完成物理层功能，接收比特流信号；</li><li>蓝色框完成数据链路层功能，CRC校验、解封帧；</li><li>红色框完成网络层功能，查找转发表决定转发的路由器输出端口。</li><li>路由器支持的端口数量范围较大，几个到ISP的几百个10Gbp</li></ul><p><strong>[基于目标的转发/基于目的地的转发]</strong></p><blockquote><p><strong>最长前缀匹配规则</strong>:当给定目标地址查找转发表时，采用<strong>最长地址前缀匹配</strong>的目标地址表项</p></blockquote><figure><img src="image-20241219105520950.png" alt="image-20241219105520950" /><figcaption aria-hidden="true">image-20241219105520950</figcaption></figure><p><strong>在路由器中经常采用TCAMs<code>硬件</code>来完成</strong></p><p><strong>[输入端口缓存]</strong></p><ul><li>当交换机构的速率小于输入端口的汇聚速率时,在输入端口可能要排队</li><li><code>Head-of-the-Line (HOL) blocking</code>: 排在队头的数据报 阻止了队列中其他数据报向前移动</li></ul><h3 id="交换结构">交换结构</h3><blockquote><p>作用: 将路由器的<strong>输入端口连接到输出端口</strong>，根据<strong>查询转发表</strong>的结果将到达的分组通过路由器的交换结构<strong>转发</strong>到输出端口</p></blockquote><p><code>交换速率</code>：分组可以按照该速率从输入传输到输 出</p><ul><li>运行速度经常是输入/输出链路速率的若干倍</li><li>如果有N 个输入端口那么交换机构的交换速度是输入线路速度的<strong>N倍</strong>比较理想，才不会成为瓶颈</li></ul><p><strong>三种典型的交换机构</strong>:</p><figure><img src="image-20241219110021471.png" alt="交换机构" /><figcaption aria-hidden="true">交换机构</figcaption></figure><p><strong>[通过内存交换]</strong></p><figure><img src="image-20241219111255929.png" alt="image-20241219111255929" /><figcaption aria-hidden="true">image-20241219111255929</figcaption></figure><p><strong>[通过总线交换]</strong></p><figure><img src="image-20241219111335065.png" alt="image-20241219111335065" /><figcaption aria-hidden="true">image-20241219111335065</figcaption></figure><p><strong>[通过互联网络的交换]</strong></p><figure><img src="image-20241219111410219.png" alt="image-20241219111410219" /><figcaption aria-hidden="true">image-20241219111410219</figcaption></figure><p><code>纵横式交换机</code>就是一种由2N条总线组成的互联网络，它连接N个输入端口 与N个输岀端口,每条垂直的总线在交叉点与每条水平的总线交叉, <code>交叉点</code>通过<code>交换结构控制器</code>（其逻辑是交换结构自身的一部分）能够在任何时候开启和闭合,纵横式网络能够<code>并行</code>转发多个分组。纵横式交换机是<code>非阻塞</code>的</p><p>然而，如果来自两个不同输入端口的两个 分组其<code>目的地</code>为<code>相同输出端口</code>，则一个分组必须在输入端等待，因为在某个时刻经给定总线仅能够发送一个分组</p><h3 id="输出端口">输出端口</h3><ul><li>从交换结构接收分组，并执行必要的链路层和物理层功能，然后在输出链路上发送出去这些分组。</li><li>取出已经存放在输出端口内存中的分组并将其发送到输出链路上,涉及到<code>选择</code></li><li>当一条链路是双向传输数据时，输入端口与输出端口成对出现在同一线路卡上</li></ul><figure><img src="image-20241219111639029.png" alt="image-20241219111639029" /><figcaption aria-hidden="true">image-20241219111639029</figcaption></figure><ul><li>当数据报从交换机构的<strong>到达速度</strong>比<strong>传输速率</strong>快 就需要<strong>输出端口缓存</strong></li><li>由<strong>调度规则</strong>选择排队的数据报进行传</li></ul><figure><img src="image-20241219112836002.png" alt="image-20241219112836002" /><figcaption aria-hidden="true">image-20241219112836002</figcaption></figure><p><strong>[调度规则]</strong></p><p><code>调度</code>: 选择下一个要通过链路传输的分组</p><p><strong>FIFP:</strong>按照分组到来的次序发送,</p><p>丢弃策略: 如果分组到达一个满的队列，哪个分组将会 被抛弃? tail drop: 丢弃刚到达的分组 priority: 根据优先权丢失/移除分组 random: 随机地丢弃/移除</p><figure><img src="image-20241219113128679.png" alt="image-20241219113128679" /><figcaption aria-hidden="true">image-20241219113128679</figcaption></figure><p><strong>优先权排队(非抢占):</strong>发送最高优先权的分组</p><p>多类，不同类别有不同的 优先权</p><p>类别可能依赖于标记或者其 他的头部字段,</p><p>先传高优先级的队列中的分 组，除非没有</p><p>高（低）优先权中的分组传 输次序：FIFO</p><figure><img src="image-20241219113116939.png" alt="image-20241219113116939" /><figcaption aria-hidden="true">image-20241219113116939</figcaption></figure><p><strong>循环排队RR</strong>: 多类  循环扫描不同类型的队列, 发送完一类的一个分组 ，再发送下一个类的一个分组，循环所有类</p><p><strong>加权公平排队</strong></p><figure><img src="image-20241219113105857.png" alt="image-20241219113105857" /><figcaption aria-hidden="true">image-20241219113105857</figcaption></figure><ul><li>循环排队：分组分类，每个类循环传输，任何时间间隔收到相同数量的服务</li><li>加权公平排队：每个类在任何时间间隔内可能收到不同数量的服务</li></ul><h3 id="路由选择处理器">路由选择处理器</h3><ul><li><strong>维护路由选择表与关联链路状态信息</strong>，为该路由器<strong>计算转发表（</strong>或者在SDN路由器中负责与远程控制器通信），并在路由器是输入端口红框中<strong>下发计算结果</strong>即转发表</li><li>路由器的<strong>输入/输出端口</strong>和<strong>交换结构</strong>都是由<strong>硬件</strong>实现的</li></ul><h2 id="ip">IP</h2><h3 id="ipv4数据报格式">IPV4数据报格式</h3><figure><img src="image-20241219113502648.png" alt="image-20241219113502648" /><figcaption aria-hidden="true">image-20241219113502648</figcaption></figure><ul><li>版本:IP协议版本号</li><li>首部长度：一般的 IP 数据报具有 <strong>20 字节的首部</strong>。</li><li>服务类型：使不同类型的 IP 数据报能相互区分开。</li><li>数据报长度：IP 数据报总长度（首部 + 数据），字节为单位。</li><li>标识，标志，片偏移：与 IP 分片有关。</li><li>上层协议：指示了一个到达的 IP 数据报的数据部分应该交给哪个<strong>特定的运输层协议</strong>。例如，<code>6</code> 表明给 <code>TCP</code>，<code>17</code> 表明给 <code>UDP</code></li><li>首部校验和：用于帮助路由器检测收到的 IP 数据报中的比特错误</li><li>选项：扩展首部，IPv4 首部大小可变，不定长</li><li>一个 IP 数据报具有总长为 20 字节的首部，如果数据报承载了一个 TCP 报文段，则每个数据报共承载了总长 40 字节的首部以及应用层报文</li></ul><p><strong>IP数据包传输TCP段时的头部有40字节:TCP(20字节)+IP(20字节)</strong></p><h3 id="ip数据报分片与装配">IP数据报分片与装配</h3><ul><li><code>最大传输单元MTU</code>:一个<strong>链路层</strong>的帧能承载的最大数据量</li><li><strong>链路层</strong>MTU<strong>限制IP分组</strong>长度</li><li>不同的链路层协议具有不同的 MTUs，例如以太网是1500字节，某些广域网链路是576字节。</li></ul><p>因此,大的IP数据报在网络上被<strong>分片</strong>:</p><blockquote><ul><li><strong>一个数据报被分割成若干个小的数据报:相同的ID 不同的偏移量 最后一个分片标记为0</strong></li><li>“重组”只在<strong>最终的目标主机</strong>进行</li><li>IP头部的信息被用于标识，排序相关分片</li></ul></blockquote><figure><img src="image-20241219143210876.png" alt="image-20241219143210876" /><figcaption aria-hidden="true">image-20241219143210876</figcaption></figure><p>源主机发送分组时给<strong>每个分组</strong>添加<strong>标识</strong>，标识号依次+1。</p><p>当中间某个路由器需要分片时，<strong>按8个字节的倍数</strong>分片：同一个分组 的每个分片具有相同的号；标志位置为1/最后一个置0；偏移量指明分片在分组的起始位置</p><h3 id="ipv4编址">IPv4编址</h3><p>主机与物理链路之间的边界叫作<code>接口</code>。</p><ul><li>一台路由器有多个接口,主机也有可能有多个接口</li><li>IP要求每台主机和路由器接口拥有自己的IP地址</li><li><strong>一个IP 地址与一个接口相关联</strong></li></ul><p><code>IP地址</code>:32位,对主机或者路由器的接口编址,用点分十进制表示</p><ul><li><p>子网部分(高位bits)</p></li><li><p>主机部分(低位bits)</p></li></ul><p><code>子网</code>: 每个互相隔离的网络成为 一个子网 subnet</p><ul><li>一个子网内的节点（主机或者路由器）它们的IP地址的<strong>高位部分</strong>相同 ，这些节点构成的网络 的一部分叫做子网</li><li>无需路由器介入，子网内各主机可以在物理上相互直接到达</li></ul><p><code>子网号</code>223.1.1.0/24为一个子网号</p><p><code>子网掩码</code> 通常指示了IP地址中哪些位是子网号，可以用/24， 也可以表示为255.255.255.0 = 11111111 11111111 11111111 00000000</p><h3 id="cidr无类别域间路由选择">CIDR无类别域间路由选择</h3><p>因特网的<strong>IP地址分配</strong>策略称为<strong>无类别域间路由策略</strong></p><ul><li>32位的IP地址被划分为两部分</li><li>a.b.c.d/x, x指示了IP地址的子网部分的比特数，即IP地址中前x位为子网号，也称为IP地址的前缀， 或网络前缀,剩余 <code>32 - x</code> 比特是用于区分子网内部设备的主机地址。</li><li>一个接入因特网的组织通常被分配一块连续的地址，即具有相同前缀的一块地址</li><li>路由器的转发表，在搜索时也是匹配网络号</li></ul><p><strong>分类编址</strong>：在 CIDR 被采用之前， IP 地址的网络部分被限制为长度为 8、16 或 24 比特。具有 8、16、24 比特子网地址的子网分别被称为 A、B、C 类网络。</p><figure><img src="image-20241219223145187.png" alt="image-20241219223145187" /><figcaption aria-hidden="true">image-20241219223145187</figcaption></figure><ul><li>当一台主机发出一个目的地址为<code>255. 255. 255. 255</code>的数据报时，该报文会交付给同一个网络中的所有主机</li><li>子网部分: 全为 0---本网络 主机部分: 全为0---本主机</li></ul><figure><img src="image-20241219144810360.png" alt="image-20241219144810360" /><figcaption aria-hidden="true">image-20241219144810360</figcaption></figure><figure><img src="image-20241219144834223.png" alt="image-20241219144834223" /><figcaption aria-hidden="true">image-20241219144834223</figcaption></figure><figure><img src="image-20241219145012828.png" alt="image-20241219145012828" /><figcaption aria-hidden="true">image-20241219145012828</figcaption></figure><h3 id="dhcp动态主机配置协议">DHCP:动态主机配置协议</h3><p><strong>目标: 允许主机在加入网络的时候，动态地从服务器那里获得IP地址</strong></p><ul><li>可以更新对主机在用IP地址的租用期-租期快到了</li><li>重新启动时，允许重新使用以前用过的IP地址</li><li>支持移动用户加入到该网络（短期在网）</li><li>即插即用、零配置，自动工作</li><li>是一个客户-服务器协议,使用DHCP协议分配IP地址的子网 内通常有一台DHCP服务器；如果没有服务器则需要一个 DCHP中继代理（通常也是一台路由器），代理知道该子网的DHCP服务器的地址</li></ul><p><strong>DHCP的4个步骤:</strong></p><ul><li><strong>DHCP 服务器发现</strong>：新到达的主机向子网<strong>广播</strong> 即 “DHCP discover ” msg [optional]来发现一个DHCP服务器，客户主机在<strong>UDP分组</strong>中向<strong>端口67</strong>发送该<strong>发现报文</strong>，使用 广播<strong>目的地址255.255.255.255和源地址0.0.0.0</strong></li><li><strong>DHCP 服务器提供</strong>：DHCP 服务器<strong>广播</strong> <strong>DHCP 提供报文</strong>,该报文向该子网的所有节点广播，仍然使用<strong>IP广播地址255. 255. 255. 255</strong>,每台服务器提供的报文包含有收到的<strong>发现报文的事务ID</strong>、向客户推荐的<strong>IP地址</strong>、<strong>网络掩码</strong>以及<strong>IP地址租用期</strong> , 即IP地址有效的时间量。服务器租用期通常设置为几小时或几 天</li><li><strong>DHCP 请求</strong>：客户选择一个服务器提供，<strong>广播</strong> <strong>DHCP 请求报文</strong>，指定选择的 DHCP 服务器 ID</li><li><strong>DHCP ACK</strong>：服务器使用 <code>DHCP ACK 报文</code>对 DHCP 请求报文进行响应，<strong>广播</strong></li></ul><figure><img src="image-20241219150921894.png" alt="image-20241219150921894" /><figcaption aria-hidden="true">image-20241219150921894</figcaption></figure><p><strong>DHCP 返回:</strong></p><ul><li>IP 地址</li><li>第一跳路由器的IP地址（默认网关）</li><li>DNS服务器的域名和IP地址</li><li>子网掩码 (指示地址部分的网络号和主机号)</li></ul><figure><img src="image-20241219151102178.png" alt="image-20241219151102178" /><figcaption aria-hidden="true">image-20241219151102178</figcaption></figure><figure><img src="image-20241219151119687.png" alt="image-20241219151119687" /><figcaption aria-hidden="true">image-20241219151119687</figcaption></figure><h3 id="nat-网络地址转换">NAT: 网络地址转换</h3><figure><img src="image-20241219151327710.png" alt="image-20241219151327710" /><figcaption aria-hidden="true">image-20241219151327710</figcaption></figure><p><strong>动机: 本地网络只有一个有效IP地址:</strong></p><ul><li>不需要从ISP分配一块地址，可用一个IP地址用于所有的（局域网）设备--省钱</li><li>可以在局域网改变设备的地址情况下而无须通知外界</li><li>可以改变ISP（地址变化）而不需要改变内部的设备地址</li><li>局域网内部的设备没有明确的地址，对外是不可见的--安全</li></ul><figure><img src="image-20241219153435835.png" alt="image-20241219153435835" /><figcaption aria-hidden="true">image-20241219153435835</figcaption></figure><figure><img src="image-20241219153511388.png" alt="image-20241219153511388" /><figcaption aria-hidden="true">image-20241219153511388</figcaption></figure><figure><img src="image-20241219153708111.png" alt="image-20241219153708111" /><figcaption aria-hidden="true">image-20241219153708111</figcaption></figure><h3 id="ipv6">IPv6</h3><p><strong>初始动机: 32-bit地址空间将会被很快用完</strong></p><p>另外的动机:</p><ul><li>头部格式改变帮助加速处理和转发</li><li>TTL-1</li><li>头部checksum</li><li>分片</li><li>头部格式改变帮助QoS</li></ul><figure><img src="image-20241219153945792.png" alt="image-20241219153945792" /><figcaption aria-hidden="true">image-20241219153945792</figcaption></figure><p>相对于IPv4主要的变化:</p><ul><li><strong>扩大的地址容量</strong>。IPv6将IP地址长度 从32比特增加到128比特</li><li>简化高效的40字节首部,<strong>40字节定长首部</strong>允许路由器更快地处理IP数据报</li><li>流标签</li><li><strong>不允许分片</strong>,中间路由器不允许对分组进行分片，如果收 到了过大的分组不能转发到输出链路上只需要将其<strong>丢弃</strong>，<strong>分组的分片和重新装配只能在源/目的端进行</strong></li><li><strong>取消校验和</strong> checksum: 传输层和数据链路层都有这个功能，而且由于TTL字段的存在导致校验和在每个路由器需要重新计算再 写入，影响了路由器的快速转发</li><li>选项 options: 没有完全取消，如果需要可在“下一个首部”字段 中指出</li><li>ICMPv6: ICMP的新版本<ul><li>附加了报文类型, e.g. “Packet Too Big”</li><li>多播组管理功能</li></ul></li></ul><p><strong>IPv4迁移到IPv6</strong></p><p><strong>IPv6向后兼容</strong>，在IPv6系统里可以转发IPv4分组；但<strong>IPv4系统里却不可以转发IPv6分组</strong></p><p><code>隧道</code>: 在<strong>IPv4路由器之间</strong>传输的<strong>IPv4数据报中携带IPv6数据报</strong></p><figure><img src="image-20241219154503178.png" alt="image-20241219154503178" /><figcaption aria-hidden="true">image-20241219154503178</figcaption></figure><figure><img src="image-20241219154539737.png" alt="image-20241219154539737" /><figcaption aria-hidden="true">image-20241219154539737</figcaption></figure><h1 id="网络层控制平面">网络层:控制平面</h1><p>2种构建网络控制平面功能的方法:</p><ul><li>每个路由器控制功能实现（传统）</li><li>逻辑上集中的控制功能实现(SDN)</li></ul><h2 id="路由选择算法">路由选择算法</h2><p><code>路由</code>:按照<strong>某种指标</strong>(传输延迟,所经过的站点数目等)找到一条从源节点到目标节点的<strong>较好路径</strong></p><p>以<strong>网络</strong>为单位进行路由（路由信息通告+路由计算）</p><p><strong>分类:</strong></p><ol type="1"><li>算法是集中式还是分散式来划分<ul><li>集中式路由选择算法: 所有的路由器拥有完整的拓扑和边的代价的信息 eg : “link state”</li><li>分散式路由选择算法:<ul><li>路由器只知道与它有<strong>物理连接关系</strong>的<strong>邻居路由器</strong>，和到相应邻居路由器的代价值</li><li>迭代式地与邻居交换路由信息、 计算路由信息 “distance vector”</li></ul></li></ul></li><li>静态或者动态<ul><li>静态路由选择算法:路由随时间变化缓慢,通常是人工-进行调整（如人为手工编辑一条链路开销）</li><li>动态路由选择算法:路由变化很快,周期性更新,响应拓扑和开销变化</li></ul></li></ol><h3 id="链路状态路由算法link-state">链路状态路由算法(link state)</h3><ul><li>各点通过各种渠道获得<strong>整个网络拓扑</strong>, 网络中<strong>所有链路</strong>代价等信息</li><li>使用LS路由算法,计算本站点到其它站点的最优路径,得到路由表</li></ul><figure><img src="image-20241220114632817.png" alt="image-20241220114632817" /><figcaption aria-hidden="true">image-20241220114632817</figcaption></figure><p><strong>[Dijsktra算法]</strong></p><p>链路状态路由选择算法的其中一种</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   Initialization:</span><br><span class="line">N<span class="comment">&#x27; = &#123;u&#125;</span></span><br><span class="line"><span class="keyword">for</span> all nodes v</span><br><span class="line"><span class="keyword">if</span> v is a neighbor of u</span><br><span class="line"><span class="keyword">then</span> D(v) = c(u,v)</span><br><span class="line"><span class="keyword">else</span> D(v) = INF</span><br><span class="line"></span><br><span class="line">   Loop</span><br><span class="line">find w <span class="keyword">not</span> in N<span class="comment">&#x27; such that D (w) is a minimum</span></span><br><span class="line">add w <span class="keyword">to</span> N<span class="comment">&#x27;</span></span><br><span class="line">update D(v) <span class="keyword">for</span> each neighbor v of w <span class="keyword">and</span> <span class="keyword">not</span> in N<span class="comment">&#x27;</span></span><br><span class="line">D (v) = min (D (v) , D (w) + c (w , v))</span><br><span class="line">/* <span class="keyword">new</span> cost <span class="keyword">to</span> v is either old cost <span class="keyword">to</span> v <span class="keyword">or</span> known</span><br><span class="line">least path cost <span class="keyword">to</span> w plus cost from w <span class="keyword">to</span> v */</span><br><span class="line"></span><br><span class="line">    until N<span class="comment">&#x27;= N</span></span><br></pre></td></tr></table></figure><figure><img src="image-20241220115134276.png" alt="image-20241220115134276" /><figcaption aria-hidden="true">image-20241220115134276</figcaption></figure><figure><img src="image-20241220115150513.png" alt="image-20241220115150513" /><figcaption aria-hidden="true">image-20241220115150513</figcaption></figure><p><strong>算法复杂度:</strong> <span class="math inline">\(O(n^2 )\)</span>可以降到<span class="math inline">\(O(n\log n)\)</span></p><p><strong>存在路由震荡问题</strong></p><h3 id="距离向量dv路由选择算法">距离向量DV路由选择算法</h3><ul><li>迭代的,交换信息并重新计算的过程要一直持续到邻居之间 无更多信息要交换位置（链路状态稳定后自停止）</li><li>异步的,不要求所有节点相互之间步伐一致地操作。</li><li>分布式,每个节点要从一个或多个直接相连的邻居交换某 些信息，并执行计算</li></ul><p><strong>Bellman- Ford方程:</strong></p><p>令<span class="math inline">\(d_x(y)\)</span>是从节点x到节点y的最低开销路径的开销 <span class="math display">\[d_x(y) = \min_v\{c(x,v) + d_v(y) \}\]</span> 方程中的<span class="math inline">\(\min_v\)</span>是对于x的所有邻居的</p><figure><img src="image-20241220134105143.png" alt="image-20241220134105143" /><figcaption aria-hidden="true">image-20241220134105143</figcaption></figure><figure><img src="image-20241220134226740.png" alt="image-20241220134226740" /><figcaption aria-hidden="true">image-20241220134226740</figcaption></figure><p>节点x真正需要知道的不是到y的最短路径距离，而是沿着最短路径到y的 下一跳路由器邻居节点<span class="math inline">\(v^*(y)\)</span>。</p><figure><img src="image-20241220134533654.png" alt="image-20241220134533654" /><figcaption aria-hidden="true">image-20241220134533654</figcaption></figure><p><strong>DV的无穷计数问题</strong></p><blockquote><p>遇到<strong>路由选择环路</strong>，当某链路开销突变，节点计算新的最低开销需要之前其他节点计算得出的链路开销信息，而该信息可能已经无效了，因为链路开销发生了突变，相当于在错误的开销上更新开销，一错再错。</p></blockquote><p>坏消息的传播速度非常慢,好消息传得快</p><p>毒性逆转解决</p><figure><img src="image-20241220134941881.png" alt="image-20241220134941881" /><figcaption aria-hidden="true">image-20241220134941881</figcaption></figure><figure><img src="image-20241220135051006.png" alt="image-20241220135051006" /><figcaption aria-hidden="true">image-20241220135051006</figcaption></figure><h2 id="因特网中自治系统内部的路由选择intra-as">因特网中自治系统内部的路由选择(intra-AS)</h2><p>在相同AS中的路由器都运行相同的路由选择算法并且有彼此的信息。在一个自治系统内运行的路由选择算法叫作自治系统内部路由选择协议</p><h3 id="开放最短路优先ospf">开放最短路优先OSPF</h3><p>“open”: 标准可公开获得</p><p>OSPF是一种链路状态协议，它使用洪泛链路状态信息和Dijkstra最低开销路径算法。</p><p>使用 <code>OSPF</code> ，一台路由器构建了一幅关于整个自治系统的完整拓扑图。于是，每台路由器在本地运行 <code>Dijkstra</code> 的最短路径算法，以确定一个以自身为根节点到所有子网的最短路径树。各条路径开销是由<strong>网络管理员</strong>配置的。使用 <code>OSPF</code> 时，路由器向自治系统内所有其他路由器广播路由选择信息，而不仅仅是向其相邻路由器广播。每当一条链路的状态发生变化时，路由器就会广播链路状态信息。即使链路状态未发生变化，它也要<strong>周期性地广播链路状态</strong>。</p><figure><img src="image-20241220141527468.png" alt="image-20241220141527468" /><figcaption aria-hidden="true">image-20241220141527468</figcaption></figure><figure><img src="image-20241220141546911.png" alt="image-20241220141546911" /><figcaption aria-hidden="true">image-20241220141546911</figcaption></figure><figure><img src="image-20241220141600512.png" alt="image-20241220141600512" /><figcaption aria-hidden="true">image-20241220141600512</figcaption></figure><h2 id="isp之间的路由选择">ISP之间的路由选择</h2><h3 id="bgp">BGP</h3><p>AS间路由选择协议涉及多个AS之间的协调，所以AS通信必须运行相同的AS间路由选择协议。在因特网中，所有的AS运行相同的AS间路由选择协议，称为<code>边界网关协议（Broder Gateway Protocol, BGP）</code></p><p><strong>分布式的 异步的路由选择协议</strong></p><p>胶水协议</p><p>对于位于<strong>相同AS中</strong>的目的地而言，在路由器转发表中的表项由AS内部路由选择协议所决定。而对于位于<strong>该AS外部的目的地</strong>而言情况如何 呢？这正是BGP用武之地</p><ul><li>BGP 提供给每个AS以以下方法：<ul><li><code>eBGP</code>: 从<strong>相邻</strong>的ASes那里<strong>获得</strong>子网可达信息</li><li><code>iBGP</code>: 将获得的子网可达信息传遍到AS内部的所有路由器 ,<strong>逻辑的非物理链路的</strong></li><li>根据子网可达信息和策略来决定到达子网的“好”路径</li></ul></li><li>允许子网向互联网其他网络通告“我在这里”</li><li>基于<code>距离矢量算法（路径矢量）</code>,不仅仅是距离矢量，还包括到达各个目标网络的<code>详细路径</code>（AS 序号的列表）能够<strong>避免简单DV算法的路由环路问题</strong></li></ul><figure><img src="image-20241220142423610.png" alt="image-20241220142423610" /><figcaption aria-hidden="true">image-20241220142423610</figcaption></figure><p><code>BGP 会话</code>: 2个BGP路由器(“peers”)在一个<strong>半永久</strong>的TCP连接上 交换BGP报文:通告向不同目标子网前缀的“路径”（BGP是一个“路径矢量”协议）</p><p><strong>重要的BGP 属性</strong></p><ul><li><code>AS-PATH</code>：包含了通告已经通过的 AS 的列表，当一个前缀通过某 AS 时，该 AS 将其 ASN 加入 <code>AS-PATH</code> 中的现有列表。检测环路；多路径选择</li><li><code>NEXT-HOP</code>：<code>NEXT-HOP</code> 是 <code>AS-PATH</code> 起始的路由器接口的 IP 地址。例如，如图 所指示的那样，对于从 AS1 通过 AS2 到 x 的路由 <code>"AS2 AS3 x"</code>，其属性 <code>NEXT-HOP</code> 是路由器 2a 左边接口的 IP 地址；对于从 AS1 绕过 AS2 到 x 的路由 <code>"AS3 x"</code>，<code>NEXT-HOP</code> 属性是路由器 3d 最左边接口 IP 地址。</li></ul><figure><img src="image-20241220143029257.png" alt="image-20241220143029257" /><figcaption aria-hidden="true">image-20241220143029257</figcaption></figure><p><strong>路由表项是由AS内和 AS间的路由共同决定的</strong></p><figure><img src="image-20241220143341091.png" alt="image-20241220143341091" /><figcaption aria-hidden="true">image-20241220143341091</figcaption></figure><figure><img src="image-20241220143420749.png" alt="image-20241220143420749" /><figcaption aria-hidden="true">image-20241220143420749</figcaption></figure><figure><img src="image-20241220143443826.png" alt="image-20241220143443826" /><figcaption aria-hidden="true">image-20241220143443826</figcaption></figure><figure><img src="image-20241220143838053.png" alt="image-20241220143838053" /><figcaption aria-hidden="true">image-20241220143838053</figcaption></figure><figure><img src="image-20241220143931331.png" alt="image-20241220143931331" /><figcaption aria-hidden="true">image-20241220143931331</figcaption></figure><figure><img src="image-20241220144030914.png" alt="image-20241220144030914" /><figcaption aria-hidden="true">image-20241220144030914</figcaption></figure><h2 id="icmp因特网控制报文协议">ICMP:因特网控制报文协议</h2><ul><li>被<strong>主机</strong>和<strong>路由器</strong>用来彼此沟通<strong>网络层</strong>的信息。</li><li>最典型的用途是<strong>差错报告</strong>。</li><li>从体系结构上位于 IP 之上，处于网络层 , 承载在 IP 分组中，作为 IP 有效载荷承载。</li><li>IP协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是ICMP协议。当传送IP数据包发生错误比如主机不可达，路由不可达等等，ICMP协议将会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会</li><li>主要功能<ul><li>侦测远端主机是否存在</li><li>建立及维护路由资料</li><li>重导数据传送路径</li><li>数据流量控制</li></ul></li></ul><figure><img src="image-20241220144329323.png" alt="image-20241220144329323" /><figcaption aria-hidden="true">image-20241220144329323</figcaption></figure><h1 id="链路层和局域网">链路层和局域网</h1><h2 id="引论和服务">引论和服务</h2><p>在一个<strong>网络内部</strong>如何由一个节点（主机或者路由器）到达另外一个相邻节点:链路层的<strong>点到点</strong>传输层功能</p><p><strong>两种类型的链路层信道</strong>：</p><ul><li><strong>广播信道</strong>，用于局域网，以广播方式通信，需要媒体访问控制。</li><li><strong>点对点信道</strong>，用于核心网里路由器之间长距离连接，控制较简单。</li></ul><p>子网的若干节点的连接方式:</p><ul><li>点到点连接</li><li>多点连接:<ul><li>共享型介质</li><li>通过网络交换机</li></ul></li></ul><p>WAN：网络形式采用点到点链路</p><p>LAN：一般采用多点连接方式</p><blockquote><ul><li>数据链路层负责从一个节点通过<strong>链路</strong>将 （帧中的）数据报发送到<strong>相邻的物理节点</strong> （一个子网内部的2节点）</li><li>数据报（分组）在不同的链路上以不同的链路协议传送</li><li>不同的链路协议提供不同的服务</li></ul></blockquote><h3 id="链路层提供的服务">链路层提供的服务</h3><p>可能的服务如下:</p><ul><li>成帧</li><li>链路接入:<code>MAC(媒体访问控制)协议</code>:规定了帧在链路上传输的规则</li><li>相邻节点的可靠交付:通常用于易产生高差错率的链路</li><li>流量控制</li><li>错误检测和差错纠正</li><li>半双工和全双工</li></ul><blockquote><p>为什么在链路层和传输层都实现了可靠性:</p><p>一般化的链路层服务，不是所有的链路层都提供这些服务 一个特定的链路层只是提供其中一部分的服务</p></blockquote><blockquote><p>为什么要在采用无线链路的网络上，链路层做可靠数据传输工作 ；还要在传输层做端到端的可靠性工作？</p><p>原因：出错率高，如果在链路层不做差错控制工作，漏出去的错误比较高；到了上层如果需要可靠控制的数据传输代价会很大</p></blockquote><p><strong>链路层工作在每一个网络设备上</strong></p><p><strong>链路层的主体部分是在网络适配器中实现的，</strong>网络适配器有时也称为网络接口卡，位于网络适配器核心的是链路层控制器，该控制器通常是一个实现了许多链路层服务（成 帧、链路接入、差错检测等）的专用芯片。因此，链路层控制器的<strong>许多功能</strong>是用<strong>硬件</strong>实现。<strong>链路层主要由硬件实现，也有部分功能用软件如链路层寻址、响应中断。</strong></p><figure><img src="image-20241221103456292.png" alt="image-20241221103456292" /><figcaption aria-hidden="true">image-20241221103456292</figcaption></figure><figure><img src="image-20241221103711011.png" alt="image-20241221103711011" /><figcaption aria-hidden="true">image-20241221103711011</figcaption></figure><h2 id="差错检测和纠正">差错检测和纠正</h2><p><code>比特级差错检测和纠正</code> ,即对从一个节点发送到另一个物理上连接的邻近节点的链路层帧中的比特损伤进行<code>检测和纠正</code>，它们通常是<code>链路层</code>提供的两种服务。</p><h3 id="奇偶校验">奇偶校验</h3><p><strong>[一维奇偶校验]</strong></p><figure><img src="image-20241221104225811.png" alt="image-20241221104225811" /><figcaption aria-hidden="true">image-20241221104225811</figcaption></figure><ul><li>偶校验：发送方保证 <code>d + 1</code> 比特数据中 <code>1</code> 的个数是偶数，如果接收方发现 <code>1</code> 的个数是奇数，则出现了奇数个比特差错</li><li>奇校验:发送方保证 <code>d + 1</code> 比特数据中 <code>1</code> 的个数是奇数，如果接收方发现 <code>1</code> 的个数是偶数，则出现了奇数个比特差错</li><li>差错往往是突发的，而非独立的，检错率50%</li></ul><p><strong>[二维奇偶校验]</strong></p><figure><img src="image-20241221104450246.png" alt="image-20241221104450246" /><figcaption aria-hidden="true">image-20241221104450246</figcaption></figure><p>接收方不仅可以检测到出现了单个比特差错的事实，而且还可以利用存在奇偶校验差错的列和行的索引来实际识别发生差错的比特并<strong>纠正</strong>它。</p><p>接收方检测和纠正差错的能力被称为<strong>前向纠错（FEC）</strong>。</p><h3 id="internet校验和">Internet校验和</h3><p>检测在传输报文段时的错误（如位翻转），（注： 仅仅用在<code>传输层</code>）,相对于CRC码来讲检错能力弱</p><figure><img src="image-20241221104744707.png" alt="image-20241221104744707" /><figcaption aria-hidden="true">image-20241221104744707</figcaption></figure><blockquote><p>为什么运输层使用检验和而链路层使用CRC呢？</p><p>前面讲过运输层常是在主机中作为用户操作系统的一部分用软件实现的。因为运输层差错检测用软件实现，采用简单而快速如检验和这样的差错检测方案是重要的。</p><p>在另一方面，链路层的差错检测在适配器中用专用的硬件实现，它能够快速执行更复杂的CRC操作。</p></blockquote><h3 id="检验和crc循环冗余校验">检验和:CRC(循环冗余校验)</h3><p>强大的差错检测码</p><p><strong>[思想]</strong></p><ul><li>将要发送的二进制数看做是0或1为系数的一个多项式 D。</li><li>发送方和接收方事先协商一个r+1比特的生成多项式 G</li><li>选择r位CRC附加位R，使得:<ul><li>正好被 G整除 (模2运算)</li><li>接收方知道 G, 将 除以 G. 如果非0余数: 检查出错误!</li><li>能检出所有少于r+1位的突发错误</li></ul></li></ul><figure><img src="image-20241221105808649.png" alt="image-20241221105808649" /><figcaption aria-hidden="true">image-20241221105808649</figcaption></figure><p><strong>模2算数前提下,加法和减法相同且等价于按位异或</strong></p><p>如何选择R:</p><p>R满足:$D ^r  XOR  R =nG $</p><p>则: $D ^r = nG XOR R $</p><p><strong>由于位模2运算,异或等价于加减法,那么我们用左边除以<span class="math inline">\(G\)</span>余数即为<span class="math inline">\(R\)</span></strong></p><figure><img src="image-20241221110659877.png" alt="image-20241221110659877" /><figcaption aria-hidden="true">image-20241221110659877</figcaption></figure><figure><img src="image-20241221110825599.png" alt="image-20241221110825599" /><figcaption aria-hidden="true">image-20241221110825599</figcaption></figure><h2 id="多路访问链路和协议">多路访问链路和协议</h2><p>两种类型的链路（一个子网内部链路连接形式）：</p><ul><li>点对点</li><li>拨号访问的PPP</li><li>以太网交换机和主机之间的点对点链路 (以太网是是一种广泛使用的局域网（LAN）技术)</li><li>广播 (<code>共享</code>线路或媒体)</li><li>传统以太网</li><li>HFC上行链路</li><li>802.11无线局域</li></ul><p>在<code>共享广播信道</code>里</p><ul><li>2个或更多站点同时传送: 碰撞</li><li>当发生碰撞时，没有一个接收节点能有效的获得传输的帧；</li><li>碰撞的帧重叠在一起，所有涉及的帧传输都失败了；</li><li>如果许多节点要频繁的传输帧会加剧碰撞浪费带宽</li></ul><p>如何协调多个发送和接收节点对一个<code>共享广播信道</code>的访问，这就是<code>多路访问问题</code></p><p><code>多路访问协议</code>:用于控制<code>共享广播信道</code>里的节点如何传输帧的<code>分布式算法</code></p><figure><img src="image-20241221111953017.png" alt="image-20241221111953017" /><figcaption aria-hidden="true">image-20241221111953017</figcaption></figure><p><strong>多路访问(MAC)协议划分为3种类型:</strong></p><ul><li>信道划分协议<ul><li>把信道划分成小片（时间、频率、编码）</li><li>分配片给每个节点专用</li></ul></li><li>随机接入协议<ul><li>信道不划分，允许碰撞</li><li>碰撞后恢复</li></ul></li><li>轮流协议<ul><li>节点依次轮流</li><li>但是有很多数据传输的节点可以获得较长的信道使用权</li></ul></li></ul><h3 id="信道划分mac协议">信道划分MAC协议</h3><p><code>时分多路复用（TDM）</code>：TDM 将时间划分为时间帧，并进一步划分每个时间帧为 N 个时隙，然后把每个时隙分配给 N 个节点中的一个。无论何时某个节点在有分组要发送的时候，它在循环的 TDM 帧中指派给它的时隙内传输分组比特。通常，选择的时隙长度应使一个时隙内能够传输单个分组。</p><p>如果站点无帧传输，时隙空闲-》浪费</p><p><code>频分多路复用（FDM）</code>：FDM 将 R bps 信道划分为不同的频段（每个频段具有 R/N 带宽），并把每个频率分配给 N 个节点中的一个。因此 FDM 在单个较大的 R bps 信道中创建了 N 个较小的 R/N bps 信道</p><p>分配给站点的频段如果没有被使用，则空闲</p><figure><img src="image-20241221112423891.png" alt="image-20241221112423891" /><figcaption aria-hidden="true">image-20241221112423891</figcaption></figure><p><code>码分多路访问CDMA</code>:</p><ul><li>所有站点在整个频段上同时进行传输, 采用编码原理加以区分</li><li>完全无冲突</li><li>假定:信号同步很好,线性叠加</li></ul><h3 id="随机访问协议">随机访问协议</h3><blockquote><p>一个传输节点总是以信道的<code>全部速率</code>（即Kbps）进行发送。当有碰撞时，涉及碰撞的每个节点<code>反复地重发</code>它 的帧（也就是分组），到该帧<code>无碰撞地</code>通过为止。但是当一个节点经历一次碰撞时，它<code>不必立刻重发</code>该帧。相反，它在重发该帧之前<code>等待一个随机时延</code>。涉及碰撞的每个节点 <code>独立地</code>选择随机时延。</p></blockquote><p>随机访问协议要解决/规定:</p><ul><li>如何检测碰撞</li><li>如何从碰撞中恢复</li></ul><p><strong>常见的随机访问协议</strong>:</p><ul><li>时隙ALOHA</li><li>ALOHA(纯ALOHA)</li><li>CSMA,CSMA/CD,CSMA/CA (载波监听多路访问)</li></ul><p><strong>时隙ALOHA</strong></p><blockquote><p>假设:</p><ol type="1"><li>所有帧由L比特组成。</li><li>时间被划分成长度为L/R秒的时隙（这就是说，一个时隙等于传输一帧的时间）。</li><li>节点只在时隙起点开始传输帧。</li><li>节点是同步的，每个节点都知道时隙何时开始。</li><li>如果在一个时隙中有两个或者更多个帧碰撞，则所有节点在该时隙结束之前检测到该碰撞事件。</li></ol></blockquote><p>在每个节点中，时隙ALOHA的<code>操作:</code></p><ul><li>当节点获取新的帧，在下一 个时隙传输</li><li>传输时没有检测到冲突，成功<ul><li>节点能够在下一时隙发送新帧</li></ul></li><li>检测时如果检测到冲突，失败<ul><li>节点在每一个随后的时隙以概率p重传帧直到成功</li></ul></li></ul><p><code>优点</code>:</p><ul><li>节点可以以信道带宽全速连续传输</li><li>高度分散：仅需要节点之间在时隙上的同步,每个节点检测碰撞并独立地决定什么时候重传</li><li>简单</li></ul><p><code>缺点:</code></p><ul><li>存在冲突，浪费时隙</li><li>即使有帧要发送，仍然有可能存在空闲的时隙</li><li>节点检测冲突的时间&lt;帧传输的时间<ul><li>必须传完</li></ul></li><li>需要时钟上同步</li></ul><figure><img src="image-20241221144558625.png" alt="image-20241221144558625" /><figcaption aria-hidden="true">image-20241221144558625</figcaption></figure><figure><img src="image-20241221144714528.png" alt="image-20241221144714528" /><figcaption aria-hidden="true">image-20241221144714528</figcaption></figure><p><strong>ALOHA/纯ALOHA(非时隙)</strong></p><blockquote><p>在<code>纯 ALOHA中</code>，当一帧首次到达（即一个网络层数据报在发送节点从网络层传递下来），节点 <code>立刻</code>将该帧完整地传输进广播信道。如果一个传输的帧与一个或多个传输经历了碰撞，这个节点将<code>立即</code>（<strong>在完全传输完它的碰撞帧之后</strong>）以概率p重传该帧。否则，该节点等待一个帧传输时间。在此等待之后，它则以概率p传输该帧，或者以概率1-p在另一个帧时间等待（保持空闲）。</p></blockquote><ul><li><p>简单、无须节点间在时间上同步</p></li><li><p>当有帧需要传输：马上传输</p></li><li><p>冲突的概率增加:</p><ul><li>帧在t0 发送，和其它在[t0 -1, t0 +1]区间内开始发送的帧冲突</li><li>和当前帧冲突的区间（其他帧在此区间开始传输）增大了一倍</li></ul><figure><img src="image-20241221145158341.png" alt="image-20241221145158341" /><figcaption aria-hidden="true">image-20241221145158341</figcaption></figure></li></ul><figure><img src="image-20241221145052473.png" alt="image-20241221145052473" /><figcaption aria-hidden="true">image-20241221145052473</figcaption></figure><p><strong>CSMA(载波侦听多路访问)</strong></p><blockquote><p>在时隙和纯ALOHA中，一个节点传输的决定独立于连接到这个广播信道上的其他节 点的活动。特别是，<strong>一个节点不关心在它开始传输时是否有其他节点碰巧在传输</strong>，而且即使有另一个节点开始干扰它的传输也不会停止传输。</p></blockquote><p><code>载波侦听(carrier sensing)</code>,即一个节点在<strong>传输前先听信道</strong>。如果来自另一 个节点的帧正向信道上发送，节点则等待直到<strong>检测到一小段时间没有传输，然后开始传输</strong>。</p><p><code>碰撞检测(collision detection)</code>,即当一个传输节点在<strong>传输时一直在侦听此信道</strong>。如果它检测到另 一个节点正在传输干扰帧，它就停止传输，在重复“<strong>侦听-当空闲时传输</strong>”循环之前<strong>等待一段随机时间</strong>。</p><p>CSMA: <strong>在传输前先侦听信道</strong>:</p><ul><li>如果侦听到信道空闲，传送整个帧</li><li>如果侦听到信道忙，推迟传送</li></ul><p>但仍然会发生碰撞,由于<code>端到端信道传播延迟</code>造成两个节点可能侦听不到正在进行的传输,并且该传播时延越长，载波侦听节点不能侦听到网络中另一个节点已经开始传输的机会就越大</p><p>例如:在时刻<span class="math inline">\(t_0\)</span>,节点B侦听到信道是空闲的，因为当前没有其他节点在传输。因此节点B开始传输，沿着广播媒体在两个方向上传播它的比特。图中B的比特随着时间的增加向下传播，这表明B的比特沿着广播媒体传播所实际需要的时间不是零（虽然以接近光 的速度）。在时刻<span class="math inline">\(t_1(t_1&gt;t_0)\)</span>,节点D有一个帧要发送。尽管节点B在时刻<span class="math inline">\(t_1\)</span>正在传输, 但B传输的比特还没有到达D,因此D在<span class="math inline">\(t_1\)</span>侦听到信道空闲。根据CSMA协议，从而D开始传输它的帧。一个短暂的时间之后，B的传输开始在D干扰D的传输</p><figure><img src="image-20241221150109348.png" alt="image-20241221150109348" /><figcaption aria-hidden="true">image-20241221150109348</figcaption></figure><p><strong>CSMA/CD(具有<u>碰撞检测</u>的载波侦听多路访问)</strong></p><p><code>碰撞检测(collision detection)</code>,即当一个传输节点在<strong>传输时一直在侦听此信道</strong>。如果它检测到另 一个节点正在传输干扰帧，它就停止传输，在重复“<strong>侦听-当空闲时传输</strong>”循环之前<strong>等待一段随机时间</strong>。</p><p>CSMA/CD:</p><ul><li>载波侦听CSMA：和在CSMA中一样发送前侦听信道</li><li>没有传完一个帧就可以在短时间内检测到冲突</li><li>冲突发生时则传输终止，减少对信道的浪费</li></ul><p>碰撞检测(CD)技术，<strong>有线局域网中容易实现</strong>:检测信号强度，比较传输与接收到的信号是否相同 或者 通过周期的过零点检测,<strong>无线局域网中较难实现</strong></p><figure><img src="image-20241221150843794.png" alt="image-20241221150843794" /><figcaption aria-hidden="true">image-20241221150843794</figcaption></figure><blockquote><p>在从与广播信道相连的适配器（在节点中）的角 度总结它的运行：</p><ol type="1"><li>适配器从网络层一条获得数据报，准备链路层帧，并将其放入帧适配器缓存中。</li><li>如果适配器侦听到信道空闲（即无信号能量从信道进入适配器），它开始传输帧。在另一方面，如果适配器侦听到信道正在忙，它将等待，直到侦听到没有信号能量时才开始传输帧。</li><li>在传输过程中，适配器监视来自其他使用该广播信道的适配器的信号能量的存在。</li><li>如果适配器传输整个帧而未检测到来自其他适配器的信号能量，该适配器就完成了该帧。在另一方面，如果适配器在传输时检测到来自其他适配器的信号能量，它中止传输（即它停止了传输帧）。 除放弃外，还发送一个Jam 信号，所有听到冲突的适配器也是如此 强化冲突：让所有站点都知道冲突</li><li>中止传输后，适配器等待一个<u>随机时间量</u>，然后返回步骤2。</li></ol></blockquote><p><strong>如何确认退避时间？</strong></p><ul><li>退避时间长，信道空闲浪费</li><li>退避时间短，会发生再次碰撞造成反复重传</li></ul><p><code>二进制指数退避算法</code>:在第<span class="math inline">\(m\)</span>次失败后，适配器从$ { 0，1，2， ， 2^m-1 } <span class="math inline">\(中随机选择一个\)</span>K<span class="math inline">\(，等待\)</span>K*512<span class="math inline">\(比特时间(即发送512比特进入以太网所需时间量的K倍)时 ，然后转到上述的步骤2 ,\)</span>m$的最大值在10以内</p><blockquote><p>假设一个适配器首次尝试传输一个帧，并在传输中它检测到碰撞。然后该节点以概率0.5选择<span class="math inline">\(K=0\)</span>,以概率0.5选择<span class="math inline">\(K = 1\)</span> , 如果该节点选择<span class="math inline">\(K=0\)</span>,则它立即开始侦听信道。如果这个适配器选择$K = 1 $,它在开始“侦听-当空闲时传输” 。周期前等待512比特时间（例如对于100Mbps以太网来说为5. 12ms）。在第2次碰撞之后，从 <span class="math inline">\((0, 1, 2, 3]\)</span>中等概率地选择<span class="math inline">\(K\)</span>。在第3次碰撞之后，从<span class="math inline">\((0, 1, 2, 3, 4, 5, 6, 7]\)</span> 中等概率地选择<span class="math inline">\(K\)</span>。在10次或更多次碰撞之后，从<span class="math inline">\(\{0, 1, 2,\cdots ,1023\}\)</span>中等概率地选择<span class="math inline">\(K\)</span>。因此从中选择K的集合长度随着碰撞次数呈<code>指数增长</code>；正是由于这个原因，该算法被称为<code>二进制指数后退</code>。</p></blockquote><figure><img src="image-20241221152104889.png" alt="image-20241221152104889" /><figcaption aria-hidden="true">image-20241221152104889</figcaption></figure><h3 id="轮流协议">轮流协议</h3><figure><img src="image-20241221153354829.png" alt="image-20241221153354829" /><figcaption aria-hidden="true">image-20241221153354829</figcaption></figure><p><strong>轮询</strong></p><figure><img src="image-20241221153425319.png" alt="image-20241221153425319" /><figcaption aria-hidden="true">image-20241221153425319</figcaption></figure><p><strong>令牌传递</strong></p><figure><img src="image-20241221153513815.png" alt="image-20241221153513815" /><figcaption aria-hidden="true">image-20241221153513815</figcaption></figure><figure><img src="image-20241221153616037.png" alt="image-20241221153616037" /><figcaption aria-hidden="true">image-20241221153616037</figcaption></figure><h2 id="局域网">局域网</h2><h3 id="链路层寻址和arp">链路层寻址和ARP</h3><p><strong>MAC地址/LAN地址/物理地址</strong></p><p>事实上，并不是主机或路由器具有链路层地址，而是它们的适配器（即网络接口）具有链路层地址,因此，具有多个网络接口的主机或路由器将具有与之相关联的多个链路层 地址，就像它也具有与之相关联的多个IP地址一样。</p><p>链路层交换机并不具有与它们的接口（这些接口是与主机和路由器相连的）相关联的链路层地址</p><figure><img src="image-20241221155357264.png" alt="image-20241221155357264" /><figcaption aria-hidden="true">image-20241221155357264</figcaption></figure><figure><img src="image-20241221155524292.png" alt="image-20241221155524292" /><figcaption aria-hidden="true">image-20241221155524292</figcaption></figure><figure><img src="image-20241221155550093.png" alt="image-20241221155550093" /><figcaption aria-hidden="true">image-20241221155550093</figcaption></figure><p>局域网上每个适配器都有一个唯一的LAN地址</p><figure><img src="image-20241221155610756.png" alt="image-20241221155610756" /><figcaption aria-hidden="true">image-20241221155610756</figcaption></figure><p><strong>ARP协议(地址解析协议)</strong></p><p>因为存在网络层地址（例如，因特网的IP地址）和链路层地址（即MAC地址），所 以需要在它们之间进行转换。对于因特网而言，这是地址解析协议。</p><ul><li>在LAN上的每个IP节点都有一个ARP表</li><li>ARP表：包括一些 LAN节点IP/MAC地 址的映射</li><li>&lt; IP address; MAC address; TTL&gt;<ul><li>TTL时间是指地址映射失效的时间</li><li>典型是20mi</li></ul></li><li><strong>查询 ARP 报文是在广播帧中发送的，而响应 ARP 报文是在一个标准帧中发送</strong></li><li><strong>只为在一个子网上的主机和路由器接口解析 IP 地址</strong></li></ul><figure><img src="image-20241221160210877.png" alt="image-20241221160210877" /><figcaption aria-hidden="true">image-20241221160210877</figcaption></figure><figure><img src="image-20241221160348096.png" alt="image-20241221160348096" /><figcaption aria-hidden="true">image-20241221160348096</figcaption></figure><figure><img src="image-20241221160422000.png" alt="image-20241221160422000" /><figcaption aria-hidden="true">image-20241221160422000</figcaption></figure><figure><img src="image-20241221160442811.png" alt="image-20241221160442811" /><figcaption aria-hidden="true">image-20241221160442811</figcaption></figure><figure><img src="image-20241221160524817.png" alt="image-20241221160524817" /><figcaption aria-hidden="true">image-20241221160524817</figcaption></figure><figure><img src="image-20241221160649760.png" alt="image-20241221160649760" /><figcaption aria-hidden="true">image-20241221160649760</figcaption></figure><h3 id="以太网">以太网</h3><p>以太网几乎占领着现有的<code>有线局域网市场</code></p><figure><img src="image-20241221160807454.png" alt="image-20241221160807454" /><figcaption aria-hidden="true">image-20241221160807454</figcaption></figure><h3 id="物理拓扑">物理拓扑</h3><figure><img src="image-20241221161318609.png" alt="image-20241221161318609" /><figcaption aria-hidden="true">image-20241221161318609</figcaption></figure><h3 id="以太帧结构">以太帧结构</h3><figure><img src="image-20241221161403558.png" alt="image-20241221161403558" /><figcaption aria-hidden="true">image-20241221161403558</figcaption></figure><p><strong>前同步码(8Byte):</strong></p><ul><li>7Byte 10101010 + 1Byte 10101011</li><li>用来同步接收方和发送方的时钟速率<ul><li>使得接收方将自己的时钟调到发送端的时钟</li><li>从而可以按照发送端的时钟来接收所发送的帧</li></ul></li></ul><p><strong>目的地址/源地址:6字节</strong></p><ul><li>如果帧目标地址与本站MAC地址相同，或者目标地址为广播地址那就接收，递交帧中的数据到网络层</li><li>否则，适配器忽略该帧</li></ul><p><strong>类型</strong>:指出高层协议(大多情况下是IP，但也支持其它网络层协议)</p><p><strong>CRC：</strong>在<strong>接收方校验</strong></p><ul><li>如果没有通过校验，丢弃错误帧</li></ul><p>所有以太网技术都向网络层提供<strong>无连接服务</strong>和<strong>不可靠服务</strong>。</p><ul><li>无连接：帧传输前，发送方和接收方之间没有握手</li><li>不可靠：接收方适配器不发送ACKs或NAKs给发送方<ul><li>递交给网络层的数据报流可能有间隙</li><li>如上层使用像传输层TCP协议这样的rdt，间隙会被补上( 源主机，TCP实体)</li><li>否则，应用层就会看到gap</li></ul></li><li>以太网的MAC协议：采用二进制退避的CSMA/CD 介质访问控制形式</li></ul><figure><img src="image-20241221162109771.png" alt="image-20241221162109771" /><figcaption aria-hidden="true">image-20241221162109771</figcaption></figure><h2 id="交换机">交换机</h2><ul><li><p>任务：接收入链路层帧并将它们转发到出链路。</p></li><li><p>链路层设备：扮演主动角色（端口执行以太网协议）</p><ul><li>对帧进行存储和转发</li><li>对于到来的帧，检查帧头，根据目标MAC地址进行选择性 转发</li><li>当帧需要向某个（些）网段进行转发，需要使用 CSMA/CD进行接入控制</li><li>通常一个交换机端口一个独立网段</li></ul></li><li><p>透明：主机对交换机的存在可以不关心</p><ul><li>通过交换机相联的各节点好像这些站点是直接相联的一样</li><li>有MAC地址；无IP地址</li></ul></li><li><p>即插即用，自学习</p><ul><li>交换机无需配置</li></ul></li></ul><figure><img src="image-20241221162645075.png" alt="image-20241221162645075" /><figcaption aria-hidden="true">image-20241221162645075</figcaption></figure><figure><img src="image-20241221162806138.png" alt="image-20241221162806138" /><figcaption aria-hidden="true">image-20241221162806138</figcaption></figure><figure><img src="image-20241221162824613.png" alt="image-20241221162824613" /><figcaption aria-hidden="true">image-20241221162824613</figcaption></figure><figure><img src="image-20241221163045040.png" alt="image-20241221163045040" /><figcaption aria-hidden="true">image-20241221163045040</figcaption></figure><p><code>过滤（filtering）</code>是决定一个帧应该转发到某个接口还是应当将其丢弃的交换机功能。</p><p><code>转发（forwarding）</code>是决定一个帧应该被导向哪个接口，并把该帧移动到那些接口的交换机功能。交换机的过滤和转发借助于<strong>交换机表（switch table）</strong>完成。</p><figure><img src="image-20241221163228796.png" alt="image-20241221163228796" /><figcaption aria-hidden="true">image-20241221163228796</figcaption></figure><figure><img src="image-20241221163318394.png" alt="image-20241221163318394" /><figcaption aria-hidden="true">image-20241221163318394</figcaption></figure><figure><img src="image-20241221163416878.png" alt="image-20241221163416878" /><figcaption aria-hidden="true">image-20241221163416878</figcaption></figure><figure><img src="image-20241221163424668.png" alt="image-20241221163424668" /><figcaption aria-hidden="true">image-20241221163424668</figcaption></figure><h3 id="vlan虚拟局域网">VLAN(虚拟局域网)</h3><p>支持 VLAN 的交换机允许经一个单一的物理局域网基础设施定义多个虚拟局域网。</p><figure><img src="image-20241221163650382.png" alt="image-20241221163650382" /><figcaption aria-hidden="true">image-20241221163650382</figcaption></figure><figure><img src="image-20241221163743913.png" alt="image-20241221163743913" /><figcaption aria-hidden="true">image-20241221163743913</figcaption></figure><figure><img src="image-20241221163851470.png" alt="image-20241221163851470" /><figcaption aria-hidden="true">image-20241221163851470</figcaption></figure><figure><img src="image-20241221163902257.png" alt="image-20241221163902257" /><figcaption aria-hidden="true">image-20241221163902257</figcaption></figure><h1 id="无线网络和移动网络">无线网络和移动网络</h1><h2 id="无线链路特征">无线链路、特征</h2><figure><img src="image-20241222101338352.png" alt="image-20241222101338352" /><figcaption aria-hidden="true">image-20241222101338352</figcaption></figure><p><strong>无线网络的构件</strong></p><ul><li><p><strong>无线主机</strong>：运行应用程序的端系统设备。可以是便携机、掌上机、智能手机或者桌面计算机。主机本身可以移动，也可能不移动。</p></li><li><p><strong>无线链路</strong>：主机通过无线通信链路连接到一个基站或者另一个无线主机。不同的无线链路技术具有不同的传输速率和能够传输不同的距离。</p></li><li><p><strong>基站</strong>：无线网络基础设施的一个关键部分。与无线主机和无线链路不同，基站在有线网络中没有明确的对应设备。它<strong>负责向与之关联的无线主机发送数据和从主机那里接收数据</strong>。基站通常<strong>负责协调与之相关联的多个无线主机的传输</strong>。</p><ul><li>一台无线主机与某基站“相关联”：1️⃣ 该主机位于该基站的无线通信覆盖范围内；2️⃣ 该主机使用该基站中继它和更大网络之间的数据</li></ul></li><li><p><strong>切换</strong>：当一台移动主机的移动超出一个基站的覆盖范围而到达另一个基站的覆盖范围后，它将改变其接入到更大的网络的连接点（即改变与之相关联的基站）。</p></li><li><p>与基站关联的主机通常被称为以<strong>基础设施模式</strong>运行。因为所有传统的网络服务（如地址分配和路由选择）都由网络向通过基站相连的主机提供。</p></li><li><p>在<strong>自组织网络</strong>中，无线主机没有这样的基础设施与之相连。在没有这样的基础设施的情况下，主机本身必须提供诸如路由选择、地址分配、类似于 DNS 的名字转换等服务。</p></li></ul><hr /><p><strong>无线网络分类</strong></p><ul><li>单跳，基于基础设施<ul><li>具有与较大的有线网络连接的基站。该基站与无线主机之间的所有通信都经过一个无线跳。</li><li><code>802.11</code>网络、<code>4G LTE</code> 数据网络。</li></ul></li><li>单跳，无基础设施<ul><li>不存在与无线网络相连的基站。单跳网络中的一个节点可以协调其他节点的传输。</li><li>蓝牙网络、具有自组织模式的 <code>802.11</code> 网络。</li></ul></li><li>多跳，基于基础设施<ul><li>一个基站表现为以有线方式与较大网络相连。某种无线节点为了经该基站通信，可能不得不通过其他无线节点中继它们的通信。</li><li>无线传感网络、无线网状网络</li></ul></li><li>多跳，无基础设施<ul><li>网络中没有基站，并且节点为了到达目的地可能必须在几个其他无线节点之间中继报文。</li><li>移动自组织网络（MANET）、车载自组织网络（VANET）</li></ul></li></ul><hr /><p><strong>无线链路和网络特征</strong></p><ul><li><strong>路径损耗</strong>：电磁波在穿过物体时强度将减弱。即使在自由空间中，信号仍将扩散，这使得信号强度随着发送方和接收方距离的增加而减弱。</li><li><strong>多径传播</strong>：当电磁波的一部分受物体和地面反射，在发送方和接收方之间走了不同长度的路径，则会出现多径传播。这使得接收方收到的信号变得模糊。位于发送方和接收方之间的移动物体可导致多径传播随时间而改变。</li><li><strong>来自其他源的干扰</strong>：在同一个频段发送信号的电波源将相互干扰</li></ul><figure><img src="image-20241222101654545.png" alt="image-20241222101654545" /><figcaption aria-hidden="true">image-20241222101654545</figcaption></figure><ul><li><p><strong>信噪比（SNR）</strong>：所收到的信号和噪声强度的相对测量。单位是分贝（dB）。</p></li><li><p><strong>比特差错率（BER）</strong>：在接收方收到的有错传输比特的概率</p></li><li><p><strong>对于给定的调制方案，SNR越高，BER 越低</strong>,由于发送方通过增加它的传输功率就能够增加SNR,因此发送方能够通过增加它的传输功率来降低接收到差错帧的概率 ,当该功率超过某个阈值时，,可证明几乎不会有实际增益.也会伴随着一些缺点：发送方必须消耗更多的能量（对于用电池供电的移动用户，这一点非常重要），并且发送方的传输更可能干扰另一个发送方的传输</p></li><li><p><strong>对于给定的SNR , 具有较高比特传输率的调制技术将具有较高的BER</strong></p></li><li><p><strong>物理层调制技术的动态选择能用于适配对信道条件的调制技术。</strong></p></li></ul><hr /><p><strong>接收方无法检测到碰撞的两种情况：</strong></p><ul><li><strong>隐藏终端问题</strong>：即使 <code>A</code> 和 <code>C</code> 的传输确实是在目的地 <code>B</code> 发生干扰，环境的物理阻拦（大山、建筑）也可能会妨碍 <code>A</code> 和<code>C</code> 互相听到对方的传输。</li><li><strong>衰减</strong>：<code>A</code> 和 <code>C</code> 所处的位置使得它们的信号强度不足以使它们相互检测到对方的传输，然而它们的传输足以强到在站点 B 处相互干扰。 <img src="2288178-20230210172501873-1026101834.png" alt="img" /></li></ul><hr /><h3 id="cdma码分多址">CDMA(码分多址)</h3><p>码分多址(Code Division Multiple Access, CDMA)属于<code>信道划分协议族</code>。它在无线LAN和蜂窝技术中应用很广泛。</p><p>要发送的每个<code>比特</code>都通过乘以一个信号（编码）的比特来进行编码，这个信号的变化速率（通常称为<strong>码片速率</strong>， chipping rate) 比初始数据比特序列的变化速率快得多。</p><figure><img src="image-20241222102223846.png" alt="image-20241222102223846" /><figcaption aria-hidden="true">image-20241222102223846</figcaption></figure><ul><li><span class="math inline">\(d_i\)</span>：第<span class="math inline">\(i\)</span> 个比特时隙中的数据比特值。</li><li>$Z_{i,m}=d_i⋅c_m $：对于 <span class="math inline">\(d_i\)</span> 比特传输时间的第 <span class="math inline">\(m\)</span> 个微时隙,CDMA 编码器的输出 <span class="math inline">\(Z_{i,m}\)</span>,是 <span class="math inline">\(d_i\)</span> 乘以分配的 $CDMA $编码的第 <span class="math inline">\(m\)</span> 比特 <span class="math inline">\(c_m\)</span>。</li><li><span class="math inline">\(d_i=\frac{∑_{m=1}^{M}Z_{i,m}⋅c_m}{M}\)</span> ：接收方恢复初始的数据比特。</li><li>当有多个发送方干扰目标发送方时，CDMA 假设对干扰的传输比特信号是<strong>加性的</strong>；接收方收到的值是在那个微时隙中从所有 N 个发送方传输的比特的总和，使用目标发送方的 CDMA 编码可以提取出目标发送方的初始数据比特。</li></ul><figure><img src="image-20241222102356703.png" alt="image-20241222102356703" /><figcaption aria-hidden="true">image-20241222102356703</figcaption></figure><h2 id="ieee-802.11-无线局域网">IEEE 802.11 无线局域网</h2><ul><li><code>IEEE 802.11 无线 LAN（WiFi）协议族</code>：无线 <code>LAN</code> 标准。</li></ul><figure><img src="image-20241222113829336.png" alt="image-20241222113829336" /><figcaption aria-hidden="true">image-20241222113829336</figcaption></figure><p>上述协议都</p><ul><li>采用CSMA/CA媒体访问协议</li><li>使用相同的链路层帧结构</li><li>都向后兼容</li></ul><h3 id="体系结构">802.11体系结构</h3><figure><img src="image-20241222113911297.png" alt="image-20241222113911297" /><figcaption aria-hidden="true">image-20241222113911297</figcaption></figure><ul><li>802.11体系结构的<code>基本构件模块</code>是基本服务集（Basic Service Set, BSS）</li><li>一个BSS包含一个或多个<code>无线站点</code>和一个在 802. 11术语中称为<strong><code>接入点</code>（ AP）的中央基站</strong></li><li><strong>每个802. 11无线站点都具有一个6字节的MAC地址</strong>，该地址 储在该站适配器（即802. 11网络接口卡）的固件中,<strong>每个AP的无线接口也具有一个 MAC地址</strong>。与以太网类似，这些MAC地址由IEEE管理，理论上是全球唯一的。</li><li>配置AP的无线LAN经常被称作<code>基础设施无线LAN</code>,其中的“基础设施”是指AP连同互联AP和一台路由器的有线以太网</li></ul><h3 id="信道与关联">信道与关联</h3><ul><li>在802. 11中，每个<code>无线站点</code>在能够发送或者接收网络层数据之前，必须与一个AP相 <code>关联</code> , 关联意味 着这一无线站点在自身和该AP之间创建一个虚拟线路。</li><li>当网络管理员安装一个<code>AP</code>时，管理员为该接入点分配一个单字或双字的<code>服务集标识符(Service Set Identifier, SSID)</code>管理员还必须为该AP分配一个<code>信道号。</code></li><li><code>WiFi丛林(WiFi jungle)</code>是一个任意物理位置，在这里无线站点能从<code>两个或多个</code>AP中收到很强的信号。</li><li>802.11标准要求<code>每个AP周期性</code>地发送<code>信标帧(beacon frame)</code>,每个信标帧包括该AP 的<code>SSID和MAC地址</code></li><li><strong>被动扫描</strong>：扫描信道和监听信标帧的过程。</li><li><strong>主动扫描</strong>：通过向位于无线主机范围内的所有 <code>AP</code> 广播探测帧完成的。AP 用一个探测响应帧应答探测请求帧。无线主机则能够在响应的 AP 中选择某 AP 与之相关联。</li></ul><figure><img src="image-20241222114918980.png" alt="image-20241222114918980" /><figcaption aria-hidden="true">image-20241222114918980</figcaption></figure><h3 id="mac协议">802.11 MAC协议</h3><ul><li>我们将无线设备或AP称为站点（station）,它们共享<code>多个接入信道</code></li><li>802.11的设计者为802. 11无线LAN选择了一种<code>随机访问协议</code>。这个随机访问 协议称作<code>带碰撞避免的CSMA （ CSMA with collision avoidance）</code>,或简称为<code>CSMA/CA</code></li><li>尽管以太网 和802. 11都使用载波侦听随机接入，但这两种MAC协议<strong>有重要的区别</strong>:<ul><li>首先，802. 11 使用<strong>碰撞避免</strong>而非碰撞检测。</li><li>其次，由于无线信道相对较高的误比特率，802. 11 使用<strong>链路层确认/重传（ARQ）方案</strong>,（不同于以太网)。</li></ul></li><li>802.11 MAC协议并未实现碰撞检测。这主要由两个重要的原因所致:<ul><li>检测碰撞的能力要求站点具有同时发送（站点自己的信号）和接收（检测其他站 点是否也在发送）的能力。因为在802. 11适配器上，接收信号的强度通常远远小 于发送信号的强度，制造具有检测碰撞能力的硬件代价较大。</li><li>更重要的是，即使适配器可以同时发送和监听信号（并且假设它一旦侦听到信道 忙就放弃发送），适配器也会由于隐藏终端问题和衰减问题而无法检测到所有的碰 撞</li></ul></li></ul><p>由于802. 11无线局域网不使用碰撞检测，一旦站点开始发送一个帧，它就完全地发送该帧</p><p>802.11 使用<strong>链路层确认/重传</strong>（ARQ）</p><p>目的站点收到一个通过 CRC 校验的帧后，它等待一个被称为<strong>短帧间间隔（SIFS）</strong>的一小段时间，然后发挥一个确认帧。如果发送站点在给定的时间内未收到确认帧，它假定出现了错误并重传该帧，使用 <code>CSMA/CA</code> 协议访问该信道 。如果在若干固定次重传后仍未收到确认，发送站点将放弃发送并丢弃该帧。</p><figure><img src="image-20241222115409912.png" alt="image-20241222115409912" /><figcaption aria-hidden="true">image-20241222115409912</figcaption></figure><ol type="1"><li>如果某站点最初监听到信道空闲，它将在一个被称为<strong>分布式帧间间隔（DIFS）</strong>的段时间段后发送该帧。</li><li>否则，该站点选取一个随机回退值并且在侦听信道<strong>空闲时递减该值</strong>。当侦听到信道忙时，计数值保持不变。</li><li>当计数值减为 0 时（只可能发生在信道被侦听为空闲时），该站点发送整个数据帧并等待确认。</li><li>如果收到确认，发送站点知道它的帧已被目的站正确接收了。如果该站点要发送另一个帧，它将从第二步开始 <code>CSMA/CA</code> 协议。如果未收到确认，发送站点将重新进入第二步中的回退阶段，并从一个更大的范围内选取随机值。</li></ol><p>在以太网的 CSMA/CD 的多路访问协议下，一旦侦听到信道空闲，站点开始发送。然而，使用 CSMA/CA, 该站点在倒计数时抑制传输，即使它侦听到该信道空闲也是如此。<strong>为什么 CSMA/CD 和 CSMA/CA 采用了不同的方法？</strong></p><ul><li>在 CSMA/CD 中碰撞不是一个严重的问题，因为两个站点检测到碰撞后等都会放弃它们的发送，从而避免了由于碰撞而造成的该帧剩余部分的无用发送。</li><li>在 802.11 中，并<strong>不检测碰撞和放弃发送</strong>，遭受碰撞的帧仍将被完全传输。因此要<strong>尽可能避免碰撞</strong>。如果两个站点侦听到信道忙，它们都将立即进入随机回退，希望选取一个不同的回退值。如果这些值的确不同，一旦信道空闲，其中的一个站点将在另一个之前发送，并且“失败站点”将会听到“胜利站点”的信号，冻结它的计数器，并且在胜利站点完成传输之前一直抑制传输，避免了高代价的碰撞。</li><li>使用 802.11 仍然可能出现碰撞的情况：1️⃣ 两个站点可能相互是隐藏的；2️⃣ 两者可能选择了非常靠近的随机回退值</li></ul><h3 id="处理隐藏终端">处理隐藏终端</h3><p>802.11 MAC协议也包括了一个极好（但为可选项）的预约方案，以帮助在出现<code>隐藏终端</code>的情 况下避免碰撞。</p><figure><img src="image-20241222151145124.png" alt="image-20241222151145124" /><figcaption aria-hidden="true">image-20241222151145124</figcaption></figure><p><strong>为什么隐藏终端会导致出现问题?</strong></p><p>假设站点H1正在传输一个帧，并且 在H1传输的中途，站点H2要向AP发送一个帧。由于H2未听到来自H1的传输，它将首先等待一个DIFS间隔，然后发送该帧，导致产生了一个碰撞。从而在H1和H2的整个发送阶段，信道都被浪费了。</p><p>为了避免这一问题，<code>IEEE 802.11协议</code>允许站点使用一个<code>短请求发送(Request to Send, RTS)控制帧</code>和一个<code>短允许发送 (Clear to Send, CTS)控制帧</code>来<code>预约</code>对信道的访问</p><figure><img src="image-20241222151315105.png" alt="image-20241222151315105" /><figcaption aria-hidden="true">image-20241222151315105</figcaption></figure><p>当发送方要发送一个data帧 时，它能够首先向AP发送一个RTS帧, 指示传输DATA帧和确认(ACK)帧需要的总时间。当AP收到RTS帧后，它<code>广播</code>一个<code>CTS帧</code>作为响应。该CTS帧有两个目的：给发送方明确的发送许可，也指示其 他站点在预约期内不要发送。</p><p>在上例中：</p><ul><li>传输 DATA 帧前，H1 首先<code>广播</code>一个 <strong>RTS 帧</strong>，指示传输 DATA 帧和确认（ACK）帧需要的总时间，该帧能被其范围内包括 AP 在内的所有站点听到。</li><li>AP 然后用一个 <strong>CTS 帧</strong> 进行<code>广播</code>响应，该帧也被其范围内的包括 H1 和 H2 在内的所有站点听到。<strong>目的是给发送方明确的发送许可，也指示其他站点在预约期内不要发送。</strong></li><li>站点 H2 听到 CTS 后，在CTS 帧中指明的时间内将<strong>抑制发送</strong>。</li></ul><p>RTS和CTS帧的使用能够<strong>在两个重要 方面提高性能</strong>：</p><ul><li>隐藏终端问题被缓解了，因为长DATA帧只有在信道预约后才被传输。</li><li>因为RTS和CTS帧较短，涉及RTS和CTS帧的碰撞将仅持续短RTS和CTS帧的持续期。一旦RTS和CTS帧被正确传输，后续的DATA和ACK帧应当能无碰撞地发送。</li></ul><hr /><h3 id="帧结构">802.11 帧结构</h3><figure><img src="image-20241222153450347.png" alt="image-20241222153450347" /><figcaption aria-hidden="true">image-20241222153450347</figcaption></figure><ul><li>帧的核心是<code>有效载荷</code>，它通常是由一个IP数据报或者ARP分组组成。尽管这一字段 允许的最大长度为2312字节，但它通常小于1500字节，放置一个IP数据报或一个ARP 分组</li><li>802.11帧包括一个<code>循环冗余校验（CRC）</code>,从而接收方可以检 测所收到帧中的比特错误。</li><li>有4个<code>地址字段</code>，其中每个都可以包 含一个6字节的MAC地址：<ul><li>地址2是传输该帧的站点的MAC地址</li><li>地址1是要接收该帧的无线站点的MAC地址</li><li>地址3：第一跳的MAC地址，接入点所连接的路由器的接口MAC地址</li></ul></li></ul><hr /><h3 id="高级特色">高级特色</h3><ul><li><strong>802.11 速率适应</strong>：如果一个节点连续发送两个帧而没有收到确认，该传输速率降低到前一个较低的速率。如果 10 个帧连续得到确认，或如果用来跟踪自上次降速以来时间的定时器超时，该传输速率提高到上一个较高的速率。</li><li><strong>功率管理</strong>：一个节点能够明显地在睡眠和唤醒状态之间交替。</li></ul><hr /><h2 id="移动管理">移动管理</h2><p>如果一个移动实体在移动过 程中能够保持其<code>IP地址不变</code>，从应用的角度，<code>移动性就变得不可见</code></p><p><strong>名词介绍：</strong></p><ul><li><strong>归属网络</strong>：在一个网络环境中，一个移动节点（智能手机）的永久居所被称为<strong>归属网络</strong>。</li><li><strong>归属代理</strong>：在归属网络中代表移动节点执行移动管理功能的实体叫<strong>归属代理</strong>。</li><li><strong>外部网络</strong>：移动节点当前所在网络叫作<strong>外部网络</strong>或<strong>被访网络</strong>。</li><li><strong>外部代理</strong>：在外部网络中帮助移动节点做移动管理功能的实体称为<strong>外部代理</strong>。<strong>外部代理的作用之一是为移动节点创建一个所谓的转交地址（COA），该 COA 的网络部分与外部网络的网络部分相匹配</strong> ，外部代理的<strong>第二个作用就是告诉归属代理，该移动节点在它的（外部代理的）网络中且具有给定的COA</strong></li><li><strong>通信者(</strong>correspondent)：就是希 望与该移动节点通信的实体</li></ul><figure><img src="image-20241222152004387.png" alt="image-20241222152004387" /><figcaption aria-hidden="true">image-20241222152004387</figcaption></figure><p>当某移动节点位于一个外部网络时，所有指向此节点<code>固定地址</code>的流量需要导向<code>外部网络</code></p><p>此一个<code>移动节点</code>可与两个地址相关联，即其<code>永久地址（permanent address）</code>（类比于流动青年的家 庭地址）与其COA,该COA有时又称为<code>外部地址（foreign address）</code>（类比于流动青年当前居 住的房屋地址）。</p><h3 id="间接路由选择">间接路由选择</h3><figure><img src="image-20241222152312902.png" alt="image-20241222152312902" /><figcaption aria-hidden="true">image-20241222152312902</figcaption></figure><p>通信者只是将数据报寻址到移动节点的固定地址，并将数据报发送到网络 中去，完全不知道移动节点是在归属网络中还是正在访问某个外部网络，因此<strong>移动性对于通信者来说是完全透明的</strong>。这些数据报就像平常一样首先导向移动节点的归属网络。</p><figure><img src="image-20241222152451449.png" alt="image-20241222152451449" /><figcaption aria-hidden="true">image-20241222152451449</figcaption></figure><h3 id="直接路由选择">直接路由选择</h3><p><code>三角路由选择问题 (triangle routing problem)</code>该问题是指即使在通信者与移动节点之间存在一条更有效的路由，发往移动节点的数据报也要先发给归属代理，然后再发送到外部网络。</p><ul><li><strong>间接路由选择会引起三角路由选择问题</strong></li><li>直接路由选择克服了三角路由选择的低效问题，但却是以增加复杂性为代价的。</li></ul><figure><img src="image-20241222152633038.png" alt="image-20241222152633038" /><figcaption aria-hidden="true">image-20241222152633038</figcaption></figure><ul><li>通信者所在网络中的一个<code>通信者代理</code>先知道该移动节点的COA,这可以通过让通信者代理向归属代理<strong>询问</strong>得知，这里假设与间接路由选择情况类似，移动节点具有一个在<strong>归属代理注册过的最新的 COA</strong>，与移动节点可以执行外部代理的功能相类似，通信者本身也可能执行通信者代理的功能。在图中显示为步骤1和步骤2。</li><li>通信者代理然后将数据报直接通过<code>隧道技术</code>发往移动节点的COA,这与归属代理使用的隧道技术相类似，参见图中步骤3 和步骤4。</li></ul><hr /><p><strong>锚外部代理:</strong>我们将首次发现移动节点的外部网络中的外部代理标识为<code>锚外部代理</code></p><ul><li>当移动节点到达一个新外部网络后,移动节点向新的外部代理注册(步骤3)</li><li><strong>新外部代理向锚外部代理提供移动节点的新COA</strong> （步骤4）。</li><li>当锚外部代理收到一个发往已经离开的移动节点的封装数据报后，它可以使用新的COA重新封装数据报并将其转发给该移动节点（步骤5）。</li><li>如果移动节点其后又移到另一个外部网络中，在该被访网络中的外部代理随后将与锚外部代理联系，以便建立到该新外部网络的转发。</li></ul><figure><img src="image-20241222152902343.png" alt="image-20241222152902343" /><figcaption aria-hidden="true">image-20241222152902343</figcaption></figure><h2 id="移动ip">移动IP</h2><p>支持移动性的因特网体系结构与协议合起来称为<code>移动IP</code> ,当前的标准［RFC 5944］规定到移动节点使用<code>间接路由选择</code>的方法。</p><p><strong>移动IP标准由三部分组成：</strong></p><ul><li><strong>代理发现</strong>。移动IP定义了一个归属代理或外部代理用来向移动节点通告其服务的协议，以及移动节点请求一个外部代理或归属代理的服务所使用的协议。</li><li><strong>向归属代理注册</strong>。移动IP定义了移动节点和/或外部代理向一个移动节点的归属 代理注册或注销COA所使用的协议。</li><li><strong>数据报的间接路由选择</strong>。该标准也定义了数据报被一个归属代理转发给移动节点 的方式，包括转发数据报使用的规则、处理差错情况的规则和几种不同的封装形式</li></ul><figure><img src="image-20241222154150591.png" alt="image-20241222154150591" /><figcaption aria-hidden="true">image-20241222154150591</figcaption></figure><figure><img src="image-20241222154405926.png" alt="image-20241222154405926" /><figcaption aria-hidden="true">image-20241222154405926</figcaption></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机网络概述&quot;&gt;计算机网络概述&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;计算机网络&lt;/strong&gt;:简称网络，由若干节点(node，计算机、集线器、交换机、路由器)和连接这些节点的链路(link)组成&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;互联网&lt;/strong&gt;：网络间</summary>
      
    
    
    
    <category term="class" scheme="https://klklkl10086.github.io/klklkl10086.github.io/categories/class/"/>
    
    
    <category term="计算机网络" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>《机器学习B》课程复习笔记</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2024/11/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0B/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2024/11/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0B/</id>
    <published>2024-11-28T06:48:29.000Z</published>
    <updated>2025-03-28T15:15:00.448Z</updated>
    
    <content type="html"><![CDATA[<p><strong>写在前面的话</strong></p><blockquote><p>考试的题型为单项选择，简答，解答和论述四种类型。</p><p>我们是第一届考试，一无所知，我随便写写，各位随便看看</p><p>推荐看一下b站上吴恩达老师的机器学习</p></blockquote><h1 id="绪论">绪论</h1><h2 id="人工智能机器学习深度学习">人工智能&amp;机器学习&amp;深度学习</h2><p>人工智能是一个让机器具有智能的一个目标;机器学习是实现这一目标的有效方式;深度学习属于机器学习的子集,通过深度神经网络完成机器学习的任务。</p><figure><img src="image-20241128145931457.png" alt="image-20241128145931457" /><figcaption aria-hidden="true">image-20241128145931457</figcaption></figure><h2 id="机器学习算法分类">机器学习算法分类</h2><ul><li>监督学习：回归、分类</li><li>无监督学习：聚类、降维</li><li>半监督学习</li><li>自监督学习</li><li>强化学习</li></ul><figure><img src="image-20241128150117881.png" alt="image-20241128150117881" /><figcaption aria-hidden="true">image-20241128150117881</figcaption></figure><h3 id="有监督学习">有监督学习</h3><blockquote><p>有监督学习(supervised learning):从给定的<strong>有标注</strong>的训练数据集中学习出一个函数(模型参数),当新的数据到来时可以根据这个函数<strong>预测结果</strong>。常见任务包括<strong>分类</strong>与回归。</p></blockquote><figure><img src="image-20241128150554465.png" alt="image-20241128150554465" /><figcaption aria-hidden="true">image-20241128150554465</figcaption></figure><h3 id="半监督学习">半监督学习</h3><blockquote><p>结合（少量的）标注训练数据和（大量的）未标注数据来进行数据的学习</p></blockquote><figure><img src="image-20241128150723128.png" alt="image-20241128150723128" /><figcaption aria-hidden="true">image-20241128150723128</figcaption></figure><h3 id="无监督学习">无监督学习</h3><blockquote><p><strong>没有标注的训练数据集</strong>，需要根据样本间的统计规律对样本集进行分析，常见任务：聚类</p></blockquote><figure><img src="image-20241128150844919.png" alt="image-20241128150844919" /><figcaption aria-hidden="true">image-20241128150844919</figcaption></figure><h3 id="自监督学习">自监督学习</h3><blockquote><p>自监督学习是无监督学习的一种方式，它的主要目的是在非人工标注的数据中通过自己监督自己来学习到有用的信息。</p></blockquote><figure><img src="image-20241128151328652.png" alt="image-20241128151328652" /><figcaption aria-hidden="true">image-20241128151328652</figcaption></figure><h3 id="强化学习">强化学习</h3><blockquote><p>一种计算性的学习方法，agent在与复杂和不确定的环境交互的时，试图使其获得的奖励总量最大化。</p></blockquote><figure><img src="image-20241128150946486.png" alt="image-20241128150946486" /><figcaption aria-hidden="true">image-20241128150946486</figcaption></figure><p><strong>强化学习与有监督学习</strong></p><p>有监督通过指导学习，强化学习通过判别学习</p><h1 id="线性回归">线性回归</h1><h2 id="代价函数">代价函数</h2><p>如何求解模型<span class="math inline">\(h_\theta(x)=\theta_0+\theta_1x_1+...+\theta_nx_n\)</span> 的参数<span class="math inline">\(\theta\)</span>？</p><p>我们可以利用代价函数<span class="math inline">\(J(\theta) = \sum_{i=1}^m |h_\theta(x^{(i)})-y^{(i)}|\)</span>，使代价函数取得最小值来确定<span class="math inline">\(\theta\)</span>的取值，<span class="math inline">\(J(\theta)\)</span>叫做<strong>绝对误差</strong></p><p>那么问题变为：求解 <span class="math inline">\(\theta\)</span>使得代价函数取得最小值</p><p>为了方便计算，代价函数（损失函数）采用误差平方和的形式: <span class="math display">\[\arg \min_{\theta} \sum_{i=1}^m  (h_\theta(x^{(i)})-y^{(i)})^2\]</span> 在使用梯度下降法计算时，为了方便计算，损失函数写成如下形式：</p><p><span class="math display">\[J(\theta) = \frac{1}{2}\sum_{i=1}^m  (h_\theta(x^{(i)})-y^{(i)})^2\]</span> 称为<strong>平方和误差</strong></p><h2 id="线性模型特点">线性模型特点</h2><ul><li>形式简单、易于建模</li><li>可解释性</li><li>非线性模型的基础</li><li>引入层级结构或高维映射</li></ul><p>系数反映了每个特征对结果的影响强弱</p><h2 id="特征规范化">特征规范化</h2><p>各个特征变量的范围要保持相近，如果差距较大，那么代价函数的等高线图会很扁，梯度下降法需要更多的迭代，因此要将特征的尺度缩放到-1和1之间 $ x_1=(x_1- mean(x_1))/std(x_1) $</p><h2 id="最小二乘法求解">最小二乘法求解</h2><blockquote><p>最小二乘法（<strong>Least Squares Method</strong>）是一种常用的数学优化方法，用于找到函数模型的最佳拟合参数，使得预测值与实际数据之间的误差平方和最小。最小二乘法的目标是最小化误差平方和（Sum of Squared Errors, SSE）,在线性回归里误差平法和是上述提到的损失函数： <span class="math display">\[J(\theta) = \frac{1}{2}\sum_{i=1}^m  (h_\theta(x^{(i)})-y^{(i)})^2\]</span></p></blockquote><h3 id="求解过程">求解过程</h3><p>我们先将<span class="math inline">\(J(\theta)\)</span>写成矩阵运算的形式,步骤如下： <span class="math display">\[h_\theta(x^{(i)})=\theta_0+\theta_1x_1^{(i)}+...+\theta_nx_n^{(i)} =\theta^{T}x^{(i)}=(x^{(i)})^T\theta\]</span> <span class="math inline">\(X\)</span>是<span class="math inline">\(m\times(n+1)\)</span>矩阵，<span class="math inline">\(m\)</span>个样本，<span class="math inline">\(n\)</span>个特征 (上标表示样本，下标表示特征)（其实是由样本矩阵增广而来） <span class="math display">\[X= \left[\matrix{  (x^{(1)})^T \\  (x^{(2)})^T \\  \vdots      \\  (x^{(m)})^T }\right]=\left[\matrix{  1 &amp;x_1^{(1)}&amp;x_2^{(1)}&amp;\cdots&amp;x_n^{(1)} \\  1 &amp;x_1^{(2)}&amp;x_2^{(2)}&amp;\cdots&amp;x_n^{(2)}\\  1 &amp;x_1^{(3)}&amp;x_2^{(3)}&amp;\cdots&amp;x_n^{(3)}      \\  \vdots &amp; \vdots&amp; \vdots&amp; \cdots&amp; \vdots\\  1 &amp;x_1^{(m)}&amp;x_2^{(m)}&amp;\cdots&amp;x_n^{(m)} }\right]\]</span> <span class="math inline">\(\theta\)</span>是<span class="math inline">\((n+1)\times1\)</span>矩阵: <span class="math display">\[\theta=\left[\matrix{  \theta_0 \\  \theta_1 \\  \vdots      \\  \theta_n }\right]\]</span></p><p><span class="math inline">\(Y\)</span>是<span class="math inline">\(m\)</span>长向量:<span class="math inline">\(m\)</span>个样本</p><p><span class="math display">\[Y=\left[\matrix{  y^{(1)} \\  y^{(2)} \\  \vdots      \\  y^{(m)} }\right]\]</span></p><p>那么： <span class="math display">\[J(\theta) = \frac{1}{2}\sum_{i=1}^m  (h_\theta(x^{(i)})-y^{(i)})^2=\frac{1}{2}(X\theta-Y)^T(X\theta-Y)\]</span></p><p>最小化<span class="math inline">\(J(\theta)\)</span>:让<span class="math inline">\(J(\theta)\)</span>关于<span class="math inline">\(\theta\)</span>的偏导数(过程略)为0： <span class="math display">\[\nabla_{\theta} J(\theta)=\nabla_{\theta}\frac{1}{2}(X^T\theta-Y)^T(X^T\theta-Y) =X^TX\theta-X^TY\\\text {令}\ X^TX\theta-X^TY=0\text{则}\ X^TX\theta=X^TY \\\theta = (X^TX)^{-1}X^TY \\\]</span> <strong>前提：<span class="math inline">\(X^TX\)</span>可逆</strong></p><h2 id="梯度下降法">梯度下降法</h2><p>最小优化问题<span class="math inline">\(\min J(\theta)\)</span> ： $_j:=_j - J() $</p><p>最大优化问题<span class="math inline">\(\max J(\theta)\)</span> ： $_j:=_j + J() $</p><p><span class="math inline">\(\alpha\)</span>称为学习率</p><blockquote><p>梯度方向是函数在该点变化最快的方向</p></blockquote><figure><img src="image-20241128160349200.png" alt="image-20241128160349200" /><figcaption aria-hidden="true">image-20241128160349200</figcaption></figure><figure><img src="image-20241128160430132.png" alt="image-20241128160430132" /><figcaption aria-hidden="true">image-20241128160430132</figcaption></figure><h3 id="线性回归应用梯度下降法"><strong>线性回归应用梯度下降法</strong>：</h3><p><span class="math display">\[\min J(\theta) = \frac{1}{2}\sum_{i=1}^m  (h_\theta(x^{(i)})-y^{(i)})^2\]</span></p><p>逐个更新全部的<span class="math inline">\(\theta\)</span>： <span class="math display">\[\theta _j:=\theta _j - \alpha \frac{1}{\theta_j}J(\theta)\]</span> 假定我们只有一个训练样本，那么： <span class="math display">\[J(\theta) = \frac{1}{2} (h_\theta(x)-y)^2  \\\theta _j:=\theta _j - \alpha (h_\theta(x)-y)x_j\text{其中$0&lt;=j&lt;=$n}\\]</span> 这就是：<strong>LMS学习规则</strong></p><blockquote><p>LMS学习规则的性质：</p><p>参数更新量的模长正比于回归误差，即<span class="math inline">\(|h_\theta(x)-y|\)</span></p></blockquote><p>让我们推广到多个样本就，就会有两种策略：</p><ul><li><strong>Batch gradient descent (BGD)：</strong>对于参数<span class="math inline">\(\theta_j\)</span>扫描计算全部的样本再进行更新</li></ul><p><span class="math display">\[\theta _j:=\theta _j + \alpha \sum_{i=1}^m (y^{(i)}-h_\theta(x^{(i)}))x_j^{(i)}  \text{for every  j}\\]</span></p><ul><li><strong>Stochastic gradient descent (SGD):</strong>对于参数<span class="math inline">\(\theta_j\)</span>遇到一个样本就进行更新</li></ul><p>​ <span class="math inline">\(\text{for i=1 to m}\ \)</span> <span class="math display">\[\theta _j:=\theta _j + \alpha  (y^{(i)}-h_\theta(x^{(i)}))x_j^{(i)}  \text{(for every  j)}\\]</span></p><p><strong>BGD与SGD对比:</strong></p><ul><li>BGD 扫描整个训练集后再更新参数</li><li>SGD 遇到一个样本后立即更新参数</li><li>对于大样本问题，BGD收敛较慢</li><li>但SGD有可能发生震荡，而无法收敛到极小值</li></ul><p>还有一种方法：</p><blockquote><p>mini-batch梯度下降：如果不是每拿到一个样本即更改梯度，而是若干个样本的平均梯度作为更新方向 ，则是 mini-batch梯度下降算法</p></blockquote><figure><img src="image-20241201204122806.png" alt="image-20241201204122806" /><figcaption aria-hidden="true">image-20241201204122806</figcaption></figure><figure><img src="image-20241128160453854-1733055692996-1.png" alt="image-20241128160453854" /><figcaption aria-hidden="true">image-20241128160453854</figcaption></figure><h3 id="梯度下降法其他讨论">梯度下降法其他讨论</h3><p>梯度下降法不能保证一定能获得全局极小值，<del>一方面是因为不一定存在全局极小值，另一方面是容易陷入局部极小值，</del>这就引申出了不同的策略解决这个问题</p><figure><img src="image-20241128161811054.png" alt="image-20241128161811054" /><figcaption aria-hidden="true">image-20241128161811054</figcaption></figure><p>我们先看线性回归如何保证<strong>存在</strong>全局极小值：</p><figure><img src="image-20241201204446987.png" alt="image-20241201204446987" /><figcaption aria-hidden="true">image-20241201204446987</figcaption></figure><h3 id="学习率与梯度下降">学习率与梯度下降</h3><p>介绍一下学习率对梯度下降法的影响：</p><blockquote><p>学习率：向代价函数下降程度最大的方向迈出一小步的步长</p></blockquote><figure><img src="image-20241128162339801.png" alt="image-20241128162339801" /><figcaption aria-hidden="true">image-20241128162339801</figcaption></figure><p>学习率的选择：</p><ul><li>学习率α过小，达到收敛所需的迭代次数高；</li><li>学习率α过大，每次迭代可能会越过极小值，导致无法收敛。</li></ul><p>应对措施：</p><ul><li>尝试不同的学习率</li><li>使用不同的动态学习率算法 Adagrad 、 RMSProp</li></ul><figure><img src="image-20241128162417331.png" alt="image-20241128162417331" /><figcaption aria-hidden="true">image-20241128162417331</figcaption></figure><h3 id="梯度下降法与正规方程法的-比较"><strong>梯度下降法与正规方程法的 比较：</strong></h3><figure><img src="image-20241128162423368.png" alt="image-20241128162423368" /><figcaption aria-hidden="true">image-20241128162423368</figcaption></figure><h2 id="线性回归的概率解释">线性回归的概率解释</h2><p>对于给定的<span class="math inline">\(y^{(i)}\)</span>总能找到 使得等式成立</p><figure><img src="image-20241201210220640.png" alt="image-20241201210220640" /><figcaption aria-hidden="true">image-20241201210220640</figcaption></figure><figure><img src="image-20241128171920340.png" alt="image-20241128171920340" /><figcaption aria-hidden="true">image-20241128171920340</figcaption></figure><h2 id="局部加权线性回归">局部加权线性回归</h2><blockquote><p><strong>局部加权线性回归</strong>（Locally Weighted Linear Regression, <strong>LWLR</strong>）是一种非参数化的回归方法，它通过赋予每个样本不同的权重来拟合一组局部的线性模型，从而在全局非线性回归问题中体现局部线性关系。它的主要特点是对每个<strong>预测点</strong>进行局部拟合，而不是使用全局模型。</p></blockquote><p>局部加权线性回归的主要思想是，在<strong>拟合点 x 附近</strong>的样本对模型的贡献更大，而远离 x的样本贡献较小。因此，每个样本点会被赋予一个权重，权重由与预测点 <em>x</em> 的距离决定。</p><figure><img src="image-20241128173057104.png" alt="image-20241128173057104" /><figcaption aria-hidden="true">image-20241128173057104</figcaption></figure><figure><img src="image-20241128173113405.png" alt="image-20241128173113405" /><figcaption aria-hidden="true">image-20241128173113405</figcaption></figure><figure><img src="image-20241128173145162.png" alt="image-20241128173145162" /><figcaption aria-hidden="true">image-20241128173145162</figcaption></figure><h2 id="非线性模型的多元回归">非线性模型的多元回归</h2><p>实际的数据可能不适用线性预测模型</p><figure><img src="image-20241128173241279.png" alt="image-20241128173241279" /><figcaption aria-hidden="true">image-20241128173241279</figcaption></figure><figure><img src="image-20241128173256827.png" alt="image-20241128173256827" /><figcaption aria-hidden="true">image-20241128173256827</figcaption></figure><figure><img src="image-20241128173313588.png" alt="image-20241128173313588" /><figcaption aria-hidden="true">image-20241128173313588</figcaption></figure><figure><img src="image-20241128173346424.png" alt="image-20241128173346424" /><figcaption aria-hidden="true">image-20241128173346424</figcaption></figure><h2 id="其他讨论">其他讨论</h2><h3 id="样本离群点">样本离群点</h3><h3 id="欠拟合与过拟合">欠拟合与过拟合</h3><p><strong>处理过拟合方式——正则化</strong></p><blockquote><p><strong>正则化</strong>（Regularization）是机器学习中一种防止模型过拟合的技术，它通过对模型参数施加约束或惩罚，降低模型复杂度，从而提高其对新数据的泛化能力。</p></blockquote><p>线性正则化的方法有 岭回归 LASSO回归</p><figure><img src="image-20241128173750015.png" alt="image-20241128173750015" /><figcaption aria-hidden="true">image-20241128173750015</figcaption></figure><p><strong>处理方式——特征选择</strong></p><h1 id="逻辑回归">逻辑回归</h1><blockquote><p>逻辑回归 = 线性回归 + sigmoid函数</p><p>逻辑回归是用来解决分类问题的</p></blockquote><p>若 y={1，2，3，…,M}，则称此问题为 M分类问题</p><ul><li>通常处理的都是二分类问题</li><li>多分类问题常被转化为多个二分类问题</li><li>生活中常见的分类应用： 人脸识别 ，指纹识别 ，手写体数字识别 ， 垃圾邮件检测</li></ul><p>用回归来解决分类问题，即做出一条线将样本分成两堆，这条线称为决策边界</p><figure><img src="image-20241129152909107.png" alt="image-20241129152909107" /><figcaption aria-hidden="true">image-20241129152909107</figcaption></figure><p>回归模型的输出是实数，可能为负值，也可能远远大于1。但在分类问题中，我们通常需要预测某事件的概率，而概率的范围是 <span class="math inline">\([0,1]\)</span>。因此，需要一个函数来对回归的结果进行变换。</p><h2 id="函数一单位阶跃函数"><strong>函数一：单位阶跃函数</strong></h2><figure><img src="image-20241129153141743.png" alt="image-20241129153141743" /><figcaption aria-hidden="true">image-20241129153141743</figcaption></figure><p>由于阶跃函数的不连续的特性，因此计算困难，确定模型参数也困难</p><h2 id="硬分类与软分类">硬分类与软分类</h2><figure><img src="image-20241129154335752.png" alt="image-20241129154335752" /><figcaption aria-hidden="true">image-20241129154335752</figcaption></figure><h2 id="函数二sigmoid-函数logistic函数"><strong>函数二：Sigmoid 函数（Logistic函数）</strong></h2><figure><img src="image-20241129153707146.png" alt="image-20241129153707146" /><figcaption aria-hidden="true">image-20241129153707146</figcaption></figure><p>即： <span class="math display">\[g(z)= \frac{1}{1+e^{-z}}\\z=\theta^{T}x=\theta_0+\sum_{j=1}^n\theta_jx_j\]</span> 我们将回归得到的输出带入Sigmoid函数的输入中 <span class="math display">\[h_\theta(x)=g(\theta^Tx)=\frac{1}{1+e^{-\theta^Tx}}\]</span> 通过上述操作，我们将线性回归输出值<span class="math inline">\(y\)</span>的取值范围从<span class="math inline">\(R\)</span>映射到区间<span class="math inline">\([0,1]\)</span>中，并且<span class="math inline">\(h_\theta(x)\)</span>的值代表概率，这就是软分类</p><p>那么我们以<strong>二分类</strong>为例： <span class="math display">\[P(y=1|x;\theta)=h_\theta(x)\\P(y=0|x;\theta)=1-h_\theta(x)\\\]</span> 上述两式可以合并为： <span class="math display">\[P(y|x;\theta) = (h_\theta(x))^y(1-h_\theta(x))^{1-y}\]</span> 如果采用Sigmoid函数那么上式可以写为： <span class="math display">\[P(y=1|x;\theta)=h_\theta(x) = \frac{1}{1+e^{-\theta^Tx}}\\P(y=0|x;\theta)=1-h_\theta(x) = \frac{e^{-\theta^Tx}}{1+e^{-\theta^Tx}}\\\]</span></p><h2 id="odds几率-几率比">Odds(几率 几率比)</h2><p>在统计和概率理论中，一个事件或者一个陈述的发生比是该事件<strong>发生</strong>和<strong>不发生</strong>的比率，又称几率、几率 比，公式为： <span class="math display">\[\frac{p}{1-p}\]</span></p><p>其中，<span class="math inline">\(p\)</span>是该事件或陈述的概率</p><p>几率比其实是一种相对概率。 一般来说，日常不太使用几率比来描述概率。</p><p>在二分类问题中，正样本的几率比就是： <span class="math display">\[\frac{P(y=1|x;\theta)}{1-P(y=1|x;\theta)}=\frac{1}{e^{-\theta^Tx}}\]</span> 取对数就得到： <span class="math display">\[\ln\frac{P(y=1|x;\theta)}{1-P(y=1|x;\theta)}=\ln\frac{1}{e^{-\theta^Tx}}=\theta^Tx\]</span></p><h2 id="似然函数">似然函数</h2><blockquote><p><strong>似然函数（Likelihood Function）</strong> 是统计学中用来衡量模型参数对观测数据的解释能力的函数。在逻辑回归中，我们通过最大化似然函数来找到最优的模型参数。</p></blockquote><h3 id="似然与概率的区别">似然与概率的区别</h3><blockquote><ul><li>概率描述了<strong>已知参数时</strong>的随机变量的输出结果；</li><li>似然则用来描述<strong>已知随机变量输出结果</strong>时，未知参数的可能取值。</li></ul></blockquote><p>例如，对于“一枚正反对称的硬币上抛十次”这种事件，我们可以问硬币落地时十次都是正面向上的“概率”是多少；而对于“一枚硬币上抛十次 ”，我们则可以问，这枚硬币正反面对称的“似然”程度是多少。 区别似然和概率的直接方法为，“XXX的概率"中XXX只能是事件，也就是 ，事件(发生)的概率是多少；而“XXX的似然"中的XXX只能是参数，比如说 ，参数等于某个值时的似然是多少。</p><h3 id="似然与概率的联系">似然与概率的联系</h3><p><strong>似然函数的定义</strong>：关于参数<span class="math inline">\(\theta\)</span>的似然函数（在数值上）等于给定参数<span class="math inline">\(\theta\)</span>后变量 data 的<strong>概率</strong>（两者的相等并不是说两个函数是同一个，只是数值上的相等）： <span class="math display">\[L(\theta|data)=P(data|\theta)=\prod_{i=1}^{N}P(x_i|\theta)\\data = (x_1,x_2,\cdots,x_n)\]</span> 似然函数的<strong>主要用法在于比较它相对取值</strong>，虽然这个数值本身不具备任何含义。例如，考虑一组样本，当其输出固定时，这组样本的某个未知参数往往会倾向于等于某个特定值，而不是随便的其他数，此时，似然函数是<strong>最大化</strong>的。 似然函数乘以一个正的常数之后仍然是似然函数，其取值并不需要满足归一化条件,即 <span class="math display">\[\sum_{x}\alpha \cdot L(\theta|x)\neq1,\alpha&gt; 0\]</span></p><h2 id="最大似然估计">最大似然估计</h2><p>最大似然估计是似然函数最初也是最自然的应用。似然函数取得最大值表示相应的参数能够使得统计模型<strong><em>最为</em></strong>合理。从这样一个想法出发，最大似然估计的做法是：首先选取似然函数（一般是概率密度函数或概率质量函数）， 整理之后求最大值。实际应用中一般会取似然函数的对数作为求最大值的函数，这样求出的最大值和直接求最大值得到的结果是相同的。<strong>似然函数的最大值不一定唯一，也不一定存在。</strong></p><h3 id="应用到逻辑回归">应用到逻辑回归</h3><p>假设有<span class="math inline">\(m\)</span>个互相独立的训练样本 <span class="math display">\[&amp;\max_\theta L(\theta)=p(\vec{y}|X;\theta)\\&amp;=\prod_{i=1}^{m}p(y^{(i)}|x^{(i)};\theta)\\&amp;=\prod_{i=1}^{m}(h_\theta(x^{(i)}))^{y^{(i)}}(1-h_\theta(x^{(i)}))^{1-y^{(i)}}\\\]</span> 上式即为<strong>最大化似然目标函数</strong></p><p>一般取对数进行计算：</p><figure><img src="image-20241129164228551.png" alt="image-20241129164228551" /><figcaption aria-hidden="true">image-20241129164228551</figcaption></figure><p>上式为<strong>最大化对数似然目标函数</strong></p><h2 id="最大化对数似然目标函数求解方法">最大化对数似然目标函数求解方法</h2><h3 id="梯度下降">梯度下降</h3><figure><img src="image-20241129164616273.png" alt="image-20241129164616273" /><figcaption aria-hidden="true">image-20241129164616273</figcaption></figure><p>由于是最大化，所以符号会有变化</p><figure><img src="image-20241129164640605.png" alt="image-20241129164640605" /><figcaption aria-hidden="true">image-20241129164640605</figcaption></figure><figure><img src="image-20241129164725872.png" alt="image-20241129164725872" /><figcaption aria-hidden="true">image-20241129164725872</figcaption></figure><h3 id="牛顿法求解对数似然函数的极大值点">牛顿法求解对数似然函数的极大值点</h3><p>牛顿法可以求解<span class="math inline">\(f(x)=0\)</span>的问题，应用到极大值点问题，即可变成：</p><figure><img src="image-20241201211626106.png" alt="image-20241201211626106" /><figcaption aria-hidden="true">image-20241201211626106</figcaption></figure><h2 id="多分类问题">多分类问题</h2><p>解决方法：</p><p><strong>One-vs-Rest:</strong></p><p>转化为多个二分类问题</p><ul><li>对于一个 <em>K</em>-类分类问题，训练 <em>K</em> 个二分类器，每个分类器负责区分一个类别与其他所有类别。</li><li>具体而言，第 <em>k</em> 个分类器的目标是预测样本是否属于第 <em>k</em> 类</li></ul><p><strong>One-vs-One：</strong></p><ul><li>对于一个 <em>K</em>-类分类问题，训练 C(K,2)个二分类器，每个分类器负责区分两类之间的关系。</li><li>每个分类器针对类别 i 和类别 <em>j</em> 构建，训练数据只包含类别 <em>i</em> 和类别 <em>j</em> 的样本。</li></ul><p><strong>softmax回归</strong></p><p>虽然前两种方法是将多分类问题转化为二分类问题，但对于多分类问题，也可以直接使用 Softmax 回归进行建模</p><figure><img src="image-20241129165056014.png" alt="image-20241129165056014" /><figcaption aria-hidden="true">image-20241129165056014</figcaption></figure><figure><img src="image-20241129165109560.png" alt="image-20241129165109560" /><figcaption aria-hidden="true">image-20241129165109560</figcaption></figure><figure><img src="image-20241129165141451.png" alt="image-20241129165141451" /><figcaption aria-hidden="true">image-20241129165141451</figcaption></figure><figure><img src="image-20241129165203853.png" alt="image-20241129165203853" /><figcaption aria-hidden="true">image-20241129165203853</figcaption></figure><h2 id="模型评估方法和性能评价指标">模型评估方法和性能评价指标</h2><figure><img src="image-20241129165806886.png" alt="image-20241129165806886" /><figcaption aria-hidden="true">image-20241129165806886</figcaption></figure><figure><img src="image-20241129165819078.png" alt="image-20241129165819078" /><figcaption aria-hidden="true">image-20241129165819078</figcaption></figure><figure><img src="image-20241129165837020.png" alt="image-20241129165837020" /><figcaption aria-hidden="true">image-20241129165837020</figcaption></figure><figure><img src="image-20241129165848482.png" alt="image-20241129165848482" /><figcaption aria-hidden="true">image-20241129165848482</figcaption></figure><figure><img src="image-20241129165900781.png" alt="image-20241129165900781" /><figcaption aria-hidden="true">image-20241129165900781</figcaption></figure><figure><img src="image-20241129165914171.png" alt="image-20241129165914171" /><figcaption aria-hidden="true">image-20241129165914171</figcaption></figure><figure><img src="image-20241129170004816.png" alt="image-20241129170004816" /><figcaption aria-hidden="true">image-20241129170004816</figcaption></figure><h1 id="人工神经网络">人工神经网络</h1><p><strong>定义</strong></p><p>美国神经网络学者Nielsen的定义：</p><ul><li>人工神经网络是一个并行、分布处理结构，它由处理单元及其称为联接的无向讯号通道互连而成。</li><li>这些处理单元具有局部内存，可以完成局部操作，即它必须仅仅依赖于处理单元接收的所有输入信号的当前值 和存储在处理单元局部内存中的值。</li><li>每个处理单元有一个单一的输出联接， 输出信号通过必要的数学模型给出。</li></ul><p><strong>特点</strong></p><ol type="1"><li><p>并行结构和并行处理</p></li><li><p>知识的分布存储</p></li></ol><ul><li><p>在神经网络中，知识不是存储在特定的存储单元，而是 分布在整个系统中，要存储多个知识就需要很多连接。</p></li><li><p>要获得存储的知识则采用“联想”的办法，这类似于人类和动物的记忆。</p></li><li><p>联想记忆的两个主要特点： ✓存储大量复杂数据的能力 ✓自适应的特征抽取能力 ✓快速的推理能力</p></li></ul><ol start="3" type="1"><li><p>自适应性</p></li><li><p>容错性</p></li></ol><h2 id="人工神经元的形式化模型">人工神经元的形式化模型</h2><h3 id="m-p模型">M-P模型</h3><figure><img src="image-20241130161802262.png" alt="image-20241130161802262" /><figcaption aria-hidden="true">image-20241130161802262</figcaption></figure><figure><img src="image-20241130162236910.png" alt="image-20241130162236910" /><figcaption aria-hidden="true">image-20241130162236910</figcaption></figure><figure><img src="image-20241130162455999.png" alt="image-20241130162455999" /><figcaption aria-hidden="true">image-20241130162455999</figcaption></figure><h3 id="线性加权模型">线性加权模型</h3><figure><img src="image-20241130162518405.png" alt="image-20241130162518405" /><figcaption aria-hidden="true">image-20241130162518405</figcaption></figure><h3 id="阶跃阈值模型">阶跃阈值模型</h3><figure><img src="image-20241130162555969.png" alt="image-20241130162555969" /><figcaption aria-hidden="true">image-20241130162555969</figcaption></figure><h3 id="逻辑阈值模型">逻辑阈值模型</h3><figure><img src="image-20241130162614559.png" alt="image-20241130162614559" /><figcaption aria-hidden="true">image-20241130162614559</figcaption></figure><h3 id="广义神经元模型">广义神经元模型</h3><figure><img src="image-20241130162645843.png" alt="image-20241130162645843" /><figcaption aria-hidden="true">image-20241130162645843</figcaption></figure><h3 id="神经元状态转移函数的类型">神经元状态转移函数的类型</h3><figure><img src="image-20241130162719465.png" alt="image-20241130162719465" /><figcaption aria-hidden="true">image-20241130162719465</figcaption></figure><h2 id="感知器模型和学习规则">感知器模型和学习规则</h2><h3 id="定义">定义</h3><blockquote><p>感知器是解决 <strong>线性可分问题</strong> 的一种算法基础，它是现代神经网络的重要前身。</p></blockquote><figure><img src="image-20241130163759630.png" alt="image-20241130163759630" /><figcaption aria-hidden="true">image-20241130163759630</figcaption></figure><p><strong>线性可分</strong>：在二维空间上，如果两类点可以被一条直线（高维空间叫超平面）完全分开叫做线性可分。</p><p><strong>损失函数</strong></p><figure><img src="image-20241130164007296.png" alt="image-20241130164007296" /><figcaption aria-hidden="true">image-20241130164007296</figcaption></figure><figure><img src="image-20241130164055326.png" alt="image-20241130164055326" /><figcaption aria-hidden="true">image-20241130164055326</figcaption></figure><figure><img src="image-20241130164132408.png" alt="image-20241130164132408" /><figcaption aria-hidden="true">image-20241130164132408</figcaption></figure><h3 id="感知器的收敛性">感知器的收敛性</h3><blockquote><h3 id="收敛性的核心内容"><strong>收敛性的核心内容</strong></h3><ol type="1"><li><strong>适用条件</strong><ul><li>数据必须是 <strong>线性可分的</strong>。也就是说，存在一个超平面可以将所有正类和负类样本完全分开。</li></ul></li><li><strong>收敛性保证</strong><ul><li>如果数据线性可分，感知机算法一定会在有限次迭代后找到一个权重向量 <em>w</em>，使得所有训练样本的分类正确。</li></ul></li><li><strong>收敛时间</strong><ul><li>收敛所需的迭代次数取决于数据的分布，例如样本之间的距离和数据的分离度。</li></ul></li></ol></blockquote><h3 id="表征能力">表征能力</h3><figure><img src="image-20241130165330709.png" alt="image-20241130165330709" /><figcaption aria-hidden="true">image-20241130165330709</figcaption></figure><figure><img src="image-20241130165408672.png" alt="image-20241130165408672" /><figcaption aria-hidden="true">image-20241130165408672</figcaption></figure><figure><img src="image-20241130165453587.png" alt="image-20241130165453587" /><figcaption aria-hidden="true">image-20241130165453587</figcaption></figure><h2 id="多层前馈网络与bp学习算法">多层前馈网络与BP学习算法</h2><blockquote><p>名称“前馈”源于数据流动的方式：输入数据通过网络从输入层流向输出层，中间没有反馈或循环。</p></blockquote><p>单层前馈神经网络</p><figure><img src="image-20241130165856698.png" alt="image-20241130165856698" /><figcaption aria-hidden="true">image-20241130165856698</figcaption></figure><figure><img src="image-20241130165910704.png" alt="image-20241130165910704" /><figcaption aria-hidden="true">image-20241130165910704</figcaption></figure><h2 id="bp学习算法backpropagation-learning-algorithm">BP学习算法（Backpropagation Learning Algorithm）</h2><blockquote><p><strong>BP（反向传播）学习算法</strong>是神经网络训练中的核心算法之一，广泛应用于前馈神经网络（尤其是多层感知器）。其主要作用是通过计算<strong>损失函数相对于网络参数</strong>（权重和偏置）的梯度，并通过<strong>梯度下降法</strong>来优化这些参数，以最小化预测误差。BP算法是深度学习中的一个基础和重要算法。</p></blockquote><p>总体思想：正向传播 + 反向传播(1986年)</p><ol type="1"><li>正向传播时，输入信息从输入层开始，经过各层神 经元的处理后产生一个输出。然后，将实际输出和 所需输出进行比较，得到一个误差矢量。</li><li>反向传播过程，从输出层至输入层，利用这个误差矢量对权值进行逐层修正。</li><li>正向传播和反向传播交替迭代进行。</li><li>通过不断迭代优化，使得网络的输出逐渐接近目标 值，从而实现对输入数据的准确识别或预测。</li></ol><figure><img src="image-20241130170202693.png" alt="image-20241130170202693" /><figcaption aria-hidden="true">image-20241130170202693</figcaption></figure><blockquote><h3 id="反向传播算法的工作原理"><strong>1. 反向传播算法的工作原理</strong></h3><p>反向传播算法的核心思想是通过链式法则来计算损失函数关于网络中各个参数（即权重和偏置）的梯度，并利用这些梯度来更新参数。其步骤如下：</p><h4 id="向前传播forward-propagation"><strong>1.1 向前传播（Forward Propagation）</strong></h4><ul><li>输入数据通过网络的各层进行传播，最终输出预测值。</li><li>每一层的神经元进行加权求和并通过激活函数处理，得到该层的输出。</li></ul><h4 id="计算损失loss-calculation"><strong>1.2 计算损失（Loss Calculation）</strong></h4><ul><li>使用损失函数计算网络输出与实际目标之间的误差。</li><li>常用的损失函数：<ul><li>均方误差（MSE）用于回归问题： <span class="math inline">\({MSE} = \frac{1}{n} \sum_{i=1}^{n} (y_i - \hat{y}_i)^2\)</span></li><li>交叉熵损失（Cross-Entropy Loss）用于分类问题。</li></ul></li></ul><h4 id="反向传播backpropagation"><strong>1.3 反向传播（Backpropagation）</strong></h4><ul><li><p><strong>反向传播的关键：</strong> 通过链式法则计算损失函数相对于各层权重和偏置的梯度。</p><ul><li><p>从输出层开始，计算损失函数相对于输出层的梯度：</p><p><span class="math inline">\(\frac{\partial L}{\partial z^{(L)}} = \hat{y} - y\)</span></p><p>其中，$z^{(L)} <span class="math inline">\(是输出层的加权和，\)</span> <span class="math inline">\(是预测值，\)</span>y<span class="math inline">\(是真实标签，\)</span>L$是损失函数。</p></li><li><p>然后通过链式法则逐层计算前面隐藏层的梯度：</p><p><span class="math inline">\(\frac{\partial L}{\partial z^{(l)}} = \left( \frac{\partial L}{\partial z^{(l+1)}} \right) \cdot W^{(l+1)} \cdot f&#39;(z^{(l)})\)</span></p><p>其中$ f'(z^{(l)}) <span class="math inline">\(是该层激活函数的导数，\)</span>W^{(l+1)}$ 是上一层的权重矩阵。</p></li></ul></li></ul><h4 id="参数更新parameter-update"><strong>1.4 参数更新（Parameter Update）</strong></h4><ul><li><p>通过计算得到的梯度更新网络中的权重和偏置，通常采用梯度下降法： $w^{(l)} = w^{(l)} -  \b^{(l)} = b^{(l)} -  $</p><p>其中，$$是学习率，控制每次更新的步长。</p></li></ul><h4 id="重复迭代"><strong>1.5 重复迭代</strong></h4><ul><li>通过多次迭代（多个epoch）来不断更新权重和偏置，直到损失函数收敛或达到设定的训练次数。</li></ul></blockquote><h2 id="神经网络训练技巧">神经网络训练技巧</h2><h3 id="批处理bp算法">批处理BP算法</h3><p>1 在每次更新权值之前，计算所有样本的误差</p><ul><li><p>真正的最速梯度下降方法</p></li><li><p>每代更新一次</p></li></ul><p>2 每计算一个样本点的误差就更新权值一 次 - 需将数据每个循环随机打乱</p><h3 id="动态学习率">动态学习率</h3><figure><img src="image-20241130181849936.png" alt="image-20241130181849936" /><figcaption aria-hidden="true">image-20241130181849936</figcaption></figure><figure><img src="image-20241130182003489.png" alt="image-20241130182003489" /><figcaption aria-hidden="true">image-20241130182003489</figcaption></figure><figure><img src="image-20241130182040923.png" alt="image-20241130182040923" /><figcaption aria-hidden="true">image-20241130182040923</figcaption></figure><h3 id="动量项">动量项</h3><blockquote><p><strong>动量项</strong>是深度学习中的一个优化技术，常用于梯度下降算法中，目的是加速收敛并帮助模型避免陷入局部最小值或鞍点。它的核心思想借鉴了物理学中“动量”的概念，即当前的更新不仅依赖于当前的梯度，还考虑了之前的梯度变化，形成一定的惯性，帮助在优化过程中保持稳定的前进方向。</p></blockquote><figure><img src="image-20241130183106419.png" alt="image-20241130183106419" /><figcaption aria-hidden="true">image-20241130183106419</figcaption></figure><figure><img src="image-20241130183346412.png" alt="image-20241130183346412" /><figcaption aria-hidden="true">image-20241130183346412</figcaption></figure><figure><img src="image-20241130183735346.png" alt="image-20241130183735346" /><figcaption aria-hidden="true">image-20241130183735346</figcaption></figure><figure><img src="image-20241130183748289.png" alt="image-20241130183748289" /><figcaption aria-hidden="true">image-20241130183748289</figcaption></figure><figure><img src="image-20241130183802231.png" alt="image-20241130183802231" /><figcaption aria-hidden="true">image-20241130183802231</figcaption></figure><h3 id="dropout">Dropout</h3><blockquote><p><strong>Dropout</strong> 是一种在训练神经网络时使用的正则化技术，用于防止过拟合。它通过在每次训练过程中随机地“丢弃”神经网络中的一些神经元，使得网络在每次前向传播时都只使用部分神经元进行计算，从而减少对某些神经元的依赖，增强模型的泛化能力。</p></blockquote><figure><img src="image-20241130183842744.png" alt="image-20241130183842744" /><figcaption aria-hidden="true">image-20241130183842744</figcaption></figure><figure><img src="image-20241130183854917.png" alt="image-20241130183854917" /><figcaption aria-hidden="true">image-20241130183854917</figcaption></figure><h1 id="径向基函数与自组织特征映射神经网络">径向基函数与自组织特征映射神经网络</h1><p><strong>神经网络的典型应用：</strong></p><ul><li>分类问题</li><li>函数逼近（回归问题）</li><li>时间序列分析</li></ul><h2 id="径向基函数">径向基函数</h2><blockquote><p>径向基函数（Radial Basis Function，简称RBF）是一类广泛应用于机器学习、函数逼近和神经网络中的数学函数。它的特点是以某个中心点为基准，随着距离中心点的增加，函数值逐渐衰减。通常，RBF是以距离的平方为自变量的函数。常见的径向基函数有高斯函数、逆多项式函数等。</p></blockquote><p>径向基函数是一个它的值(y)只依赖于变 量(x)距原点距离的函数，即 𝜙(𝑋) = 𝜙( ||𝑋|| ) 也可以是距其他某个中心点的距离，即 𝜙(𝑋) = 𝜙( ||𝑋 − 𝑐|| ) 任一满足𝜙(𝑋) = 𝜙( ||𝑋 − 𝑐|| )的函数都可 称作径向函数。其中，范数一般为欧几里得距离，不过亦可使用其他距离函数</p><p>径向函数𝜙(𝑋) = 𝜙( ||𝑋 − 𝑐|| )包含三个参 数：</p><ul><li>中心：𝑐;</li><li>距离度量： 𝑟 = || 𝑋 − 𝑐 ||</li><li>形状：𝜙</li></ul><h3 id="常见的径向基函数">常见的径向基函数</h3><figure><img src="image-20241201101725251.png" alt="image-20241201101725251" /><figcaption aria-hidden="true">image-20241201101725251</figcaption></figure><h2 id="径向基神经网络">径向基神经网络</h2><blockquote><p>径向基函数网络是一种以<strong>径向基函数作为激活函数</strong>的 人工神经网络。</p><ul><li>网络的输出是输入和神经元参数的径向基函数的线性组合，能够以任意精度逼近任意连续函数。</li><li>径向基函数网络有许多用途，包括函数逼近、时间序 列预测、分类和系统控制。</li><li>一个隐层：激活函数为径向函数，例如，高斯函数.</li><li>神经元的输入离该中心点越远，神经元的激活程度就越低。隐节点的这一特性常被称为“局部特性”。</li></ul></blockquote><figure><img src="image-20241201102129397.png" alt="image-20241201102129397" /><figcaption aria-hidden="true">image-20241201102129397</figcaption></figure><h3 id="rbf网络与经典神经网络的区别">RBF网络与经典神经网络的区别</h3><p>隐藏层不同：RBF网络隐藏层每个节点执行一个径向基函数操作，产生与输入数据的距离相关的输出。 经典神经网络采用进行加权和非线性变换。</p><p>输出层相同：均为线性组合</p><h2 id="完全径向基神经网络">完全径向基神经网络</h2><p><strong>以插值问题为例：</strong></p><blockquote><p>插值问题描述: 考虑N维空间到一维空间的映射.</p><p>设N维空间有𝑃个输入向量<span class="math inline">\(𝒙_𝑝, 𝑝 = 1,2, … , 𝑃\)</span>它们 在输入空间相应的目标值为<span class="math inline">\(𝑑_𝑝, 𝑝 = 1,2, … , 𝑃\)</span> 插值的目的是寻找一个非线性映射函数<span class="math inline">\(F(𝒙)\)</span>,使得满足下述插值条件 <span class="math inline">\(F(𝒙_𝑝) = 𝑑_𝑝, 𝑝 = 1,2, … , P\)</span></p></blockquote><p>解决方法：</p><figure><img src="image-20241201103742309.png" alt="image-20241201103742309" /><figcaption aria-hidden="true">image-20241201103742309</figcaption></figure><figure><img src="image-20241201103923823.png" alt="image-20241201103923823" /><figcaption aria-hidden="true">image-20241201103923823</figcaption></figure><figure><img src="image-20241201104037657.png" alt="image-20241201104037657" /><figcaption aria-hidden="true">image-20241201104037657</figcaption></figure><figure><img src="image-20241201104051986.png" alt="image-20241201104051986" /><figcaption aria-hidden="true">image-20241201104051986</figcaption></figure><p>存在的问题：</p><blockquote><p>完全内插存在的问题(正则化RBF网络):</p><ul><li>经过所有训练数据点,当存在噪声时,泛化能力差</li><li>径向基函数数目与训练样本数相同,当训练样本数远远大于系统的固有自由度时,问题是超定的, 插值矩阵求逆容易不稳定</li></ul></blockquote><h2 id="广义径向基神经网络">广义径向基神经网络</h2><ul><li>径向基函数数目M与训练样本数P不同,且一般M&lt;&lt;P</li><li>径向基函数的中心不再限制在数据点上,由训练确定</li><li>各径向基函数的扩展常数不再统一,由训练确定</li><li>输出函数的线性中包含阈值参数,用于补偿函数在样本集上的平均值与目标之平均值之间的差别</li></ul><figure><img src="image-20241201110658556.png" alt="image-20241201110658556" /><figcaption aria-hidden="true">image-20241201110658556</figcaption></figure><figure><img src="image-20241201111020018.png" alt="image-20241201111020018" /><figcaption aria-hidden="true">image-20241201111020018</figcaption></figure><figure><img src="image-20241201111041983.png" alt="image-20241201111041983" /><figcaption aria-hidden="true">image-20241201111041983</figcaption></figure><figure><img src="image-20241201111140872.png" alt="image-20241201111140872" /><figcaption aria-hidden="true">image-20241201111140872</figcaption></figure><figure><img src="image-20241201111436367.png" alt="image-20241201111436367" /><figcaption aria-hidden="true">image-20241201111436367</figcaption></figure><figure><img src="image-20241201111551755.png" alt="image-20241201111551755" /><figcaption aria-hidden="true">image-20241201111551755</figcaption></figure><h2 id="广义径向基神经网络与多层感知器比较">广义径向基神经网络与多层感知器比较</h2><figure><img src="image-20241201111643075.png" alt="image-20241201111643075" /><figcaption aria-hidden="true">image-20241201111643075</figcaption></figure><figure><img src="image-20241201111751940.png" alt="image-20241201111751940" /><figcaption aria-hidden="true">image-20241201111751940</figcaption></figure><h2 id="rbfn用于分类">RBFN用于分类</h2><figure><img src="image-20241201111913022.png" alt="image-20241201111913022" /><figcaption aria-hidden="true">image-20241201111913022</figcaption></figure><h2 id="自组织特征映射神经网络">自组织特征映射神经网络</h2><blockquote><p>SOFM网络的核心思想是<strong>保持输入数据的拓扑结构</strong>，使得相似的数据点在映射空间中尽量接近，而不相似的数据点则远离。</p></blockquote><p>自组织映射(SOM)或自组织特征映射(SOFM)由Kohonen 教授于1981年提出，是一种无监督机器学习技术，用于 生成高维数据集的低维(通常是二维)表示，同时保留数据 的拓扑结构。</p><p>不同于一般神经网络基于损失函数的反向传递来训练 ，它运用竞争学习(competitive learning)策略,依靠神经元 之间互相竞争逐步优化网络。且使用近邻关系函数 (neighborhood function)来维持输入空间的拓扑结构</p><figure><img src="image-20241201112412425.png" alt="image-20241201112412425" /><figcaption aria-hidden="true">image-20241201112412425</figcaption></figure><figure><img src="image-20241201113212181.png" alt="image-20241201113212181" /><figcaption aria-hidden="true">image-20241201113212181</figcaption></figure><figure><img src="image-20241201113336508.png" alt="image-20241201113336508" /><figcaption aria-hidden="true">image-20241201113336508</figcaption></figure><figure><img src="image-20241201113604262.png" alt="image-20241201113604262" /><figcaption aria-hidden="true">image-20241201113604262</figcaption></figure><figure><img src="image-20241201113736330.png" alt="image-20241201113736330" /><figcaption aria-hidden="true">image-20241201113736330</figcaption></figure><figure><img src="image-20241201113806700.png" alt="image-20241201113806700" /><figcaption aria-hidden="true">image-20241201113806700</figcaption></figure><figure><img src="image-20241201114735214.png" alt="image-20241201114735214" /><figcaption aria-hidden="true">image-20241201114735214</figcaption></figure><figure><img src="image-20241201114745081.png" alt="image-20241201114745081" /><figcaption aria-hidden="true">image-20241201114745081</figcaption></figure><h1 id="支持向量机">支持向量机</h1><blockquote><p>二类分类模型。它的基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使它有别于感知机。</p><p>支持向量机还包括<strong>核技巧</strong>，这使它成为实质上的非线性分类器。</p><p>支持向量机的学习策略就是间隔最大化，可形式化为一个求解凸二次规划(convex quadratic programming)的问题，也等价于正则化的Hinge 损失函数的最小化问题。支持向量机的学习算法是求解凸二次规划的最优化算法。</p></blockquote><p><strong>分类：</strong></p><ul><li><strong>线性可分支持向量机</strong>(linear support vector machine in linearly separable case )：<strong>硬间隔</strong>最大化(hard margin maximization)；</li><li><strong>线性支持向量机</strong>(linear support vector machine) ：训练数据<strong>近似线性可分</strong>时，通过<strong>软间隔</strong>最大化(soft margin maximization)；</li><li><strong>非线性支持向量机</strong>(non-linear support vector machine) ：当训练数据<strong>线性不可分</strong>时，通过使用<strong>核技巧</strong>(kernel trick)及<strong>软间隔</strong>最大化。</li></ul><p><strong>核函数</strong></p><blockquote><p>当输入空间为欧氏空间或离散集合、特征空间为希尔伯特空间时，核函数(kernel function)表 示将输入从输入空间映射到特征空间得到的特征向量之间的内积；</p><p>通过使用核函数可以学习非线性支持向量机,等价于隐式地在<strong>高维的特征空间</strong>中学习线性支持向量机，这样的方法称为核技巧；</p><p>核方法(kernel method)是比支持向量机更为一般的机器学习方法。</p></blockquote><h2 id="理论基础">理论基础</h2><p>统计学习理论是SVM的理论基础</p><figure><img src="image-20241202193431790.png" alt="image-20241202193431790" /><figcaption aria-hidden="true">image-20241202193431790</figcaption></figure><figure><img src="image-20241202193439517.png" alt="image-20241202193439517" /><figcaption aria-hidden="true">image-20241202193439517</figcaption></figure><figure><img src="image-20241202193447397.png" alt="image-20241202193447397" /><figcaption aria-hidden="true">image-20241202193447397</figcaption></figure><figure><img src="image-20241202193508901.png" alt="image-20241202193508901" /><figcaption aria-hidden="true">image-20241202193508901</figcaption></figure><h2 id="线性可分支持向量机">线性可分支持向量机</h2><blockquote><p><strong>线性可分</strong>:</p><p>设<span class="math inline">\(D_0\)</span>和<span class="math inline">\(D_1\)</span>是n维欧氏空间中的两个点集,如果存在n维向量<span class="math inline">\(w\)</span>和实数<span class="math inline">\(b\)</span>,使得: 1.所有属于<span class="math inline">\(D_0\)</span>的点<span class="math inline">\(x_i\)</span>都有<span class="math inline">\(wx_i+b&gt;0\)</span></p><p>2.而对于所有属于<span class="math inline">\(D_1\)</span>的点<span class="math inline">\(x_j\)</span>则有<span class="math inline">\(wx_j+b&lt;0\)</span>,则我们称<span class="math inline">\(D_0\)</span>和<span class="math inline">\(D_1\)</span><strong>线性可分</strong></p><p>3.从二维扩展到多维空间中时,将<span class="math inline">\(D_0\)</span>和<span class="math inline">\(D_1\)</span>完全正确地划分开的<span class="math inline">\(wx+b=0\)</span>就成了一个超平面。</p></blockquote><figure><img src="image-20241202194013655.png" alt="image-20241202194013655" /><figcaption aria-hidden="true">image-20241202194013655</figcaption></figure><figure><img src="image-20241202194027453.png" alt="image-20241202194027453" /><figcaption aria-hidden="true">image-20241202194027453</figcaption></figure><p>法向量指向的一侧为正类，另一侧为负类</p><p>一般地,当训练数据集<strong>线性可分</strong>时,存在无穷个分离超平面可将两类数据正确分开，<strong>感知机</strong>利用误分类最小的策略,求得分离超平面,不过这时的解有<strong>无穷多个</strong>.线性可分支持向量机利用<strong>间隔最大化</strong>求<strong>最优</strong>分离超平面,这时,解是<strong>唯一</strong>的.</p><figure><img src="image-20241202194547640.png" alt="image-20241202194547640" /><figcaption aria-hidden="true">image-20241202194547640</figcaption></figure><p>我们希望找到间隔最大化（硬间隔最大化）的超平面，即最大化离分类平面最近的点的距离</p><figure><img src="image-20241202194637387.png" alt="image-20241202194637387" /><figcaption aria-hidden="true">image-20241202194637387</figcaption></figure><p>已知点到平面的距离公式：</p><figure><img src="image-20241202194704527.png" alt="image-20241202194704527" /><figcaption aria-hidden="true">image-20241202194704527</figcaption></figure><figure><img src="image-20241202194756648.png" alt="image-20241202194756648" /><figcaption aria-hidden="true">image-20241202194756648</figcaption></figure><figure><img src="image-20241202194945722.png" alt="image-20241202194945722" /><figcaption aria-hidden="true">image-20241202194945722</figcaption></figure><figure><img src="image-20241202195058660.png" alt="image-20241202195058660" /><figcaption aria-hidden="true">image-20241202195058660</figcaption></figure><figure><img src="image-20241202200323516.png" alt="image-20241202200323516" /><figcaption aria-hidden="true">image-20241202200323516</figcaption></figure><figure><img src="image-20241202200354735.png" alt="image-20241202200354735" /><figcaption aria-hidden="true">image-20241202200354735</figcaption></figure><h2 id="支持向量机的优化算法">支持向量机的优化算法</h2><p>若数据是<strong>线性可分</strong>的，则上述<strong>凸二次规划问题</strong>的解<strong>存在且唯一</strong>。二次规划问题有很多算法可以求解，也有很多求解器能直接解决二次规划问题。但是<strong>一般我们不直接求解原问题，而是求解其对偶问题，</strong></p><p><strong>原因</strong>有几点：</p><ol type="1"><li>对偶问题更简单，更容易求解，效率更高；</li><li>对偶问题将原始问题中的不等式约束转为了对偶问题中的等式约束；</li><li>对偶问题方便核函数的引入，进而可以推广到非线性分类问题</li></ol><figure><img src="image-20241202200558459.png" alt="image-20241202200558459" /><figcaption aria-hidden="true">image-20241202200558459</figcaption></figure><p><strong>求解线性可分支持向量机的步骤</strong>为：</p><ol type="1"><li>利用<strong>拉格朗日乘子法</strong>，构造拉格朗日函数；</li><li>利用<strong>强对偶性</strong>(<strong>KKT条件</strong>)将优化问题进行转化， 并求解；</li><li>利用最优的<span class="math inline">\(𝑤^∗\)</span>和<span class="math inline">\(𝑏^∗\)</span>构建分类器</li></ol><h3 id="第一步构造拉格朗日函数">第一步：构造拉格朗日函数</h3><figure><img src="image-20241202202739031.png" alt="image-20241202202739031" /><figcaption aria-hidden="true">image-20241202202739031</figcaption></figure><h3 id="第二步利用强对偶性kkt条件将优化问题进行转化">第二步：利用<strong>强对偶性</strong>(<strong>KKT条件</strong>)将优化问题进行转化</h3><figure><img src="image-20241202202750456.png" alt="image-20241202202750456" /><figcaption aria-hidden="true">image-20241202202750456</figcaption></figure><figure><img src="image-20241202202910999.png" alt="image-20241202202910999" /><figcaption aria-hidden="true">image-20241202202910999</figcaption></figure><figure><img src="image-20241202203038318.png" alt="image-20241202203038318" /><figcaption aria-hidden="true">image-20241202203038318</figcaption></figure><figure><img src="image-20241202203111878.png" alt="image-20241202203111878" /><figcaption aria-hidden="true">image-20241202203111878</figcaption></figure><figure><img src="image-20241202203852966.png" alt="image-20241202203852966" /><figcaption aria-hidden="true">image-20241202203852966</figcaption></figure><figure><img src="image-20241202203928894.png" alt="image-20241202203928894" /><figcaption aria-hidden="true">image-20241202203928894</figcaption></figure><figure><img src="image-20241202203940321.png" alt="image-20241202203940321" /><figcaption aria-hidden="true">image-20241202203940321</figcaption></figure><figure><img src="image-20241202204054239.png" alt="image-20241202204054239" /><figcaption aria-hidden="true">image-20241202204054239</figcaption></figure><p>。。。。。。。</p><h2 id="线性支持向量机">线性支持向量机</h2><blockquote><p>软间隔最大化</p></blockquote><figure><img src="image-20241202204421947.png" alt="image-20241202204421947" /><figcaption aria-hidden="true">image-20241202204421947</figcaption></figure><figure><img src="image-20241202204437736.png" alt="image-20241202204437736" /><figcaption aria-hidden="true">image-20241202204437736</figcaption></figure><figure><img src="image-20241202204534762.png" alt="image-20241202204534762" /><figcaption aria-hidden="true">image-20241202204534762</figcaption></figure><h2 id="非线性支持向量机">非线性支持向量机</h2><blockquote><p>核方法</p></blockquote><figure><img src="image-20241202204737122.png" alt="image-20241202204737122" /><figcaption aria-hidden="true">image-20241202204737122</figcaption></figure><figure><img src="image-20241202204752734.png" alt="image-20241202204752734" /><figcaption aria-hidden="true">image-20241202204752734</figcaption></figure><figure><img src="image-20241202205812682.png" alt="image-20241202205812682" /><figcaption aria-hidden="true">image-20241202205812682</figcaption></figure><figure><img src="image-20241202205832143.png" alt="image-20241202205832143" /><figcaption aria-hidden="true">image-20241202205832143</figcaption></figure><figure><img src="image-20241202205854065.png" alt="image-20241202205854065" /><figcaption aria-hidden="true">image-20241202205854065</figcaption></figure><figure><img src="image-20241202205923768.png" alt="image-20241202205923768" /><figcaption aria-hidden="true">image-20241202205923768</figcaption></figure><figure><img src="image-20241202205953883.png" alt="image-20241202205953883" /><figcaption aria-hidden="true">image-20241202205953883</figcaption></figure><h2 id="回归问题">回归问题</h2><figure><img src="image-20241202211451547.png" alt="image-20241202211451547" /><figcaption aria-hidden="true">image-20241202211451547</figcaption></figure><figure><img src="image-20241202211534994.png" alt="image-20241202211534994" /><figcaption aria-hidden="true">image-20241202211534994</figcaption></figure><figure><img src="image-20241202211604876.png" alt="image-20241202211604876" /><figcaption aria-hidden="true">image-20241202211604876</figcaption></figure><figure><img src="image-20241202211618142.png" alt="image-20241202211618142" /><figcaption aria-hidden="true">image-20241202211618142</figcaption></figure><h1 id="聚类">聚类</h1><blockquote><p>聚类（Clustering）是最常见的<strong>无监督学习</strong>算法，它指的是按照某个特定标准（如距离）把一个数据集分割成不同的类或簇，使得<strong>同一个簇内的数据对象的相似性尽可能大</strong>，同时<strong>不在同一个簇中的数据对象的差异性也尽可能地大</strong>。</p></blockquote><p><strong>问题描述</strong></p><figure><img src="image-20241203103045465.png" alt="image-20241203103045465" /><figcaption aria-hidden="true">image-20241203103045465</figcaption></figure><p><strong>聚类分析要解决的问题:</strong></p><ul><li>定义数据间的距离/相似度度量</li><li>使用相应的算法对数据集进行分割</li><li>度量聚类结果的性能</li></ul><h2 id="数据间的距离相似度度量">数据间的距离/相似度度量</h2><p>每一条数据都可以理解为多维空间中的一个点可以根据<strong>点和点之间的距离</strong>来评价数据间的相似度。</p><p><strong>常见的指标:</strong></p><figure><img src="image-20241203103522021.png" alt="image-20241203103522021" /><figcaption aria-hidden="true">image-20241203103522021</figcaption></figure><p><strong>闵可夫斯基距离/欧式距离</strong></p><figure><img src="image-20241203103714043.png" alt="image-20241203103714043" /><figcaption aria-hidden="true">image-20241203103714043</figcaption></figure><p><strong>余弦相似度与相关系数</strong></p><figure><img src="image-20241203103858203.png" alt="image-20241203103858203" /><figcaption aria-hidden="true">image-20241203103858203</figcaption></figure><p><span class="math inline">\(x_{i,k}\)</span>表示向量<span class="math inline">\(\mathbf{x}_{i}\)</span>在第<span class="math inline">\(k\)</span>维的分量</p><p>余弦相似度(样本相关系数)是用来衡量两个向量在<strong>方向</strong>上的相似度，而不考虑它们的<strong>大小</strong>（模）。</p><p><strong>样本相关系数</strong></p><figure><img src="image-20241203105253955.png" alt="image-20241203105253955" /><figcaption aria-hidden="true">image-20241203105253955</figcaption></figure><h2 id="类型">类型</h2><p><strong>聚类主要类型</strong> :</p><ul><li>划分聚类（K-means、K-medoids等）</li><li>层次聚类（凝聚法、分裂法）</li><li>密度聚类（DBScan、 基于密度峰值算法）</li><li>网格法（STING、CLIQUE）</li><li>模型法（概率模型：高斯混合模型Gaussian Mixture Models ；神经网络模型:SOM；吸引子传播算法： AP聚类）</li><li>谱聚类</li></ul><h2 id="基于划分的聚类">基于划分的聚类</h2><p>给定包含N个点的数据集，划分法将构造K个分组，每个分组代表一个聚类，这里每个分组至少包含一个数据点，每个数据点属于且仅属于 一个分组。</p><p>例如:K-means K-medoids</p><figure><img src="image-20241203191043416.png" alt="image-20241203191043416" /><figcaption aria-hidden="true">image-20241203191043416</figcaption></figure><h3 id="k-means算法">K-means算法</h3><blockquote><p>K-means聚类，也称为K-平均或K-均值聚类</p><p>K：是最终簇数量（即：K 往往代表类别的个数）， 它是超参数，需要预先设定</p><p>means：在算法计算中会涉及到求均值</p></blockquote><p><strong>[算法流程]</strong></p><ol type="1"><li>随机选择 K 个簇中心点（可以选已有的数据作为中心点，也可直接选高维空间中的位置）</li><li>样本被分配到离其最近的中心点</li><li>K 个簇中心点根据所在簇样本，以求平均值的方式重新计算</li><li>开始迭代，重复第2步和第3步直到所有样本的分配不再改变</li></ol><figure><img src="image-20241203191917606.png" alt="image-20241203191917606" /><figcaption aria-hidden="true">image-20241203191917606</figcaption></figure><p><strong>[损失函数]</strong></p><figure><img src="image-20241203192245882.png" alt="image-20241203192245882" /><figcaption aria-hidden="true">image-20241203192245882</figcaption></figure><p><strong>[K-means算法 K 的选择-----肘部法]</strong></p><p>目标：找到最合适的点——拐）</p><p>找到一个聚类数目，使得K高于该值之后的<strong>损失变换</strong>会发生<strong>显著递减</strong>,这个 K 值，称为<strong>肘部点</strong>（elbow point），因为它看起来像一个人的肘部。</p><p><strong>[总结]</strong></p><p><strong>优点：</strong></p><ul><li>是解决聚类问题的一种<strong>经典算法</strong>，简单、快速</li><li>对处理大数据集，该算法保持可伸缩性和高效率</li><li>当结果簇是密集的，它的效果较好</li></ul><p><strong>缺点:</strong></p><ul><li>只适合对数值型数据聚类</li><li>必须事先给出k（要生成的簇的数目），而且<strong>对初值敏感</strong>， 对于不同的初始值，可能会导致不同结果。</li><li>不适合于发现非凸面形状的簇或者大小差别很大的簇</li><li>对噪声和孤立点数据敏感</li></ul><p><strong>常常结合其他聚类算法使用</strong></p><p><strong>[改进算法]</strong></p><figure><img src="image-20241203192742427.png" alt="image-20241203192742427" /><figcaption aria-hidden="true">image-20241203192742427</figcaption></figure><h2 id="基于层次的聚类">基于层次的聚类</h2><p>将给定数据集进行<strong>逐层分解</strong>，直到满足某种条件为止</p><p>具体可分为自底向上和自顶向下两种方案。</p><ul><li>凝聚法</li><li>分裂法</li></ul><figure><img src="image-20241203191131821.png" alt="image-20241203191131821" /><figcaption aria-hidden="true">image-20241203191131821</figcaption></figure><h3 id="层次聚类法">层次聚类法</h3><blockquote><p>层次聚类法 (Hierarchical clustering, 也称系统聚类法)</p><p>层次聚类法需要度量<strong>样本点之间的距离</strong> (dissimilarity) 和 <strong>类与类之间的联接</strong> (linkage) 程度</p><p>层次聚类法包括两种:</p><ul><li>聚合方法(agglomerative hierarchical method)(自下而上)</li><li>分裂方法(divisive hierarchical method) (自上而下)</li></ul></blockquote><figure><img src="image-20241203193040585.png" alt="image-20241203193040585" /><figcaption aria-hidden="true">image-20241203193040585</figcaption></figure><p><strong>[树状图]</strong></p><blockquote><p>层次聚类的结果常常使用树状图(dendrogram)来表示.</p></blockquote><figure><img src="image-20241203193521578.png" alt="image-20241203193521578" /><figcaption aria-hidden="true">image-20241203193521578</figcaption></figure><ul><li><p>每个节点表示一个类</p></li><li><p>每个叶子节点表示一个独点(只含一个样本点的类).</p></li><li><p>根节点是包含了所有样本点的类</p></li><li><p>每个中间节点有两个子节点,表示其通过合并这两个子类而来</p></li><li><p>当叶子节点调整到高度0时候,则每个中间节点的高度与其两个子节点间的相异度大小成比例</p></li><li><p>在合适的高度上对树进行切割得到聚类结果,上图的虚线切割成了7类</p></li></ul><p><strong>[算法过程]</strong></p><ol type="1"><li>输入所有样本点,每个点为一个类</li><li>计算相异度(距离)矩阵(<span class="math inline">\(d_{ij}\)</span>)</li><li>合并最小链接(linkage)的两个类</li><li>计算新的类和其他所有类之间链接大小</li><li>重复3-4,直至所有类合并为一个类或者满足停止条件</li><li>输出树状图,切割树状图得到聚类结果</li></ol><p><strong>聚合聚类方法</strong>较分裂式聚类方法更<strong>常用,</strong>分裂方法由于<strong>难以指定合适分裂方法</strong>而不太常用.</p><p><strong>[类间联系程度度量]</strong></p><p><strong>Single linkage单链法</strong></p><blockquote><p>两个簇中最小的两个点之间的距离。</p></blockquote><p>计算公式:<span class="math inline">\(D(I,J)=\min_{i\in I,j \in J} \{d_{ij}\}\)</span></p><p>Single linkage 下的类有<strong>串链特点</strong>. 合并两个类时只看它们最近的点而不管其他点,聚出的类呈现<strong>链状.</strong> 因此适合于<strong>条形甚至S 形的类</strong>. 其聚类结果对相异度的单调变换不变.</p><figure><img src="image-20241203194647059.png" alt="image-20241203194647059" /><figcaption aria-hidden="true">image-20241203194647059</figcaption></figure><figure><img src="image-20241203194912061.png" alt="image-20241203194912061" /><figcaption aria-hidden="true">image-20241203194912061</figcaption></figure><figure><img src="image-20241203194938448.png" alt="image-20241203194938448" /><figcaption aria-hidden="true">image-20241203194938448</figcaption></figure><figure><img src="image-20241203195002649.png" alt="image-20241203195002649" /><figcaption aria-hidden="true">image-20241203195002649</figcaption></figure><figure><img src="image-20241203195412199.png" alt="image-20241203195412199" /><figcaption aria-hidden="true">image-20241203195412199</figcaption></figure><p><strong>[层次聚类法的特点]</strong></p><figure><img src="image-20241203195510120.png" alt="image-20241203195510120" /><figcaption aria-hidden="true">image-20241203195510120</figcaption></figure><h2 id="基于密度的聚类">基于密度的聚类</h2><blockquote><p>密度聚类也称为“基于密度的聚类” (density-based clustering)。指导思想是，只要样本点的密度大于某阈值，则将该样本添加到最近的簇中。</p><p>可发现任意形状的聚类， 且对噪声数据不敏感。但计算密度单元的计算复杂度大，需要建立空间索引来降低计算量。</p></blockquote><p>不依赖于距离，而是依赖于密度，从而克服基 于距离的算法只能发现“球形”聚簇的缺点。只要一个区域中点的密度大于某个阈值，就把它加到与之相近的聚类中去。</p><p>如: DBScan,基于密度峰值算法</p><figure><img src="image-20241203191231428.png" alt="image-20241203191231428" /><figcaption aria-hidden="true">image-20241203191231428</figcaption></figure><h3 id="dbscan算法">DBSCAN算法</h3><blockquote><p>核心思想：将簇定义为密度相连的点的最大集合，能够把具有高密度的区域划分为簇。</p></blockquote><figure><img src="image-20241203200426746.png" alt="image-20241203200426746" /><figcaption aria-hidden="true">image-20241203200426746</figcaption></figure><figure><img src="image-20241203200456844.png" alt="image-20241203200456844" /><figcaption aria-hidden="true">image-20241203200456844</figcaption></figure><figure><img src="image-20241203200856012.png" alt="image-20241203200856012" /><figcaption aria-hidden="true">image-20241203200856012</figcaption></figure><p>密度直达、密度可达、密度相连的两个点属于同一个 聚类；非密度相连的两个点属于不同的聚类簇，或者 其中存在噪声点。</p><figure><img src="image-20241203201047295.png" alt="image-20241203201047295" /><figcaption aria-hidden="true">image-20241203201047295</figcaption></figure><p><strong>[算法步骤]</strong></p><p>通过检查数据集中每个对象的ε 邻域来寻找聚类</p><p>具体步骤如下：</p><ol type="1"><li>如果一个点p 的<span class="math inline">\(\epsilon\)</span>邻域中大于m个对象，则创建一个p 为核心对象的新簇</li><li>依据p 来反复寻找<strong>密度相连</strong>的集合（有可能合并原有已经生成的簇）</li><li>当没有任何新的点可以被添加到簇中的时候，寻找结束。</li></ol><h2 id="基于模型的聚类">基于模型的聚类</h2><p>给每一个聚类<strong>假定一个模型</strong>，然后去寻找能很好的拟合模型的数据集,模型可能是数据点在空间中的<strong>密度分布函数</strong>或者其它。 数据集是由一系列的潜在概率分布生成的。</p><p>如:GMM,SOM,AP</p><figure><img src="image-20241203191355012.png" alt="image-20241203191355012" /><figcaption aria-hidden="true">image-20241203191355012</figcaption></figure><h3 id="吸引子传播算法ap聚类">吸引子传播算法(AP聚类)</h3><blockquote><p>吸引子传播(Affinity propagation)算法基本思想：通过在不同点之间不断的传递信息（吸引度(responsibility)和归属 度(availability) ），从而最终选出聚类中心，完成聚类。</p></blockquote><figure><img src="image-20241203201429438.png" alt="image-20241203201429438" /><figcaption aria-hidden="true">image-20241203201429438</figcaption></figure><figure><img src="image-20241203201448790.png" alt="image-20241203201448790" /><figcaption aria-hidden="true">image-20241203201448790</figcaption></figure><h3 id="基于网格的聚类">基于网格的聚类</h3><p>将数据空间划分成有限个单元的网格结构，所有的处理都是以单个的单元为对象。</p><p>如:STING,CLIQUE</p><figure><img src="image-20241203191435380.png" alt="image-20241203191435380" /><figcaption aria-hidden="true">image-20241203191435380</figcaption></figure><h1 id="降维">降维</h1><h2 id="主成分分析法">主成分分析法</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;写在前面的话&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;考试的题型为单项选择，简答，解答和论述四种类型。&lt;/p&gt;
&lt;p&gt;我们是第一届考试，一无所知，我随便写写，各位随便看看&lt;/p&gt;
&lt;p&gt;推荐看一下b站上吴恩达老师的机器学习&lt;/p&gt;</summary>
      
    
    
    
    <category term="class" scheme="https://klklkl10086.github.io/klklkl10086.github.io/categories/class/"/>
    
    
    <category term="Machine Learning" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>题解--Codeforces Round 680 [C. Division]</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2024/10/02/cf/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2024/10/02/cf/</id>
    <published>2024-10-02T14:44:09.000Z</published>
    <updated>2024-10-02T14:50:52.680Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1445/problem/C">C. Division</a></p><h3 id="c.-division">C. Division</h3><p>Oleg's favorite subjects are History and Math, and his favorite branch of mathematics is division.</p><p>To improve his division skills, Oleg came up with <span class="math inline">\(t\)</span> pairs of integers <span class="math inline">\(p_i\)</span> and <span class="math inline">\(q_i\)</span> and for each pair decided to find the <strong>greatest</strong> integer <span class="math inline">\(x_i\)</span>, such that:</p><ul><li><span class="math inline">\(p_i\)</span> is divisible by <span class="math inline">\(x_i\)</span>;</li><li><span class="math inline">\(x_i\)</span> is not divisible by <span class="math inline">\(q_i\)</span>.</li></ul><p>Oleg is really good at division and managed to find all the answers quickly, how about you?</p><p><strong>Input</strong></p><p>The first line contains an integer <span class="math inline">\(t\)</span> (<span class="math inline">\(1 \le t \le 50\)</span>) — the number of pairs.</p><p>Each of the following <span class="math inline">\(t\)</span> lines contains two integers <span class="math inline">\(p_i\)</span> and <span class="math inline">\(q_i\)</span> (<span class="math inline">\(1 \le p_i \le 10^{18}\)</span>; <span class="math inline">\(2 \le q_i \le 10^{9}\)</span>) — the <span class="math inline">\(i\)</span>-th pair of integers.</p><p><strong>Output</strong></p><p>Print <span class="math inline">\(t\)</span> integers: the <span class="math inline">\(i\)</span>-th integer is the largest <span class="math inline">\(x_i\)</span> such that <span class="math inline">\(p_i\)</span> is divisible by <span class="math inline">\(x_i\)</span>, but <span class="math inline">\(x_i\)</span> is not divisible by <span class="math inline">\(q_i\)</span>.</p><p>One can show that there is always at least one value of <span class="math inline">\(x_i\)</span> satisfying the divisibility conditions for the given constraints.</p><h4 id="样例">样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">3</span><br><span class="line">10 4</span><br><span class="line">12 6</span><br><span class="line">179 822</span><br><span class="line">输出:</span><br><span class="line">10</span><br><span class="line">4</span><br><span class="line">179</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr /><h3 id="算法1">算法1</h3><h5 id="分解质因数">分解质因数</h5><figure><img src="image-20241002225028721.png" alt="image-20241002225028721" /><figcaption aria-hidden="true">image-20241002225028721</figcaption></figure><h4 id="参考文献">参考文献</h4><p><a href="https://blog.csdn.net/JdiLfc/article/details/109479448?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-109479448-blog-109470145.235%5Ev43%5Epc_blog_bottom_relevance_base3&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">参考</a> #### C++ 代码 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(ll x)</span><span class="comment">//质因数分解</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">2</span>;i*i&lt;=x;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(x%i==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">res.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">while</span>(x%i==<span class="number">0</span>)</span><br><span class="line">x/=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x!=<span class="number">1</span>) res.<span class="built_in">push_back</span>(x);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">       ll p,q;</span><br><span class="line">       <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;p,&amp;q);</span><br><span class="line">       <span class="keyword">if</span>(p%q!=<span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p);</span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br><span class="line">       vector&lt;<span class="type">int</span> &gt;a = <span class="built_in">div</span>(q);<span class="comment">//获取q的所有质因数</span></span><br><span class="line">       ll res=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)<span class="comment">//遍历q的全部因数</span></span><br><span class="line">       &#123;</span><br><span class="line">        ll k=p;</span><br><span class="line">        <span class="keyword">while</span>(k%q==<span class="number">0</span>)<span class="comment">//如果剩下的数能被q整除 说明还有a[i]这个因数</span></span><br><span class="line">        &#123;</span><br><span class="line">        k/=a[i];</span><br><span class="line"> &#125;</span><br><span class="line"> res=<span class="built_in">max</span>(res,k);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1445/problem/C&quot;&gt;C. Division&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;c.-division&quot;&gt;C. Division&lt;/h3&gt;
&lt;p&gt;Oleg&#39;s favorite su</summary>
      
    
    
    
    <category term="算法" scheme="https://klklkl10086.github.io/klklkl10086.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="题解" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="codeforces" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/codeforces/"/>
    
    <category term="质因数分解" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%88%86%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>前端学习笔记(从html到js)</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2024/09/02/%E5%89%8D%E7%AB%AF-html5-css/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2024/09/02/%E5%89%8D%E7%AB%AF-html5-css/</id>
    <published>2024-09-02T00:55:50.000Z</published>
    <updated>2025-03-29T05:46:17.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="html5">HTML5</h1><h2 id="标签">标签</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>声明</p><h3 id="基础骨架标签">基础骨架标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="标题标签"><strong>标题标签</strong></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span><span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span><span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line">// h$*6 快速生成六个标题标签</span><br></pre></td></tr></table></figure><p>h1最重要,h6最不重要</p><p><strong>位置设置</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">align</span>=<span class="string">&quot;left&quot;</span>&gt;</span>one<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>two<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">align</span>=<span class="string">&quot;right&quot;</span>&gt;</span>three<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure><p>默认left</p><h3 id="段落标签">段落标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>i am pass<span class="tag">&lt;<span class="name">br</span>&gt;</span>age2<span class="tag">&lt;/<span class="name">p</span>&gt;</span> //单标签<span class="tag">&lt;<span class="name">br</span>&gt;</span>表示换行</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span> <span class="attr">color</span>=<span class="string">&quot;red&quot;</span> <span class="attr">width</span>=<span class="string">&quot;px1&quot;</span> <span class="attr">size</span>=<span class="string">&quot;px12&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>/&gt;</span> //分割线</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> <span class="tag">&lt;<span class="name">hr</span> <span class="attr">color</span>=<span class="string">&quot;red&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300px&quot;</span> <span class="attr">size</span>=<span class="string">&quot;&quot;</span> <span class="attr">align</span>=<span class="string">&quot;left&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">分割线的颜色 宽度 高度 位置(默认center)</span><br></pre></td></tr></table></figure><h3 id="图片标签">图片标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">width</span>=<span class="string">&quot;&quot;</span> <span class="attr">height</span>=<span class="string">&quot;&quot;</span> <span class="attr">title</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">src:图片的路径  绝对路径 相对路径 网络路径</span><br><span class="line">alt:图片无法显示的时候显示的文本,可以不写</span><br><span class="line">width:图像宽度</span><br><span class="line">height:图片高度</span><br><span class="line">title:鼠标悬停的图片的提示</span><br></pre></td></tr></table></figure><h3 id="超文本链接">超文本链接</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">url</span>&gt;</span>名称<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span>&gt;</span> baidu <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>没点过是蓝色,点过变成紫色</p><h3 id="文本标签">文本标签</h3><blockquote><p>显示不一样的文字,与段落标签不同,文本标签仅仅是为了词汇文本,可以嵌套</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span> em klklkl<span class="tag">&lt;/<span class="name">em</span>&gt;</span> //着重 斜体</span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span> i klklkl<span class="tag">&lt;/<span class="name">i</span>&gt;</span>   // 斜体</span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>b klklkl<span class="tag">&lt;/<span class="name">b</span>&gt;</span>      //加粗</span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>strong klklkl<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>  // 加粗 加重语气</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>span klklkl<span class="tag">&lt;/<span class="name">span</span>&gt;</span>    //无效果 为了css</span><br><span class="line"><span class="tag">&lt;<span class="name">del</span>&gt;</span>del klklkl<span class="tag">&lt;/<span class="name">del</span>&gt;</span>   //删除线</span><br></pre></td></tr></table></figure><figure><img src="image-20240902094946221.png" alt="image-20240902094946221" /><figcaption aria-hidden="true">image-20240902094946221</figcaption></figure><h3 id="列表标签">列表标签</h3><p><strong>有序列表</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>1st line<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>2st line<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>3st line<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>4st line<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>5st line<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><figure><img src="image-20240902101449978.png" alt="image-20240902101449978" /><figcaption aria-hidden="true">image-20240902101449978</figcaption></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>1st line<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>type可以为: 1, a, A, i, I</strong></p><p><strong>可以嵌套</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>2st line</span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>嵌套<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>无序列表</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1st line<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2st line<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3st line<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>4st line<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>5st line<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure><img src="image-20240902102039693.png" alt="image-20240902102039693" /><figcaption aria-hidden="true">image-20240902102039693</figcaption></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span>&gt;</span>// disc默认实心圆  circle空心圆 square小方块 none不显示</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1st line<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">ul&gt;li*[数字] 快捷生成若干个li标签</span><br></pre></td></tr></table></figure><p><strong>和有序标签一样可以嵌套</strong></p><p><strong>可以实现导航效果(css)</strong></p><h3 id="表格标签">表格标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">表格:<span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">行:  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">单元格:<span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>r1 c1,<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>r1 c2,<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>r1 c3,<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>r2 c1,<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>r2 c2,<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>r2 c3,<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>r3 c1,<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>r3 c2,<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>r3 c3,<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>r4 c1,<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>r4 c2,<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>r4 c3,<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><figure><img src="image-20240902103208417.png" alt="image-20240902103208417" /><figcaption aria-hidden="true">image-20240902103208417</figcaption></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">快速生成表格:table&gt;tr*[num]&gt;td*[num]&#123;内容&#125;</span><br></pre></td></tr></table></figure><p><strong>表格属性</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> [<span class="attr">属性</span>]=<span class="string">&quot;&quot;</span> [<span class="attr">属性</span>]=<span class="string">&quot;&quot;</span> [<span class="attr">属性</span>]=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>常用属性</p><p>border : 边框</p><p>width :宽度</p><p>height :高度</p></blockquote><p><strong>表格单元格合并</strong></p><blockquote><p>水平合并: colspan 保留左边删除右边</p><p>垂直合并: rowspan 保留上边删除下边</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">clospan</span>=<span class="string">&quot;[num]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">rowspan</span>=<span class="string">&quot;[num]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">clospan</span>=<span class="string">&quot;[num]&quot;</span> <span class="attr">rowspan</span>=<span class="string">&quot;[num]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="容器标签">容器标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> &gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>分区</p><figure><img src="image-20240904104545395.png" alt="image-20240904104545395" /><figcaption aria-hidden="true">image-20240904104545395</figcaption></figure><figure><img src="image-20240904104637631.png" alt="image-20240904104637631" /><figcaption aria-hidden="true">image-20240904104637631</figcaption></figure><p>但是,H5新标签对浏览器有要求</p><h2 id="form表单">Form表单</h2><blockquote><p>用户输入,使网页具有交互性,例如: 登录注册 搜索框</p><p>容器+控件</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> &gt;</span>  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>action:服务器地址</li><li>method:数据的提交方式 get / post</li><li>name:表单名称</li></ul><h3 id="表单元素">表单元素</h3><blockquote><p>表单标签 表单域 表单按钮</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> &gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span>// 表单域</span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span> //表单按钮</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure><img src="image-20240902105311053.png" alt="image-20240902105311053" /><figcaption aria-hidden="true">image-20240902105311053</figcaption></figure><h3 id="文本框">文本框</h3><blockquote><p>文本域通过 <code>&lt;input type="text"&gt;</code>标签进行设定,当用户需要向表单中键入字母 数字等内容时,会用到文本域</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>  <span class="attr">method</span>=<span class="string">&quot;&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> &gt;</span> </span><br><span class="line">        username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        keyword: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure><img src="image-20240903112901105.png" alt="image-20240903112901105" /><figcaption aria-hidden="true">image-20240903112901105</figcaption></figure><h3 id="密码框">密码框</h3><blockquote><p><code>&lt;input type="password"&gt;</code>进行设定,密码字段字符不会明文显示,而是以星号或者圆点替代</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>  <span class="attr">method</span>=<span class="string">&quot;&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> &gt;</span> </span><br><span class="line">        username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        Password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure><img src="image-20240903113153821.png" alt="image-20240903113153821" /><figcaption aria-hidden="true">image-20240903113153821</figcaption></figure><h3 id="提交按钮">提交按钮</h3><blockquote><p>用户点击确认按钮的时候,表单的内容会被传送到另一个文件,表单的动作属性定义了目的文件的文件名,由动作属性定义的这个文件会对接收到的输入进行相关处理</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>  <span class="attr">method</span>=<span class="string">&quot;&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> &gt;</span> </span><br><span class="line">           username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">           Password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;login&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure><img src="image-20240903113626406.png" alt="image-20240903113626406" /><figcaption aria-hidden="true">image-20240903113626406</figcaption></figure><h2 id="块级元素与行内元素内联元素">块级元素与行内元素(内联元素)</h2><figure><img src="image-20240903113955906.png" alt="image-20240903113955906" /><figcaption aria-hidden="true">image-20240903113955906</figcaption></figure><p><strong>常见的块级元素</strong></p><blockquote><p>div form h1-h6 hr p table ul ol ...</p></blockquote><p><strong>常见行内元素</strong></p><blockquote><p>a b em i span strong...</p></blockquote><p><strong>行内快级元素(特点:不换行 能够识别宽高)</strong></p><blockquote><p>button img input ..</p></blockquote><h1 id="css">CSS</h1><blockquote><p>美化器</p></blockquote><h2 id="语法">语法</h2><blockquote><p>选择器 + 声明(样式)</p><p>选择器选择HTML元素,一个声明由一个属性和一个值组成</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">     <span class="selector-tag">h3</span>&#123;</span></span><br><span class="line"><span class="language-css">          <span class="attribute">color</span>:red;</span></span><br><span class="line"><span class="language-css">          <span class="attribute">font-size</span>:<span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="引入方式">引入方式</h2><h3 id="内联样式">内联样式</h3><p>在head中进行书写,对head所在的网页的元素进行设置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>my page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">            <span class="selector-tag">h3</span>&#123;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">color</span>:red;</span></span><br><span class="line"><span class="language-css">            &#125;</span></span><br><span class="line"><span class="language-css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>     </span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span> &gt;</span> title <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当网页跳转后,样式设置会失效</p><h3 id="内部样式">内部样式</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">style</span>=<span class="string">&quot;color: blue;&quot;</span>&gt;</span> title <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="外部样式">外部样式</h3><figure><img src="image-20240904162535090.png" alt="image-20240904162535090" /><figcaption aria-hidden="true">image-20240904162535090</figcaption></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./try.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在head标签中书写,表示对整个网页应用href的样式</p><h2 id="选择器">选择器</h2><h3 id="全局选择器">全局选择器</h3><blockquote><p><strong>可以与任何元素匹配,优先级最低,一般做样式的初始化</strong></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">    font-size: 30px;</span><br><span class="line">     color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="元素选择器">元素选择器</h3><blockquote><p><strong>p b div a img body</strong></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">span&#123;</span><br><span class="line">      font-size: 40px;</span><br><span class="line">      color: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>my page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">            <span class="selector-tag">span</span>&#123;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">font-size</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">color</span>: green;</span></span><br><span class="line"><span class="language-css">            &#125;</span></span><br><span class="line"><span class="language-css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>no 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>i am title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>no 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>i<span class="tag">&lt;<span class="name">span</span>&gt;</span> am<span class="tag">&lt;/<span class="name">span</span>&gt;</span> color<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure><img src="image-20240904163815074.png" alt="image-20240904163815074" /><figcaption aria-hidden="true">image-20240904163815074</figcaption></figure><p>所有的标签都可以是选择器</p><p>选择的是所有</p><h3 id="类选择器">类选择器</h3><blockquote><p><strong>规定用圆点来定义,针对你想要的所有标签使用,较为灵活</strong></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.content&#123;</span><br><span class="line">                color:red;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>my page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">            <span class="selector-class">.content</span>&#123;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">color</span>:red;</span></span><br><span class="line"><span class="language-css">            &#125;</span></span><br><span class="line"><span class="language-css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span> i  am  world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure><img src="image-20240904164219259.png" alt="image-20240904164219259" /><figcaption aria-hidden="true">image-20240904164219259</figcaption></figure><ul><li><strong>类选择器可以被多种标签使用</strong></li><li><strong>类名不能以数字开头</strong></li><li><strong>同一个标签可以使用多个类选择器,用<u>空格</u>隔开</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.content&#123;</span><br><span class="line">                color:red;</span><br><span class="line">            &#125;</span><br><span class="line"> .size&#123;</span><br><span class="line"> font-sizez:30px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;content size&quot;</span>&gt;</span> i  am  world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="id选择器">ID选择器</h3><blockquote><p>针对某一个特定的标签来使用,只能使用一次,以<code>#</code>定义,id只能重复一次</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>my page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">            <span class="selector-id">#text</span>&#123;</span></span><br><span class="line"><span class="language-css">                 <span class="attribute">color</span>:red;</span></span><br><span class="line"><span class="language-css">                &#125;</span></span><br><span class="line"><span class="language-css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;text&quot;</span>&gt;</span>hello <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">//不能出现两个text</span><br></pre></td></tr></table></figure><h3 id="合并选择器">合并选择器</h3><blockquote><p>提取共同的样式,减少代码重复</p><p>语法:选择器1,选择器2...{}</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>my page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">            <span class="selector-tag">p</span>,<span class="selector-tag">h3</span>&#123;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">font-size</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">                 </span></span><br><span class="line"><span class="language-css">                &#125;</span></span><br><span class="line"><span class="language-css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> &gt;</span>hello <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>world<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure><img src="image-20240909085739481.png" alt="image-20240909085739481" /><figcaption aria-hidden="true">image-20240909085739481</figcaption></figure><h3 id="优先级">优先级</h3><table><thead><tr class="header"><th style="text-align: center;">选择器类型</th><th style="text-align: center;">格式</th><th style="text-align: center;">权重</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">全局</td><td style="text-align: center;">*</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">元素</td><td style="text-align: center;">标签名字</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;">类</td><td style="text-align: center;">claa名字(.)</td><td style="text-align: center;">10</td></tr><tr class="even"><td style="text-align: center;">ID</td><td style="text-align: center;">id名字(#)</td><td style="text-align: center;">100</td></tr></tbody></table><blockquote><p>行内样式&gt;ID选择器&gt;类选择器&gt;元素选择器,相同优先级后写的生效</p></blockquote><h2 id="字体属性">字体属性</h2><blockquote><p>颜色 大小 加粗 文字样式</p></blockquote><h3 id="color">color</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">color:red;</span><br><span class="line">color:#ff0000;  // 红色  6位十六进制数字</span><br><span class="line">color:rgb(0,0,0);  //每个数字0-255</span><br><span class="line">color:rgba(0,0,0,0);  //最后一位表示透明度 0-1之间</span><br></pre></td></tr></table></figure><h3 id="font-size">font-size</h3><p><strong>字体大小</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-size:100px;</span><br></pre></td></tr></table></figure><p><strong>chorm浏览器接受的最小字体是12px</strong></p><h3 id="font-weight">font-weight</h3><p><strong>字体粗细</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-weight:[value];</span><br></pre></td></tr></table></figure><table><thead><tr class="header"><th style="text-align: center;">值</th><th style="text-align: center;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">bold</td><td style="text-align: center;">粗体</td></tr><tr class="even"><td style="text-align: center;">bolder</td><td style="text-align: center;">更粗</td></tr><tr class="odd"><td style="text-align: center;">lighter</td><td style="text-align: center;">更细</td></tr><tr class="even"><td style="text-align: center;">100-900</td><td style="text-align: center;">由细到粗 400为默认 700等价于bold</td></tr></tbody></table><h3 id="font-style">font-style</h3><p><strong>字体样式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-style:[value];</span><br></pre></td></tr></table></figure><table><thead><tr class="header"><th style="text-align: center;">值</th><th style="text-align: center;">样式</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">normal</td><td style="text-align: center;">默认值</td></tr><tr class="even"><td style="text-align: center;">italic</td><td style="text-align: center;">斜体</td></tr></tbody></table><h3 id="font-family">font-family</h3><p>指定元素字体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: &quot;微软雅黑&quot;; </span><br></pre></td></tr></table></figure><h2 id="背景属性">背景属性</h2><h3 id="background-color">background-color</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>my page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">            <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">width</span>:<span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">            &#125;</span></span><br><span class="line"><span class="language-css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> &gt;</span>颜色属性 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>world<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure><img src="image-20240909091943212.png" alt="image-20240909091943212" /><figcaption aria-hidden="true">image-20240909091943212</figcaption></figure><h3 id="background-image">background-image</h3><blockquote><p>设置元素背景图片</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>my page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">            <span class="selector-class">.box1</span>&#123;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">width</span>:<span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">            &#125;</span></span><br><span class="line"><span class="language-css">            <span class="selector-class">.box2</span>&#123;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">width</span>: <span class="number">1000px</span>;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">&quot;pexels-eberhardgross-691668.jpg&quot;</span>);</span></span><br><span class="line"><span class="language-css">            &#125;</span></span><br><span class="line"><span class="language-css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> &gt;</span>颜色属性 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>world<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="background-repeat">background-repeat</h3><blockquote><p>设置如何平铺图像</p></blockquote><table><thead><tr class="header"><th style="text-align: center;">值</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">repeat</td><td style="text-align: center;">默认值</td></tr><tr class="even"><td style="text-align: center;">repeat-x</td><td style="text-align: center;">只水平方向平铺</td></tr><tr class="odd"><td style="text-align: center;">repeat-y</td><td style="text-align: center;">只垂直方向</td></tr><tr class="even"><td style="text-align: center;">no-repeat</td><td style="text-align: center;">不平铺</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>my page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">            <span class="selector-class">.box1</span>&#123;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">width</span>:<span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">            &#125;</span></span><br><span class="line"><span class="language-css">            <span class="selector-class">.box2</span>&#123;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">width</span>: <span class="number">1000px</span>;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">&quot;pexels-eberhardgross-691668.jpg&quot;</span>);</span></span><br><span class="line"><span class="language-css">                <span class="attribute">background-repeat</span>: repeat-x;</span></span><br><span class="line"><span class="language-css">            &#125;</span></span><br><span class="line"><span class="language-css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> &gt;</span>颜色属性 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>world<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="background-size">background-size</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">background-size:100px,100px;</span><br><span class="line">background-size:100%,100%;</span><br><span class="line">background-size:cover;</span><br><span class="line">background-size:contain;</span><br></pre></td></tr></table></figure><figure><img src="image-20240909093321278.png" alt="image-20240909093321278" /><figcaption aria-hidden="true">image-20240909093321278</figcaption></figure><h3 id="background-position">background-position</h3><p>设置图像的起始位置,默认为 0 % 0%</p><figure><img src="image-20240909093701055.png" alt="image-20240909093701055" /><figcaption aria-hidden="true">image-20240909093701055</figcaption></figure><h2 id="文本属性">文本属性</h2><h3 id="text-align">text-align</h3><blockquote><p>指定文本的对齐方式</p></blockquote><figure><img src="image-20240909094004279.png" alt="image-20240909094004279" /><figcaption aria-hidden="true">image-20240909094004279</figcaption></figure><h3 id="text-decoration">text-decoration</h3><blockquote><p>上划线 下划线 删除线等</p></blockquote><figure><img src="image-20240909094131426.png" alt="image-20240909094131426" /><figcaption aria-hidden="true">image-20240909094131426</figcaption></figure><h3 id="text-transform">text-transform</h3><blockquote><p>控制文本大小写</p></blockquote><figure><img src="image-20240909094231263.png" alt="image-20240909094231263" /><figcaption aria-hidden="true">image-20240909094231263</figcaption></figure><h3 id="text-indent">text-indent</h3><blockquote><p>规定文本块首行文本缩进</p></blockquote><figure><img src="image-20240909094300020.png" alt="image-20240909094300020" /><figcaption aria-hidden="true">image-20240909094300020</figcaption></figure><h2 id="表格属性">表格属性</h2><h3 id="表格边框">表格边框</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span>,<span class="selector-tag">td</span>&#123;</span><br><span class="line">                <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">                <span class="attribute">border-collapse</span>:collapse ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="image-20240909095044271.png" alt="image-20240909095044271" /><figcaption aria-hidden="true">image-20240909095044271</figcaption></figure><h3 id="折叠边框">折叠边框</h3><p>让表格被单一的边框隔开</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span>&#123; <span class="attribute">border-collapse</span>:collapse ;&#125;</span><br></pre></td></tr></table></figure><h3 id="大小">大小</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span>&#123; <span class="attribute">width</span>:<span class="number">100px</span> ;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">50px</span>;&#125;</span><br></pre></td></tr></table></figure><h3 id="表格文字对齐方式">表格文字对齐方式</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">td</span>&#123;<span class="attribute">text-align</span>:center; &#125;</span><br><span class="line"><span class="selector-tag">td</span>&#123;<span class="attribute">vertical-align</span>:bottom; &#125;</span><br></pre></td></tr></table></figure><figure><img src="image-20240909095336983.png" alt="image-20240909095336983" /><figcaption aria-hidden="true">image-20240909095336983</figcaption></figure><h3 id="表格填充">表格填充</h3><p>控制空格之间的边框</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">td</span>&#123;<span class="attribute">padding</span>:<span class="number">15px</span>; &#125;</span><br></pre></td></tr></table></figure><h3 id="表格颜色">表格颜色</h3><figure><img src="image-20240909100536827.png" alt="image-20240909100536827" /><figcaption aria-hidden="true">image-20240909100536827</figcaption></figure><h2 id="关系选择器">关系选择器</h2><h3 id="后代选择器">后代选择器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E F&#123;&#125;</span><br><span class="line">选择被E包括的所有F标签,设置其样式</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE <span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">html</span>&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;my page&lt;/title&gt;</span><br><span class="line">        &lt;meta charset=&quot;utf-<span class="number">8</span>&quot;&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            <span class="selector-tag">ul</span> <span class="selector-tag">li</span>&#123;</span><br><span class="line">                <span class="attribute">color</span>: green;</span><br><span class="line">        &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">      &lt;<span class="selector-tag">ul</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">li</span>&gt;</span><br><span class="line">            one</span><br><span class="line">            &lt;<span class="selector-tag">ul</span>&gt;</span><br><span class="line">                &lt;<span class="selector-tag">li</span>&gt;<span class="number">1.1</span>&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">            &lt;/<span class="selector-tag">ul</span>&gt;</span><br><span class="line">        &lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">      &lt;/<span class="selector-tag">ul</span>&gt;</span><br><span class="line">      </span><br><span class="line">    &lt;/<span class="selector-tag">body</span>&gt;</span><br><span class="line">   </span><br><span class="line">&lt;/<span class="selector-tag">html</span>&gt;</span><br></pre></td></tr></table></figure><figure><img src="image-20240909101116612.png" alt="image-20240909101116612" /><figcaption aria-hidden="true">image-20240909101116612</figcaption></figure><h3 id="子代选择器">子代选择器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E&gt;F&#123;&#125;</span><br></pre></td></tr></table></figure><p>选择E标签的直接子代标签</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE <span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">html</span>&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;my page&lt;/title&gt;</span><br><span class="line">        &lt;meta charset=&quot;utf-<span class="number">8</span>&quot;&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            <span class="selector-tag">div</span>&gt;<span class="selector-tag">p</span>&#123;</span><br><span class="line">                <span class="attribute">color</span>: green;</span><br><span class="line">        &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">      &lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">p</span>&gt;<span class="selector-tag">div</span> 的子代&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">span</span>&gt;</span><br><span class="line">            &lt;<span class="selector-tag">p</span>&gt; <span class="number">000000</span>&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">        &lt;/<span class="selector-tag">span</span>&gt;</span><br><span class="line">      &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">      </span><br><span class="line">    &lt;/<span class="selector-tag">body</span>&gt;</span><br><span class="line">   </span><br><span class="line">&lt;/<span class="selector-tag">html</span>&gt;</span><br></pre></td></tr></table></figure><figure><img src="image-20240909101352542.png" alt="image-20240909101352542" /><figcaption aria-hidden="true">image-20240909101352542</figcaption></figure><h3 id="相邻兄弟选择器">相邻兄弟选择器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E+F&#123;&#125;</span><br></pre></td></tr></table></figure><p>选择E相邻的F标签,只能向下选择</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>my page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">            <span class="selector-tag">h3</span>+<span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">color</span>: green;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">h3</span>&gt;</span> head<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>bro 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>bro 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure><img src="image-20240909101539706.png" alt="image-20240909101539706" /><figcaption aria-hidden="true">image-20240909101539706</figcaption></figure><h3 id="通用兄弟选择器">通用兄弟选择器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E~F&#123;&#125;</span><br></pre></td></tr></table></figure><p>选择E下面所有为F标签的兄弟元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>my page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">            <span class="selector-tag">h3</span>~<span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">color</span>: green;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">h3</span>&gt;</span> head<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>bro 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>bro 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure><img src="image-20240909101705239.png" alt="image-20240909101705239" /><figcaption aria-hidden="true">image-20240909101705239</figcaption></figure><h2 id="盒子模型">盒子模型</h2><figure><img src="image-20240909101944621.png" alt="image-20240909101944621" /><figcaption aria-hidden="true">image-20240909101944621</figcaption></figure><figure><img src="image-20240909102444114.png" alt="image-20240909102444114" /><figcaption aria-hidden="true">image-20240909102444114</figcaption></figure><figure><img src="image-20240909102620251.png" alt="image-20240909102620251" /><figcaption aria-hidden="true">image-20240909102620251</figcaption></figure><h2 id="弹性盒模型">弹性盒模型</h2><figure><img src="image-20240909103056436.png" alt="image-20240909103056436" /><figcaption aria-hidden="true">image-20240909103056436</figcaption></figure><blockquote><p>弹性盒子由弹性容器(Flex container)和弹性子元素(Flex item)组成。</p><p>弹性容器通过设置 display 属性的值为 flex 或 inline-flex将其定义为弹性容器。</p><p>弹性容器内包含了一个或多个弹性子元素。</p></blockquote><p><strong>弹性子元素在弹性盒子内默认横向摆放</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE <span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">html</span>&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;my page&lt;/title&gt;</span><br><span class="line">        &lt;meta charset=&quot;utf-<span class="number">8</span>&quot;&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">           <span class="selector-class">.container</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>:<span class="number">500px</span>;</span><br><span class="line">            <span class="attribute">height</span>:<span class="number">500px</span>;</span><br><span class="line">            <span class="attribute">background-color</span>: black;</span><br><span class="line">            <span class="attribute">display</span>:flex;<span class="comment">/*设置为弹性盒子*/</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="selector-class">.box1</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">background-color</span>: red;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="selector-class">.box2</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">background-color</span>: blue;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="selector-class">.box3</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">background-color</span>: green;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="selector-class">.box4</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">background-color</span>: orange;</span><br><span class="line">           &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">div</span> class=&quot;container&quot; &gt;</span><br><span class="line">            &lt;<span class="selector-tag">div</span> class = &quot;box1&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">            &lt;<span class="selector-tag">div</span> class = &quot;box2&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">            &lt;<span class="selector-tag">div</span> class = &quot;box3&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">            &lt;<span class="selector-tag">div</span> class = &quot;box4&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">        &lt;/<span class="selector-tag">div</span>&gt;    </span><br><span class="line">    &lt;/<span class="selector-tag">body</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">html</span>&gt;</span><br></pre></td></tr></table></figure><figure><img src="image-20240911223141689.png" alt="image-20240911223141689" /><figcaption aria-hidden="true">image-20240911223141689</figcaption></figure><h3 id="弹性容器的属性">弹性容器的属性</h3><p><strong><code>flex-direction</code></strong> 决定弹性项目的主轴方向（水平或垂直）：</p><ul><li><p><code>row</code>：主轴为水平方向，项目从左到右排列（默认值）。</p></li><li><p><code>row-reverse</code>：主轴为水平方向，项目<strong>从右到左</strong>排列。</p></li><li><p><code>column</code>：主轴为垂直方向，项目从上到下排列。</p></li><li><p><code>column-reverse</code>：主轴为垂直方向，项目<strong>从下到上</strong>排列。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>:<span class="number">500px</span>;</span><br><span class="line">            <span class="attribute">height</span>:<span class="number">500px</span>;</span><br><span class="line">            <span class="attribute">background-color</span>: black;</span><br><span class="line">            <span class="attribute">display</span>:flex;</span><br><span class="line">            <span class="attribute">flex-direction</span>: column;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong><code>justify-content</code></strong> 控制弹性项目在主轴上的对齐方式(垂直方向上进行控制)：</p><ul><li><code>flex-start</code>：项目向主轴起点对齐。(默认)</li><li><code>flex-end</code>：项目向主轴终点对齐。</li><li><code>center</code>：项目在主轴上居中。</li><li><code>space-between</code>：项目在主轴上均匀分布，第一项靠起点，最后一项靠终点。</li><li><code>space-around</code>：项目在主轴上均匀分布，项目两侧有相同的间距。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>:<span class="number">500px</span>;</span><br><span class="line">            <span class="attribute">height</span>:<span class="number">500px</span>;</span><br><span class="line">            <span class="attribute">background-color</span>: black;</span><br><span class="line">            <span class="attribute">display</span>:flex;</span><br><span class="line">            <span class="attribute">flex-direction</span>: column;</span><br><span class="line">            <span class="attribute">justify-content</span>: space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>align-items</code></strong> 控制弹性项目在交叉轴（与主轴垂直的轴）上的对齐方式(水平方向进行控制)：</p><ul><li><p><code>stretch</code>：默认值，项目在交叉轴上拉伸以填满容器（如果未设置固定高度）。</p></li><li><p><code>flex-start</code>：项目向交叉轴的起点对齐。</p></li><li><p><code>flex-end</code>：项目向交叉轴的终点对齐。</p></li><li><p><code>center</code>：项目在交叉轴上居中。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>:<span class="number">500px</span>;</span><br><span class="line">            <span class="attribute">height</span>:<span class="number">500px</span>;</span><br><span class="line">            <span class="attribute">background-color</span>: black;</span><br><span class="line">            <span class="attribute">display</span>:flex;</span><br><span class="line">            <span class="attribute">flex-direction</span>: column;</span><br><span class="line">            <span class="attribute">justify-content</span>: center;</span><br><span class="line">            <span class="attribute">align-items</span>: center;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong><code>flex-wrap</code></strong> 控制弹性项目是否换行：</p><ul><li><code>nowrap</code>：项目不换行，超出容器的内容会溢出（默认值）。</li><li><code>wrap</code>：项目自动换行。</li></ul><h3 id="弹性项目的属性">弹性项目的属性</h3><p><strong><code>flex-grow</code></strong> 控制项目的放大比例，如果所有项目的 <code>flex-grow</code> 为1，它们将等比例分配剩余空间。</p><p><strong>优先级大于宽度的优先级</strong></p><p><strong><code>flex-shrink</code></strong> 控制项目的缩小比例，当容器空间不足时，项目将按该比例缩小。</p><p><strong><code>flex-basis</code></strong> 定义了项目在主轴方向上的初始大小。</p><h2 id="浮动">浮动</h2><blockquote><p>CSS中的<strong>浮动</strong>（<code>float</code>）是一种用于布局的机制，可以将元素从正常的文档流中取出，使其在容器的左侧或右侧浮动。浮动元素允许文本和其他内联元素环绕在其周围，常用于实现文本环绕图片、多列布局等效果。</p></blockquote><h3 id="基本语法">基本语法</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left; <span class="comment">/* 可以是 left、right、none、inherit */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE <span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">html</span>&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;my page&lt;/title&gt;</span><br><span class="line">        &lt;meta charset=&quot;utf-<span class="number">8</span>&quot;&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">           <span class="selector-class">.box</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">            <span class="attribute">background-color</span>:black;        </span><br><span class="line">           &#125;</span><br><span class="line">           <span class="selector-class">.containner</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>:<span class="number">400px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">            <span class="attribute">background-color</span>:red;</span><br><span class="line">           &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">div</span> class=&quot;box&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">div</span> class=&quot;containner&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;/<span class="selector-tag">body</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">html</span>&gt;</span><br></pre></td></tr></table></figure><figure><img src="image-20240911230130721.png" alt="image-20240911230130721" /><figcaption aria-hidden="true">image-20240911230130721</figcaption></figure><p><code>设置为浮动之后</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE <span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">html</span>&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;my page&lt;/title&gt;</span><br><span class="line">        &lt;meta charset=&quot;utf-<span class="number">8</span>&quot;&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">           <span class="selector-class">.box</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">            <span class="attribute">background-color</span>:black;</span><br><span class="line">            <span class="attribute">float</span><span class="selector-pseudo">:left</span>;<span class="comment">/*设置左浮动*/</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="selector-class">.containner</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>:<span class="number">400px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">            <span class="attribute">background-color</span>:red;</span><br><span class="line">           &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">div</span> class=&quot;box&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">div</span> class=&quot;containner&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &lt;/<span class="selector-tag">body</span>&gt;</span><br><span class="line">   </span><br><span class="line">&lt;/<span class="selector-tag">html</span>&gt;</span><br></pre></td></tr></table></figure><figure><img src="image-20240911230307354.png" alt="image-20240911230307354" /><figcaption aria-hidden="true">image-20240911230307354</figcaption></figure><p><strong>浮动元素脱离了文档流,在上层显示</strong></p><h3 id="float-属性的值"><code>float</code> 属性的值</h3><ul><li><strong><code>left</code></strong>：元素向左浮动，后续内容环绕在元素的右侧。<u>可以利用此点让元素横向摆放</u></li><li><strong><code>right</code></strong>：元素向右浮动，后续内容环绕在元素的左侧。</li><li><strong><code>none</code></strong>：默认值，元素不浮动，遵循正常的文档流。</li><li><strong><code>inherit</code></strong>：继承父元素的浮动属性。</li></ul><h3 id="浮动的特点">浮动的特点</h3><ul><li><strong>脱离文档流</strong>：浮动元素不占据正常文档流的位置，后续的块级元素会忽略它的存在。</li><li><strong>文本环绕</strong>：内联元素（如文本）会围绕在浮动元素的周围。</li><li><strong>影响父容器高度</strong>：如果父容器内的所有子元素都浮动，父容器的高度可能会塌陷为0。</li><li>当容器不足以横向摆放时会放到下一行</li><li>只有左右浮动没有上下</li></ul><h2 id="清除浮动">清除浮动</h2><p>由于浮动元素会影响<strong>后续元素</strong>的布局，常需要<strong>清除浮动</strong>以恢复正常的文档流。使用 <code>clear</code> 属性可以指定元素的哪一侧不允许浮动元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">  <span class="attribute">clear</span>: both; <span class="comment">/* 可以是 left、right、both、none */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>left</code></strong>：元素的左侧不允许有浮动元素。</li><li><strong><code>right</code></strong>：元素的右侧不允许有浮动元素。</li><li><strong><code>both</code></strong>：元素的左右两侧都不允许有浮动元素。</li><li><strong><code>none</code></strong>：默认值，允许浮动元素出现在两侧。</li></ul><h3 id="常用方法">常用方法</h3><ol type="1"><li><p><strong>添加清除元素</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;float-element&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;clear&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.clear</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">clear</span>: both;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用伪对象清除浮动</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 <code>overflow</code> 属性</strong>(使用较多)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>示例</strong></p><p><strong>图片左浮动，文字环绕</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;float: left; margin-right: 10px;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  这是一段示例文本，会环绕在左侧浮动的图片周围。通过设置图片的浮动，可以实现文字环绕的效果。</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>TIPS</strong>:</p><ul><li><strong>父容器高度塌陷</strong>：如果所有子元素都浮动，父容器可能会高度塌陷，需要清除浮动。</li><li><strong>布局复杂性</strong>：过度使用浮动可能导致布局混乱，现代布局中更推荐使用 <strong>Flexbox</strong> 或 <strong>Grid</strong>。</li><li><strong>兼容性</strong>：浮动在所有主流浏览器中都得到良好支持，但在响应式设计中需要谨慎使用。</li></ul><h2 id="定位">定位</h2><p>CSS 中的定位（Positioning）用于确定 HTML 元素在页面上的布局位置。定位方式有多种，分别适用于不同的场景。常见的定位方式有以下五种：</p><h3 id="静态定位static"><strong>静态定位（<code>static</code>）</strong></h3><ul><li><strong>默认值</strong>：每个 HTML 元素默认使用 <code>static</code> 定位。</li><li><strong>特点</strong>：<ul><li>不进行特殊定位，元素按照文档流正常排列。</li><li>元素不会受 <code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code> 属性的影响。</li></ul></li></ul><p><strong>示例：</strong> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: static;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="相对定位relative"><strong>相对定位（<code>relative</code>）</strong></h3><ul><li><strong>特点</strong>：<ul><li>元素相对于它在文档流中的正常位置进行定位。</li><li>使用 <code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code> 来偏移元素，但元素仍然占据原本的空间。</li><li>相对定位不会影响其他元素的位置。</li></ul></li></ul><p><strong>示例：</strong> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">10px</span>;  <span class="comment">/* 相对于元素的原始位置向下移动10px */</span></span><br><span class="line">  <span class="attribute">left</span>: <span class="number">20px</span>; <span class="comment">/* 相对于元素的原始位置向右移动20px */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="绝对定位absolute"><strong>绝对定位（<code>absolute</code>）</strong></h3><ul><li><strong>特点</strong>：<ul><li>元素相对于 <strong>最近的非 <code>static</code> 定位的祖先元素</strong>（或视口，如果没有这样的祖先元素）进行定位。</li><li>元素会脱离文档流，其他元素会忽略它的存在。</li><li>可以通过 <code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code> 属性精确控制位置。</li></ul></li></ul><p><strong>示例：</strong> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50px</span>;   <span class="comment">/* 距离最近的非static定位的父元素顶部50px */</span></span><br><span class="line">  <span class="attribute">left</span>: <span class="number">100px</span>; <span class="comment">/* 距离最近的非static定位的父元素左边100px */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="固定定位fixed"><strong>固定定位（<code>fixed</code>）</strong></h3><ul><li><strong>特点</strong>：<ul><li>元素相对于 <strong>浏览器视口</strong> 进行定位，即使页面滚动，元素的位置也不会发生变化。</li><li>元素脱离文档流，类似 <code>absolute</code> 定位。</li><li>常用于创建固定导航栏或浮动按钮。</li></ul></li></ul><p><strong>示例：</strong> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">10px</span>; <span class="comment">/* 固定在视口底部10px */</span></span><br><span class="line">  <span class="attribute">right</span>: <span class="number">20px</span>;  <span class="comment">/* 固定在视口右边20px */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="粘性定位sticky"><strong>粘性定位（<code>sticky</code>）</strong></h3><ul><li><strong>特点</strong>：<ul><li>元素在页面滚动时表现为 <strong>相对定位</strong>，当滚动到特定位置后则表现为 <strong>固定定位</strong>。</li><li>通过 <code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code> 指定何时触发固定定位。</li><li>常用于创建粘性导航栏或某些随页面滚动的 UI 元素。</li></ul></li></ul><p><strong>示例：</strong> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: sticky;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;  <span class="comment">/* 元素在滚动到视口顶部时变为固定定位 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="堆叠顺序z-index"><strong>堆叠顺序（<code>z-index</code>）</strong></h3><ul><li>当元素使用 <code>relative</code>、<code>absolute</code>、<code>fixed</code> 或 <code>sticky</code> 定位时，可以通过 <code>z-index</code> 属性控制元素的堆叠顺序。</li><li><strong><code>z-index</code> 值越大</strong>，元素越靠前。</li><li>只对定位元素生效。</li></ul><p><strong>示例：</strong> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">10</span>; <span class="comment">/* 将该元素放在堆叠顺序的前面 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>定位方式的对比：</strong></p><ul><li><strong><code>static</code></strong>：默认，不参与定位，元素按文档流正常排列。</li><li><strong><code>relative</code></strong>：相对自身位置的偏移，仍在文档流中占位。</li><li><strong><code>absolute</code></strong>：脱离文档流，相对于最近的非 <code>static</code> 祖先定位。</li><li><strong><code>fixed</code></strong>：相对于视口定位，脱离文档流，<strong>页面滚动时位置不变</strong>。</li><li><strong><code>sticky</code></strong>：结合相对与固定定位，滚动到指定位置后固定。</li></ul><p><strong>相对定位和绝对定位是相对 具有定位的父级元素 进行位置调整,如果父级元素不存在定位,则逐级向上寻找,直到顶层文档</strong></p><h2 id="css新特性">css新特性</h2><h3 id="圆角border-radius">圆角<code>border-radius</code></h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.containner</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">background-color</span>:red;</span><br><span class="line">            <span class="attribute">border-radius</span>: <span class="number">20px</span>;</span><br><span class="line">           &#125;</span><br><span class="line">设置为<span class="number">100%</span>变成圆形</span><br></pre></td></tr></table></figure><figure><img src="image-20240914092032529.png" alt="image-20240914092032529" /><figcaption aria-hidden="true">image-20240914092032529</figcaption></figure><h3 id="阴影box-shadow">阴影<code>box-shadow</code></h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.containner</span>&#123;</span><br><span class="line">           <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">           <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">           <span class="attribute">background-color</span>:red;</span><br><span class="line">           <span class="attribute">box-shadow</span>: <span class="number">10px</span> <span class="number">10px</span> <span class="number">20px</span> black;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><figure><img src="image-20240914093315234.png" alt="image-20240914093315234" /><figcaption aria-hidden="true">image-20240914093315234</figcaption></figure><h3 id="动画">动画</h3><blockquote><p>让元素从一种样式逐渐变成另一种样式</p></blockquote><h3 id="雪碧图">雪碧图</h3><h3 id="字体图标">字体图标</h3><h1 id="javascript">JavaScript</h1><blockquote><p>JavaScript 是一种轻量级、解释型的编程语言，主要用于开发网页前端功能。</p></blockquote><h2 id="基础知识">基础知识</h2><h3 id="变量">变量</h3><p><code>var</code></p><p><code>let</code>：声明一个可以改变的变量。</p><p><code>const</code>：声明一个不可重新赋值的常量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;<span class="comment">//用var声明</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><h3 id="输出方式">输出方式</h3><p><strong>弹出框</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;我是弹出框&quot;</span>);</span><br></pre></td></tr></table></figure><figure><img src="image-20240916205054179.png" alt="image-20240916205054179" /><figcaption aria-hidden="true">image-20240916205054179</figcaption></figure><p><strong>页面输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.write(&quot;我是输出到页面&quot;);</span><br></pre></td></tr></table></figure><figure><img src="image-20240916205447778.png" alt="image-20240916205447778" /><figcaption aria-hidden="true">image-20240916205447778</figcaption></figure><p><strong>控制台输出(常用)</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num)</span><br></pre></td></tr></table></figure><figure><img src="image-20240916203143729.png" alt="image-20240916203143729" /><figcaption aria-hidden="true">image-20240916203143729</figcaption></figure><h3 id="变量提升">变量提升</h3><blockquote><p><strong>变量提升</strong>（Hoisting）是 JavaScript 的一个默认行为，它将变量声明提升到其作用域的顶部，换句话说，在代码执行之前，JavaScript 会将变量声明（而不是赋值）提升到作用域的顶部。</p></blockquote><p>使用 <code>var</code> 进行变量声明</p><p>当你使用 <code>var</code> 声明变量时，JavaScript 会将变量声明提升到当前作用域的顶部，但不会提升赋值部分。如下例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 输出 undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>上面的代码在执行时，实际上相当于这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;        <span class="comment">// 变量声明被提升到了顶部</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 变量存在，但未赋值，因此输出 undefined</span></span><br><span class="line">a = <span class="number">5</span>;        <span class="comment">// 赋值操作在原来的位置</span></span><br></pre></td></tr></table></figure><p><code>let</code> 和 <code>const</code> 不存在提升（或提升但不能使用）</p><p>在 <code>let</code> 和 <code>const</code> 声明的变量中，虽然也有提升，但它们会被暂时锁定在一个“<strong>暂时性死区</strong>”（Temporal Dead Zone，TDZ）中，在声明之前访问它们会导致错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// ReferenceError: Cannot access &#x27;b&#x27; before initialization</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>这里，变量 <code>b</code> 是在它的声明之前访问的，JavaScript 引擎会抛出错误，因为 <code>let</code> 和 <code>const</code> 变量在声明之前是不可访问的。</p><h3 id="函数提升"><strong>函数提升</strong></h3><p>函数声明也会被提升，并且它们会在整个作用域内都可以使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">greet</span>(); <span class="comment">// 输出 &quot;Hello&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码会正常工作，因为函数声明也会被提升到作用域的顶部。</p><p><strong>tips:</strong></p><ul><li><strong><code>var</code> 变量提升</strong>：变量声明被提升，但赋值不会被提升，未赋值时默认值为 <code>undefined</code>。</li><li><strong><code>let</code> 和 <code>const</code></strong>：变量声明提升但在“暂时性死区”内，无法在声明前访问。</li><li><strong>函数声明提升</strong>：完整的函数声明会被提升，但函数表达式不会。</li></ul><h3 id="数据类型"><strong>数据类型</strong></h3><p>JavaScript 支持多种数据类型：</p><ul><li><strong>原始类型</strong>：<code>Number</code>（数字），<code>String</code>（字符串），<code>Boolean</code>（布尔值），<code>null</code>，<code>undefined</code>，<code>Symbol</code>。</li><li><strong>复杂类型</strong>：<code>Object</code>，包括数组、函数等。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">42</span>;         <span class="comment">// Number</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello&quot;</span>;    <span class="comment">// String</span></span><br><span class="line"><span class="keyword">let</span> isTrue = <span class="literal">true</span>;    <span class="comment">// Boolean</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,<span class="attr">age</span>:<span class="number">19</span>&#125;;  <span class="comment">// Object</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];  <span class="comment">// Array</span></span><br></pre></td></tr></table></figure><p>null 和 undefine 没有什么特殊意思,只是表示空</p><h3 id="js引入到文件">js引入到文件</h3><p><strong>嵌入HTML文件中</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> num = <span class="number">10</span>;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(num);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>引入本地独立js文件</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./home.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>引入网络来源文件</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">url</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="typeof运算符">typeof运算符</h3><blockquote><p>判断基本数学类型</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">42</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> x);  <span class="comment">// 输出 &quot;number&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> y = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> y);  <span class="comment">// 输出 &quot;string&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> z = &#123;<span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> z);  <span class="comment">// 输出 &quot;object&quot;</span></span><br></pre></td></tr></table></figure><ul><li>对于 <code>null</code>，<code>typeof null</code> 返回 <code>"object"</code>，这是一个已知的语言设计问题，通常可以通过额外的检查来处理。</li><li><code>typeof</code> 可以用来动态检查变量类型，避免某些类型相关的错误。</li></ul><h3 id="算术运算符">算术运算符</h3><table><thead><tr class="header"><th>运算符</th><th>名称</th><th>描述</th><th>示例</th><th>结果</th></tr></thead><tbody><tr class="odd"><td><code>+</code></td><td>加法</td><td>两个值相加</td><td><code>5 + 3</code></td><td><code>8</code></td></tr><tr class="even"><td><code>-</code></td><td>减法</td><td>两个值相减</td><td><code>5 - 3</code></td><td><code>2</code></td></tr><tr class="odd"><td><code>*</code></td><td>乘法</td><td>两个值相乘</td><td><code>5 * 3</code></td><td><code>15</code></td></tr><tr class="even"><td><code>/</code></td><td>除法</td><td>两个值相除</td><td><code>9 / 3</code></td><td><code>3</code></td></tr><tr class="odd"><td><code>%</code></td><td>取模（余数）</td><td>除法的余数</td><td><code>10 % 3</code></td><td><code>1</code></td></tr><tr class="even"><td><code>++</code></td><td>自增</td><td>变量的值增加1，前置（<code>++x</code>）或后置（<code>x++</code>）</td><td><code>x++</code></td><td><code>x = 6</code></td></tr><tr class="odd"><td><code>--</code></td><td>自减</td><td>变量的值减小1，前置（<code>--x</code>）或后置（<code>x--</code>）</td><td><code>x--</code></td><td><code>x = 4</code></td></tr><tr class="even"><td><code>**</code></td><td>幂运算</td><td>表示某个数的幂（指数）</td><td><code>2 ** 3</code></td><td><code>8</code></td></tr><tr class="odd"><td><code>-</code></td><td>负号</td><td>取负数</td><td><code>-x</code></td><td><code>-5</code></td></tr></tbody></table><p><strong>tips:</strong></p><ul><li><strong>自增/自减运算符</strong>（<code>++</code>/<code>--</code>）：可以放在变量前面或后面。前置自增/自减会先执行运算，再返回值；后置则先返回值，再执行运算。</li><li><strong>取模运算符</strong>（<code>%</code>）：返回除法的余数，常用于判断奇偶性或循环中的边界条件。</li></ul><h3 id="赋值运算符">赋值运算符</h3><table><thead><tr class="header"><th>运算符</th><th>名称</th><th>描述</th><th>示例</th><th>结果</th></tr></thead><tbody><tr class="odd"><td><code>=</code></td><td>简单赋值</td><td>将右侧的值赋给左侧的变量</td><td><code>x = 5</code></td><td><code>x = 5</code></td></tr><tr class="even"><td><code>+=</code></td><td>加法赋值</td><td>将右侧的值加到左侧的变量上，并将结果赋给左侧变量</td><td><code>x += 3</code></td><td><code>x = x + 3</code></td></tr><tr class="odd"><td><code>-=</code></td><td>减法赋值</td><td>将右侧的值从左侧的变量中减去，并将结果赋给左侧变量</td><td><code>x -= 3</code></td><td><code>x = x - 3</code></td></tr><tr class="even"><td><code>*=</code></td><td>乘法赋值</td><td>将左侧变量与右侧的值相乘，并将结果赋给左侧变量</td><td><code>x *= 3</code></td><td><code>x = x * 3</code></td></tr><tr class="odd"><td><code>/=</code></td><td>除法赋值</td><td>将左侧变量除以右侧的值，并将结果赋给左侧变量</td><td><code>x /= 3</code></td><td><code>x = x / 3</code></td></tr><tr class="even"><td><code>%=</code></td><td>取模赋值</td><td>将左侧变量除以右侧的值，赋值为余数</td><td><code>x %= 3</code></td><td><code>x = x % 3</code></td></tr><tr class="odd"><td><code>**=</code></td><td>幂赋值</td><td>将左侧变量取右侧值的幂，并将结果赋给左侧变量</td><td><code>x **= 2</code></td><td><code>x = x ** 2</code></td></tr><tr class="even"><td><code>&lt;&lt;=</code></td><td>左移赋值</td><td>将左侧变量的二进制表示左移指定的位数，并赋值给左侧变量</td><td><code>x &lt;&lt;= 2</code></td><td><code>x = x &lt;&lt; 2</code></td></tr><tr class="odd"><td><code>&gt;&gt;=</code></td><td>右移赋值</td><td>将左侧变量的二进制表示右移指定的位数，并赋值给左侧变量</td><td><code>x &gt;&gt;= 2</code></td><td><code>x = x &gt;&gt; 2</code></td></tr><tr class="even"><td><code>&gt;&gt;&gt;=</code></td><td>无符号右移赋值</td><td>将左侧变量的二进制表示无符号右移指定的位数，赋值给左侧</td><td><code>x &gt;&gt;&gt;= 2</code></td><td><code>x = x &gt;&gt;&gt; 2</code></td></tr><tr class="odd"><td><code>&amp;=</code></td><td>按位与赋值</td><td>将左侧变量与右侧值进行按位与运算，并将结果赋值给左侧变量</td><td><code>x &amp;= 3</code></td><td><code>x = x &amp; 3</code></td></tr><tr class="even"><td><code>|=</code></td><td>按位或赋值</td><td>将左侧变量与右侧值进行按位或运算，并将结果赋值给左侧变量</td><td><code>x |= 3</code></td><td><code>x = x | 3</code></td></tr><tr class="odd"><td><code>^=</code></td><td>按位异或赋值</td><td>将左侧变量与右侧值进行按位异或运算，并将结果赋值给左侧变量</td><td><code>x ^= 3</code></td><td><code>x = x ^ 3</code></td></tr></tbody></table><p><strong>说明：</strong></p><ul><li><strong>复合赋值运算符</strong>（如 <code>+=</code>、<code>-=</code> 等）：先执行对应的算术运算，再赋值给左侧变量。</li><li><strong>位移赋值运算符</strong>：适用于二进制数的位运算操作，通常用于低级别的优化或位操作。</li></ul><h3 id="比较运算符">比较运算符</h3><table><thead><tr class="header"><th>运算符</th><th>名称</th><th>描述</th><th>示例</th><th>结果</th></tr></thead><tbody><tr class="odd"><td><code>==</code></td><td>相等</td><td>比较两个值是否相等（不比较类型，值相等即可）</td><td><code>5 == "5"</code></td><td><code>true</code></td></tr><tr class="even"><td><code>===</code></td><td>严格相等</td><td>比较两个值及其类型是否严格相等</td><td><code>5 === "5"</code></td><td><code>false</code></td></tr><tr class="odd"><td><code>!=</code></td><td>不相等</td><td>比较两个值是否不相等（不比较类型）</td><td><code>5 != "5"</code></td><td><code>false</code></td></tr><tr class="even"><td><code>!==</code></td><td><strong>严格不相等</strong></td><td>比较两个值及其类型是否严格不相等</td><td><code>5 !== "5"</code></td><td><code>true</code></td></tr><tr class="odd"><td><code>&gt;</code></td><td>大于</td><td>判断左侧值是否大于右侧值</td><td><code>10 &gt; 5</code></td><td><code>true</code></td></tr><tr class="even"><td><code>&lt;</code></td><td>小于</td><td>判断左侧值是否小于右侧值</td><td><code>10 &lt; 5</code></td><td><code>false</code></td></tr><tr class="odd"><td><code>&gt;=</code></td><td>大于等于</td><td>判断左侧值是否大于或等于右侧值</td><td><code>10 &gt;= 10</code></td><td><code>true</code></td></tr><tr class="even"><td><code>&lt;=</code></td><td>小于等于</td><td>判断左侧值是否小于或等于右侧值</td><td><code>10 &lt;= 9</code></td><td><code>false</code></td></tr></tbody></table><p><strong>说明：</strong></p><ul><li><strong>相等运算符 (<code>==</code>)</strong>：只比较值，类型不同但能转换的也会判定为相等（如数字 <code>5</code> 和字符串 <code>"5"</code> 相等）。</li><li><strong>严格相等运算符 (<code>===</code>)</strong>：同时比较值和类型，只有值和类型都相同时才判定为相等。</li><li><strong>不相等运算符 (<code>!=</code>) 和严格不相等运算符 (<code>!==</code>)</strong>：分别是相等和严格相等的反向判断。</li><li><strong>大小比较运算符 (<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>)</strong>：用于比较数值大小，也可比较字符串（按字母顺序比较）。</li></ul><h3 id="条件语句">条件语句</h3><blockquote><p>JavaScript 中的条件语句用于根据表达式的布尔值（<code>true</code> 或 <code>false</code>）来执行不同的代码。常见的条件语句包括 <code>if</code>、<code>else if</code>、<code>else</code> 和 <code>switch</code> 语句</p></blockquote><p><strong><code>if</code> 语句</strong></p><p><code>if</code> 语句用于在某个条件为 <code>true</code> 时执行代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  <span class="comment">// 当 condition 为 true 时执行这段代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">if</span> (age &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;You are an adult.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>if...else</code> 语句</p><p><code>if...else</code> 语句在条件为 <code>true</code> 时执行 <code>if</code> 块的代码，条件为 <code>false</code> 时执行 <code>else</code> 块的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  <span class="comment">// 当 condition 为 true 时执行这段代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 当 condition 为 false 时执行这段代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">if</span> (age &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;You are an adult.&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;You are a minor.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>else if</code> 语句</strong></p><p><code>else if</code> 语句用于处理多个条件。在第一个条件为 <code>false</code> 时，依次检查其他条件，直到找到一个为 <code>true</code> 的条件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1) &#123;</span><br><span class="line">  <span class="comment">// 当 condition1 为 true 时执行这段代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition2) &#123;</span><br><span class="line">  <span class="comment">// 当 condition2 为 true 时执行这段代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 如果所有条件都为 false，执行这段代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> score = <span class="number">85</span>;</span><br><span class="line"><span class="keyword">if</span> (score &gt;= <span class="number">90</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Grade: A&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">80</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Grade: B&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">70</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Grade: C&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Grade: F&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>switch</code> 语句</strong></p><p><code>switch</code> 语句用于基于一个变量或表达式的值，在多个可能的值中执行相应的代码块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="attr">value1</span>:</span><br><span class="line">    <span class="comment">// 当 expression 等于 value1 时执行这段代码</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="attr">value2</span>:</span><br><span class="line">    <span class="comment">// 当 expression 等于 value2 时执行这段代码</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="comment">// 当 expression 不等于任何 case 中的值时执行这段代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> day = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Monday&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Tuesday&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Wednesday&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Unknown day&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环语句">循环语句</h3><p><strong><code>for</code> 循环</strong></p><p><code>for</code> 循环用于在指定次数内重复执行代码块，通常用于已知次数的循环。</p><p><strong>语法</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; condition; update) &#123;</span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>initialization</code></strong>：初始化变量。</li><li><strong><code>condition</code></strong>：循环条件，条件为 <code>true</code> 时继续执行。</li><li><strong><code>update</code></strong>：每次循环结束后更新变量的表达式。</li></ul><p><strong>示例</strong>： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);  <span class="comment">// 输出 0 到 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>while</code> 循环</p><p><code>while</code> 循环在条件为 <code>true</code> 时重复执行代码块。适用于循环次数不确定的情况。</p><p><strong>语法</strong>： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>示例</strong>： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);  <span class="comment">// 输出 0 到 4</span></span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>do...while</code> 循环</p><p><code>do...while</code> 循环至少执行一次代码块，然后根据条件决定是否继续执行。适用于至少需要执行一次的情况。</p><p><strong>语法</strong>： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">&#125; <span class="keyword">while</span> (condition);</span><br></pre></td></tr></table></figure></p><p><strong>示例</strong>： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);  <span class="comment">// 输出 0 到 4</span></span><br><span class="line">  i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">5</span>);</span><br></pre></td></tr></table></figure></p><p><strong><code>for...in</code> 循环</strong></p><p><code>for...in</code> 循环用于遍历对象的可枚举属性。</p><p><strong>语法</strong>： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>示例</strong>： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">age</span>: <span class="number">25</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&quot;: &quot;</span> + person[key]);  <span class="comment">// 输出 &quot;name: Alice&quot; 和 &quot;age: 25&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>for...of</code> 循环</strong></p><p><code>for...of</code> 循环用于遍历可迭代对象（如数组、字符串、集合等）的值。</p><p><strong>语法</strong>： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> number <span class="keyword">of</span> numbers) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(number);  <span class="comment">// 输出 1 到 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>break</code> 和 <code>continue</code></strong></p><ul><li><strong><code>break</code></strong>：用于终止循环。</li><li><strong><code>continue</code></strong>：用于跳过当前循环的剩余部分，继续执行下一次循环。</li></ul><p><strong>示例</strong>（<code>break</code>）： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i === <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;  <span class="comment">// 当 i 等于 3 时终止循环</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);  <span class="comment">// 输出 0、1、2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>示例（<code>continue</code>）：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i === <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;  <span class="comment">// 当 i 等于 3 时跳过当前循环，继续下一次</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);  <span class="comment">// 输出 0、1、2、4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li><strong><code>for</code> 循环</strong>：用于已知次数的循环。</li><li><strong><code>while</code> 循环</strong>：用于未知次数的循环，条件前检查。</li><li><strong><code>do...while</code> 循环</strong>：至少执行一次，条件后检查。</li><li><strong><code>for...in</code> 循环</strong>：遍历对象的属性。</li><li><strong><code>for...of</code> 循环</strong>：遍历可迭代对象的值。</li><li><strong><code>break</code> 和 <code>continue</code></strong>：用于控制循环的执行。</li></ul><h2 id="字符串">字符串</h2><h3 id="length方法">length方法</h3><blockquote><p>返回字符串的字符数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="property">length</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h3 id="charat方法">charAt方法</h3><blockquote><p>返回字符串指定位置的字符</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;0123456789&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">charAt</span>(<span class="number">4</span>));<span class="comment">//4</span></span><br></pre></td></tr></table></figure><p>传入数字超出字符串的话会返回空字符串</p><h3 id="concat方法">concat方法</h3><blockquote><p>连接两个或多个字符串，并返回一个新字符串。并且不改变原来字符串,如果传入的非字符串,会将其转化为字符串再连接</p></blockquote><blockquote><p>str1.concat(str2, str3, ..., strN);</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> str3 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str1.<span class="title function_">concat</span>(<span class="string">&quot;, &quot;</span>, str2)); <span class="comment">// &quot;Hello, World&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str1.<span class="title function_">concat</span>(str3,<span class="string">&quot;, &quot;</span>, str2));</span><br></pre></td></tr></table></figure><p><strong>也可以使用+号进行字符串的连接</strong></p><h3 id="substring方法">substring方法</h3><blockquote><p>提取字符串中两个指定索引之间的字符，并返回一个新字符串。</p></blockquote><blockquote><p>str.substring(start, end);</p><p><strong>start</strong>：提取的起始索引（包含）。</p><p><strong>end</strong>：提取的结束索引（不包含）。如果省略，默认为字符串的结束。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">substring</span>(<span class="number">0</span>, <span class="number">5</span>)); <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">substring</span>(<span class="number">7</span>));     <span class="comment">// &quot;World!&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>负索引处理</strong>：<code>substring()</code> 不支持负索引，负数会被转换为 0。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">substring</span>(-<span class="number">3</span>, <span class="number">5</span>)); <span class="comment">// &quot;Hell&quot;（起始变为 0）</span></span><br></pre></td></tr></table></figure></li><li><p><strong>参数顺序</strong>：如果 <code>start</code> 大于 <code>end</code>，则这两个参数会互换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">substring</span>(<span class="number">5</span>, <span class="number">0</span>)); <span class="comment">// &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>不修改原字符串</strong>：<code>substring()</code> 不会修改原始字符串，始终返回一个新字符串。</p></li></ul><h3 id="substr方法">substr方法</h3><blockquote><p>从一个字符串中提取指定长度的子字符串，并返回该子字符串。与 <code>substring()</code> 和 <code>slice()</code> 方法不同，<code>substr()</code> 需要提供提取的起始索引和子字符串的长度</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="title function_">substr</span>(start, length);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">substr</span>(<span class="number">7</span>, <span class="number">5</span>)); <span class="comment">// &quot;World&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">substr</span>(<span class="number">0</span>, <span class="number">5</span>)); <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">substr</span>(-<span class="number">6</span>));    <span class="comment">// &quot;World!&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>负索引</strong>：可以使用负数作为起始索引，从字符串的末尾开始提取。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">substr</span>(-<span class="number">6</span>, <span class="number">5</span>)); <span class="comment">// &quot;World&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>不修改原字符串</strong>：<code>substr()</code> 不会改变原始字符串，始终返回一个新字符串。</p></li><li><p><strong>长度参数的处理</strong>：如果 <code>length</code> 为负数或零，则返回空字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">substr</span>(<span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="indexof方法">indexOf方法</h3><blockquote><p>用于返回<strong>指定值</strong>在字符串中第一次出现的位置。如果未找到该值，则返回 -1。它是区分大小写的。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="title function_">indexOf</span>(searchValue, fromIndex);</span><br><span class="line"><span class="comment">//searchValue：要查找的字符串。</span></span><br><span class="line"><span class="comment">//fromIndex（可选）：开始查找的位置，默认为 0。</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找字符 &quot;o&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">indexOf</span>(<span class="string">&quot;o&quot;</span>)); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找字符 &quot;W&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">indexOf</span>(<span class="string">&quot;W&quot;</span>)); <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找不存在的字符</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">indexOf</span>(<span class="string">&quot;z&quot;</span>)); <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从指定位置查找</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">indexOf</span>(<span class="string">&quot;o&quot;</span>, <span class="number">5</span>)); <span class="comment">// 8 (从索引 5 开始查找)</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>区分大小写</strong>：<code>indexOf()</code> 是区分大小写的，因此查找 "hello" 和 "Hello" 会返回不同的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">indexOf</span>(<span class="string">&quot;hello&quot;</span>)); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure></li><li><p><strong>从指定位置开始查找</strong>：可以通过 <code>fromIndex</code> 参数指定查找的起始位置。如果指定的索引大于或等于字符串的长度，则返回 -1。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">indexOf</span>(<span class="string">&quot;o&quot;</span>, <span class="number">10</span>)); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure></li><li><p><strong>返回的索引</strong>：如果找到匹配项，返回的是第一个匹配字符的索引（从 0 开始计数）。</p></li></ul><h3 id="trim方法">trim方法</h3><blockquote><p>用于去除字符串两端的空格（包括空格、制表符和换行符），并返回一个新的字符串。它不会改变原始字符串，因为字符串在 JavaScript 中是不可变的。</p></blockquote><p><strong>语法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="title function_">trim</span>();</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;   Hello, World!   &quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">trim</span>()); <span class="comment">// &quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure><p><strong>特点</strong></p><ol type="1"><li><p><strong>去除两端空格</strong>：<code>trim()</code> 只去除字符串开头和结尾的空格，字符串中间的空格不会被去除。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str2 = <span class="string">&quot;   Hello,    World!   &quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str2.<span class="title function_">trim</span>()); <span class="comment">// &quot;Hello,    World!&quot;</span></span><br></pre></td></tr></table></figure></p></li><li><p><strong>不修改原字符串</strong>：<code>trim()</code> 方法返回一个新字符串，原始字符串不受影响。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str); <span class="comment">// &quot;   Hello, World!   &quot;</span></span><br></pre></td></tr></table></figure></p></li><li><p><strong>兼容性</strong>：<code>trim()</code> 是 ECMAScript 5（ES5）引入的，因此在现代浏览器和环境中广泛支持。</p></li></ol><p><strong>相关方法</strong></p><ul><li><strong><code>trimStart()</code></strong>（或 <code>trimLeft()</code>）：去除字符串开头的空格。</li><li><strong><code>trimEnd()</code></strong>（或 <code>trimRight()</code>）：去除字符串结尾的空格。</li></ul><p><strong>示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;   Hello, World!   &quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">trimStart</span>()); <span class="comment">// &quot;Hello, World!   &quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">trimEnd</span>());   <span class="comment">// &quot;   Hello, World!&quot;</span></span><br></pre></td></tr></table></figure><p><code>trim()</code> 方法在处理用户输入或清理数据时非常有用。如果你有具体的用例或问题，请告诉我！</p><h3 id="split方法">split方法</h3><blockquote><p><code>split()</code> 方法用于将一个字符串分割成一个字符串数组，基于<strong>指定的分隔符</strong>。这个方法返回一个<strong>新数组</strong>，原始字符串不受影响。</p></blockquote><p><strong>语法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="title function_">split</span>(separator, limit);</span><br></pre></td></tr></table></figure><ul><li><strong>separator</strong>：用于分隔字符串的字符、正则表达式或字符串。如果省略，则整个字符串作为单一元素返回。</li><li><strong>limit</strong>（可选）：一个整数，指定返回的数组的最大长度。</li></ul><p><strong>示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用逗号和空格作为分隔符</span></span><br><span class="line"><span class="keyword">const</span> result = str.<span class="title function_">split</span>(<span class="string">&quot;, &quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// [&quot;Hello&quot;, &quot;World!&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用空格作为分隔符</span></span><br><span class="line"><span class="keyword">const</span> words = <span class="string">&quot;This is a test&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(words.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>)); <span class="comment">// [&quot;This&quot;, &quot;is&quot;, &quot;a&quot;, &quot;test&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用分隔符</span></span><br><span class="line"><span class="keyword">const</span> singleElementArray = str.<span class="title function_">split</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(singleElementArray); <span class="comment">// [&quot;Hello, World!&quot;]</span></span><br></pre></td></tr></table></figure><p><strong>特点</strong></p><ol type="1"><li><p><strong>多种分隔符</strong>：可以使用任意字符或正则表达式作为分隔符。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str2 = <span class="string">&quot;one,two;three four&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> result2 = str2.<span class="title function_">split</span>([,; ]/); <span class="comment">// 使用正则表达式分割</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result2); <span class="comment">// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;]</span></span><br></pre></td></tr></table></figure></p></li><li><p><strong>限制返回元素数量</strong>：<code>limit</code> 参数可以限制返回的数组长度。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str3 = <span class="string">&quot;a,b,c,d,e&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str3.<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>, <span class="number">3</span>)); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure></p></li><li><p><strong>返回的数组</strong>：如果字符串中没有找到分隔符，返回的数组将只包含一个元素，即原始字符串。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> noSeparator = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(noSeparator.<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>)); <span class="comment">// [&quot;Hello&quot;]</span></span><br></pre></td></tr></table></figure></p></li></ol><p><strong>使用场景</strong></p><p><code>split()</code> 方法常用于处理和解析字符串数据，比如从 CSV 文件中提取数据、处理用户输入等。</p><p>如果你对 <code>split()</code> 有更具体的问题或想了解其他相关内容，请告诉我！</p><h2 id="数组">数组</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="string">&#x27;sxt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,&#123;<span class="string">&quot;A&quot;</span>:<span class="string">&quot;b&quot;</span>&#125;];</span><br></pre></td></tr></table></figure><h3 id="遍历">遍历</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i  =<span class="number">0</span> ;i&lt;arr.<span class="property">length</span>;i++)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[i]);</span><br><span class="line"><span class="keyword">var</span> i =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;arr.<span class="property">length</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[i]);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> arr) </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[i]);</span><br></pre></td></tr></table></figure><h3 id="isarray方法">isArray()方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">typeof</span>(arr));<span class="comment">//object</span></span><br></pre></td></tr></table></figure><blockquote><p><code>Array.isArray()</code> 是 JavaScript 中用于检查一个值是否为数组的方法。它返回一个布尔值：如果该值是数组，则返回 <code>true</code>，否则返回 <code>false</code>。</p></blockquote><p><strong>语法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li><strong>value</strong>: 需要检查的值。</li></ul><p><strong>示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(<span class="string">&#x27;hello&#x27;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(&#123;&#125;)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(<span class="literal">null</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(<span class="literal">undefined</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>这个方法非常有用，特别是在处理动态类型的数据时，确保你操作的确实是数组。</p><h3 id="push和pop方法">push()和pop()方法</h3><blockquote><p><code>push()</code> 和 <code>pop()</code> 是 JavaScript 数组的两个常用方法，用于管理数组的末尾元素。</p></blockquote><p><strong><code>push()</code></strong></p><ul><li><strong>功能</strong>: 向数组末尾添加一个或多个元素。</li><li><strong>返回值</strong>: 返回新数组的长度。</li></ul><p><strong>示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">4</span>); <span class="comment">// arr 变为 [1, 2, 3, 4]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="property">length</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p><strong><code>pop()</code></strong></p><ul><li><strong>功能</strong>: 移除数组末尾的元素。</li><li><strong>返回值</strong>: 返回被移除的元素。</li></ul><p><strong>示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> lastElement = arr.<span class="title function_">pop</span>(); <span class="comment">// lastElement 为 4，arr 变为 [1, 2, 3]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lastElement); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>这两个方法常用于实现栈（LIFO）数据结构。</p><h3 id="shift和unshift方法">shift()和unshift()方法</h3><blockquote><p><code>shift()</code> 和 <code>unshift()</code> 是 JavaScript 数组中用于管理数组头部元素的方法。</p></blockquote><p><code>shift()</code></p><ul><li><strong>功能</strong>: 移除数组的第一个元素。</li><li><strong>返回值</strong>: 返回被移除的元素。</li></ul><p><strong>示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> firstElement = arr.<span class="title function_">shift</span>(); <span class="comment">// firstElement 为 1，arr 变为 [2, 3]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(firstElement); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><strong><code>unshift()</code></strong></p><ul><li><strong>功能</strong>: 向数组的开头添加一个或多个元素。</li><li><strong>返回值</strong>: 返回新数组的长度。</li></ul><p><strong>示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">unshift</span>(<span class="number">1</span>); <span class="comment">// arr 变为 [1, 2, 3]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="property">length</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>这两个方法常用于实现队列（FIFO）数据结构。</p><h3 id="join方法">join()方法</h3><blockquote><p><code>join()</code> 是 JavaScript 数组的一个方法，用于将数组中的所有元素连接成一个字符串。可以指定一个分隔符，默认分隔符为逗号（<code>,</code>）。</p></blockquote><p><strong>语法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.<span class="title function_">join</span>(separator)</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li><strong>separator</strong>（可选）：用于分隔每个元素的字符串。如果省略，则使用逗号作为默认分隔符。</li></ul><p><strong>示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;World&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> result = arr.<span class="title function_">join</span>(); <span class="comment">// &#x27;Hello,World&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> resultWithSpace = arr.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>); <span class="comment">// &#x27;Hello World&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(resultWithSpace);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> resultWithDash = arr.<span class="title function_">join</span>(<span class="string">&#x27;-&#x27;</span>); <span class="comment">// &#x27;Hello-World&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(resultWithDash);</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>如果数组中有 <code>undefined</code> 或 <code>null</code>，它们会被转换为字符串 <code>"undefined"</code> 或 <code>"null"</code>。</li><li>如果数组为空，<code>join()</code> 返回一个空字符串。</li></ul><h3 id="concat方法-1">concat()方法</h3><blockquote><p><code>concat()</code> 是 JavaScript 数组的方法，用于合并两个或多个数组。此方法<strong>不会改变</strong>原数组，而是返回一个新数组。</p></blockquote><p><strong>语法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array1.<span class="title function_">concat</span>(array2, array3, ..., arrayN)</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li><strong>array2, array3, ..., arrayN</strong>: 需要合并的一个或多个数组或值。</li></ul><p><strong>示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> arr3 = arr1.<span class="title function_">concat</span>(arr2); <span class="comment">// arr3 变为 [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr4 = arr1.<span class="title function_">concat</span>(<span class="number">7</span>, <span class="number">8</span>); <span class="comment">// arr4 变为 [1, 2, 3, 7, 8]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr4);</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li><code>concat()</code> 也可以接受非数组的参数，这些参数会被添加到新数组中。</li><li>原始数组不受影响。</li></ul><h3 id="reverse方法">reverse()方法</h3><blockquote><p><code>reverse()</code> 是 JavaScript 数组的方法，用于反转数组中元素的顺序。该方法会<strong>直接修改原数组</strong>，并返回反转后的数组</p></blockquote><p><strong>语法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.<span class="title function_">reverse</span>()</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> reversedArr = arr.<span class="title function_">reverse</span>(); <span class="comment">// arr 变为 [4, 3, 2, 1]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reversedArr); <span class="comment">// [4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>该方法会改变原数组，所以如果需要保留原数组，可以先使用 <code>slice()</code> 创建副本再反转。</li><li>反转空数组仍然是空数组。</li></ul><h3 id="indexof方法-1">indexOf()方法</h3><blockquote><p><code>indexOf()</code> 是 JavaScript 数组的方法，用于查找指定元素在数组中的第一个索引。如果找到了元素，则返回该元素的索引；如果未找到，则返回 <code>-1</code>。</p></blockquote><p><strong>语法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.<span class="title function_">indexOf</span>(element, fromIndex)</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li><strong>element</strong>: 要查找的元素。</li><li><strong>fromIndex</strong>（可选）: 开始查找的位置（索引）。默认值为 <code>0</code>。如果为负值，则从数组尾部开始查找。</li></ul><p><strong>示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">indexOf</span>(<span class="number">2</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">indexOf</span>(<span class="number">5</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">indexOf</span>(<span class="number">10</span>)); <span class="comment">// -1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">indexOf</span>(<span class="number">2</span>, <span class="number">1</span>)); <span class="comment">// 3（从索引 1 开始查找）</span></span><br></pre></td></tr></table></figure><h3 id="注意">注意</h3><ul><li><code>indexOf()</code> 使用严格相等（<code>===</code>）进行比较，因此对不同类型的值（如数字和字符串）会返回 <code>-1</code>。</li><li>如果数组中存在多个相同的元素，<code>indexOf()</code> 只返回第一个匹配的索引。</li></ul><h2 id="函数">函数</h2><blockquote><p>JavaScript 中的函数是可以被调用的代码块，用于执行特定任务或计算并返回值。函数可以接受参数并且可以返回结果，是实现代码复用和模块化的重要工具。</p></blockquote><h3 id="定义">定义</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">functionName</span>(<span class="params">parameters</span>) &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a,b</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> res = a+b;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//箭头函数:ES6 中引入的一种简化的函数定义语法，使用箭头（=&gt;）表示。它更简洁，通常用于简化函数表达式。</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">functionName</span> = (<span class="params">parameters</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 输出 5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="函数表达式">函数表达式</h3><blockquote><p>将一个函数赋值给一个变量,可以是命名函数或匿名函数</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const functionName = function(parameters) &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 输出 5</span></span><br></pre></td></tr></table></figure><h3 id="箭头函数">箭头函数</h3><blockquote><p>箭头函数是 ES6 中引入的一种简化的函数定义语法，使用箭头（<code>=&gt;</code>）表示。它更简洁，通常用于简化函数表达式。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const functionName = (parameters) =&gt; &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 输出 5</span></span><br></pre></td></tr></table></figure><p><strong>特性</strong></p><ol type="1"><li><p><strong>简洁语法</strong>: 如果箭头函数只有一个表达式，可以省略 <code>&#123;&#125;</code> 和 <code>return</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">a, b</span>) =&gt; a + b; <span class="comment">// 更简洁的写法</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>this</code> 绑定</strong>: 箭头函数不具有自己的 <code>this</code>，它的 <code>this</code> 是从外层函数中继承的。这使得在回调函数中引用外部上下文更加方便。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">count</span>++; <span class="comment">// `this` 引用外部的 Counter</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">count</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> counter = <span class="keyword">new</span> <span class="title class_">Counter</span>(); <span class="comment">// 每秒输出递增的计数</span></span><br></pre></td></tr></table></figure></li><li><p><strong>不能作为构造函数</strong>: 箭头函数不能用 <code>new</code> 关键字调用，因此不能被用作构造函数。</p></li><li><p><strong>没有 <code>arguments</code> 对象</strong>: 箭头函数不具有 <code>arguments</code> 对象，但可以使用剩余参数语法（<code>...args</code>）代替。</p></li></ol><h3 id="函数名的提升">函数名的提升</h3><blockquote><p>指的是在代码执行之前，函数声明被提升到其所在作用域的顶部。这意味着在函数声明之前调用该函数是可以的。</p></blockquote><p><strong>函数提升的特性</strong></p><ol type="1"><li><p><strong>函数声明的提升:</strong></p><ul><li>如果使用函数声明的方式定义函数，整个函数体会被提升，而不仅仅是函数名。</li><li>这使得你可以在函数声明之前调用它。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">greet</span>()); <span class="comment">// 输出 &quot;Hello!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>函数表达式的提升:</strong></p><ul><li>如果使用函数表达式（例如，赋值给变量），则只有变量的声明会被提升，而不会提升赋值。这意味着在赋值之前调用该函数会导致错误。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">greet</span>()); <span class="comment">// TypeError: greet is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> greet = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p><strong>总结</strong></p><ul><li><strong>函数声明</strong>可以在声明之前调用，因为整个函数体被提升。</li><li><strong>函数表达式</strong>不能在赋值之前调用，因为只有变量的声明被提升。</li></ul><p>理解函数提升有助于避免常见的错误和混淆。在编写代码时，尽量将函数调用放在函数声明之后，以提高代码的可读性。</p><h2 id="对象">对象</h2><blockquote><p>对象是用于存储多个值和复杂实体的基本数据结构。对象是无序的键值对集合，键（属性）通常是字符串或符号，值可以是任意数据类型，包括其他对象、数组、函数等,如果一个属性的值为函数,通常把这个属性称为方法,可以像函数一样调用,并且可以通过 <code>this</code> 关键字访问对象的属性。</p></blockquote><h3 id="创建方式">创建方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.字面量</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">    <span class="attr">greet</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//2.使用 new Object()</span></span><br><span class="line"><span class="keyword">const</span> car = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">car.<span class="property">make</span> = <span class="string">&#x27;Toyota&#x27;</span>;</span><br><span class="line">car.<span class="property">model</span> = <span class="string">&#x27;Corolla&#x27;</span>;</span><br><span class="line"><span class="comment">//3.构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> alice = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Alice&#x27;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="读取方式">读取方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//点语法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// &#x27;Alice&#x27;</span></span><br><span class="line"><span class="comment">//方括号语法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person[<span class="string">&#x27;age&#x27;</span>]); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;lisi&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">13</span>,</span><br><span class="line">    <span class="attr">jobs</span>:[<span class="string">&quot;worker&quot;</span>,<span class="string">&quot;doctor&quot;</span>],</span><br><span class="line">    <span class="attr">getName</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;lis&quot;</span>)&#125;,</span><br><span class="line">    <span class="attr">container</span>:&#123;</span><br><span class="line">        <span class="attr">frontEnd</span>:<span class="string">&quot;前端&quot;</span>,</span><br><span class="line">        <span class="attr">backEnd</span>:[<span class="string">&#x27;js&#x27;</span>,<span class="string">&#x27;css&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">name</span>);<span class="comment">//lisi</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user[<span class="string">&#x27;age&#x27;</span>]);<span class="comment">//13</span></span><br><span class="line">user.<span class="title function_">getName</span>();<span class="comment">//lis</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">container</span>.<span class="property">frontEnd</span>);<span class="comment">//前端</span></span><br></pre></td></tr></table></figure><h3 id="遍历-1">遍历</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> user)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key,user[key]);</span><br></pre></td></tr></table></figure><h2 id="math对象">Math对象</h2><blockquote><p><code>Math</code> 对象是 JavaScript 的内置对象，提供了丰富的数学常量和函数。<code>Math</code> 对象本身是一个静态对象，因此不能创建实例，也不需要使用 <code>new</code> 关键字。</p></blockquote><h3 id="常用属性"><strong>常用属性</strong></h3><ol type="1"><li><strong><code>Math.PI</code></strong><ul><li>圆周率 π，约等于 3.14159。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="property">PI</span>); <span class="comment">// 3.141592653589793</span></span><br></pre></td></tr></table></figure></li></ul></li><li><strong><code>Math.E</code></strong><ul><li>自然对数的底数 e，约等于 2.71828。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="property">E</span>); <span class="comment">// 2.718281828459045</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="常用方法-1"><strong>常用方法</strong></h3><ol type="1"><li><strong><code>Math.abs(x)</code></strong><ul><li>返回 x 的绝对值。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">abs</span>(-<span class="number">5</span>)); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></li></ul></li><li><strong><code>Math.max(...values)</code></strong><ul><li>返回一组数中的最大值。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li></ul></li><li><strong><code>Math.min(...values)</code></strong><ul><li>返回一组数中的最小值。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>)); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li></ul></li><li><strong><code>Math.random()</code></strong><ul><li>返回一个在 0（包含）到 1（不包含）之间的伪随机数。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()); <span class="comment">// 随机数，例如 0.123456</span></span><br></pre></td></tr></table></figure></li></ul></li><li><strong><code>Math.round(x)</code></strong><ul><li>返回四舍五入后的整数。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="number">2.5</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li></ul></li><li><strong><code>Math.floor(x)</code></strong><ul><li>返回小于或等于 x 的最大整数（向下取整）。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">2.9</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li></ul></li><li><strong><code>Math.ceil(x)</code></strong><ul><li>返回大于或等于 x 的最小整数（向上取整）。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="number">2.1</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li></ul></li><li><strong><code>Math.sqrt(x)</code></strong><ul><li>返回 x 的平方根。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">sqrt</span>(<span class="number">9</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li></ul></li><li><strong><code>Math.pow(base, exponent)</code></strong><ul><li>返回 base 的 exponent 次方。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure></li></ul></li><li><strong><code>Math.sin(x)</code>、<code>Math.cos(x)</code>、<code>Math.tan(x)</code></strong><ul><li>返回给定角度（以弧度为单位）的三角函数值。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">sin</span>(<span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">2</span>)); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="data对象">Data对象</h2><blockquote><p><code>Date</code> 对象是 JavaScript 中用于处理日期和时间的内置对象。它提供了多种方法来创建、格式化和操作日期。</p></blockquote><h3 id="创建-date-对象">创建 <code>Date</code> 对象</h3><ol type="1"><li><p><strong>当前日期和时间</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(now); <span class="comment">// 输出当前日期和时间</span></span><br></pre></td></tr></table></figure></p></li><li><p><strong>指定日期和时间</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> specificDate = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2023-09-25T10:00:00&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(specificDate); <span class="comment">// 输出指定的日期和时间</span></span><br></pre></td></tr></table></figure></p></li><li><p><strong>使用时间戳</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dateFromTimestamp = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1633036800000</span>); <span class="comment">// 以毫秒为单位的时间戳,距离1970/1/1 00:00:00 UTC(格林威治时间) 1970/1/1 08:00:00(北京时间)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dateFromTimestamp);<span class="comment">//Fri Oct 01 2021 05:20:00 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure></p></li></ol><h3 id="常用方法-2">常用方法</h3><ol type="1"><li><p><strong>获取日期和时间信息</strong></p><ul><li><code>getFullYear()</code>: 获取年份。</li><li><code>getMonth()</code>: 获取月份（0-11，0 代表 1 月）。</li><li><code>getDate()</code>: 获取日期（1-31）。</li><li><code>getHours()</code>: 获取小时（0-23）。</li><li><code>getMinutes()</code>: 获取分钟（0-59）。</li><li><code>getSeconds()</code>: 获取秒数（0-59）。</li><li><code>getMilliseconds()</code>: 获取毫秒数（0-999）。</li><li><code>getTime()</code>: 获取自1970年1月1日以来的毫秒数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2023-09-25T10:00:00&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">getFullYear</span>()); <span class="comment">// 2023</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">getMonth</span>()); <span class="comment">// 8（9月）</span></span><br></pre></td></tr></table></figure></li><li><p><strong>设置日期和时间</strong></p><ul><li><code>setFullYear(year)</code>: 设置年份。</li><li><code>setMonth(month)</code>: 设置月份。</li><li><code>setDate(date)</code>: 设置日期。</li><li><code>setHours(hours)</code>: 设置小时。</li><li><code>setMinutes(minutes)</code>: 设置分钟。</li><li><code>setSeconds(seconds)</code>: 设置秒数。</li><li><code>setMilliseconds(milliseconds)</code>: 设置毫秒数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date.<span class="title function_">setFullYear</span>(<span class="number">2024</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date); <span class="comment">// 更新年份</span></span><br></pre></td></tr></table></figure></li><li><p><strong>日期格式化</strong></p><ul><li><code>toString()</code>: 返回日期的字符串表示。</li><li><code>toISOString()</code>: 返回 ISO 格式的字符串。</li><li><code>toLocaleString()</code>: 根据本地时间格式返回字符串。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toISOString</span>()); <span class="comment">// &#x27;2024-09-25T10:00:00.000Z&#x27;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="日期计算">日期计算</h3><p>可以通过直接操作 <code>Date</code> 对象的时间戳来进行日期计算，例如： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> futureDate = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">futureDate.<span class="title function_">setDate</span>(futureDate.<span class="title function_">getDate</span>() + <span class="number">5</span>); <span class="comment">// 5天后的日期</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(futureDate);</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getLeftDays</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> today=<span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="keyword">var</span> endday = <span class="keyword">new</span> <span class="title class_">Date</span>(today.<span class="title function_">getFullYear</span>(),<span class="number">11</span>,<span class="number">31</span>,<span class="number">23</span>,<span class="number">59</span>,<span class="number">59</span>,<span class="number">999</span>);</span><br><span class="line">    <span class="keyword">var</span> msPerDay = <span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">round</span>((endday.<span class="title function_">getTime</span>()-today.<span class="title function_">getTime</span>())/msPerDay);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getLeftDays</span>());</span><br></pre></td></tr></table></figure><h2 id="dom">DOM</h2><blockquote><p>DOM（文档对象模型）是一个编程接口,是js操作网页的接口，用于表示和操作 HTML 和 XML 文档的结构。它将文档视为一个树形结构，文档中的每个部分（如元素、属性、文本）都被视为一个节点。作用就是将网页转化为一个js对象,从而可以用脚本进行各种操作</p></blockquote><figure><img src="image-20240928155859833.png" alt="image-20240928155859833" /><figcaption aria-hidden="true">image-20240928155859833</figcaption></figure><h3 id="dom-的基本概念">DOM 的基本概念</h3><ol type="1"><li><p><strong>节点</strong>:DOM的最小组成单位, DOM 中的每个元素都是一个节点，节点类型包括：</p><ul><li><p><strong>元素节点（Element Node）</strong></p><ul><li>代表 HTML 或 XML 中的元素，如 <code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;a&gt;</code> 等。</li><li>可以通过 <code>tagName</code> 属性获取节点的标签名。</li></ul><p><strong>文本节点（Text Node）</strong></p><ul><li>代表元素或属性中的文本内容。</li><li>文本节点通常是元素节点的子节点。</li></ul><p><strong>属性节点（Attribute Node）</strong></p><ul><li>代表元素的属性（如 <code>class</code>、<code>id</code>）。</li><li>属性节点不是 DOM 的直接节点类型，但可以通过元素节点访问。</li></ul><p><strong>文档节点（Document Node）</strong></p><ul><li>代表整个文档，是 DOM 树的根节点。</li><li>可以通过 <code>document</code> 对象访问。</li></ul><p><strong>文档片段节点（DocumentFragment Node）</strong></p><ul><li>轻量级的容器，用于临时存储一组节点。</li><li>可以高效地操作多个节点，避免频繁更新 DOM。</li></ul><p><strong>注释节点（Comment Node）</strong></p><ul><li>代表文档中的注释。</li><li>用于在 HTML 或 XML 中添加注释。</li></ul><p><strong>Doctype 节点（DocumentType Node）</strong></p><ul><li>代表文档类型声明（如 <code>&lt;!DOCTYPE html&gt;</code>）。</li><li>提供文档的类型信息。</li></ul></li></ul></li><li><p><strong>树结构</strong>: DOM 以树形结构表示文档，<code>文档节点</code>为根节点，所有其他节点为其子节点。</p><figure><img src="image-20240928160406257.png" alt="image-20240928160406257" /><figcaption aria-hidden="true">image-20240928160406257</figcaption></figure><figure><img src="image-20240928160350092.png" alt="image-20240928160350092" /><figcaption aria-hidden="true">image-20240928160350092</figcaption></figure></li><li><p><strong>节点之间的关系</strong></p><p>-父节点关系</p><p>-子节点关系</p><p>-同级节点关系</p></li><li><p><strong>Node.nodeType属性</strong></p><figure><img src="image-20240928160727804.png" alt="image-20240928160727804" /><figcaption aria-hidden="true">image-20240928160727804</figcaption></figure></li></ol><h3 id="dom-的方法">DOM 的方法</h3><ol type="1"><li><p><strong>选择元素</strong>:</p><ul><li><code>document.getElementById(id)</code>: 根据 ID 选择元素。</li><li><code>document.getElementsByClassName(className)</code>: 根据类名选择元素。</li><li><code>document.getElementsByTagName(tagName)</code>: 根据标签名选择元素。</li><li><code>document.querySelector(selector)</code>: 根据 CSS 选择器选择第一个匹配的元素。</li><li><code>document.querySelectorAll(selector)</code>: 根据 CSS 选择器选择所有匹配的元素。</li></ul></li><li><p><strong>创建元素</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newDiv = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>); <span class="comment">// 创建新元素</span></span><br><span class="line">newDiv.<span class="property">textContent</span> = <span class="string">&#x27;Hello, World!&#x27;</span>; <span class="comment">// 设置文本</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(newDiv); <span class="comment">// 添加到文档</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>my page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//创建元素 </span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> text = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;p&quot;</span>);<span class="comment">//创建p标签</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> content = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;我是文本&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> id = <span class="variable language_">document</span>.<span class="title function_">createAttribute</span>(<span class="string">&quot;id&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        id.<span class="property">value</span> = <span class="string">&quot;root&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//appendChild 将内容或者子元素放入容器中</span></span></span><br><span class="line"><span class="language-javascript">        text.<span class="title function_">appendChild</span>(content);</span></span><br><span class="line"><span class="language-javascript">        text.<span class="title function_">setAttributeNode</span>(id);<span class="comment">//属性比较特别</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(text);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//将上述节点塞到文本树中</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;container&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        container.<span class="title function_">appendChild</span>(text);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure><img src="image-20240928163521900.png" alt="image-20240928163521900" /><figcaption aria-hidden="true">image-20240928163521900</figcaption></figure></li></ol><h3 id="element对象属性">Element对象属性</h3><blockquote><p>Element对象对应网页的HTML元素,每一个元素在DOM树上都会转化为Element节点对象</p></blockquote><p><strong>Element .id</strong></p><blockquote><p>返回指定元素的id属性,可读写</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span> = <span class="string">&quot;box&quot;</span> id=<span class="string">&quot;root&quot;</span>&gt; hexo &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">--------------------------------------------</span><br><span class="line"><span class="keyword">var</span> root = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>);</span><br><span class="line"> root.<span class="property">id</span> = <span class="string">&quot;rots&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>Element .className</strong></p><blockquote><p>用来读写当前元素节点的class属性,它的值是一个字符串,每个class之间用空格分隔</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> root = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>);</span><br><span class="line"> root.<span class="property">className</span>=<span class="string">&quot;box box1&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>Element .classList</strong></p><p>该对象有以下方法:</p><blockquote><p><code>add()</code>:增加一个clas</p><p><code>remove()</code>:移除一个class</p><p><code>contains()</code>:检查当前元素是否包含某个class,有返回True</p><p><code>toggle()</code>:将某个class移入或者移出当前元素,存在删除,不存在就添加</p></blockquote><p><strong>innerHTML和innerText</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(root.<span class="property">innerHTML</span>);<span class="comment">//读取</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(root.<span class="property">innerHTML</span>=<span class="string">&quot;aaaaa&quot;</span>);<span class="comment">//设置</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(root.<span class="property">innerText</span>);<span class="comment">//读取</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(root.<span class="property">innerText</span>=<span class="string">&quot;WAHAHAH&quot;</span>);<span class="comment">//设置</span></span><br></pre></td></tr></table></figure><ul><li>使用 <code>innerHTML</code> 时，可以处理 HTML 标签和结构，而 <code>innerText</code> 只处理文本内容。</li><li><code>innerHTML</code> 适合需要插入和处理 HTML 的情况，而 <code>innerText</code> 更适合简单的文本内容处理，尤其是在需要避免潜在的 XSS（跨站脚本攻击）时。</li></ul><h3 id="dom-事件">DOM 事件</h3><p>DOM 允许你处理用户与网页的交互。常见事件包括： - <code>click</code>: 鼠标点击。 - <code>mouseover</code>: 鼠标悬停。 - <code>keydown</code>: 键盘按下。 - <code>submit</code>: 表单提交。</p>]]></content>
    
    
    <summary type="html">前端学习记录</summary>
    
    
    
    <category term="前端" scheme="https://klklkl10086.github.io/klklkl10086.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="html5" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/html5/"/>
    
    <category term="css" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/css/"/>
    
    <category term="JavaScript" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>算法基础</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2024/07/11/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2024/07/11/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</id>
    <published>2024-07-11T14:03:08.000Z</published>
    <updated>2025-04-04T14:35:11.194Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://www.acwing.com/activity/content/introduction/11/">课程</a></strong></p><p><strong>y总模板</strong></p><p><a href="https://www.acwing.com/file_system/file/content/whole/index/content/3271/">常用代码模板2——数据结构</a></p><p><a href="https://www.acwing.com/file_system/file/content/whole/index/content/3272/">常用代码模板3——搜索与图论</a></p><h1 id="小技巧">小技巧</h1><h3 id="快速去重">快速去重</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">先进行升序排序</span><br><span class="line"><span class="comment">// 使用 unique 去重并将结果压缩到前面</span></span><br><span class="line"> <span class="keyword">auto</span> last = std::<span class="built_in">unique</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 截取去重后的部分</span></span><br><span class="line"> vec.<span class="built_in">erase</span>(last, vec.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h3 id="读入技巧">读入技巧</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getline</span>(cin,line);</span><br><span class="line"><span class="built_in">sscanf</span>(line.<span class="built_in">c_str</span>(),<span class="string">&quot;%d:%d:%d %d:%d:%d (+%d)&quot;</span>,&amp;hh1,&amp;mm1,&amp;ss1,&amp;hh2,&amp;mm2,&amp;ss2,&amp;dd);</span><br><span class="line"><span class="comment">//line.c_str() 是 C++ 中的一个方法，用于将 std::string 类型的字符串转换为 C 风格字符串（即以 \0 结尾的字符数组）</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="built_in">getline</span>(cin,str);</span><br><span class="line"><span class="keyword">while</span>(cnt--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">getline</span>(cin,str);</span><br><span class="line">    <span class="function">stringstream <span class="title">ssin</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(ssin&gt;&gt;a[n]) n++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="排序">排序</h1><h2 id="快速排序">快速排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">//用j的情况下应当保证x取不到左边界，用i要保证取不到右边界，</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/blog/content/277/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h2 id="归并排序">归并排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/blog/content/277/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h1 id="二分">二分</h1><p><strong>有单调性一定可以二分，没有单调性也可能可以二分</strong></p><h2 id="整数二分">整数二分</h2><figure><img src="image-20240808190812596-1723119355203-2.png" alt="image-20240808190812596" /><figcaption aria-hidden="true">image-20240808190812596</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/blog/content/277/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h2 id="浮点数二分">浮点数二分</h2><p>控制精度来控制循环，精度要比题目所要求的多2（y总经验）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="高精度">高精度</h1><figure><img src="1.jpg" alt="算法_202408092113_02094 2" /><figcaption aria-hidden="true">算法_202408092113_02094 2</figcaption></figure><figure><img src="2.jpg" alt="算法_202408092113_03934 3" /><figcaption aria-hidden="true">算法_202408092113_03934 3</figcaption></figure><h2 id="加法">加法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;<span class="comment">//t代表上一位的进位,初始为0只有两种取值0或者1 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/blog/content/277/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h2 id="减法">减法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;<span class="comment">//t代表上一位的借位初始为0 只有两种取值0或者1 </span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/blog/content/277/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h2 id="乘法">乘法</h2><p>**高精度*低精度**</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;<span class="comment">//代表上一位的进位 t&gt;=0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();<span class="comment">//去除前导0 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/blog/content/277/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h2 id="除法">除法</h2><p><strong>高精度除以低精度</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/blog/content/277/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h1 id="前缀和与差分">前缀和与差分</h1><figure><img src="image-20241114212056491.png" alt="image-20241114212056491" /><figcaption aria-hidden="true">image-20241114212056491</figcaption></figure><figure><img src="image-20241114212111998.png" alt="image-20241114212111998" /><figcaption aria-hidden="true">image-20241114212111998</figcaption></figure><h2 id="前缀和">前缀和</h2><p><a href="https://www.acwing.com/activity/content/problem/content/829/">一维前缀和</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) s[i] = s[i - <span class="number">1</span>] + a[i]; <span class="comment">// 前缀和的初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[r] - s[l - <span class="number">1</span>]); <span class="comment">// 区间和的计算</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/activity/content/code/content/39796/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/798/">子矩阵的和</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">int</span> s[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            s[i][j] += s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[x2][y2] - s[x1 - <span class="number">1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/activity/content/code/content/39797/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h2 id="差分">差分</h2><p><a href="https://www.acwing.com/problem/content/799/">一维差分</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">insert</span>(i, i, a[i]);<span class="comment">//小技巧</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;c);</span><br><span class="line">        <span class="built_in">insert</span>(l, r, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) b[i] += b[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/activity/content/code/content/39799/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/800/">差分矩阵</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">int</span> a[N][N], b[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            <span class="built_in">insert</span>(i, j, i, j, a[i][j]);<span class="comment">//小技巧</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1, y1, x2, y2, c;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">        <span class="built_in">insert</span>(x1, y1, x2, y2, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            b[i][j] += b[i - <span class="number">1</span>][j] + b[i][j - <span class="number">1</span>] - b[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i][j]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/activity/content/code/content/39800/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h1 id="双指针">双指针</h1><figure><img src="image-20241117225214841.png" alt="image-20241117225214841" /><figcaption aria-hidden="true">image-20241117225214841</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; <span class="built_in">check</span>(i, j)) j ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体问题的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">常见问题分类：</span><br><span class="line">    (<span class="number">1</span>) 对于一个序列，用两个指针维护一段区间</span><br><span class="line">    (<span class="number">2</span>) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</span><br></pre></td></tr></table></figure><h1 id="位运算">位运算</h1><h2 id="基础操作">基础操作</h2><figure><img src="image-20241117225306326.png" alt="image-20241117225306326" /><figcaption aria-hidden="true">image-20241117225306326</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求n的第k位数字: </span></span><br><span class="line">n &gt;&gt; k &amp; <span class="number">1</span></span><br><span class="line"><span class="comment">//返回n的最后一位1：</span></span><br><span class="line"><span class="built_in">lowbit</span>(n) = n &amp; -n</span><br></pre></td></tr></table></figure><h2 id="快速幂">快速幂</h2><figure><img src="image-20241001204959516.png" alt="image-20241001204959516" /><figcaption aria-hidden="true">image-20241001204959516</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对p做二进制拆分， 对n做平方倍增 -- O(log n)</span></span><br><span class="line"> <span class="function">ll <span class="title">quick_power</span><span class="params">(ll n, ll p)</span></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;  <span class="comment">//如果指数不为0</span></span><br><span class="line">        <span class="keyword">if</span>(p &amp; <span class="number">1</span>) res *= n;  <span class="comment">// 如果对应二进制数的当前位为1, 则res 乘以当前位的值</span></span><br><span class="line">        n *= n;              <span class="comment">//对n进行倍增</span></span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>;             <span class="comment">//指数右移1位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>延申</strong></p><p><a href="https://www.acwing.com/problem/content/92/">64位整数乘法</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ULL a, b, p;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;<span class="comment">//a*b 看成a个b相加</span></span><br><span class="line">    ULL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &amp; <span class="number">1</span>) res = (res + b) % p;</span><br><span class="line">        b = (b + b) % p;</span><br><span class="line">        a &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="离散化">离散化</h1><figure><img src="image-20241117225439611.png" alt="image-20241117225439611" /><figcaption aria-hidden="true">image-20241117225439611</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">// 存储所有待离散化的值</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());   <span class="comment">// 去掉重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 找到第一个大于等于x的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 映射到1, 2, ...n</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/file_system/file/content/whole/index/content/3190/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h1 id="区间合并">区间合并</h1><figure><img src="image-20241117225456596.png" alt="image-20241117225456596" /><figcaption aria-hidden="true">image-20241117225456596</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;<span class="comment">//最左边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line"></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/file_system/file/content/whole/index/content/3190/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h1 id="数学">数学</h1><h2 id="高斯消元">高斯消元</h2><p><strong>应用</strong></p><p><a href="https://www.acwing.com/file_system/file/content/whole/index/content/4410/">883.高斯消元解线性方程组</a></p><h2 id="质因数分解">质因数分解</h2><p><a href="https://oi-wiki.org/math/number-theory/pollard-rho/">OI-wiki 分解质因数</a></p><p><a href="https://www.acwing.com/file_system/file/content/whole/index/content/4394/">867.分解质因数</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; <span class="built_in">div</span>(<span class="type">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=x;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> times=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(x%i==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                x/=i;</span><br><span class="line">                times++;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(i,times));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x!=<span class="number">1</span>)</span><br><span class="line">        res.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(x,<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="坐标旋转公式">坐标旋转公式</h2><p><span class="math display">\[\left(                   \begin{array}{c}       x^{&#39;} \\ y^{&#39;}     \end{array}\right)     =\left(                   \begin{array}{c}       \cos\alpha&amp;\sin\alpha \\ - \sin\alpha &amp;  \cos\alpha    \end{array}\right)   \left(                  \begin{array}{c}      x \\ y   \end{array}\right)\]</span></p><h1 id="数据结构">数据结构</h1><h2 id="链表">链表</h2><p>不采用结构体+指针的做法，因为效率低下，采用<strong>数组模拟</strong></p><figure><img src="算法课程_202502181430_06788%2011.jpg" alt="算法课程_202502181430_06788 11" /><figcaption aria-hidden="true">算法课程_202502181430_06788 11</figcaption></figure><figure><img src="算法课程_202502181430_08625%2012.jpg" alt="算法课程_202502181430_08625 12" /><figcaption aria-hidden="true">算法课程_202502181430_08625 12</figcaption></figure><h3 id="单链表">单链表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表头插入一个数a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = a, ne[idx] = head, head = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将头结点删除，需要保证头结点存在</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = ne[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双链表">双链表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//0是左端点，1是右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在节点a的右边插入一个数x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = a, r[idx] = r[a];</span><br><span class="line">    l[r[a]] = idx, r[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[r[a]] = l[a];</span><br><span class="line">    r[l[a]] = r[a];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈与队列">栈与队列</h2><figure><img src="02502181437_07407%2013.jpg" alt="02502181437_07407 13" /><figcaption aria-hidden="true">02502181437_07407 13</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tt表示栈顶</span></span><br><span class="line"><span class="type">int</span> stk[N], tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向栈顶插入一个数</span></span><br><span class="line">stk[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从栈顶弹出一个数</span></span><br><span class="line">tt -- ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈顶的值</span></span><br><span class="line">stk[tt];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空，如果 tt &gt; 0，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (tt &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空，如果 hh &lt;= tt，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (hh &lt;= tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调栈">单调栈</h3><p><a href="https://www.acwing.com/problem/content/832/">AcWing 830. 单调栈</a></p><figure><img src="算法课程_202502181437_07407%2013.jpg" alt="算法课程_202502181437_07407 13" /><figcaption aria-hidden="true">算法课程_202502181437_07407 13</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">常见模型：找出每个数左边离它最近的比它大/小的数,栈中存储的是数组的下标</span><br><span class="line"><span class="type">int</span> tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (tt &amp;&amp; <span class="built_in">check</span>(stk[tt], i)) tt -- ;</span><br><span class="line">    stk[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调队列">单调队列</h3><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/?envType=problem-list-v2&amp;envId=sliding-window&amp;">力扣--无重复字符的最长子串</a></p><figure><img src="算法课程_202502181437_09401%2014.jpg" alt="算法课程_202502181437_09401 14" /><figcaption aria-hidden="true">算法课程_202502181437_09401 14</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">常见模型：找出滑动窗口中的最大值/最小值</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check_out</span>(q[hh])) hh ++ ;  <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check</span>(q[tt], i)) tt -- ;</span><br><span class="line">    q[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="kmp">KMP</h2><p><a href="https://www.acwing.com/problem/content/833/">KMP字符串</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度,下标均从1开始</span></span><br><span class="line">求模式串的Next数组：</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    <span class="keyword">if</span> (j == m)</span><br><span class="line">    &#123;</span><br><span class="line">        j = ne[j];</span><br><span class="line">        <span class="comment">// 匹配成功后的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并查集">并查集</h2><figure><img src="算法课程_202502181451_21985%2017.jpg" alt="算法课程_202502181451_21985 17" /><figcaption aria-hidden="true">算法课程_202502181451_21985 17</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)朴素并查集：</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p[N]; <span class="comment">//存储每个点的祖宗节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回x的祖宗节点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)维护size的并查集：</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p[N], size[N];</span><br><span class="line">    <span class="comment">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回x的祖宗节点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        size[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">    size[<span class="built_in">find</span>(b)] += size[<span class="built_in">find</span>(a)];</span><br><span class="line">    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)维护到祖宗节点距离的并查集：</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p[N], d[N];</span><br><span class="line">    <span class="comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回x的祖宗节点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u = <span class="built_in">find</span>(p[x]);</span><br><span class="line">            d[x] += d[p[x]];</span><br><span class="line">            p[x] = u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        d[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">    d[<span class="built_in">find</span>(a)] = distance; <span class="comment">// 根据具体问题，初始化find(a)的偏移量</span></span><br></pre></td></tr></table></figure><h2 id="trie树">Trie树</h2><p>字典树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">// 0号点既是根节点，又是空节点</span></span><br><span class="line"><span class="comment">// son[][]存储树中每个节点的子节点</span></span><br><span class="line"><span class="comment">// cnt[]存储以每个节点为结尾的单词数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询字符串出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆">堆</h2><figure><img src="算法课程_202502181451_23639%2018.jpg" alt="算法课程_202502181451_23639 18" /><figcaption aria-hidden="true">算法课程_202502181451_23639 18</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// ph[k]存储第k个插入的点在堆中的位置  数组下标--&gt;堆中的下标</span></span><br><span class="line"><span class="comment">// hp[k]存储堆中下标是k的点是第几个插入的  堆中的下标---&gt;数组下标</span></span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个点，及其映射关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//小根堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;<span class="comment">//与左边子节点进行比较取小的</span></span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;<span class="comment">//与右边子节点比较取小的</span></span><br><span class="line">    <span class="keyword">if</span> (u != t)<span class="comment">//将小的变为父节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i -- ) <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure><h2 id="哈希">哈希</h2><h3 id="一般哈希">一般哈希</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) 拉链法</span><br><span class="line">    <span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向哈希表中插入一个数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">        e[idx] = x;</span><br><span class="line">        ne[idx] = h[k];<span class="comment">//插入头部</span></span><br><span class="line">        h[k] = idx ++ ;<span class="comment">//更新头指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在哈希表中查询某个数是否存在</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">            <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>) 开放寻址法</span><br><span class="line">    <span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line">        <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)</span><br><span class="line">        &#123;</span><br><span class="line">            t ++ ;</span><br><span class="line">            <span class="keyword">if</span> (t == N) t = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="字符串哈希">字符串哈希</h3><p><strong>核心思想</strong>：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低 <strong>小技巧</strong>：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line">ULL h[N], p[N]; <span class="comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算子串 str[l ~ r] 的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="搜索">搜索</h1><h2 id="dfs与bfs">DFS与BFS</h2><p>宽搜用队列</p><p>深搜用栈</p><h2 id="树和图">树和图</h2><p>树是特殊的图</p><p>图的存储：</p><ul><li>邻接表</li><li>邻接矩阵</li></ul><h1 id="动态规划">动态规划</h1><p><strong>用集合的思想思考动态规划问题,没有固定的代码模板,重在思想</strong></p><h2 id="背包问题">背包问题</h2><p>问题分类:</p><ul><li>0-1背包</li><li>完全背包</li><li>多重背包</li><li>分组背包</li></ul><h3 id="背包">0-1背包</h3><h3 id="完全背包">完全背包</h3><h3 id="多重背包">多重背包</h3><h3 id="分组背包">分组背包</h3><h2 id="线性dp">线性DP</h2><h1 id="树状数组">树状数组</h1><p>在线,支持修改（前缀和不支持修改）,使用的时候<strong>下标要从1开始</strong></p><h4 id="用处">用处</h4><p>在O(logn)的时间内:</p><ol type="1"><li>给指定位置上的数字加上一个数字(<strong>单点修改</strong>)</li><li>求指定的前缀和(<strong>区间查询</strong>)</li></ol><p>可以通过转化例如利用差分转换为单点查询区间修改等。</p><p>对于树状数组,每个节点i的父节点是<span class="math inline">\(i+lowbit(i)\)</span></p><h4 id="计算">计算</h4><p><span class="math inline">\(tr[x]=\sum_{x-lowbit(x)+1}^{x}{a[i]}\)</span></p><p><span class="math inline">\(lowbit(x)=x\&amp;(-x)\)</span></p><h4 id="基本操作">基本操作</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i)) tr[i]+=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//返回[1,x]的和</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&gt;<span class="number">0</span>;i-=<span class="built_in">lowbit</span>(i))res+=tr[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线段树">线段树</h1><p>线段树的使用范围比树状数组大很多,树状数组类似于手术刀,线段树类似于大砍刀。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l,r;<span class="comment">//所对应的w数组左右端点</span></span><br><span class="line"><span class="type">int</span> sum;</span><br><span class="line">&#125;tr[<span class="number">4</span>*N];</span><br></pre></td></tr></table></figure><p>节点个数一般开4N,存储方式使用一维数组,类似于堆的存储,可以通过下标找到父节点和孩子节点。 ### 操作</p><p>在<strong>O(logn)</strong>时间内完成:</p><ol type="1"><li>单点修改</li><li>区间查询</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span><span class="comment">//更新一下当前节点的sum,当前节点的编号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tr[u].sum=tr[u*<span class="number">2</span>].sum+tr[u*<span class="number">2</span>+<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span><span class="comment">//当前节点,当前节点对应的范围</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r) tr[u]=&#123;l,r,w[l]&#125;;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">tr[u]=&#123;l,r&#125;;</span><br><span class="line"><span class="built_in">build</span>(u*<span class="number">2</span>,l,mid),<span class="built_in">build</span>(u*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> x,<span class="type">int</span> v)</span><span class="comment">//当前节点,要修改的节点,要加的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[u].l==tr[u].r) tr[u].sum+=v;<span class="comment">//找到了要修改的节点</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid)<span class="built_in">modify</span>(u*<span class="number">2</span>,x,v);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">modify</span>(u*<span class="number">2</span>+<span class="number">1</span>,x,v);</span><br><span class="line"><span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span> <span class="comment">//当前节点,要查的区间</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line"><span class="type">int</span> mid = tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) sum=<span class="built_in">query</span>(u*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r&gt;=mid+<span class="number">1</span>) sum+=<span class="built_in">query</span>(u*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>也可以进行区间修改和区间查询,会加上懒标记。(较为复杂)</strong></p>]]></content>
    
    
    <summary type="html">Acwing算法课程学习记录</summary>
    
    
    
    <category term="算法" scheme="https://klklkl10086.github.io/klklkl10086.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>「吉林大学软件学院」操作系统实验</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2024/06/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2024/06/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/</id>
    <published>2024-06-05T02:38:09.000Z</published>
    <updated>2025-03-29T05:50:50.601Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写在前面的话：</p><p>本课程一共有四个实验，最后一个选做，由于时间原因，我只写了三个，并且每个都参考了老师所给的参考代码，建议还是要自己先试一试，构思一下，然后和参考代码作对比。至于实验环境的配置请自己搜索，我这里不再赘述。</p><p>前置知识部分，有的我借助了chatgpt进行生成，也许有不对的，欢迎指出，可以以邮件的形式发送给我。</p></blockquote><p><strong>实验环境： centos 7</strong></p><h1 id="实验一-进程与线程linux-进程与线程通讯">实验一 ：进程与线程——Linux 进程与线程通讯</h1><h2 id="实验内容">实验内容</h2><blockquote><p>•以Linux系统进程和线程机制为背景，掌握fork()和clone()系统调用的形式和功能，以及与其相适应的高级通讯方式。由fork派生的子进程之间通过pipe通讯，由clone创建的线程之间通过共享内存通讯，对于后者需要考虑互斥问题。</p><p>•以生产者/消费者问题为例，通过实验理解fork()和clone()两个系统调用的区别。程序要求能够创建4个进程或线程，其中包括两个生产者和两个消费者，生产者和消费者之间能够传递数据。</p></blockquote><h2 id="前置知识">前置知识</h2><h3 id="fork">fork()</h3><p><strong>函数定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//创建进程成功：在父进程中返回子进程的PID，在子进程中返回0</span></span><br><span class="line"><span class="comment">//创建失败返回-1</span></span><br></pre></td></tr></table></figure><p>作用：通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事情。</p><ul><li><p>一个进程调用fork函数之后，系统会先给新的进程分配资源，如存储数据、代码空间，然后将原来进程的所有值都<strong>复制</strong>给新的进程中，相当于克隆了一个自己。</p></li><li><p>子进程是父进程的几乎完全拷贝，包括代码段、数据段、堆和栈等。</p></li><li><p>虽然子进程和父进程的地址空间相同，但它们是独立的；修改子进程的内存不会影响父进程，反之亦然。</p></li><li><p>使用 <code>fork</code> 创建子进程之后，父进程和子进程会并发运行</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> tag=<span class="number">1</span>;</span><br><span class="line"> <span class="type">pid_t</span> pid;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;tag is %d now\n&quot;</span>,tag);</span><br><span class="line"> pid=fork();</span><br><span class="line"> <span class="keyword">if</span>(pid==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;there is error!\n&quot;</span>);</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;i am father\n&quot;</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;我是父亲,my pid is %d，我将修改tag，由%d变为%d\n&quot;</span>,getpid(),tag,tag+<span class="number">1</span>);</span><br><span class="line">     tag++;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;father:%d\n&quot;</span>,tag);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;i am son\n&quot;</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;我是儿子，my pid is%d,my father&#x27;s pid is %d,我将修改tag，由%d变为%d\n&quot;</span>,getpid(),getppid(),tag,tag<span class="number">-10</span>);</span><br><span class="line">     tag-=<span class="number">10</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;son:%d\n&quot;</span>,tag);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//tag is 1 now</span></span><br><span class="line"><span class="comment">//i am son</span></span><br><span class="line"><span class="comment">//我是儿子，my pid is56935,my father&#x27;s pid is 2467,我将修改tag，由1变为-9</span></span><br><span class="line"><span class="comment">//son:-9</span></span><br><span class="line"><span class="comment">//i am father</span></span><br><span class="line"><span class="comment">//我是父亲,my pid is 56936，我将修改tag，由1变为2</span></span><br><span class="line"><span class="comment">//father:2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由上述输出可以见得：</p><ul><li><strong>父进程和子进程虽然共用地址空间，但是互相不影响</strong></li><li><strong>子进程会从fork处开始运行</strong></li></ul><h3 id="clone">clone()</h3><p><strong>函数定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">clone</span> <span class="params">(<span class="type">int</span> ( *fn ) (<span class="type">void</span>  *arg) ,<span class="type">void</span> *<span class="built_in">stack</span> ,<span class="type">int</span> flag ,<span class="type">void</span>  *arg)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong><code>fn</code></strong>: 指向新进程将要执行的函数的指针。</li><li><strong><code>stack</code></strong>: 为新进程分配的栈空间的指针。新进程将从该栈开始执行。</li><li><strong><code>flag</code></strong>: 用于指定新进程的行为和资源共享方式的标志位。不同的标志位允许控制是否共享虚拟内存、文件描述符、信号处理等资源。</li><li><strong><code>arg</code></strong>: 传递给新进程的参数</li></ul><p><strong>常用flag：</strong></p><ul><li><strong><code>CLONE_VM</code></strong>: 新进程与父进程共享同一个内存空间。这意味着对内存的任何修改在两个进程中都是可见的。这通常用于创建线程，因为线程通常需要访问相同的内存。</li><li><strong><code>CLONE_FS</code></strong>: 新进程与父进程共享文件系统信息。父进程和子进程将共享文件系统相关的信息，包括当前工作目录和根目录。这意味着对 <code>chdir</code> 或 <code>chroot</code> 的调用将对两个进程同时生效。</li><li><strong><code>CLONE_FILES</code></strong>: 新进程与父进程共享文件描述符表。父进程和子进程将共享文件描述符表。关闭一个进程中的文件描述符将使该文件描述符在另一个进程中也不可用。</li><li><strong><code>CLONE_SIGHAND</code></strong>: 新进程与父进程共享信号处理器。父进程和子进程将共享信号处理函数。这意味着信号处理函数的设置对两个进程都是有效的，信号处理的变化会互相影响。</li><li><strong><code>CLONE_THREAD</code></strong>: 新进程与父进程属于同一个线程组。新进程将与父进程在同一个线程组（同一个进程的不同线程）中，这意味着它们作为一个单元协同工作，共享相同的线程组 ID (TGID)。</li></ul><p><strong>作用：</strong></p><p>和fork一样也是用于创建当前进程的一个新进程（也可以创建线程），但更佳灵活，可以<strong>更精细地</strong>控制新进程的行为和父进程的资源共享方式,关键就在<strong>flag的组合</strong></p><h3 id="pipe">pipe()</h3><p><strong>函数定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;<span class="comment">//创建管道</span></span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li><strong><code>pipefd</code></strong>：这是一个包含两个整数的数组。<code>pipefd[0]</code> 是用于读取的文件描述符，<code>pipefd[1]</code> 是用于写入的文件描述符。</li></ul><p><strong>返回值</strong></p><ul><li>成功时返回 0。</li><li>失败时返回 -1，并设置 <code>errno</code> 以指示错误。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//chatgpt生成</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">pid_t</span> cpid;</span><br><span class="line">    <span class="type">char</span> buf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建管道</span></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    cpid = fork();</span><br><span class="line">    <span class="keyword">if</span> (cpid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cpid == <span class="number">0</span>) &#123;    <span class="comment">// 子进程</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);  <span class="comment">// 关闭写端</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从管道读取数据并输出到标准输出</span></span><br><span class="line">        <span class="keyword">while</span> (read(pipefd[<span class="number">0</span>], &amp;buf, <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            write(STDOUT_FILENO, &amp;buf, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        _exit(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;            <span class="comment">// 父进程</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);  <span class="comment">// 关闭读端</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向管道写入数据</span></span><br><span class="line">        write(pipefd[<span class="number">1</span>], <span class="string">&quot;Hello from parent\n&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        </span><br><span class="line">        close(pipefd[<span class="number">1</span>]);  <span class="comment">// 关闭写端</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);        <span class="comment">// 等待子进程结束</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>管道是单向的</strong></p><p><strong>作用</strong>：实现父进程与子进程之间的简单通信</p><h3 id="sem_wait"><strong>sem_wait()</strong></h3><p>P操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li><strong><code>sem</code></strong>：指向信号量对象的指针。</li></ul><p><strong>返回值</strong></p><ul><li>成功时返回 0。</li><li>失败时返回 -1，并设置 <code>errno</code> 以指示错误。</li></ul><p><strong>功能</strong></p><ul><li>如果信号量的值大于0，<code>sem_wait</code> 将信号量的值减1并立即返回。</li><li>如果信号量的值为0，<code>sem_wait</code> 将阻塞，直到信号量的值大于0。</li></ul><h3 id="sem_post"><strong>sem_post() </strong></h3><p>V操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li><strong><code>sem</code></strong>：指向信号量对象的指针。</li></ul><p><strong>返回值</strong></p><ul><li>成功时返回 0。</li><li>失败时返回 -1，并设置 <code>errno</code> 以指示错误。</li></ul><p><strong>功能</strong></p><ul><li>将信号量的值增加1。如果有其他进程或线程在等待这个信号量，<code>sem_post</code> 会唤醒其中一个等待者。</li></ul><h3 id="sem_init"><strong>sem_init()</strong></h3><p>初始化信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ol type="1"><li><p><strong><code>sem</code></strong>：指向信号量对象的指针。</p></li><li><p><code>pshared</code></p><p>：指定信号量是否在进程间共享。</p><ul><li><strong><code>0</code></strong>：信号量用于进程内的线程同步。</li><li><strong>非零值</strong>：信号量在进程间共享。</li></ul></li><li><p><strong><code>value</code></strong>：信号量的初始值。通常表示资源的初始数量。</p></li></ol><p><strong>返回值</strong></p><ul><li><strong><code>0</code></strong>：成功。</li><li><strong><code>-1</code></strong>：失败，并设置 <code>errno</code> 以指示错误。</li></ul><h3 id="pthread_mutex_lock">pthread_mutex_lock()</h3><blockquote><p>用于实现互斥锁。互斥锁是一种用于<strong>线程间</strong>同步的机制，它可以确保在任何时候只有一个线程能够访问共享资源，从而防止竞态条件的发生。</p></blockquote><p><strong>函数定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li><code>mutex</code>：一个指向互斥锁对象的指针，用于对其进行加锁操作。</li></ul><p><strong>返回值</strong></p><ul><li>若成功，返回0。</li><li>若失败，返回一个非零的错误码，表示出现了错误。</li></ul><p><strong>作用</strong></p><ul><li><code>pthread_mutex_lock()</code> 用于尝试对指定的互斥锁进行加锁操作。</li><li>如果互斥锁已经被其他线程锁定，调用线程将会被阻塞，直到该互斥锁可用为止。</li><li>如果当前线程已经持有了该互斥锁，再次调用 <code>pthread_mutex_lock()</code> 会导致死锁</li></ul><h3 id="pthread_mutex_unlock">pthread_mutex_unlock()</h3><blockquote><p>用于释放互斥锁的函数之一</p></blockquote><p><strong>函数定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li><code>mutex</code>：一个指向互斥锁对象的指针，用于对其进行解锁操作。</li></ul><p><strong>返回值</strong></p><ul><li>若成功，返回0。</li><li>若失败，返回一个非零的错误码，表示出现了错误。</li></ul><p><strong>作用</strong></p><ul><li><code>pthread_mutex_unlock()</code> 用于释放指定的互斥锁。</li><li>当一个线程拥有互斥锁时，调用 <code>pthread_mutex_unlock()</code> 可以将该互斥锁释放，以允许其他线程访问受保护的临界区。</li></ul><p><strong>确保每次 <code>pthread_mutex_unlock()</code> 都是由之前成功调用的 <code>pthread_mutex_lock()</code> 进行匹配，避免出现死锁等问题。</strong></p><h3 id="pthread_mutex_init">pthread_mutex_init</h3><blockquote><p>用于初始化互斥锁的函数。在使用互斥锁之前，需要通过该函数对互斥锁进行初始化。</p></blockquote><p><strong>函数定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li><code>mutex</code>：指向要初始化的互斥锁对象的指针。</li><li><code>attr</code>：指向包含互斥锁属性的指针，通常设置为 <code>NULL</code>，表示使用默认属性。</li></ul><p><strong>返回值</strong></p><ul><li>若成功，返回0。</li><li>若失败，返回一个非零的错误码，表示出现了错误。</li></ul><h3 id="生产者消费者问题">生产者消费者问题</h3><blockquote><p><strong>生产者消费者问题</strong>（英语：Producer-consumer problem），也称<strong>有限缓冲问题</strong>（Bounded-buffer problem），是一个<a href="https://zh.wikipedia.org/wiki/多进程">多进程</a><a href="https://zh.wikipedia.org/wiki/同步">同步</a>问题的经典案例。该问题描述了共享固定大小<a href="https://zh.wikipedia.org/wiki/缓冲区">缓冲区</a>的两个进程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</p><p>要解决该问题，就必须让生产者在缓冲区满时休眠（要么干脆就放弃数据），等到下次消费者消耗缓冲区中的数据的时候，生产者才能被唤醒，开始往缓冲区添加数据。同样，也可以让消费者在缓冲区空时进入休眠，等到生产者往缓冲区添加数据之后，再唤醒消费者。通常采用<a href="https://zh.wikipedia.org/wiki/进程间通信">进程间通信</a>的方法解决该问题，常用的方法有<a href="https://zh.wikipedia.org/wiki/信号量">信号灯法</a><a href="https://zh.wikipedia.org/wiki/生产者消费者问题#cite_note-1">生产者消费者问题</a>等。如果解决方法不够完善，则容易出现死锁的情况。出现死锁时，两个线程都会陷入休眠，等待对方唤醒自己。该问题也能被推广到多个生产者和消费者的情形。</p><p>----维基百科</p></blockquote><h2 id="代码1">代码1</h2><blockquote><p>使用了pipe函数 frok函数实现生产者消费者问题</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">producer</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">consumer</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> r_buf[<span class="number">4</span>],w_buf[<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> pipfd[<span class="number">2</span>];</span><br><span class="line"><span class="type">pid_t</span> pid_p1,pid_p2,pid_c1,pid_c2;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pipe(pipfd)==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;管道创建失败！\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;管道创建成功！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pid_p1=fork()==<span class="number">0</span>)<span class="comment">// 子进程</span></span><br><span class="line">producer(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(pid_p2=fork()==<span class="number">0</span>)<span class="comment">//子进程</span></span><br><span class="line">producer(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(pid_c1=fork()==<span class="number">0</span>)<span class="comment">//子进程</span></span><br><span class="line">consumer(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">if</span>(pid_c2=fork()==<span class="number">0</span>)<span class="comment">//子进程</span></span><br><span class="line">consumer(<span class="number">2</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">close(pipfd[<span class="number">0</span>]),close(pipfd[<span class="number">1</span>]);</span><br><span class="line"><span class="type">int</span> status,pid,i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)<span class="comment">//等待子进程结束</span></span><br><span class="line">pid=wait(&amp;status); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">producer</span><span class="params">(<span class="type">int</span> id)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;生产者 %d ing ing\n&quot;</span>,id) ;</span><br><span class="line">close(pipfd[<span class="number">0</span>]);<span class="comment">//关闭读</span></span><br><span class="line"><span class="keyword">for</span>( i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;producer %d &#x27;s %dth\n&quot;</span>,id,i);</span><br><span class="line"><span class="keyword">if</span>(id==<span class="number">1</span>)<span class="comment">//生产者1号</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(w_buf,<span class="string">&quot;p1\0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(w_buf,<span class="string">&quot;p2\0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(write(pipfd[<span class="number">1</span>],w_buf,<span class="number">4</span>)==<span class="number">-1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;生产者写入管道失败!\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;producer %d write %s\n&quot;</span>,id,w_buf);</span><br><span class="line">&#125;</span><br><span class="line">close(pipfd[<span class="number">1</span>]);<span class="comment">//关闭写 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;生产者 %d 结束！\n&quot;</span>,id);</span><br><span class="line"><span class="built_in">exit</span>(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">consumer</span><span class="params">(<span class="type">int</span> id)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;消费者 %d inging...\n&quot;</span>,id);</span><br><span class="line">close(pipfd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(read(pipfd[<span class="number">0</span>],r_buf,<span class="number">4</span>)==<span class="number">0</span>)</span><br><span class="line"> <span class="keyword">break</span>;<span class="comment">//读完了</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;消费者 %d 得到了 %s\n&quot;</span>,id,r_buf) ;</span><br><span class="line">&#125;</span><br><span class="line">close(pipfd[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;消费者%d 结束了\n&quot;</span>,id);</span><br><span class="line"><span class="built_in">exit</span>(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输出1">输出1</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">管道创建成功！</span><br><span class="line">消费者 <span class="number">2</span> inging...</span><br><span class="line">生产者 <span class="number">1</span> ing ing</span><br><span class="line">producer <span class="number">1</span> <span class="string">&#x27;s 1th</span></span><br><span class="line"><span class="string">producer 1 write p1</span></span><br><span class="line"><span class="string">producer 1 &#x27;</span>s <span class="number">2</span>th</span><br><span class="line">producer <span class="number">1</span> write p1</span><br><span class="line">producer <span class="number">1</span> <span class="string">&#x27;s 3th</span></span><br><span class="line"><span class="string">producer 1 write p1</span></span><br><span class="line"><span class="string">producer 1 &#x27;</span>s <span class="number">4</span>th</span><br><span class="line">producer <span class="number">1</span> write p1</span><br><span class="line">producer <span class="number">1</span> <span class="string">&#x27;s 5th</span></span><br><span class="line"><span class="string">producer 1 write p1</span></span><br><span class="line"><span class="string">生产者 1 结束！</span></span><br><span class="line"><span class="string">生产者 2 ing ing</span></span><br><span class="line"><span class="string">producer 2 &#x27;</span>s <span class="number">1</span>th</span><br><span class="line">producer <span class="number">2</span> write p2</span><br><span class="line">producer <span class="number">2</span> <span class="string">&#x27;s 2th</span></span><br><span class="line"><span class="string">producer 2 write p2</span></span><br><span class="line"><span class="string">producer 2 &#x27;</span>s <span class="number">3</span>th</span><br><span class="line">producer <span class="number">2</span> write p2</span><br><span class="line">producer <span class="number">2</span> <span class="string">&#x27;s 4th</span></span><br><span class="line"><span class="string">producer 2 write p2</span></span><br><span class="line"><span class="string">producer 2 &#x27;</span>s <span class="number">5</span>th</span><br><span class="line">producer <span class="number">2</span> write p2</span><br><span class="line">生产者 <span class="number">2</span> 结束！</span><br><span class="line">消费者 <span class="number">1</span> inging...</span><br><span class="line">消费者 <span class="number">2</span> 得到了 p1</span><br><span class="line">消费者 <span class="number">1</span> 得到了 p1</span><br><span class="line">消费者 <span class="number">2</span> 得到了 p1</span><br><span class="line">消费者 <span class="number">1</span> 得到了 p1</span><br><span class="line">消费者 <span class="number">2</span> 得到了 p1</span><br><span class="line">消费者 <span class="number">1</span> 得到了 p2</span><br><span class="line">消费者 <span class="number">2</span> 得到了 p2</span><br><span class="line">消费者 <span class="number">1</span> 得到了 p2</span><br><span class="line">消费者 <span class="number">2</span> 得到了 p2</span><br><span class="line">消费者 <span class="number">1</span> 得到了 p2</span><br><span class="line">消费者<span class="number">2</span> 结束了</span><br><span class="line">消费者<span class="number">1</span> 结束了</span><br></pre></td></tr></table></figure><h2 id="代码2">代码2</h2><blockquote><p>使用clone函数通过信号量和互斥锁实现</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>  <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* args)</span>;</span><br><span class="line"><span class="type">int</span>  <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* args)</span>;</span><br><span class="line"><span class="type">pid_t</span> pid_p[<span class="number">2</span>],pid_c[<span class="number">2</span>];<span class="comment">//p1,p2,c1,c2</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">sem_t</span> products,empty;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">8</span>][<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> buf_size=<span class="number">8</span>,top=<span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line"> sem_init(&amp;products,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"> sem_init(&amp;empty,<span class="number">0</span>,<span class="number">8</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="type">int</span> i=<span class="number">0</span>,flag=CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND| SIGCHLD;</span><br><span class="line">    <span class="comment">//一定要加上SIGCHLD</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span>( i=<span class="number">0</span>;i&lt;=<span class="number">1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>*id=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (<span class="type">int</span>));</span><br><span class="line"> *(id)=i+<span class="number">1</span>;</span><br><span class="line"><span class="type">char</span>* <span class="built_in">stack</span> = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">4096</span>);</span><br><span class="line">pid_p[i] = clone(producer, <span class="built_in">stack</span> + <span class="number">4095</span>, flag, id);</span><br><span class="line">        <span class="keyword">if</span> (pid_p[i] == <span class="number">-1</span>) </span><br><span class="line">&#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;Failed to create producer process!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;producer %d is created!\n&quot;</span>, *id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( i=<span class="number">0</span>;i&lt;=<span class="number">1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>*id=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (<span class="type">int</span>)); *(id)=i+<span class="number">1</span>;</span><br><span class="line"><span class="type">char</span>* <span class="built_in">stack</span>= (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">4096</span>);</span><br><span class="line">pid_c[i]=clone(consumer,<span class="built_in">stack</span>+<span class="number">4095</span>,flag,id);</span><br><span class="line"><span class="keyword">if</span> (pid_p[i] == <span class="number">-1</span>) </span><br><span class="line">&#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;Failed to create consumer process!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;consumer %d is created!\n&quot;</span>,*id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> status=<span class="number">0</span>,pid;</span><br><span class="line">    <span class="comment">//一定要写这个 否则父进程会先于子进程结束</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line">pid=wait(&amp;status);</span><br><span class="line">    <span class="comment">//销毁锁和信号量</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">sem_destroy(&amp;products);</span><br><span class="line">sem_destroy(&amp;empty);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* args)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>,id=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;producer %d is running!\n&quot;</span>,id=*((<span class="type">int</span>*)args));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  sleep(i);</span><br><span class="line">  sem_wait(&amp;empty);</span><br><span class="line">  pthread_mutex_lock(&amp;mutex);</span><br><span class="line">  top=top+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(id==<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">strcpy</span>(buf[top],<span class="string">&quot;p1\0&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">     <span class="built_in">strcpy</span>(buf[top],<span class="string">&quot;p2\0&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;producer %d put %s into buf[%d]\n&quot;</span>,id,buf[top],top);</span><br><span class="line"></span><br><span class="line">  pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">  sem_post(&amp;products);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;producer %d is deaded\n&quot;</span>,id);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* args)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>,id=*((<span class="type">int</span>*)args);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;consumer %d is running!\n&quot;</span>,id);</span><br><span class="line"><span class="keyword">for</span>( i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">10</span>-i);</span><br><span class="line"></span><br><span class="line">sem_wait(&amp;products);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;consumer %d gets %s from buf[%d]\n&quot;</span>,id,buf[top],top);</span><br><span class="line">top--;</span><br><span class="line"></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">sem_post(&amp;empty);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;consumer %d is deaded\n&quot;</span>,id);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h3 id="为什么需要-sigchld">为什么需要 <code>SIGCHLD</code></h3><ul><li><strong>通知机制</strong>：<code>SIGCHLD</code> 信号用于通知父进程其子进程已经终止。这允许父进程通过 <code>wait</code> 或 <code>waitpid</code> 函数来获取子进程的终止状态，并进行相应的处理。</li><li><strong>避免僵尸进程</strong>：当子进程终止时，如果父进程没有使用 <code>wait</code> 或 <code>waitpid</code> 获取子进程的终止状态，子进程会变成僵尸进程。<code>SIGCHLD</code> 信号可以触发父进程调用这些函数，从而防止僵尸进程的产生。</li></ul></blockquote><blockquote><p><strong>为什么要在主函数最后写<code>wait</code></strong></p><h3 id="避免僵尸进程">1. <strong>避免僵尸进程</strong></h3><ul><li>当一个子进程终止时，它不会立即被完全清除。子进程的终止状态（如退出代码等）仍然保留在系统中，直到父进程调用 <code>wait</code> 或 <code>waitpid</code> 函数来获取这个状态。</li><li>如果父进程没有调用 <code>wait</code> 或 <code>waitpid</code>，这些终止的子进程会变成僵尸进程，占用系统资源。通过调用 <code>wait</code> 或 <code>waitpid</code>，父进程可以清理这些子进程，释放相关的资源。</li></ul><h3 id="同步父子进程">2. <strong>同步父子进程</strong></h3><ul><li>使用 <code>wait</code> 或 <code>waitpid</code> 可以确保父进程在继续执行之前等待子进程完成。这对于确保所有子进程执行完毕并且所有资源都被正确释放是必要的。</li><li>这也可以<u><strong>防止父进程在所有子进程完成之前退出，从而保证所有任务都能正确执行完毕</strong></u>。</li></ul><h3 id="获取子进程的退出状态">3. <strong>获取子进程的退出状态</strong></h3><ul><li><code>wait</code> 或 <code>waitpid</code> 可以让父进程获取子进程的退出状态，这对于调试、日志记录或者根据子进程的执行结果采取相应的措施非常重要。</li></ul></blockquote><h2 id="输出2">输出2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">producer <span class="number">1</span> is created!</span><br><span class="line">producer <span class="number">2</span> is created!</span><br><span class="line">consumer <span class="number">1</span> is created!</span><br><span class="line">consumer <span class="number">2</span> is created!</span><br><span class="line">consumer <span class="number">2</span> is running!</span><br><span class="line">producer <span class="number">1</span> is running!</span><br><span class="line">producer <span class="number">2</span> is running!</span><br><span class="line">consumer <span class="number">1</span> is running!</span><br><span class="line">producer <span class="number">1</span> put p1 into buf[<span class="number">0</span>]</span><br><span class="line">producer <span class="number">2</span> put p2 into buf[<span class="number">1</span>]</span><br><span class="line">producer <span class="number">1</span> put p1 into buf[<span class="number">2</span>]</span><br><span class="line">producer <span class="number">2</span> put p2 into buf[<span class="number">3</span>]</span><br><span class="line">producer <span class="number">1</span> put p1 into buf[<span class="number">4</span>]</span><br><span class="line">producer <span class="number">2</span> put p2 into buf[<span class="number">5</span>]</span><br><span class="line">consumer <span class="number">2</span> gets p2 from buf[<span class="number">5</span>]</span><br><span class="line">consumer <span class="number">1</span> gets p1 from buf[<span class="number">4</span>]</span><br><span class="line">producer <span class="number">1</span> put p1 into buf[<span class="number">4</span>]</span><br><span class="line">producer <span class="number">2</span> put p2 into buf[<span class="number">5</span>]</span><br><span class="line">producer <span class="number">1</span> put p1 into buf[<span class="number">6</span>]</span><br><span class="line">producer <span class="number">2</span> put p2 into buf[<span class="number">7</span>]</span><br><span class="line">consumer <span class="number">2</span> gets p2 from buf[<span class="number">7</span>]</span><br><span class="line">consumer <span class="number">1</span> gets p1 from buf[<span class="number">6</span>]</span><br><span class="line">producer <span class="number">1</span> put p1 into buf[<span class="number">6</span>]</span><br><span class="line">producer <span class="number">2</span> put p2 into buf[<span class="number">7</span>]</span><br><span class="line">consumer <span class="number">2</span> gets p2 from buf[<span class="number">7</span>]</span><br><span class="line">consumer <span class="number">1</span> gets p1 from buf[<span class="number">6</span>]</span><br><span class="line">producer <span class="number">1</span> put p1 into buf[<span class="number">6</span>]</span><br><span class="line">producer <span class="number">2</span> put p2 into buf[<span class="number">7</span>]</span><br><span class="line">consumer <span class="number">2</span> gets p2 from buf[<span class="number">7</span>]</span><br><span class="line">consumer <span class="number">1</span> gets p1 from buf[<span class="number">6</span>]</span><br><span class="line">consumer <span class="number">2</span> gets p2 from buf[<span class="number">5</span>]</span><br><span class="line">consumer <span class="number">1</span> gets p1 from buf[<span class="number">4</span>]</span><br><span class="line">producer <span class="number">1</span> put p1 into buf[<span class="number">4</span>]</span><br><span class="line">producer <span class="number">2</span> put p2 into buf[<span class="number">5</span>]</span><br><span class="line">consumer <span class="number">2</span> gets p2 from buf[<span class="number">5</span>]</span><br><span class="line">consumer <span class="number">1</span> gets p1 from buf[<span class="number">4</span>]</span><br><span class="line">consumer <span class="number">2</span> gets p2 from buf[<span class="number">3</span>]</span><br><span class="line">consumer <span class="number">1</span> gets p1 from buf[<span class="number">2</span>]</span><br><span class="line">consumer <span class="number">2</span> gets p2 from buf[<span class="number">1</span>]</span><br><span class="line">consumer <span class="number">1</span> gets p1 from buf[<span class="number">0</span>]</span><br><span class="line">producer <span class="number">1</span> put p1 into buf[<span class="number">0</span>]</span><br><span class="line">producer <span class="number">2</span> put p2 into buf[<span class="number">1</span>]</span><br><span class="line">consumer <span class="number">1</span> gets p2 from buf[<span class="number">1</span>]</span><br><span class="line">consumer <span class="number">1</span> gets p1 from buf[<span class="number">0</span>]</span><br><span class="line">consumer <span class="number">1</span> is deaded</span><br><span class="line">producer <span class="number">1</span> put p1 into buf[<span class="number">0</span>]</span><br><span class="line">producer <span class="number">1</span> is deaded</span><br><span class="line">producer <span class="number">2</span> put p2 into buf[<span class="number">1</span>]</span><br><span class="line">producer <span class="number">2</span> is deaded</span><br><span class="line">consumer <span class="number">2</span> gets p2 from buf[<span class="number">1</span>]</span><br><span class="line">consumer <span class="number">2</span> gets p1 from buf[<span class="number">0</span>]</span><br><span class="line">consumer <span class="number">2</span> is deaded </span><br></pre></td></tr></table></figure><h2 id="拓展">拓展</h2><h3 id="shm">shm</h3><h3 id="msg">msg</h3><h1 id="实验二处理机调度实时调度算法edf和rms">实验二：处理机调度——实时调度算法EDF和RMS</h1><h2 id="实验内容-1">实验内容</h2><blockquote><p>在Linux环境中采用用户级线程模拟实现EDF和RMS两种实时调度算法。给定一组实时任务，按照EDF算法和RMS算法分别判断是否可调度，在可调度的情况下，创建一组用户级线程，分别代表各个实时任务，并按算法确定的调度次序安排各个线程运行，运行时在终端上画出其Gantt图。为避免图形绘制冲淡算法，Gantt图可用字符表示。</p></blockquote><h2 id="前置知识-1">前置知识</h2><h3 id="edf算法">EDF算法</h3><blockquote><p>EDF算法（Earliest Deadline First）是一种实时任务调度算法，它的核心思想是优先调度最紧迫的任务，即 <strong>将截止时间最早的任务优先分配处理器时间片</strong>。EDF算法适用于实时系统，其中任务有明确的截止时间，并且必须在截止时间之前完成。</p></blockquote><h4 id="调度规则"><strong>调度规则</strong></h4><ul><li>系统在每个时刻会检查所有已到达但未完成的任务，并选择截止期限最早的任务进行执行。</li><li>如果新的任务到达且其截止期限早于当前正在执行的任务，系统会进行任务切换，将新的任务置于当前任务之前执行。</li></ul><h4 id="特点">特点</h4><ol type="1"><li><strong>最优性</strong>：<ul><li>EDF算法在理想条件下（如任务可抢占、无上下文切换开销、系统负载不超过100%）是最优的单处理器实时调度算法。这意味着，如果有一种方法能按时完成所有任务，EDF就能做到这一点。</li></ul></li><li><strong>动态优先级</strong>：<ul><li>任务的优先级是动态的，随着时间的推移和新任务的到来而变化。</li></ul></li><li><strong>简单性</strong>：<ul><li>实现相对简单，只需维护一个任务列表，并在任务到达或完成时更新列表排序。</li></ul></li><li><strong>可抢先性调度算法</strong></li></ol><h4 id="优点">优点</h4><ul><li><strong>高效性</strong>：在可抢占的环境中，EDF能够高效地利用处理器资源，最大限度地减少任务的等待时间。</li><li><strong>灵活性</strong>：适用于不同类型的任务，包括周期性任务和单次任务。</li></ul><h4 id="缺点">缺点</h4><ul><li><strong>开销问题</strong>：频繁的任务切换和排序操作可能带来一定的开销，尤其是在任务数量较多时。</li><li><strong>负载限制</strong>：在系统负载接近或超过100%时，EDF可能会无法确保所有任务都能按时完成，这时需要其他机制来处理超载情况。</li></ul><h4 id="例子">例子</h4><p>假设有三个任务，它们的执行时间和截止期限如下：</p><ul><li>任务A：执行时间为2，截止期限为4</li><li>任务B：执行时间为1，截止期限为3</li><li>任务C：执行时间为2，截止期限为5</li></ul><p>任务按照以下顺序到达：A、B、C</p><ol type="1"><li>系统开始执行任务A，因为此时只有任务A在队列中。</li><li>任务B到达，截止期限比任务A早，因此系统切换到任务B。</li><li>任务B完成后系统继续执行任务A。</li><li>任务C到达，但任务A仍然是最早截止的任务，因此系统继续执行任务A。</li><li>任务A完成后系统执行任务C。</li></ol><p>通过上述例子可以看出，EDF算法始终选择最紧急的任务来执行，从而尽量保证所有任务都能按时完成。</p><p>总的来说，Earliest Deadline First算法是实时系统中非常重要的一种调度策略，广泛应用于需要高实时性和确定性的领域。</p><h4 id="调度条件">调度条件</h4><p><span class="math display">\[\sum(\frac{C_{i}}{T_{i}})\leq1\]</span></p><p><code>Ci</code>是任务i需要的工作时间，<code>Ti</code>是任务i的周期， 该条件表明任务系统的总CPU利用率不超过100%。</p><h3 id="rms算法">RMS算法</h3><blockquote><p>Rate Monotonic Scheduling (RMS) 是一种用于实时系统的优先级调度算法，主要用于调度周期性任务。它是一种固定优先级（static priority）的调度算法，每个任务的优先级在系统运行期间保持不变。</p></blockquote><h4 id="调度规则-1"><strong>调度规则</strong></h4><ul><li>任务的优先级是根据其周期来确定的：周期越短，优先级越高。</li></ul><h4 id="特点-1">特点</h4><ol type="1"><li><strong>固定优先级</strong>：<ul><li>任务的优先级在整个系统运行期间保持不变，这与动态优先级调度算法（如EDF）不同。</li></ul></li><li><strong>周期性任务优化</strong>：<ul><li>RMS专门针对周期性任务进行优化，确保周期性任务能够在其周期内按时完成。</li></ul></li><li><strong>理论基础</strong>：<ul><li>RMS有严格的数学证明支持，证明了在某些条件下，RMS是最优的固定优先级调度算法。</li></ul></li><li><strong>不可抢先性调度算法。</strong></li></ol><h4 id="优点-1">优点</h4><ul><li><strong>简单性</strong>：由于优先级是固定的，实现起来相对简单。</li><li><strong>可预测性</strong>：固定优先级使得任务调度行为易于预测和分析。</li><li><strong>理论保证</strong>：对于周期性任务，RMS具有良好的理论基础和最优性保证。</li></ul><h4 id="缺点-1">缺点</h4><ul><li><strong>利用率限制</strong>：RMS在任务的总CPU利用率达到一定限度时，可能无法保证所有任务都能按时完成。具体来说，对于 nnn 个任务的系统，最大CPU利用率上限为 Umax=n(21/n−1)U_{max} = n(2^{1/n} - 1)Umax=n(21/n−1)。当任务数增加时，这个上限趋近于 ln⁡(2)≈0.693(2) 0.693ln(2)≈0.693 或者 69.3%。</li><li><strong>不适合非周期性任务</strong>：RMS主要针对周期性任务，非周期性任务可能无法得到有效调度。</li></ul><h4 id="例子-1">例子</h4><p>假设有三个任务，它们的执行时间和周期如下：</p><ul><li>任务A：执行时间 CA=1C_A = 1CA=1，周期 PA=4P_A = 4PA=4</li><li>任务B：执行时间 CB=1C_B = 1CB=1，周期 PB=5P_B = 5PB=5</li><li>任务C：执行时间 CC=2C_C = 2CC=2，周期 PC=8P_C = 8PC=8</li></ul><p>根据RMS规则，任务的优先级顺序为：A &gt; B &gt; C（周期越短，优先级越高）。</p><p>调度过程：</p><ol type="1"><li>从时间0开始，任务A、B、C均到达。由于A优先级最高，执行任务A。</li><li>时间1，任务A完成，执行任务B（下一个优先级最高的任务）。</li><li>时间2，任务B完成，执行任务C。</li><li>时间4，任务A的下一个周期到来，打断任务C，执行任务A。</li><li>时间5，继续执行任务C。</li><li>时间8，任务A和B的下一个周期同时到来，首先执行任务A，然后执行任务B，任务C被打断。</li></ol><p>通过上述例子可以看出，RMS算法总是优先执行周期最短的任务，确保高优先级任务按时完成。</p><h4 id="调度条件-1">调度条件</h4><p><span class="math display">\[\sum(\frac{C_{i}}{T_{i}})\leq n(2^{\frac{1}{n}}-1)\]</span></p><p>这里 <code>n</code> 是任务的数量。这个条件表明任务系统的总CPU利用率的上限随着任务数量的增加而变化，并且随着任务数量的增加，这个上限趋近 69.3%。</p><h3 id="rms与edf对比">RMS与EDF对比</h3><ul><li><strong>优先级类型</strong>：RMS使用固定优先级，EDF使用动态优先级。</li><li><strong>适用任务</strong>：RMS适用于周期性任务，EDF适用于周期性和非周期性任务。</li><li><strong>CPU利用率</strong>：EDF在理想条件下可以实现100%的CPU利用率，而RMS的利用率上限为69.3%（对于较多任务）。</li></ul><h3 id="pthread_create">pthread_create()</h3><blockquote><p><code>pthread_create</code> 是 POSIX 线程库 (pthread) 中的一个函数，用于创建一个新的线程。这个函数是多线程编程的基础之一，允许程序在并发执行中创建和管理多个线程。</p></blockquote><h4 id="函数定义">函数定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数详解</strong></p><ol type="1"><li><strong>pthread_t *thread</strong>:<ul><li>这是一个指向 <code>pthread_t</code> 类型变量的指针。这个变量将保存新创建线程的 ID（线程句柄），用于后续对该线程的操作（如等待线程结束、取消线程等）。</li></ul></li><li><strong>const pthread_attr_t *attr</strong>:<ul><li>这是一个指向线程属性对象的指针，用于设置新线程的属性。如果传递 <code>NULL</code>，则使用默认属性。</li><li>线程属性可以包括堆栈大小、调度策略、优先级等。属性对象通过 <code>pthread_attr_init</code>、<code>pthread_attr_set*</code> 和 <code>pthread_attr_destroy</code> 函数进行管理。</li></ul></li><li><strong>void *(*start_routine)(void *)</strong>:<ul><li>这是一个函数指针，指向新线程的起始例程（函数）。新线程开始时将执行这个函数。</li><li>这个函数必须符合特定的签名，即接收一个 <code>void *</code> 类型的参数并返回一个 <code>void *</code> 类型的值。</li></ul></li><li><strong>void *arg</strong>:<ul><li>这是传递给 <code>start_routine</code> 函数的参数。可以传递任意类型的数据，但必须通过 <code>void *</code> 进行类型转换。</li><li>如果不需要传递参数，可以传递 <code>NULL</code>。</li></ul></li></ol><p><strong>返回值</strong></p><ul><li>成功时，<code>pthread_create</code> 返回 0。</li><li>失败时，返回一个非零的错误代码，表示失败原因，如 <code>EAGAIN</code>（资源临时不可用）、<code>EINVAL</code>（无效的属性设置）或 <code>EPERM</code>（无权限设置指定的属性）。</li></ul><h4 id="特点-2">特点</h4><ul><li><strong>共享地址空间</strong>：线程之间共享相同的地址空间（全局变量、堆等）。</li><li><strong>轻量级</strong>：线程的创建和销毁比进程开销小。</li><li><strong>并发执行</strong>：多个线程可以并发执行，提高性能。</li><li><strong>同步机制</strong>：需要使用同步机制（如互斥锁、条件变量）来防止共享资源竞争。</li></ul><h2 id="代码">代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> task_id;<span class="comment">//任务id</span></span><br><span class="line">  <span class="type">int</span> call_num;<span class="comment">//发生次数</span></span><br><span class="line">  <span class="type">int</span> c_left;<span class="comment">//剩余工作时间</span></span><br><span class="line">  <span class="type">int</span> t_left;<span class="comment">//剩余周期时间</span></span><br><span class="line">  <span class="type">int</span> c;<span class="comment">// 工作时间</span></span><br><span class="line">  <span class="type">int</span> t; <span class="comment">//周期</span></span><br><span class="line">  <span class="type">int</span> flag;<span class="comment">//状态 1活跃 2不活跃</span></span><br><span class="line">  <span class="type">int</span> arg;<span class="comment">//参数</span></span><br><span class="line">  <span class="type">pthread_t</span> th;<span class="comment">//对应线程</span></span><br><span class="line">&#125; task;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">proc</span><span class="params">(<span class="type">void</span>* a)</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">idle</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">select_proc</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> task_num=<span class="number">0</span>,idle_num=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> choice;<span class="comment">//1 is EDF 2 is RMS</span></span><br><span class="line"><span class="type">int</span> curr_proc=<span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> demo_time=<span class="number">100</span>;</span><br><span class="line">task* tasks;</span><br><span class="line"><span class="type">pthread_mutex_t</span> proc_wait[<span class="number">100</span>];<span class="comment">//每个任务对应一个等待互斥锁</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> main_wait,idle_wait;<span class="comment">//main  闲逛进程</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> idle_proc;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化互斥锁</span></span><br><span class="line">    pthread_mutex_init(&amp;main_wait,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_lock(&amp;main_wait);</span><br><span class="line">    pthread_mutex_init(&amp;idle_wait,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_lock(&amp;idle_wait);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读入任务</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;有多少任务：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;task_num);</span><br><span class="line">    tasks=(task*)<span class="built_in">malloc</span>(task_num*<span class="keyword">sizeof</span>(task));</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;task_num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_init(&amp;proc_wait[i],<span class="literal">NULL</span>);</span><br><span class="line">        pthread_mutex_lock(&amp;proc_wait[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;task_num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入任务id C和T\n&quot;</span>);</span><br><span class="line">    getchar();<span class="comment">//一定要写</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c %d %d&quot;</span>,&amp;tasks[i].task_id,&amp;tasks[i].c,&amp;tasks[i].t);</span><br><span class="line">        tasks[i].c_left=tasks[i].c;</span><br><span class="line">        tasks[i].t_left=tasks[i].t;</span><br><span class="line">        tasks[i].flag=<span class="number">2</span>;</span><br><span class="line">        tasks[i].arg=i;</span><br><span class="line">        tasks[i].call_num=<span class="number">1</span>;</span><br><span class="line">        sum+=(<span class="type">float</span>)tasks[i].c/(<span class="type">float</span>)tasks[i].t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//选择调度 判断是否满足条件</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;用什么调度1.EDF 2.RMS\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;choice);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;想要运行多长时间\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;demo_time);</span><br><span class="line">    <span class="type">double</span> r=<span class="number">1</span>;<span class="comment">//EDF 为1</span></span><br><span class="line">    <span class="keyword">if</span>(choice==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r=((<span class="type">double</span>)task_num)*(<span class="built_in">exp</span>(<span class="built_in">log</span>(<span class="number">2</span>)/(<span class="type">double</span>)task_num)<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;r = %f\n&quot;</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum&gt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;不满足条件，不能调度\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建闲逛进程</span></span><br><span class="line">    pthread_create(&amp;idle_proc,<span class="literal">NULL</span>,(<span class="type">void</span>*)idle,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 创建实时任务线程</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;task_num;i++) </span><br><span class="line">        pthread_create(&amp;tasks[i].th,<span class="literal">NULL</span>,proc,(<span class="type">void</span>*)&amp;tasks[i].arg);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//运行</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;demo_time;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="comment">//选择线程</span></span><br><span class="line">        <span class="keyword">if</span>((curr_proc=select_proc(choice))!=<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;proc_wait[curr_proc]);</span><br><span class="line">            pthread_mutex_lock(&amp;main_wait);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//没有任务了 上闲逛线程</span></span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;idle_wait);</span><br><span class="line">            pthread_mutex_lock(&amp;main_wait);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;task_num;j++)<span class="comment">//执行完一个时间片 更新剩余周期时间</span></span><br><span class="line">        &#123;</span><br><span class="line">            tasks[j].t_left--;</span><br><span class="line">            <span class="keyword">if</span>(tasks[j].t_left==<span class="number">0</span>)<span class="comment">//周期到了 又来了一个</span></span><br><span class="line">            &#123;</span><br><span class="line">                tasks[j].t_left=tasks[j].t;</span><br><span class="line">            tasks[j].c_left=tasks[j].c;</span><br><span class="line">            pthread_create(&amp;tasks[j].th,<span class="literal">NULL</span>,(<span class="type">void</span>*)proc,&amp;tasks[j].arg);</span><br><span class="line">                tasks[j].flag=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">proc</span><span class="params">(<span class="type">void</span>* a)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span>* args=(<span class="type">int</span>*)a;</span><br><span class="line">    <span class="keyword">while</span>(tasks[*args].c_left&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;proc_wait[*args]);</span><br><span class="line">        <span class="keyword">if</span>(idle_num!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;idle:%d\n&quot;</span>,idle_num);</span><br><span class="line">            idle_num=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c is running,已被调用%d 次\n&quot;</span>,tasks[*args].task_id,tasks[*args].call_num);</span><br><span class="line">        tasks[*args].c_left--;<span class="comment">//剩余执行减一</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(tasks[*args].c_left==<span class="number">0</span>)<span class="comment">//执行完了</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;task %c over(it&#x27;s work time is%d)\n&quot;</span>,tasks[*args].task_id,tasks[*args].c);</span><br><span class="line">            tasks[*args].flag=<span class="number">0</span>;</span><br><span class="line">            tasks[*args].call_num++;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;main_wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">idle</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;idle_wait);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&gt;&quot;</span>); </span><br><span class="line">        idle_num++;</span><br><span class="line">        pthread_mutex_unlock(&amp;main_wait); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">select_proc</span><span class="params">(<span class="type">int</span> choice)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(choice==<span class="number">2</span>&amp;&amp;curr_proc!=<span class="number">-1</span>&amp;&amp;tasks[curr_proc].flag!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> curr_proc;<span class="comment">// RMS算法的优先级不会发生改变</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> j,tmp1=<span class="number">1000</span>,index=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;task_num;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tasks[j].flag==<span class="number">2</span>)<span class="comment">//当前任务活跃</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(choice==<span class="number">1</span>)<span class="comment">//EDF</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp1&gt;tasks[j].c_left) </span><br><span class="line">                    &#123;</span><br><span class="line">                        tmp1=tasks[j].c_left;</span><br><span class="line">                        index=j;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//RMS</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp1&gt;tasks[j].t)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp1=tasks[j].t;</span><br><span class="line">                    index=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>tips：</strong> <strong>编译的时候要加上-pthread -lm选项</strong></p><h1 id="实验三存储管理动态不等长存储资源分配算法">实验三：存储管理——动态不等长存储资源分配算法</h1><h2 id="实验内容-2">实验内容</h2><blockquote><p>•分析UNIX最先适应(FF)存储分配算法，即map数据结构、存储分配函数malloc()和存储释放函数mfree()，找出与算法有关的成分。</p><p>• 修改上述与算法有关的成分，使其<strong>分别体现BF分配原则和WF分配原则</strong>。</p></blockquote><h2 id="前置知识-2">前置知识</h2><h3 id="最先适应存储分配算法">最先适应存储分配算法</h3><blockquote><p><strong>工作原理：</strong></p><ol type="1"><li><strong>维护空闲内存块</strong>：操作系统维护一个空闲内存块的链表（或其他数据结构）（ <code>按地址由低到高排列</code>），这些内存块表示可用的内存空间。</li><li><strong>按顺序查找</strong>：当有进程需要分配内存时，从链表的开始位置按顺序查找，寻找第一个能够满足该进程所需大小的空闲内存块。</li><li><strong>分配内存</strong>：找到合适的内存块后，将这块内存分配给进程。如果空闲内存块大于所需大小，则将该块分割成两部分，一部分分配给进程，另一部分继续作为空闲内存块保留在链表中。</li><li><strong>更新链表</strong>：分配完成后，更新空闲内存块链表。</li></ol><p><strong>优点</strong>：</p><ul><li><strong>简单易实现</strong>：最先适应算法实现简单，遍历链表寻找合适的空闲块即可。</li><li><strong>较低的开销</strong>：由于从头开始查找第一个符合要求的块，通常能快速找到适合的内存块。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>外部碎片化</strong>：长期运行后，系统会出现大量的小而零散的空闲块，导致无法有效利用内存。</li><li><strong>非最佳选择</strong>：最先适应算法可能不会总是选择最优的内存块，例如选择一个较大的块来满足小需求，从而留下更多的内存碎片。</li></ul></blockquote><h3 id="最佳分配算法">最佳分配算法</h3><blockquote><h4 id="工作原理"><strong>工作原理</strong></h4><ol type="1"><li><strong>维护空闲块列表</strong>：操作系统维护一个空闲内存块的链表（或其他数据结构）（按照<code>容量递增</code>的次序排列）。</li><li><strong>查找合适的块</strong>：当有内存分配请求时，遍历整个空闲块列表，找到能满足请求的<code>最小块</code>。</li><li><strong>分割和分配</strong>：如果找到的空闲块比请求的大小大，进行分割；否则直接分配整个块。</li><li><strong>更新空闲块列表</strong>：分配后更新空闲块列表，确保空闲块的管理和跟踪。</li></ol><p><strong>优点</strong></p><ul><li><strong>减少碎片</strong>：由于选择最小的能满足请求的块，最佳分配算法往往能减少内存碎片。</li><li><strong>高效利用内存</strong>：优化内存块的利用率，提高内存分配的效率。</li></ul><p><strong>缺点</strong></p><ul><li><strong>时间复杂度高</strong>：每次分配内存时都需要遍历整个空闲块列表，时间复杂度较高。</li><li><strong>维护复杂</strong>：需要频繁维护和更新空闲块列表，管理复杂度较高。</li></ul></blockquote><h3 id="最坏分配算法">最坏分配算法</h3><blockquote><p><strong>工作原理</strong></p><ol type="1"><li><strong>维护空闲块列表</strong>：操作系统维护一个空闲内存块的链表或其他数据结构（<code>按照容量由高到低排列</code>）。</li><li><strong>查找最大的块</strong>：当有内存分配请求时，遍历整个空闲块列表，找到最大的空闲块。</li><li><strong>分割和分配</strong>：如果找到的空闲块比请求的大小大，进行分割；否则直接分配整个块。</li><li><strong>更新空闲块列表</strong>：分配后更新空闲块列表，确保空闲块的管理和跟踪。</li></ol><p><strong>优点</strong></p><ul><li><strong>减少外部碎片</strong>：最坏分配算法通过分割最大的块来避免产生许多小块，从而减少外部碎片的数量。</li><li><strong>简单实现</strong>：该算法易于实现，因为只需找到最大的块进行分配。</li></ul><p><strong>缺点</strong></p><ul><li><strong>时间复杂度高</strong>：每次分配内存时都需要遍历整个空闲块列表以找到最大的块，时间复杂度较高。</li><li><strong>可能导致大的块被频繁分割</strong>：这可能导致大块内存变得稀缺，对于需要大块内存的请求来说可能会变得困难。</li></ul></blockquote><h3 id="malloc">malloc()</h3><blockquote><p><code>malloc</code>函数用于在堆上动态分配指定大小的内存块，并返回指向该内存块的指针。</p></blockquote><p><strong>原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><h4 id="参数"><strong>参数</strong></h4><ul><li><code>size</code>: 要分配的内存块的大小（以字节为单位）。</li></ul><p><strong>返回值</strong></p><ul><li>成功时：返回指向分配内存块的指针。</li><li>失败时：返回<code>NULL</code>，表示内存分配失败（例如内存不足）。</li></ul><h3 id="free">free()</h3><blockquote><p><code>free</code>函数用于释放之前由<code>malloc</code>、<code>calloc</code>或<code>realloc</code>函数分配的内存块，避免内存泄漏。</p></blockquote><p><strong>原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li><code>ptr</code>: 指向要释放的内存块的指针。如果<code>ptr</code>为<code>NULL</code>，则<code>free</code>函数什么也不做。</li></ul><p><strong>返回值</strong></p><ul><li>无返回值。</li></ul><h3 id="register">*register</h3><blockquote><p>在C语言中，<code>register</code>关键字用于提示编译器将变量尽量存储在处理器的寄存器中，而不是在内存中。这样可以提高变量的访问速度，因为寄存器比内存访问速度快得多。需要注意的是，这只是一个建议，最终是否将变量存储在寄存器中取决于编译器。</p></blockquote><p><strong>语法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="type">int</span> counter;</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sum: %d\n&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>tips</strong></p><ol type="1"><li><p><strong>仅用于自动变量</strong>：<code>register</code>关键字只能用于自动变量（局部变量）和函数参数。全局变量和静态变量不能使用<code>register</code>关键字。</p></li><li><p><strong>限制数量</strong>：由于寄存器数量有限，不可能所有的<code>register</code>变量都被存储在寄存器中。编译器会根据寄存器的使用情况决定是否将变量存储在寄存器中。</p></li><li><p><strong>无法获取地址</strong></p><p>由于寄存器可能不在内存中，因此不能对register变量使用取地址运算符（&amp;），即不能获取register变量的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="type">int</span> counter;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;counter;  <span class="comment">// 错误：无法获取register变量的地址</span></span><br></pre></td></tr></table></figure></li><li><p><strong>现代编译器优化</strong>：现代编译器已经具备非常先进的优化技术，能够自动选择哪些变量应该放在寄存器中。因此，在大多数情况下，不需要显式使用<code>register</code>关键字。编译器通常会比手动指定做得更好。</p></li></ol><h2 id="代码-1">代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAPSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MAP</span>//存储资源表项</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> addr;<span class="comment">//起始地址</span></span><br><span class="line"><span class="type">int</span> map_size; <span class="comment">//</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MAP</span> <span class="title">map</span>[<span class="title">MAPSIZE</span>];</span><span class="comment">//</span></span><br><span class="line"><span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> alg;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">BF_distru</span><span class="params">(<span class="type">int</span> apply_size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">WF_distru</span><span class="params">(<span class="type">int</span> apply_size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mfree</span><span class="params">(<span class="type">int</span> addr,<span class="type">int</span> rsize)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b is BF,w is WF:\n&quot;</span>);</span><br><span class="line">getchar();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;alg);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1代表申请，2代表释放，0代表退出：\n&quot;</span>);</span><br><span class="line"><span class="type">int</span> option;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;option);</span><br><span class="line"><span class="keyword">if</span>(option==<span class="number">0</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(option==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;你想申请多大的空间：\n&quot;</span>);</span><br><span class="line"><span class="type">int</span> apply_size,res;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;apply_size);</span><br><span class="line"><span class="keyword">if</span>(alg==<span class="string">&#x27;b&#x27;</span>) res=BF_distru(apply_size);</span><br><span class="line"><span class="keyword">else</span> res=WF_distru(apply_size);</span><br><span class="line"><span class="keyword">if</span>(res==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;空间不足，申请失败!\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;申请成功，起始地址为%d 大小为%d \n&quot;</span>,res,apply_size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;你想释放空间的起始地址和大小：\n&quot;</span>);</span><br><span class="line"><span class="type">int</span> addr,rsize;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;addr,&amp;rsize);</span><br><span class="line">mfree(addr,rsize);</span><br><span class="line">&#125;</span><br><span class="line">show();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> addr,_size,i=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;starting address and total size: \n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;addr,&amp;_size);</span><br><span class="line"><span class="built_in">map</span>[<span class="number">0</span>].addr=addr;</span><br><span class="line"><span class="built_in">map</span>[<span class="number">0</span>].map_size=_size;</span><br><span class="line"><span class="built_in">map</span>[<span class="number">1</span>].map_size=<span class="number">0</span>;</span><br><span class="line">num=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">BF_distru</span><span class="params">(<span class="type">int</span> apply_size)</span><span class="comment">//找最小空闲分配，更新表，按容量递增排序</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>,addr=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[i].map_size&gt;=apply_size)</span><br><span class="line">&#123;</span><br><span class="line">addr=<span class="built_in">map</span>[i].addr;</span><br><span class="line"><span class="built_in">map</span>[i].addr+=apply_size;</span><br><span class="line"><span class="built_in">map</span>[i].map_size-=apply_size;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[i].map_size==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">num--;</span><br><span class="line"><span class="type">int</span> j=i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=i+<span class="number">1</span>;j&lt;num;j++) <span class="built_in">map</span>[j<span class="number">-1</span>]=<span class="built_in">map</span>[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j=i<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[j].map_size&gt;<span class="built_in">map</span>[i].map_size) </span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MAP</span> <span class="title">tmp</span>;</span></span><br><span class="line">tmp=<span class="built_in">map</span>[j]; <span class="built_in">map</span>[j]=<span class="built_in">map</span>[i];<span class="built_in">map</span>[i]=tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> addr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">WF_distru</span><span class="params">(<span class="type">int</span> apply_size)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>,addr=<span class="number">-1</span>; </span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[<span class="number">0</span>].map_size&lt;apply_size) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>( i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[i].map_size&gt;=apply_size)</span><br><span class="line">&#123;</span><br><span class="line">addr=<span class="built_in">map</span>[i].addr;</span><br><span class="line"><span class="built_in">map</span>[i].addr+=apply_size;</span><br><span class="line"><span class="built_in">map</span>[i].map_size-=apply_size;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[i].map_size==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">num--;</span><br><span class="line"><span class="type">int</span> j=i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=i+<span class="number">1</span>;j&lt;num;j++) <span class="built_in">map</span>[j<span class="number">-1</span>]=<span class="built_in">map</span>[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j=i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;num;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[j].map_size&gt;<span class="built_in">map</span>[i].map_size) </span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MAP</span> <span class="title">tmp</span>;</span></span><br><span class="line">tmp=<span class="built_in">map</span>[j]; <span class="built_in">map</span>[j]=<span class="built_in">map</span>[i];<span class="built_in">map</span>[i]=tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mfree</span><span class="params">(<span class="type">int</span> addr,<span class="type">int</span> rsize)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[i].addr+<span class="built_in">map</span>[i].map_size==addr)<span class="comment">//upper</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">map</span>[i].map_size+=rsize;</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[i].addr-rsize==addr)<span class="comment">//lower</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">map</span>[i].map_size+=rsize;</span><br><span class="line"><span class="built_in">map</span>[i].addr=addr;</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j;j&lt;num;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(j!=i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[j].addr+<span class="built_in">map</span>[j].map_size==<span class="built_in">map</span>[i].addr) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">map</span>[j].map_size+=<span class="built_in">map</span>[i].map_size;</span><br><span class="line"><span class="type">int</span> k=i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(k;k&lt;num;k++) <span class="built_in">map</span>[k<span class="number">-1</span>]=<span class="built_in">map</span>[k];</span><br><span class="line">num--;</span><br><span class="line">i=j;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[i].addr+<span class="built_in">map</span>[i].map_size==<span class="built_in">map</span>[j].addr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">map</span>[i].map_size+=<span class="built_in">map</span>[j].map_size;</span><br><span class="line"><span class="type">int</span> k=j+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(k;k&lt;num;k++) <span class="built_in">map</span>[k<span class="number">-1</span>]=<span class="built_in">map</span>[k];</span><br><span class="line">num--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(alg==<span class="string">&#x27;b&#x27;</span>)<span class="comment">//BF</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j=i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(j;j&lt;num;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[j].map_size&lt;<span class="built_in">map</span>[i].map_size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MAP</span> <span class="title">tmp</span>;</span></span><br><span class="line">tmp=<span class="built_in">map</span>[j]; <span class="built_in">map</span>[j]=<span class="built_in">map</span>[i];<span class="built_in">map</span>[i]=tmp;</span><br><span class="line">i=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j=i<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(j;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[j].map_size&lt;<span class="built_in">map</span>[i].map_size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MAP</span> <span class="title">tmp</span>;</span></span><br><span class="line">tmp=<span class="built_in">map</span>[j]; <span class="built_in">map</span>[j]=<span class="built_in">map</span>[i];<span class="built_in">map</span>[i]=tmp;</span><br><span class="line">j=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">num++;</span><br><span class="line"><span class="built_in">map</span>[num<span class="number">-1</span>].addr=addr;</span><br><span class="line"><span class="built_in">map</span>[num<span class="number">-1</span>].map_size=rsize;</span><br><span class="line"><span class="keyword">if</span>(alg==<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j;j&lt;num;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[j].map_size&gt;rsize) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j!=num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> k=num<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(k;k&gt;=j+<span class="number">1</span>;k--) <span class="built_in">map</span>[k]=<span class="built_in">map</span>[k<span class="number">-1</span>];</span><br><span class="line"><span class="built_in">map</span>[j].addr=addr;</span><br><span class="line"><span class="built_in">map</span>[j].map_size=rsize;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j;j&lt;num;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[j].map_size&lt;rsize) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j!=num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> k=num<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(k;k&gt;=j+<span class="number">1</span>;k--) <span class="built_in">map</span>[k]=<span class="built_in">map</span>[k<span class="number">-1</span>];</span><br><span class="line"><span class="built_in">map</span>[j].addr=addr;</span><br><span class="line"><span class="built_in">map</span>[j].map_size=rsize;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&lt;%d , %d&gt;\n&quot;</span>,<span class="built_in">map</span>[i].addr,<span class="built_in">map</span>[i].map_size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;写在前面的话：&lt;/p&gt;
&lt;p&gt;本课程一共有四个实验，最后一个选做，由于时间原因，我只写了三个，并且每个都参考了老师所给的参考代码，建议还是要自己先试一试，构思一下，然后和参考代码作对比。至于实验环境的配置请自己搜索，我这里不再赘述。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="class" scheme="https://klklkl10086.github.io/klklkl10086.github.io/categories/class/"/>
    
    
    <category term="操作系统" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Database</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2024/05/07/Database/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2024/05/07/Database/</id>
    <published>2024-05-07T11:03:11.000Z</published>
    <updated>2024-09-12T02:11:18.149Z</updated>
    
    <content type="html"><![CDATA[<p><strong>肯定有错，PPT来源于学校，如果侵权请通过邮箱告知</strong></p><h1 id="sql初步">SQL初步</h1><p><strong>Structed Query Language 结构化查询语言</strong></p><figure><img src="Screenshot_20240507_190655_com.huawei.hinote.png" alt="Screenshot_20240507_190655_com.huawei.hinote" /><figcaption aria-hidden="true">Screenshot_20240507_190655_com.huawei.hinote</figcaption></figure><h2 id="属性域的类型">属性域的类型</h2><blockquote><ul><li>char(n) 固定长度字符串，用户指定长度为n，若输入为短于n的字符串，自动补空格</li><li>varchar(n) 可变长度字符串，最大长度为n，由用户指定</li><li>int 整数型</li><li>smallint 小整数</li><li>numeric(p,d) 定点小数，长度一共为p其中有d位小数，p与d由用户指定</li><li>real,double precision 浮点数 双精度浮点数</li><li>float(n) 精度为n的浮点数</li></ul></blockquote><h2 id="完整性约束">完整性约束</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#非空约束：</span><br><span class="line">not null</span><br><span class="line">#主键约束  非空且唯一</span><br><span class="line">primary key(A1,A2,...,An)</span><br><span class="line">#外码约束</span><br><span class="line">foreign key(A1,A3,...An) references r</span><br></pre></td></tr></table></figure><h2 id="创建表">创建表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE r(A1 D1,A2 D2,....,An Dn,</span><br><span class="line">              (完整性约束1)，</span><br><span class="line">              (完整性约束2)，</span><br><span class="line">               .....，</span><br><span class="line">               (完整性约束n)，</span><br><span class="line">              )</span><br></pre></td></tr></table></figure><p><strong>r是关系名字，A是属性名字，D是属性域类型</strong></p><figure><img src="Screenshot_20240507_202654_com.huawei.hinote.png" alt="Screenshot_20240507_202654_com.huawei.hinote" /><figcaption aria-hidden="true">Screenshot_20240507_202654_com.huawei.hinote</figcaption></figure><figure><img src="image-20240507203933365.png" alt="image-20240507203933365" /><figcaption aria-hidden="true">image-20240507203933365</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">create table department(</span><br><span class="line">    dept_name varchar(20),</span><br><span class="line">    building varchar(15),</span><br><span class="line">    budget numeric(12,2),</span><br><span class="line">    primary key(dept_name)</span><br><span class="line">);</span><br><span class="line">create table instructor(</span><br><span class="line">    ID char(5),</span><br><span class="line">    _name varchar(20) not null,</span><br><span class="line">    dept_name varchar(20),</span><br><span class="line">    salary numeric(8,2),</span><br><span class="line">    primary key(ID),</span><br><span class="line">    foreign key(dept_name) references department(dept_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="insert">Insert</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into R values (&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,...,&#x27;&#x27;);</span><br><span class="line"></span><br><span class="line">insert into department values(&#x27;Biology&#x27;,&#x27;biology&#x27;,&#x27;15000&#x27;);</span><br></pre></td></tr></table></figure><h2 id="delete">Delete</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#保留关系，移除所有元组</span><br><span class="line">delete from R</span><br><span class="line"></span><br><span class="line">delete from student</span><br></pre></td></tr></table></figure><h2 id="drop">Drop</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#删除关系r</span><br><span class="line">drop table r</span><br></pre></td></tr></table></figure><h2 id="alter">Alter</h2><p>增删属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alter table r add A D </span><br><span class="line">alter table students add parent varchar(10);</span><br><span class="line"></span><br><span class="line">alter table r drop A</span><br><span class="line">alter table students drop parent;</span><br></pre></td></tr></table></figure><p><strong>也可以用于创建表之后对表进行新的主码约束和非空限制等操作</strong></p><h2 id="查询">查询</h2><figure><img src="Screenshot_20240507_205222_com.huawei.hinote.png" alt="Screenshot_20240507_205222_com.huawei.hinote" /><figcaption aria-hidden="true">Screenshot_20240507_205222_com.huawei.hinote</figcaption></figure><p><strong>返回结果为关系</strong></p><p><strong>Select</strong></p><p>关系代数中的投影运算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#选取所有列</span><br><span class="line">select * </span><br><span class="line">from instructor;</span><br><span class="line"></span><br><span class="line">select &#x27;2011&#x27;;</span><br><span class="line"></span><br><span class="line">select &#x27;2011&#x27; as year;</span><br><span class="line"></span><br><span class="line">select &#x27;A&#x27; </span><br><span class="line">from instructor;</span><br></pre></td></tr></table></figure><figure><img src="image-20240507205828047.png" alt="image-20240507205828047" /><figcaption aria-hidden="true">image-20240507205828047</figcaption></figure><figure><img src="image-20240507205844996.png" alt="image-20240507205844996" /><figcaption aria-hidden="true">image-20240507205844996</figcaption></figure><figure><img src="image-20240507205758202.png" alt="image-20240507205758202" /><figcaption aria-hidden="true">image-20240507205758202</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select ID,name,salary/12 </span><br><span class="line">from instructor;</span><br><span class="line"></span><br><span class="line"> select ID,name,salary/12 as monthly_salary</span><br><span class="line"> from instructor;</span><br></pre></td></tr></table></figure><p><strong>tips：</strong></p><ol type="1"><li><strong>在sql中是不区分大小写的</strong></li><li><strong>sql中查询默认不会自动去重，想要去重需要加上distinct关键字，想要显示地不去重，可以使用all关键字</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct dept_name from instructor</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select all dept_name from instructor</span><br></pre></td></tr></table></figure><p>​ 3.**select 语句中可以包含算术表达式，比如= ,-,*,/作用于属性上**</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select ID, name, salary/12 from instructor</span><br><span class="line"></span><br><span class="line">select ID, name, salary/12 as monthly_salary from instructor</span><br></pre></td></tr></table></figure><p><strong>where</strong></p><ul><li><strong>限制选取元组的条件</strong>，类似于关系代数的选择操作</li><li><strong>可以使用 and or not 进行多个条件的连接，只有让where语句为true的元组才能被选中</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select name</span><br><span class="line">from instructor</span><br><span class="line">where dept_name=&#x27;Biology&#x27;;</span><br><span class="line"></span><br><span class="line">select name</span><br><span class="line">from instructor</span><br><span class="line">where dept_name=&#x27;Biology&#x27; and salary&gt;80;# and ,or, not</span><br></pre></td></tr></table></figure><ul><li><strong>between 比较运算符表 [ ]（数学上的左闭右闭）</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name from instructor where salary between 90000 and 100000</span><br></pre></td></tr></table></figure><ul><li><strong>元组比较</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select name, course_id</span><br><span class="line">from instructor, teaches</span><br><span class="line">where (instructor.ID, dept_name) = (teaches.ID, &#x27;Biology&#x27;);</span><br></pre></td></tr></table></figure><p><strong>from</strong></p><ul><li><strong>若from后面有多个关系，则是对多个关系进行笛卡尔乘积</strong>，在进行where的判断，最后执行select</li><li><strong>支持重命名操作</strong></li></ul><h2 id="更名">更名</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">oldname as newname</span><br><span class="line">select ID,name,salary/12 as monthly_salary</span><br><span class="line">  from instructor;</span><br></pre></td></tr></table></figure><h2 id="字符串">字符串</h2><p><strong>like关键字</strong></p><blockquote><p>% :匹配任意字符串</p><p>_ : 匹配任意字符</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select name </span><br><span class="line">from instructor </span><br><span class="line">where name like &#x27;%dar%&#x27; #选择含有dar的字符串</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>escape关键字</strong></p><p>表转义字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">like &#x27;100 \%&#x27;  escape  &#x27;\&#x27; </span><br><span class="line">#匹配“100%”字符串</span><br></pre></td></tr></table></figure><p><strong>运算</strong></p><ul><li><p>连接运算 || 表连接</p></li><li><p>字符串匹配对大小写敏感</p></li><li><p>大小写转换</p></li><li><p>计算字符串长度等</p></li></ul><h2 id="排序">排序</h2><p><strong>order by</strong></p><p>排列元组的<strong>显示</strong>顺序</p><p><strong>默认为升序，加上desc关键字表降序，也可以加asc显式地指出为升序</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select distinct name</span><br><span class="line">from instructor</span><br><span class="line">order by name#根据name进行升序排序</span><br><span class="line"></span><br><span class="line">select distinct name</span><br><span class="line">from instructor</span><br><span class="line">order by name desc#根据name进行降序排序</span><br><span class="line"></span><br><span class="line">order by dept_name, name#多个属性为排序依据</span><br><span class="line">order by dept_name desc, name asc</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure><img src="image-20240508222044255.png" alt="image-20240508222044255" /><figcaption aria-hidden="true">image-20240508222044255</figcaption></figure><h2 id="集合运算">集合运算</h2><p><strong>并 union</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(select course_id from section where sem = ‘Fall&#x27; and year = 2009)</span><br><span class="line">union</span><br><span class="line">(select course_id from section where sem = ‘Spring&#x27; and year = 2010)</span><br></pre></td></tr></table></figure><p><strong>交 intersect</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(select course_id from section where sem = ‘Fall&#x27; and year = 2009)</span><br><span class="line">intersect</span><br><span class="line">(select course_id from section where sem = ‘Spring&#x27; and year = 2010)</span><br></pre></td></tr></table></figure><p><strong>差 except</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(select course_id from section where sem = ‘Fall&#x27; and year = 2009)</span><br><span class="line">except</span><br><span class="line">(select course_id from section where sem = ‘Spring&#x27; and year = 2010)</span><br></pre></td></tr></table></figure><p><strong>sql上的集合运算自动去重</strong></p><p><strong>若想要保留重复元组，则要显式地指出，union all, intersect all except all</strong></p><h2 id="null-空值">Null 空值</h2><ul><li><p><strong>表未知 unkonwn</strong></p></li><li><p><strong>空值参与任何算术表达式的结果都是空值</strong></p></li><li><p><strong>is null 可以用来检验是否是空值，如果是空值则返回true</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select name</span><br><span class="line">from instructor</span><br><span class="line">where salary is null</span><br></pre></td></tr></table></figure></li><li><p><strong>空值与逻辑运算</strong></p><figure><img src="image-20240508223215396.png" alt="image-20240508223215396" /><figcaption aria-hidden="true">image-20240508223215396</figcaption></figure></li><li><p><strong>如果where子句的谓词计算出的结果为false或者是unkonwn则元组不可出现在结果中</strong></p></li></ul><h2 id="聚集函数">聚集函数</h2><blockquote><ul><li><strong>avg:</strong> average value</li><li><strong>min:</strong> minimum value</li><li><strong>max:</strong> maximum value</li><li><strong>sum:</strong> sum of values</li><li><strong>count:</strong> number of values</li></ul><p><strong>输入元组集合返回单个值</strong></p></blockquote><ul><li><p><strong>avg，min，max，sum的作用对象必须是数字集</strong></p></li><li><p><strong>除了count其他函数面对空值都视而不见，如果表中只有空值，count会返回0，其他函数范围null</strong></p></li><li><p><strong>聚集函数只可以出现在select子句和having子句中，不可以出现在where中</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select avg (salary)</span><br><span class="line">from instructor</span><br><span class="line">where dept_name= &#x27;Comp. Sci.&#x27;;</span><br><span class="line"></span><br><span class="line">select count (distinct ID)</span><br><span class="line">from teaches</span><br><span class="line">where semester = &#x27;Spring&#x27; and year = 2010;</span><br></pre></td></tr></table></figure><h2 id="分组">分组</h2><p><strong>group by</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#分组聚合</span><br><span class="line">select dept_name, avg (salary) as avg_salary</span><br><span class="line">from instructor</span><br><span class="line">group by dept_name;</span><br></pre></td></tr></table></figure><p><strong>没有出现在select聚集函数中的属性必须出现在group by中，出现在group by中的属性不一定出现在select中</strong></p><h2 id="having">having</h2><ul><li><p><strong>无group by无having，形成分组之后再应用having语句</strong></p></li><li><p><strong>from -&gt; where -&gt; group by -&gt; having -&gt; select -&gt;order by</strong></p></li><li><p><strong>任何出现在having语句中但未被聚集的属性必须出现在group by语句中</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select dept_name, avg (salary)</span><br><span class="line">from instructor</span><br><span class="line">group by dept_name</span><br><span class="line">having avg (salary) &gt; 42000;</span><br></pre></td></tr></table></figure><h2 id="嵌套子查询">嵌套子查询</h2><p><strong>where</strong></p><ul><li><p><strong>集合成员资格</strong></p><p><strong>in</strong>：若在则true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select count (distinct ID)</span><br><span class="line">from takes</span><br><span class="line">where (course_id, sec_id, semester, year) in   </span><br><span class="line">(select course_id, sec_id, semester, year</span><br><span class="line">                                 from teaches</span><br><span class="line">                                 where teaches.ID= 10101);</span><br></pre></td></tr></table></figure><p><strong>not in</strong>：不在则true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select distinct course_id</span><br><span class="line">from section</span><br><span class="line">where semester = &#x27;Fall&#x27; and year= 2009 and</span><br><span class="line">course_id  not in (select course_id</span><br><span class="line">                                        from section</span><br><span class="line">                                        where semester = &#x27;Spring&#x27;and year= 2010);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>集合比较</strong></p><p><strong>some</strong>：至少有一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select name</span><br><span class="line">from instructor</span><br><span class="line">where salary &gt; some (select salary</span><br><span class="line">                      from instructor</span><br><span class="line">                      where dept name = &#x27;Biology&#x27;);</span><br><span class="line">#查询工资比同部门至少一个人高的生物系教授的名字</span><br></pre></td></tr></table></figure><figure><img src="image-20240510195352004.png" alt="image-20240510195352004" /><figcaption aria-hidden="true">image-20240510195352004</figcaption></figure><p><strong>all</strong>：全都</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select name</span><br><span class="line">from instructor</span><br><span class="line">where salary &gt; all (select salary</span><br><span class="line">                   from instructor</span><br><span class="line">                   where dept name = &#x27;Biology&#x27;);</span><br><span class="line"> #查找生物系教授中工资最大（比同系其他教授都高）的教授名字</span><br></pre></td></tr></table></figure><figure><img src="image-20240510195712732.png" alt="image-20240510195712732" /><figcaption aria-hidden="true">image-20240510195712732</figcaption></figure></li><li><p><strong>集合约束</strong></p></li></ul><p>​ <strong>空关系验证 exists</strong></p><p>​ <img src="image-20240510200104835.png" alt="image-20240510200104835" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select course_id</span><br><span class="line">from section as S#S被称作为相关名称</span><br><span class="line">where semester = &#x27;Fall&#x27; and year = 2009 and </span><br><span class="line">exists (select * #内查询叫作相关子查询</span><br><span class="line">                from section as T</span><br><span class="line">                        where semester = &#x27;Spring&#x27;  </span><br><span class="line">                        and year= 2010  and S.course_id = T.course_id);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Find all students who have taken all courses offered in the Biology department.</span><br><span class="line">select distinct S.ID, S.name</span><br><span class="line">from student as S</span><br><span class="line">where not exists ( (select course_id  from course</span><br><span class="line">                                 where dept_name = &#x27;Biology&#x27;)</span><br><span class="line">                               except</span><br><span class="line">                                 (select T.course_id  from takes as T</span><br><span class="line">                                   where S.ID = T.ID));</span><br></pre></td></tr></table></figure><p>​ <strong>检查是否存在重复元组 unique</strong></p><p>​ unique：<strong>存在重复返回false，不存在则返回true</strong></p><p>​ not unique：<strong>反之</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#Find all courses that were offered at most once in 2009</span><br><span class="line">select T.course_id</span><br><span class="line">from course as T</span><br><span class="line">where unique (select R.course_id  from section as R</span><br><span class="line">where T.course_id= R.course_id  and R.year = 2009);</span><br></pre></td></tr></table></figure><p><strong>from</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select dept_name, avg_salary</span><br><span class="line">from (select dept_name, avg (salary) as avg_salary</span><br><span class="line">      from instructor</span><br><span class="line">      group by dept_name)</span><br><span class="line">      where avg_salary &gt; 42000;</span><br><span class="line">或者</span><br><span class="line">select dept_name, avg_salary</span><br><span class="line">from (select dept_name, avg (salary) </span><br><span class="line">      from instructor</span><br><span class="line">      group by dept_name) as dept_avg (dept_name, avg_salary)</span><br><span class="line">    where avg_salary &gt; 42000;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​ <strong>with</strong></p><blockquote><p><strong>定义临时关系，只能在同一查询的后面使用</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">with max_budget (value) as  #max_budget 是临时关系</span><br><span class="line">    (select max(budget)</span><br><span class="line">     from department)</span><br><span class="line">select department.name</span><br><span class="line">from department, max_budget</span><br><span class="line">where department.budget = max_budget.value;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Find all departments where the total salary is greater than the average of the total salary at all departments</span><br><span class="line">with dept _total (dept_name, value) as</span><br><span class="line">        (select dept_name, sum(salary)</span><br><span class="line">         from instructor</span><br><span class="line">         group by dept_name),</span><br><span class="line">        dept_total_avg(value) as</span><br><span class="line">        ( select avg(value)</span><br><span class="line">          from dept_total )</span><br><span class="line">select dept_name</span><br><span class="line">from dept_total, dept_total_avg</span><br><span class="line">where dept_total.value &gt; dept_total_avg.value;</span><br></pre></td></tr></table></figure><p><strong>select</strong></p><blockquote><p><strong>标量子查询：用在 只返回一个包含单个属性的元组的查询 的地方</strong></p><p><strong>如果子查询返回多于一个结果的元组会出现error</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select dept_name, ( select count(*)  from instructor                                 where department.dept_name = instructor.dept_name)                               as num_instructors</span><br><span class="line">from department;</span><br></pre></td></tr></table></figure><h2 id="删除">删除</h2><p><strong>delete</strong></p><blockquote><ul><li><strong>delet只能删除元组</strong></li><li><strong>一个delete只能作用与一个关系上</strong></li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#Delete all instructors</span><br><span class="line">delete from instructor </span><br><span class="line"></span><br><span class="line">#Delete all instructors from the Finance department</span><br><span class="line">delete from instructor where dept_name= &#x27;Finance&#x27;;</span><br><span class="line"></span><br><span class="line">#Delete all tuples in the instructor relation for those instructors associated with a department located in the Watson building.</span><br><span class="line">delete from instructor</span><br><span class="line">where dept_name in ( select dept name</span><br><span class="line">                    from department</span><br><span class="line">                    where building = &#x27;Watson&#x27;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#a funny example:</span><br><span class="line">delete from instructor</span><br><span class="line">where salary &lt; (select avg (salary) </span><br><span class="line">                           from instructor);</span><br><span class="line">#Problem:  as we delete tuples from deposit, the average salary changes,边删除平均值边改变</span><br><span class="line">#Solution used in SQL:</span><br><span class="line">#1.   First, compute avg (salary) and find all tuples to delete</span><br><span class="line">#2.   Next, delete all tuples found above (without recomputing  avg or retesting the tuples) </span><br></pre></td></tr></table></figure><h2 id="插入">插入</h2><p><strong>insert</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insert into course</span><br><span class="line">values (&#x27;CS-437&#x27;, &#x27;Database Systems&#x27;, &#x27;Comp. Sci.&#x27;, 4);</span><br><span class="line">#or equivalently</span><br><span class="line">insert into course (course_id, title, dept_name, credits)</span><br><span class="line">values (&#x27;CS-437&#x27;, &#x27;Database Systems&#x27;, &#x27;Comp. Sci.&#x27;, 4);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#Add a new tuple to student with tot_creds set to null</span><br><span class="line">insert into student</span><br><span class="line">values (&#x27;3003&#x27;, &#x27;Green&#x27;, &#x27;Finance&#x27;, null);</span><br></pre></td></tr></table></figure><blockquote><p><strong>系统在执行任何插入之前先执行完select语句十分重要</strong></p><p><strong>Otherwise</strong> queries like</p><p>​ <strong>insert into</strong> <em>table</em>1 <strong>select</strong> * <strong>from</strong> <em>table</em>1</p><p>would cause problem</p></blockquote><h2 id="更新">更新</h2><p><strong>update</strong></p><blockquote><p>改变某个元组的某个属性的值</p><p>update table1</p><p>​ set attribute1 [ ]</p><p>​ where</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#Increase salaries of instructors whose salary is over $100,000 by 3%, and all others by a 5% </span><br><span class="line">update instructor</span><br><span class="line">set salary = salary * 1.03</span><br><span class="line">where salary &gt; 100000;</span><br><span class="line">update instructor</span><br><span class="line">set salary = salary * 1.05</span><br><span class="line">where salary &lt;= 100000;</span><br><span class="line">#顺序很重要，不能两次更新不能交换位置</span><br></pre></td></tr></table></figure><p><strong>case</strong></p><blockquote><p>case</p><p>​ when predict1 then result1</p><p>​ when predict2 then result2</p><p>​ ......</p><p>​ else result</p><p>end</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#可以用case语句进行书写</span><br><span class="line">update instructor</span><br><span class="line">set salary = case</span><br><span class="line">when salary &lt;= 100000 then salary * 1.05</span><br><span class="line">else salary * 1.03</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>update 与标量子查询</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#Recompute and update tot_creds value for all students</span><br><span class="line">update student S </span><br><span class="line">set tot_cred = ( select sum(credits)</span><br><span class="line">                from takes, course</span><br><span class="line">                where takes.course_id = course.course_id and </span><br><span class="line">                S.ID= takes.ID.and  takes.grade &lt;&gt; &#x27;F&#x27; and </span><br><span class="line">                                              takes.grade is not null );</span><br><span class="line">#Instead of sum(credits), use:</span><br><span class="line">case</span><br><span class="line">when sum(credits) is not null then sum(credits)</span><br><span class="line">else 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h1 id="sql进阶">SQL进阶</h1><h2 id="连接">连接</h2><blockquote><p>join ：输入两个关系返回一个关系</p><figure><img src="image-20240513103308652.png" alt="image-20240513103308652" /><figcaption aria-hidden="true">image-20240513103308652</figcaption></figure></blockquote><figure><img src="image-20240513103317354.png" alt="image-20240513103317354" /><figcaption aria-hidden="true">image-20240513103317354</figcaption></figure><h3 id="自然连接">自然连接</h3><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自然连接基于相同的属性名称和数据类型连接两个表。结果表将包含两个表的所有属性，但每个公共列仅保留一份副本</span><br></pre></td></tr></table></figure></blockquote><h3 id="内连接">内连接</h3><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内连接基于在 ON 子句中明确指定的列连接两个表。结果表将包含两个表中的所有属性，包括公共列。</span><br></pre></td></tr></table></figure></blockquote><h3 id="左外连接">左外连接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">course natural left outer join prereq</span><br></pre></td></tr></table></figure><p>出现在左边的元组一定会出现在结果之中，对于没有右边信息的用null填充</p><figure><img src="image-20240513103326108.png" alt="image-20240513103326108" /><figcaption aria-hidden="true">image-20240513103326108</figcaption></figure><h3 id="右外连接">右外连接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">course natural right outer join prereq</span><br></pre></td></tr></table></figure><p>出现在右边关系中的元组一定会出现在结果之中，对于没有左边信息的用null填充</p><figure><img src="image-20240513103334101.png" alt="image-20240513103334101" /><figcaption aria-hidden="true">image-20240513103334101</figcaption></figure><h3 id="全外连接">全外连接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">course natural full outer join prereq</span><br></pre></td></tr></table></figure><p>出现在两个关系的元组都会出现在结果中，无信息用null填充</p><figure><img src="image-20240513103544065.png" alt="image-20240513103544065" /><figcaption aria-hidden="true">image-20240513103544065</figcaption></figure><h3 id="连接条件">连接条件</h3><blockquote><p>只有满足条件的元组才能进行连接，并且条件中的属性在结果中会被重复保留</p></blockquote><figure><img src="image-20240513104154472.png" alt="image-20240513104154472" /><figcaption aria-hidden="true">image-20240513104154472</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">course inner join prereq on course.course_id = prereq.course_id</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure><img src="image-20240513103744413.png" alt="image-20240513103744413" /><figcaption aria-hidden="true">image-20240513103744413</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">course left outer join prereq on course.course_id = prereq.course_id</span><br></pre></td></tr></table></figure><figure><img src="image-20240513104107848.png" alt="image-20240513104107848" /><figcaption aria-hidden="true">image-20240513104107848</figcaption></figure><figure><img src="image-20240513104238809.png" alt="image-20240513104238809" /><figcaption aria-hidden="true">image-20240513104238809</figcaption></figure><figure><img src="image-20240513104340385.png" alt="image-20240513104340385" /><figcaption aria-hidden="true">image-20240513104340385</figcaption></figure><h2 id="视图">视图</h2><blockquote><p>A <strong>view</strong> provides a mechanism <strong>to hide certain data from the view of certain users</strong>.</p><p>Any relation that is not of the conceptual model but is made visible to a user as a “virtual relation” is called a <strong>view</strong>.</p></blockquote><h3 id="视图的定义">视图的定义</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v <span class="keyword">as</span> <span class="operator">&lt;</span> query expression <span class="operator">&gt;</span></span><br><span class="line"># <span class="keyword">where</span> <span class="operator">&lt;</span>query expression<span class="operator">&gt;</span> <span class="keyword">is</span> <span class="keyword">any</span> legal <span class="keyword">SQL</span> expression.  The <span class="keyword">view</span> name <span class="keyword">is</span> represented <span class="keyword">by</span> v.</span><br></pre></td></tr></table></figure><ul><li>一旦视图被定义，那么这个视图的名字可以用来代指视图产生的<strong>虚拟关系</strong></li><li>数据库系统存储的是与视图关系相关联的<strong>查询表达式</strong></li><li>视图关系概念上包含了查询结果的元组但<strong>不进行预先计算和存储</strong></li><li>视图一旦被创建，在被显示删除之前一直可用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create view faculty as</span><br><span class="line">select ID, name, dept_name</span><br><span class="line">from instructor</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Find all instructors in the Biology department</span><br><span class="line">select name</span><br><span class="line">from faculty</span><br><span class="line">where dept_name = &#x27;Biology&#x27;</span><br><span class="line">#Create a view of department salary totals</span><br><span class="line">create view departments_total_salary( dept_name,total_salary) as </span><br><span class="line">select dept_name, sum (salary)</span><br><span class="line">                 from instructor</span><br><span class="line">                 group by dept_name;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="用视图定义视图">用视图定义视图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create view physics_fall_2009 as</span><br><span class="line">select course.course_id, sec_id, building, room_number</span><br><span class="line">from course, section</span><br><span class="line">where course.course_id = section.course_id  and course.dept_name = &#x27;Physics&#x27;and section.semester = &#x27;Fall&#x27; and section.year = &#x27;2009&#x27;;</span><br><span class="line"></span><br><span class="line">create view physics_fall_2009_watson as</span><br><span class="line">select course_id, room_number</span><br><span class="line">from physics_fall_2009</span><br><span class="line">where building= &#x27;Watson&#x27;;</span><br></pre></td></tr></table></figure><blockquote><ul><li>若视图v1在定义的时候使用了视图v2，则v1直接依赖于v2</li><li>若视图v1在定义的时候使用了视图v2，或者视图v1到视图v2之间存在依赖路径，则v1依赖于v2</li><li>A view relation <em>v</em> is said to be <em>recursive</em> if it depends on itself.</li></ul></blockquote><p><strong>判断闭包的方法</strong></p><blockquote><p><strong>repeat </strong> Find any view relation *v**i* in <em>e</em>1 Replace the view relation *v**i* by the expression defining *v<strong>i* </strong>until** no more view relations are present in <em>e</em>1</p></blockquote><p>As long as the view definitions are not recursive, this loop will terminate</p><h3 id="视图更新">视图更新</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#向视图中添加新的元组</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> faculty <span class="keyword">values</span> (<span class="string">&#x27;30765&#x27;</span>, <span class="string">&#x27;Green&#x27;</span>, <span class="string">&#x27;Music&#x27;</span>);</span><br><span class="line">#This insertion must be represented <span class="keyword">by</span> the insertion <span class="keyword">of</span> the tuple</span><br><span class="line">#(<span class="string">&#x27;30765&#x27;</span>, <span class="string">&#x27;Green&#x27;</span>, <span class="string">&#x27;Music&#x27;</span>, <span class="keyword">null</span>)</span><br><span class="line">#<span class="keyword">into</span> the instructor relation</span><br></pre></td></tr></table></figure><p><strong>sql视图是可更新（插入 删除 更新），若满足下列条件</strong></p><blockquote><p>The <strong>from</strong> clause has only one database relation.</p><p>The <strong>select</strong> clause contains only attribute names of the relation, and does not have any expressions, aggregates, or <strong>distinct</strong> specification.</p><p>Any attribute not listed in the <strong>select</strong> clause can be set to null</p><p>The query does not have a <strong>group</strong> <strong>by</strong> or <strong>having</strong> clause.</p></blockquote><h3 id="物化视图">物化视图</h3><blockquote><p>create a physical table containing all the tuples in the result of the query defining the view</p></blockquote><p><strong>tips：</strong></p><ul><li><p>If relations used in the query are updated, the materialized view result becomes out of date</p></li><li><p>Need to <strong>maintain</strong> the view, by updating the view whenever the underlying relations are updated.</p></li><li><p>视图是一种“虚关系”，实际查询时需要根据定义查询底层关系，当存在大量这样的查询时会有较高的成本。</p></li><li><p>某些数据库支持物化视图，像存储表一样将创建的视图关系“物化”存储在数据库中。</p></li><li><p>物化视图的创建、修改与删除语法同视图类似，区别是多了关键字 <strong>MATERIALIZED</strong></p></li></ul><h2 id="完整性约束-1">完整性约束</h2><blockquote><p>保护数据的一致性</p></blockquote><p><strong>单个关系上的完整性约束</strong></p><blockquote><p><strong>not null </strong> 非空</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">Declare</span> name <span class="keyword">and</span> budget <span class="keyword">to</span> be <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>       </span><br><span class="line">budget <span class="type">numeric</span>(<span class="number">12</span>,<span class="number">2</span>) <span class="keyword">not</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>primary key</strong> 主码</p></blockquote><p>既要非空又要保证唯一性</p><blockquote><p><strong>unique </strong> 唯一性</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unique</span> ( A1, A2, …, Am)</span><br></pre></td></tr></table></figure><ul><li><strong>让A1,A2,..,Am，成为了超码</strong></li><li><strong>声明了唯一性的属性允许为空</strong></li></ul><blockquote><p><strong>check</strong> (P), where P is a predicate</p></blockquote><p><strong>关系中的每个元组都要满足谓词P</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#ensure that semester <span class="keyword">is</span> <span class="keyword">one</span> <span class="keyword">of</span> fall, winter, spring <span class="keyword">or</span> summer:</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> section (</span><br><span class="line">    course_id <span class="type">varchar</span> (<span class="number">8</span>),</span><br><span class="line">    sec_id <span class="type">varchar</span> (<span class="number">8</span>),</span><br><span class="line">    semester <span class="type">varchar</span> (<span class="number">6</span>),</span><br><span class="line">    <span class="keyword">year</span> <span class="type">numeric</span> (<span class="number">4</span>,<span class="number">0</span>),</span><br><span class="line">    building <span class="type">varchar</span> (<span class="number">15</span>),</span><br><span class="line">    room_number <span class="type">varchar</span> (<span class="number">7</span>),</span><br><span class="line">    <span class="type">time</span> slot id <span class="type">varchar</span> (<span class="number">4</span>), </span><br><span class="line">    <span class="keyword">primary</span> key (course_id, sec_id, semester, <span class="keyword">year</span>),</span><br><span class="line">    <span class="keyword">check</span> (semester <span class="keyword">in</span> (<span class="string">&#x27;Fall&#x27;</span>, <span class="string">&#x27;Winter&#x27;</span>, <span class="string">&#x27;Spring&#x27;</span>, <span class="string">&#x27;Summer&#x27;</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>引用完整性</strong></p><blockquote><ul><li><strong>保证引用关系中的给定属性集合的取值也在被引用关系的特定属性集的取值中出现</strong></li><li><strong>外码是引用完整性约束的一种形式，其中被引用的属性构成被引用关系的主码</strong></li><li>至少要保证被引用关系的唯一性，要么主码约束要么唯一性约束</li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> course (</span><br><span class="line">course_id   <span class="type">char</span>(<span class="number">5</span>) <span class="keyword">primary</span> key,</span><br><span class="line">title <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">dept_name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">references</span> department#dept_name是department的主码</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>引用完整性上的级联操作</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> course (</span><br><span class="line">…</span><br><span class="line">dept_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line"><span class="keyword">foreign</span> key (dept_name) <span class="keyword">references</span> department</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">delete</span> cascade#如果被引用关系上的删除，更新操作违反了约束，那么就进行级联删除或者更新</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">update</span> cascade,</span><br><span class="line">. . . </span><br><span class="line">)</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">update</span> cascade</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">delete</span> cascade</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">set</span> <span class="keyword">null</span>#置空值</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">set</span> defualt#置缺省置</span><br></pre></td></tr></table></figure><p><strong>复杂check语句</strong></p><blockquote><p><strong>复杂的check语句在我们希望保证数据的完整性是有用的，但开销十分巨大</strong></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">check</span> (time_slot_id <span class="keyword">in</span> (<span class="keyword">select</span> time_slot_id <span class="keyword">from</span> time_slot))</span><br><span class="line">#section关系上定义约束</span><br><span class="line">#why <span class="keyword">not</span> use a <span class="keyword">foreign</span> key here?   因为不是超码</span><br></pre></td></tr></table></figure><p>上述语句不仅要在section更新时候进行计算，也要在time_slot发生更新的时候计算</p><h2 id="断言"><strong>断言</strong></h2><blockquote><p>谓词，表达了希望数据库总满足的一个条件</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> assertion <span class="operator">&lt;</span>assertion<span class="operator">-</span>name<span class="operator">&gt;</span> <span class="keyword">check</span> <span class="operator">&lt;</span>predicate<span class="operator">&gt;</span>;</span><br><span class="line">#不被任何数据库支持</span><br></pre></td></tr></table></figure><p><strong>创建断言的时候系统会检测其有效性，检测和维护有效性的开销很大，但触发器可以实现等价功能</strong></p><h2 id="数据类型">数据类型</h2><figure><img src="image-20240520195105693.png" alt="image-20240520195105693" /><figcaption aria-hidden="true">image-20240520195105693</figcaption></figure><h2 id="创建索引">创建索引</h2><blockquote><p><strong>索引：一种数据结构，允许数据库系统高效地找到关系中具有该属性指定值的元组，而不扫描关系的所有元组</strong></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student</span><br><span class="line">( ID <span class="type">varchar</span> (<span class="number">5</span>),</span><br><span class="line">name <span class="type">varchar</span> (<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">dept_name <span class="type">varchar</span> (<span class="number">20</span>),</span><br><span class="line">tot_cred <span class="type">numeric</span> (<span class="number">3</span>,<span class="number">0</span>) <span class="keyword">default</span> <span class="number">0</span>,</span><br><span class="line"><span class="keyword">primary</span> key (ID) )</span><br><span class="line"><span class="keyword">create</span> index studentID_index <span class="keyword">on</span> student(ID)</span><br><span class="line"><span class="comment">---------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span>  student</span><br><span class="line"><span class="keyword">where</span>  ID <span class="operator">=</span> ‘<span class="number">12345</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">#can be executed by using the index to find the required record, without looking at all records of student</span></span><br></pre></td></tr></table></figure><h2 id="用户自定义类型">用户自定义类型</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> type Dollars <span class="keyword">as</span> <span class="type">numeric</span> (<span class="number">12</span>,<span class="number">2</span>) <span class="keyword">final</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> department</span><br><span class="line">( dept_name <span class="type">varchar</span> (<span class="number">20</span>),</span><br><span class="line"> building <span class="type">varchar</span> (<span class="number">15</span>),</span><br><span class="line"> budget Dollars );</span><br><span class="line"><span class="keyword">create</span> type Pounds <span class="keyword">as</span> <span class="type">numeric</span> (<span class="number">12</span>,<span class="number">2</span>) <span class="keyword">final</span> </span><br><span class="line"># Pounds和Dollars不是一种类型</span><br></pre></td></tr></table></figure><h2 id="域">域</h2><figure><img src="image-20240520195647678.png" alt="image-20240520195647678" /><figcaption aria-hidden="true">image-20240520195647678</figcaption></figure><h2 id="大对象类型">大对象类型</h2><figure><img src="image-20240520195728022.png" alt="image-20240520195728022" /><figcaption aria-hidden="true">image-20240520195728022</figcaption></figure><h2 id="授权">授权</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="operator">&lt;</span>privilege list<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">on</span> <span class="operator">&lt;</span>relation name <span class="keyword">or</span> <span class="keyword">view</span> name<span class="operator">&gt;</span> <span class="keyword">to</span> <span class="operator">&lt;</span><span class="keyword">user</span> list<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>sql中的权限：</p><ul><li><strong>select：allows read access to</strong> <strong>relation,or</strong> <strong>the ability to query using the view</strong></li><li><strong>insert:the ability to insert tuples</strong></li><li><strong>update:</strong> <strong>the ability to update using the SQL update statement</strong></li><li><strong>delete：the ability to delete tuples.</strong></li><li><strong>all</strong> <strong>privileges：used as a short form for all the allowable privileges</strong></li></ul><h3 id="移除权限">移除权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> <span class="operator">&lt;</span>privilege list<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">on</span> <span class="operator">&lt;</span>relation name <span class="keyword">or</span> <span class="keyword">view</span> name<span class="operator">&gt;</span> <span class="keyword">from</span> <span class="operator">&lt;</span><span class="keyword">user</span> list<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><ul><li>如果 <strong><revokee-list></strong>包含public那么全部的用户会失去权限，除了授权用户</li><li>如果相同的权限被不同的人授予给相同的用户两次，那么在被一次撤权后会保留权限。</li><li>所有依赖被撤除权限的权限也会被撤除</li></ul><h3 id="角色">角色</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> role instructor</span><br><span class="line"><span class="keyword">grant</span> instructor <span class="keyword">to</span> Amit</span><br><span class="line"># Privileges can be granted <span class="keyword">to</span> roles:</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> takes <span class="keyword">to</span> instructor</span><br><span class="line"># Roles can be granted <span class="keyword">to</span> users, <span class="keyword">as</span> well <span class="keyword">as</span> <span class="keyword">to</span> other roles</span><br><span class="line"><span class="keyword">create</span> role teaching_assistant</span><br><span class="line"><span class="keyword">grant</span> teaching_assistant <span class="keyword">to</span> instructor # Instructor inherits <span class="keyword">all</span> privileges <span class="keyword">of</span> teaching_assistant</span><br></pre></td></tr></table></figure><h3 id="视图的授权">视图的授权</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> geo_instructor <span class="keyword">as</span></span><br><span class="line">( <span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"> <span class="keyword">from</span> instructor</span><br><span class="line"> <span class="keyword">where</span> dept_name <span class="operator">=</span> ’Geology’);</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> geo_instructor <span class="keyword">to</span>  geo_staff</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="授权的转移">授权的转移</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#允许被授权用户进行授权</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> department <span class="keyword">to</span> Amit <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br><span class="line">#级联收权，缺省</span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">select</span> <span class="keyword">on</span> department <span class="keyword">from</span> Amit, Satoshi cascade;</span><br><span class="line">#显示限定不级联收权</span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">select</span> <span class="keyword">on</span> department <span class="keyword">from</span> Amit, Satoshi restrict;</span><br><span class="line">#仅收回授权选项</span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">grant</span> option <span class="keyword">for</span> <span class="keyword">select</span> <span class="keyword">on</span> department <span class="keyword">from</span> Amit, Satoshi restrict;</span><br></pre></td></tr></table></figure><p><strong>一个用户具有权限等价于授权图中存在由根到用户节点的路径</strong></p><h1 id="高级sql">高级SQL</h1><h2 id="函数与过程">函数与过程</h2><h3 id="函数">函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">Define</span> a <span class="keyword">function</span> that, given the name <span class="keyword">of</span> a department, <span class="keyword">returns</span> the count <span class="keyword">of</span> the number <span class="keyword">of</span> instructors <span class="keyword">in</span> that department.</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> dept_count (dept_name <span class="type">varchar</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">returns</span> <span class="type">integer</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> d_count  <span class="type">integer</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span> (<span class="operator">*</span> ) <span class="keyword">into</span> d_count</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> instructor.dept_name <span class="operator">=</span> dept_name</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> d_count;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--------</span></span><br><span class="line"><span class="keyword">select</span> dept_name, budget</span><br><span class="line"><span class="keyword">from</span> department</span><br><span class="line"><span class="keyword">where</span> dept_count (dept_name ) <span class="operator">&gt;</span> <span class="number">12</span></span><br></pre></td></tr></table></figure><figure><img src="image-20240522090152312.png" alt="image-20240522090152312" /><figcaption aria-hidden="true">image-20240522090152312</figcaption></figure><h3 id="存储过程">存储过程</h3><figure><img src="image-20240522085957034.png" alt="image-20240522085957034" /><figcaption aria-hidden="true">image-20240522085957034</figcaption></figure><figure><img src="image-20240522090006465.png" alt="image-20240522090006465" /><figcaption aria-hidden="true">image-20240522090006465</figcaption></figure><figure><img src="image-20240522090059620.png" alt="image-20240522090059620" /><figcaption aria-hidden="true">image-20240522090059620</figcaption></figure><p>区别</p><ul><li><strong>存储过程和函数是事先经过编译并存储在数据库中的一段SQL语句的集合</strong></li><li><strong>存储过程和函数可以对一段代码进行封装，以便日后调用</strong></li><li><strong>数据库中创建存储过程的语句为CREATE PROCEDURE，并通过CALL语句加存储过程名来调用存储过程</strong></li><li><strong>数据库中创建函数的语句为CREATE FUNCTION，并通过函数名来调用函数</strong></li><li><strong>存储过程和函数都用于提高数据库性能，减少频繁访问数据库和减少网络延迟等方式加速执行效率。</strong></li><li><strong>函数：简单的计算型任务，例如字符串或日期拼接、返回单个值等。</strong></li><li><strong>存储过程：复杂的业务逻辑、更新和删除相关操作。</strong></li><li><strong>存储过程需要显式地被调用，并且可以包含各种复杂的控制结构和代码块。</strong></li></ul><figure><img src="image-20240522090240468.png" alt="image-20240522090240468" /><figcaption aria-hidden="true">image-20240522090240468</figcaption></figure><h2 id="触发器">触发器</h2><blockquote><p>可以被系统自动执行、作为数据库修改的side effect 的语句</p></blockquote><ul><li><p><strong>我们要指定触发器执行的条件和动作</strong></p></li><li><p><strong>触发器事件可以是插入、删除、更新，其中更新可以限定到一个属性上 更新前后可以被引用</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">referencing</span> <span class="keyword">old</span> <span class="type">row</span> <span class="keyword">as</span>  :<span class="keyword">for</span> deletes <span class="keyword">and</span> updates</span><br><span class="line"><span class="keyword">referencing</span> <span class="keyword">new</span> <span class="type">row</span> <span class="keyword">as</span>  : <span class="keyword">for</span> inserts <span class="keyword">and</span> updates</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> setnull_trigger before <span class="keyword">update</span> <span class="keyword">of</span> takes</span><br><span class="line"><span class="keyword">referencing</span> <span class="keyword">new</span> <span class="type">row</span> <span class="keyword">as</span> nrow</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">when</span> (nrow.grade <span class="operator">=</span> ‘ ‘)</span><br><span class="line"><span class="keyword">begin</span> <span class="keyword">atomic</span></span><br><span class="line"><span class="keyword">set</span> nrow.grade <span class="operator">=</span> <span class="keyword">null</span>;   </span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> credits_earned after <span class="keyword">update</span> <span class="keyword">of</span> takes <span class="keyword">on</span> (grade)</span><br><span class="line"><span class="keyword">referencing</span> <span class="keyword">new</span> <span class="type">row</span> <span class="keyword">as</span> nrow</span><br><span class="line"><span class="keyword">referencing</span> <span class="keyword">old</span> <span class="type">row</span> <span class="keyword">as</span> orow</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">when</span> nrow.grade <span class="operator">&lt;&gt;</span> ’F’ <span class="keyword">and</span> nrow.grade <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line"><span class="keyword">and</span> (orow.grade <span class="operator">=</span> ’F’ <span class="keyword">or</span> orow.grade <span class="keyword">is</span> <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">begin</span> <span class="keyword">atomic</span></span><br><span class="line"><span class="keyword">update</span> student</span><br><span class="line"><span class="keyword">set</span> tot_cred<span class="operator">=</span> tot_cred <span class="operator">+</span> </span><br><span class="line">(<span class="keyword">select</span> credits</span><br><span class="line"><span class="keyword">from</span> course</span><br><span class="line"><span class="keyword">where</span> course.course_id<span class="operator">=</span> nrow.course_id)</span><br><span class="line"><span class="keyword">where</span> student.id <span class="operator">=</span> nrow.id;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><figure><img src="image-20240522091147745.png" alt="image-20240522091147745" /><figcaption aria-hidden="true">image-20240522091147745</figcaption></figure><figure><img src="image-20240522090959333.png" alt="image-20240522090959333" /><figcaption aria-hidden="true">image-20240522090959333</figcaption></figure><figure><img src="image-20240522091258072.png" alt="image-20240522091258072" /><figcaption aria-hidden="true">image-20240522091258072</figcaption></figure><figure><img src="image-20240522091316867.png" alt="image-20240522091316867" /><figcaption aria-hidden="true">image-20240522091316867</figcaption></figure><h2 id="闭包查询">闭包查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="keyword">recursive</span> rec_prereq(course_id, prereq_id) <span class="keyword">as</span> (</span><br><span class="line"><span class="keyword">select</span> course_id, prereq_id</span><br><span class="line"><span class="keyword">from</span> prereq</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> rec_prereq.course_id, prereq.prereq_id,</span><br><span class="line"><span class="keyword">from</span> rec_rereq, prereq</span><br><span class="line"><span class="keyword">where</span> rec_prereq.prereq_id <span class="operator">=</span> prereq.course_id</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> ∗ </span><br><span class="line"><span class="keyword">from</span> rec_prereq;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数据库系统原理的部分笔记</summary>
    
    
    
    <category term="class" scheme="https://klklkl10086.github.io/klklkl10086.github.io/categories/class/"/>
    
    
    <category term="SQL" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2024/02/22/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2024/02/22/%E8%93%9D%E6%A1%A5%E6%9D%AF/</id>
    <published>2024-02-22T02:50:11.000Z</published>
    <updated>2025-03-29T05:46:47.936Z</updated>
    
    <content type="html"><![CDATA[<p>放在前面的话：</p><p>​ 这份笔记是在大二下刚开学的时候进行书写的，主要参考的是Acwing的<a href="https://www.acwing.com/activity/content/19/">蓝桥杯辅导课</a>，笔者在成体系的学习算法之前已经学习过基本的<a href="https://comeupklklkl.gitee.io/jluloser.github.io/2023/10/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>，以及离散数学。（PS: y总讲课很好，如果可以建议报一下试试）</p><h1 id="基础概念">基础概念</h1><p>1s内c++可以运算一亿次即1e8次，因此我们的最大次数小于1e7到1e8之间便可以</p><p>int的范围约为[-2e9,+2e9]，最大值可以通过 0x7fffffff 来表示，long long的范围是 [- 1e18，+1e18]</p><p>由数据范围反推算法复杂度以及算法内容：</p><figure><img src="image-20240412192522712.png" alt="image-20240412192522712" /><figcaption aria-hidden="true">image-20240412192522712</figcaption></figure><p>下取整 （int）直接除</p><p>上取整：转化成下取整</p><figure><img src="image-20240314212814712.png" alt="image-20240314212814712" /><figcaption aria-hidden="true">image-20240314212814712</figcaption></figure><figure><img src="image-20240314213050728.png" alt="image-20240314213050728" /><figcaption aria-hidden="true">image-20240314213050728</figcaption></figure><h1 id="输入技巧">输入技巧</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="built_in">getline</span>(cin,str);</span><br><span class="line"><span class="keyword">while</span>(cnt--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">getline</span>(cin,str);</span><br><span class="line">        <span class="function">stringstream <span class="title">ssin</span><span class="params">(str)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(ssin&gt;&gt;a[n]) n++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="递归与递推">递归与递推</h1><p>递归：把问题分成若干个相同子问题</p><p>递推：由子问题推出最终问题</p><h1 id="二分">二分</h1><h2 id="整数二分">整数二分</h2><ul><li><p>确定一个区间使得答案一定在一个区间里</p></li><li><p>找一个性质，满足两点：</p><p>性质具有二段性</p><p>答案是二段性的分段点（有两种情况，一种是前段的终点a，一种是后段的起点b，a与b不重合）</p></li></ul><figure><img src="image-20240307215445608.png" alt="image-20240307215445608" /><figcaption aria-hidden="true">image-20240307215445608</figcaption></figure><figure><img src="image-20240307215206733.png" alt="image-20240307215206733" /><figcaption aria-hidden="true">image-20240307215206733</figcaption></figure><p><a href="https://www.acwing.com/file_system/file/content/whole/index/content/3073/">y总模板</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;<span class="comment">//一定要加一</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;<span class="comment">//</span></span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记忆技巧：</p><p>如果我们想要的点x是左部分的<strong>右端点</strong>，则区间分为 [l,mid-1] ,[<strong>mid</strong>,r]</p><p>如果我们想要的点x是右部分的<strong>左端点</strong>，则区间分为 [l,<strong>mid</strong>] ,[mid+1,r]</p><p>即我们想要的x是什么方向的端点，mid就在哪个部分，<strong>只要l=mid出现计算mid的时候一定要加一</strong></p><h1 id="前缀和">前缀和</h1><p><strong>一定要将下标加一，不然遇见s[i-1]会出问题</strong></p><h2 id="一维前缀和">一维前缀和</h2><p>利用数列的思想： <span class="math display">\[S_r-S_l=a_{l+1}+a_{l+2}+...+a_{r}\]</span></p><h2 id="二维前缀和">二维前缀和</h2><p>与一维前缀和思想类似:</p><blockquote><p><strong>容斥原理</strong>:</p><p>在计数时，必须注意没有重复，没有遗漏。为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目<a href="https://baike.baidu.com/item/排斥/10717656?fromModule=lemma_inlink">排斥</a>出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理</p></blockquote><p><strong>1.计算前缀和矩阵</strong> <span class="math display">\[S_{(x,y)} = S_{(x-1,y)}+S_{(x,y-1)}-S_{(x-1,y-1)}+a_{(x,y)}\]</span> <strong>2.利用前缀和矩阵计算子矩阵的和</strong> <span class="math display">\[S_{(x_1,y_1),(x_2,y_2)} = S_{(x_2,y_2)}-S_{(x_2,y_1-1)}-S_{(x_1-1,y_2)}+S_{(x_1-1,y_1-1)}\]</span></p><h1 id="差分">差分</h1><p>前缀和的逆应用</p><p><strong>在指定的区间内统一加上或者减去一个数字</strong></p><figure><img src="image-20240412195444573.png" alt="image-20240412195444573" /><figcaption aria-hidden="true">image-20240412195444573</figcaption></figure><p>输入一个 n 行 m列的整数矩阵，再输入 q 个操作，每个操作包含五个整数 x1,y1,x2,y2,c1,1,2,2,，其中 (x1,y1)和 (x2,y2)表示一个子矩阵的左上角坐标和右下角坐标。</p><p>每个操作都要将选中的子矩阵中的每个元素的值加上 c。</p><p>请你将进行完所有操作后的矩阵输出。</p><h4 id="输入格式">输入格式</h4><p>第一行包含整数 n,m,q,,。</p><p>接下来 n 行，每行包含 m 个整数，表示整数矩阵。</p><p>接下来 q 行，每行包含 55个整数 x1,y1,x2,y2，c表示一个操作。</p><h4 id="输出格式">输出格式</h4><p>共 n 行，每行 m 个整数，表示所有操作进行完毕后的最终矩阵。</p><h4 id="输入样例">输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3 4 3</span><br><span class="line">1 2 2 1</span><br><span class="line">3 2 2 1</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 2 2 1</span><br><span class="line">1 3 2 3 2</span><br><span class="line">3 1 3 4 1</span><br></pre></td></tr></table></figure><h4 id="输出样例">输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 3 4 1</span><br><span class="line">4 3 4 1</span><br><span class="line">2 2 2 2</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> a[N][N],n,m,q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">a[i][j]+=x;</span><br><span class="line">a[i+<span class="number">1</span>][j]-=x;</span><br><span class="line">a[i][j+<span class="number">1</span>]-=x;</span><br><span class="line">a[i+<span class="number">1</span>][j+<span class="number">1</span>]+=x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> x1,y1,x2,y2,c;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;c);</span><br><span class="line">a[x1][y1]+=c;</span><br><span class="line">a[x2+<span class="number">1</span>][y1]-=c;</span><br><span class="line">a[x1][y2+<span class="number">1</span>]-=c;</span><br><span class="line">a[x2+<span class="number">1</span>][y2+<span class="number">1</span>]+=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">a[i][j]+=a[i<span class="number">-1</span>][j]+a[i][j<span class="number">-1</span>]-a[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i][j]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一维差分">一维差分</h2><h2 id="二维差分">二维差分</h2><h1 id="数学知识">数学知识</h1><p>尽力分析</p><p>打表找规律</p><h3 id="裴蜀定理">裴蜀定理</h3><figure><img src="image-20240412201207067.png" alt="image-20240412201207067" /><figcaption aria-hidden="true">image-20240412201207067</figcaption></figure><figure><img src="image-20240412201220057.png" alt="image-20240412201220057" /><figcaption aria-hidden="true">image-20240412201220057</figcaption></figure><figure><img src="image-20240314210202079.png" alt="image-20240314210202079" /><figcaption aria-hidden="true">image-20240314210202079</figcaption></figure><h3 id="最大公因数">最大公因数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="朴素筛质数"><strong>朴素筛质数</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[i]) <span class="keyword">continue</span>;</span><br><span class="line">        primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + i; j &lt;= n; j += i)</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="枚举-模拟-排序">枚举 模拟 排序</h1><p><strong>归并排序模板</strong></p><p>计算逆序对</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    cnt+=<span class="built_in">merge_sort</span>(q,l,mid)+<span class="built_in">merge_sort</span>(q,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="type">int</span> i=l,j=mid+<span class="number">1</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i]&lt;=q[j]) tmp[k++]=q[i++];</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            cnt+=mid-i+<span class="number">1</span>;<span class="comment">////key</span></span><br><span class="line">            tmp[k++]=q[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) tmp[k++]=q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) tmp[k++]=q[j++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l,j=<span class="number">0</span>;i&lt;=r;i++,j++) q[i]=tmp[j];</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="树状数组与线段树">树状数组与线段树</h1><p>前者精密 后者处理范围广</p><figure><img src="image-20240324104634741.png" alt="image-20240324104634741" /><figcaption aria-hidden="true">image-20240324104634741</figcaption></figure><figure><img src="image-20240324105942645.png" alt="image-20240324105942645" /><figcaption aria-hidden="true">image-20240324105942645</figcaption></figure><figure><img src="image-20240324110501255.png" alt="image-20240324110501255" /><figcaption aria-hidden="true">image-20240324110501255</figcaption></figure><figure><img src="image-20240324194807646.png" alt="image-20240324194807646" /><figcaption aria-hidden="true">image-20240324194807646</figcaption></figure><figure><img src="image-20240324195124747.png" alt="image-20240324195124747" /><figcaption aria-hidden="true">image-20240324195124747</figcaption></figure><p>线段树节点的个数最多是4n，存储方式和堆的存储方式一样，使用一维数组存储，下标为x的节点的父节点是x/2（x&gt;&gt;1） 左儿子是2x 右儿子是2x+1</p><h1 id="位运算">位运算</h1><p>求n的第k位数字: n &gt;&gt; k &amp; 1 返回n的最后一位1：lowbit(n) = n &amp; -n</p><h1 id="快速幂">快速幂</h1><figure><img src="image-20241001204959516.png" alt="image-20241001204959516" /><figcaption aria-hidden="true">image-20241001204959516</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对p做二进制拆分， 对n做平方倍增 -- O(log n)</span></span><br><span class="line"> <span class="function">ll <span class="title">quick_power</span><span class="params">(ll n, ll p)</span></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;  <span class="comment">//如果指数不为0</span></span><br><span class="line">        <span class="keyword">if</span>(p &amp; <span class="number">1</span>) res *= n;  <span class="comment">// 如果对应二进制数的当前位为1, 则res 乘以当前位的值</span></span><br><span class="line">        n *= n;              <span class="comment">//对n进行倍增</span></span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>;             <span class="comment">//指数右移1位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="高精度计算">高精度计算</h1><h2 id="大数加法">大数加法</h2><h3 id="课程">课程</h3><p><strong>没有考虑负数的情况</strong></p><p><a href="https://www.bilibili.com/video/BV1Ne411v78Z/?spm_id_from=333.788&amp;vd_source=9a4fe569cfdfb26138828e9c87e1512d">b站大数加法</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">vector2string</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; x, <span class="type">int</span> s, <span class="type">bool</span> flag = <span class="number">1</span>)</span><span class="comment">//flag为1则x为正数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">string <span class="title">ans</span><span class="params">(s, <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s; i++)</span><br><span class="line">&#123;</span><br><span class="line">ans[i] = <span class="string">&#x27;0&#x27;</span> + x[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());<span class="comment">//倒置</span></span><br><span class="line"> <span class="keyword">if</span>(!flag)    ans.<span class="built_in">insert</span>(<span class="number">0</span>,<span class="string">&quot;-&quot;</span>);<span class="comment">//如果为负数在数字前面添加负号</span></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">add</span><span class="params">(string&amp; num1, string&amp; num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(num1.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(num2.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num1.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">a[num1.<span class="built_in">size</span>() - i - <span class="number">1</span>] = num1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num2.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">b[num2.<span class="built_in">size</span>() - i - <span class="number">1</span>] = num2[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(num1.size() + num2.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> len = num2.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (num2.<span class="built_in">size</span>() &gt; num1.<span class="built_in">size</span>()) len = num1.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">c[i]+= a[i] + b[i];</span><br><span class="line">c[i + <span class="number">1</span>] += c[i] / <span class="number">10</span>;</span><br><span class="line">c[i] %= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//位数较长的数平移加上对应位置的c[i]</span></span><br><span class="line"><span class="keyword">if</span> (num1.<span class="built_in">size</span>() &gt; num2.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; num1.<span class="built_in">size</span>(); i++)</span><br><span class="line">c[i] += a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (num1.<span class="built_in">size</span>() &lt; num2.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; num2.<span class="built_in">size</span>(); i++)</span><br><span class="line">c[i] += b[i];</span><br><span class="line">&#125;</span><br><span class="line">    len = num1.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (num2.<span class="built_in">size</span>() &gt; num1.<span class="built_in">size</span>()) len = num2.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span> (c[len] == <span class="number">0</span>)<span class="comment">//去除前导0</span></span><br><span class="line">&#123;</span><br><span class="line">len--;</span><br><span class="line">&#125;</span><br><span class="line">string ans = <span class="built_in">vector2string</span>(c, len + <span class="number">1</span>);<span class="comment">//转换为string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习">练习</h3><p><a href="https://leetcode.cn/problems/add-strings/submissions/504061261/">力扣 字符串加法</a></p><h2 id="大数减法">大数减法</h2><h3 id="课程-1">课程</h3><p><a href="https://www.bilibili.com/video/BV1kb4y1A7Wf/?spm_id_from=333.788&amp;vd_source=9a4fe569cfdfb26138828e9c87e1512d">b站</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">divide</span><span class="params">(string&amp; num1, string&amp; num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> flag = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (num1.<span class="built_in">size</span>() &lt; num2.<span class="built_in">size</span>() || (num1.<span class="built_in">size</span>() == num2.<span class="built_in">size</span>() &amp;&amp; num1 &lt; num2))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(num1, num2);</span><br><span class="line">flag = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(num1.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(num2.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num1.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">a[num1.<span class="built_in">size</span>() - i - <span class="number">1</span>] = num1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num2.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">b[num2.<span class="built_in">size</span>() - i - <span class="number">1</span>] = num2[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(num1.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> len = num2.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt; b[i])</span><br><span class="line">&#123;</span><br><span class="line">a[i] += <span class="number">10</span>;</span><br><span class="line">a[i + <span class="number">1</span>]--;</span><br><span class="line">&#125;</span><br><span class="line">c[i] += a[i] - b[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; num1.<span class="built_in">size</span>(); i++)</span><br><span class="line">c[i] += a[i];</span><br><span class="line">len=c.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (c[len] == <span class="number">0</span>)</span><br><span class="line">len--;</span><br><span class="line"></span><br><span class="line">string ans;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans = <span class="built_in">vector2string</span>(c, len + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ans = <span class="built_in">vector2string</span>(c, len + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大数乘法">大数乘法</h2><p><a href="https://www.bilibili.com/video/BV1LA411v7mt?p=3&amp;vd_source=9a4fe569cfdfb26138828e9c87e1512d">b站 高精度算法</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">mulity</span><span class="params">(string&amp; num1, string&amp; num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(num1.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(num2.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(num1.size() + num2.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= num1.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">a[num1.<span class="built_in">size</span>() - i] = num1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= num2.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">b[num2.<span class="built_in">size</span>() - i] = num2[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= num2.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= num1.<span class="built_in">size</span>(); j++)</span><br><span class="line">&#123;</span><br><span class="line">c[i + j - <span class="number">1</span>] += b[i] * a[j];</span><br><span class="line">c[i + j] += c[i + j - <span class="number">1</span>] / <span class="number">10</span>;</span><br><span class="line">c[i + j - <span class="number">1</span>] %= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> len = c.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (c[len] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">len--;</span><br><span class="line">&#125;</span><br><span class="line">string ans = <span class="built_in">vector2string</span>(c, len + <span class="number">1</span>);</span><br><span class="line">ans = ans.<span class="built_in">substr</span>(<span class="number">0</span>, ans.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态规划dp">动态规划（dp）</h1><p>暴力dfs-&gt;记忆化搜索--&gt;递推（dp）</p><p>记忆化搜索 = 暴力dfs+记录答案</p><p>递推的公式 = dfs向下递归的公式</p><p>dp的重点在于状态转移方程，即从树的最下层向上归的过程</p><p><a href="https://www.acwing.com/file_system/file/content/whole/index/content/10768518/">跳楼梯</a></p><p><a href="https://acm.cjlu.edu.cn/problem/3641">大盗阿福</a></p><h2 id="背包问题">背包问题</h2><ul><li><p>状态表示</p></li><li><p>状态计算</p><figure><img src="image-20240315092802200.png" alt="image-20240315092802200" /><figcaption aria-hidden="true">image-20240315092802200</figcaption></figure><figure><img src="image-20240315093548155.png" alt="image-20240315093548155" /><figcaption aria-hidden="true">image-20240315093548155</figcaption></figure></li></ul><p>注意：右边的子集不一定存在只有 当 j &gt;= v[i]的时候才存在</p><p>之后转化为一维</p><h3 id="背包问题-1">0-1背包问题</h3><blockquote><p>已知一个背包容积为V，现在有N个物品，每个物品有一个价值Wi，一个体积Vi，每件物品最多用一次，求可以选择的总价值最大。</p></blockquote><h3 id="完全背包问题">完全背包问题</h3><p>每件物品有无限个</p><h3 id="多重背包问题">多重背包问题</h3><p>每个物品有有限个</p><h3 id="分组背包问题">分组背包问题</h3><p>每一组最多选择一个物品</p>]]></content>
    
    
    <summary type="html">蓝桥杯学习记录</summary>
    
    
    
    <category term="算法" scheme="https://klklkl10086.github.io/klklkl10086.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="蓝桥杯" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>Python基础知识</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2024/01/14/Python/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2024/01/14/Python/</id>
    <published>2024-01-14T07:15:19.000Z</published>
    <updated>2024-11-14T13:18:52.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本知识">基本知识</h1><h2 id="字面量">字面量</h2><blockquote><p>在代码中，被写下来的固定的值</p></blockquote><p><strong>常见的字面量数据类型</strong></p><ul><li>数字 整数 浮点数 复数 布尔</li><li>字符串 双引号包围 "字符串"</li><li>列表</li><li>元组</li><li>集合</li><li>字典</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字面量（有空格）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)<span class="comment">#字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">12</span>) <span class="comment">#整数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1.0</span>) <span class="comment">#浮点数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;钱包还有:&quot;</span>, money, <span class="string">&quot;收了一块钱还剩:&quot;</span>, money+<span class="number">1</span>) <span class="comment"># 输出多个变量</span></span><br></pre></td></tr></table></figure><p>写在print语句中的是字面量</p><h2 id="注释">注释</h2><p><strong>单行注释</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我是单行注释（建议有空格）</span></span><br></pre></td></tr></table></figure><p><strong>多行注释</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;我是多行注释一般用于开头解释类和程序</span></span><br><span class="line"><span class="string">三个引号开头，三个引号结尾，可以换行</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="变量">变量</h2><blockquote><p>记录数据的盒子,值可以改变</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变量名 = 变量值</span></span><br><span class="line">money = <span class="number">52</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;钱包还有:&quot;</span>, money, <span class="string">&quot;\n收了一块钱还剩:&quot;</span>, money+<span class="number">1</span>)</span><br><span class="line">money = money-<span class="number">10</span> <span class="comment">#  + -  *  /</span></span><br></pre></td></tr></table></figure><h2 id="数据类型">数据类型</h2><blockquote><p>变量没有类型，<strong>变量中存储的数据</strong>有类型</p></blockquote><p><strong>type()语句</strong></p><blockquote><p>用于查看<strong>数据</strong>的类型的函数</p></blockquote><p><strong>使用print直接输出</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="string">&quot;str&quot;</span>))</span><br><span class="line">money = <span class="number">52</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(money))</span><br></pre></td></tr></table></figure><p><strong>用变量存储返回的结果</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str_type = (<span class="built_in">type</span>(<span class="string">&quot;123456&quot;</span>))</span><br><span class="line">money = <span class="number">52</span></span><br><span class="line">money_type = (<span class="built_in">type</span>(money))</span><br></pre></td></tr></table></figure><p><strong>数据类型的转换</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转为整数</span></span><br><span class="line"><span class="built_in">int</span>(x) </span><br><span class="line">num = <span class="built_in">int</span>(<span class="string">&quot;11&quot;</span>)<span class="comment"># 保字符串里都是数字</span></span><br><span class="line">int_float = <span class="built_in">int</span>(<span class="number">11.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转为浮点</span></span><br><span class="line"><span class="built_in">float</span>(x)</span><br><span class="line">float_int = <span class="built_in">float</span>(<span class="number">11</span>)</span><br><span class="line"><span class="comment"># 转为字符串</span></span><br><span class="line"><span class="built_in">str</span>(x)</span><br><span class="line">float_str = <span class="built_in">str</span>(<span class="number">111.34</span>)</span><br></pre></td></tr></table></figure><blockquote><p>任何语句都可转换成字符串</p></blockquote><h2 id="标识符">标识符</h2><blockquote><p><strong>名字</strong></p></blockquote><p><strong>命名规则</strong></p><ul><li>英文 大小写敏感</li><li>中文 不推荐使用</li><li>数字 不可以作为开头</li><li>下划线 _<br /></li><li>不可以使用关键字</li></ul><h2 id="运算符">运算符</h2><p><strong>数学运算符</strong></p><table><thead><tr class="header"><th style="text-align: center;">运算符</th><th style="text-align: center;">操作</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">+</td><td style="text-align: center;">加法</td></tr><tr class="even"><td style="text-align: center;">-</td><td style="text-align: center;">减法</td></tr><tr class="odd"><td style="text-align: center;">*</td><td style="text-align: center;">乘法</td></tr><tr class="even"><td style="text-align: center;">/</td><td style="text-align: center;">除法</td></tr><tr class="odd"><td style="text-align: center;">//</td><td style="text-align: center;">取整除</td></tr><tr class="even"><td style="text-align: center;">%</td><td style="text-align: center;">取余数</td></tr><tr class="odd"><td style="text-align: center;">**</td><td style="text-align: center;">指数</td></tr></tbody></table><p><strong>赋值运算符</strong></p><table><thead><tr class="header"><th style="text-align: center;">运算符</th><th style="text-align: center;">操作</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">=</td><td style="text-align: center;">赋值</td></tr></tbody></table><p><strong>复合赋值运算符</strong></p><table><thead><tr class="header"><th style="text-align: center;">运算符</th><th style="text-align: center;">操作</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">+=</td><td style="text-align: center;">c+=a 等价于 c=c+a</td></tr><tr class="even"><td style="text-align: center;">-=</td><td style="text-align: center;">c-=a 等价于 c=c-a</td></tr><tr class="odd"><td style="text-align: center;">*=</td><td style="text-align: center;">c*=a 等价于 c=c*a</td></tr><tr class="even"><td style="text-align: center;">/=</td><td style="text-align: center;">c/=a 等价于 c=c/a</td></tr><tr class="odd"><td style="text-align: center;">%=</td><td style="text-align: center;">c%=a 等价于 c=c%a</td></tr><tr class="even"><td style="text-align: center;">**=</td><td style="text-align: center;">c**=a 等价于 c=c **a</td></tr><tr class="odd"><td style="text-align: center;">//=</td><td style="text-align: center;">c//=a 等价于 c=c//a</td></tr></tbody></table><h2 id="字符串">字符串</h2><p><strong>定义</strong></p><ul><li><p>单引号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="string">&#x27;hhhh&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>可以内含双引号</strong></p></li><li><p>双引号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name2 = <span class="string">&quot;hhhhhh2&quot;</span></span><br></pre></td></tr></table></figure><p><strong>可以内含单引号</strong></p></li><li><p>三引号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和多行注释一样</span></span><br><span class="line">name3 = <span class="string">&quot;&quot;&quot;hhhhh</span></span><br><span class="line"><span class="string">hhh3&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>可以用  解除效用 变成普通字符串</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;&quot;123456&#x27;</span></span><br><span class="line">name = <span class="string">&quot;&#x27;12345&#x27;&quot;</span></span><br><span class="line">name = <span class="string">&quot;\&quot;123456&quot;</span></span><br></pre></td></tr></table></figure><p><strong>字符串拼接</strong></p><blockquote><p>使用+号</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>+<span class="string">&quot;456&quot;</span>)</span><br><span class="line">name = <span class="string">&quot;987&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;12345&quot;</span> + name + <span class="string">&quot;564&quot;</span>)</span><br><span class="line">tel = <span class="number">132456</span></span><br><span class="line"><span class="comment"># print(&quot;111111&quot; + tel +&quot;454&quot;) error</span></span><br></pre></td></tr></table></figure><p><strong>字符串没有办法和其他类型拼接</strong></p><p><strong>字符串格式化</strong></p><p><strong>方法一：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;kjkjk&quot;</span></span><br><span class="line">where = <span class="string">&quot;at kl&quot;</span></span><br><span class="line">message = <span class="string">&quot;abced %s %s&quot;</span> % (name, where)</span><br><span class="line"><span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出： abced kjkjk at kl</span></span><br></pre></td></tr></table></figure><p><strong>通过占位的形式完成拼接，%表示占位，s表示将变量变成字符串放入占位的地方</strong></p><table><thead><tr class="header"><th>格式符号</th><th>转化</th></tr></thead><tbody><tr class="odd"><td>%s</td><td>转化为<strong>字符串</strong>放入占位位置</td></tr><tr class="even"><td>%d</td><td>转化为<strong>整数</strong>放入占位位置</td></tr><tr class="odd"><td>%f</td><td>转化为<strong>浮点</strong>放入占位位置</td></tr></tbody></table><p><strong>方法二:</strong></p><p><strong>不限数据类型，不做精度控制，适合对精度没有要求时快速使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">f&quot;...<span class="subst">&#123;变量&#125;</span> &quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num1=<span class="number">11</span></span><br><span class="line">name = <span class="string">&quot;klklklk&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;my name is <span class="subst">&#123;name&#125;</span> ,and age is <span class="subst">&#123;num1&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">my name is klklklk ,and age is 11</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>格式化的精度控制</strong></p><blockquote><p>m.n 控制数度的宽度和精度，m控制宽度，<strong>但当宽度小于自身时不生效</strong>，n控制精度会进行<strong>四舍五入</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">num1=<span class="number">11</span></span><br><span class="line">num2=<span class="number">11.345</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数字11宽度5：%5d\n&quot;</span> % num1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数字11宽度1：%1d\n&quot;</span> % num1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数字11.345宽度7，精度2：%7.2f\n&quot;</span> % num2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数字11.345宽度不限，精度2: %.2f&quot;</span> % num2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数字11.345精度不限，宽度2: %2f&quot;</span> % num2)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">数字11宽度5：   11</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">数字11宽度1：11</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">数字11.345宽度7，精度2：  11.35</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">数字11.345宽度不限，精度2: 11.35</span></span><br><span class="line"><span class="string">数字11.345精度不限，宽度2: 11.345000</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>表达式格式化</strong></p><blockquote><p>表达式：一条具有明确执行结果的代码语句</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1 * 1 = %d&quot;</span> % (<span class="number">1</span>*<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;1 * 2 = <span class="subst">&#123;<span class="number">1</span>*<span class="number">2</span>&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;字符串在python的类型名是：%s&quot;</span> % <span class="built_in">type</span>(<span class="string">&quot;字符串&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出:</span></span><br><span class="line"><span class="string">1 * 1 = 1</span></span><br><span class="line"><span class="string">1 * 2 = 2</span></span><br><span class="line"><span class="string">字符串在python的类型名是：&lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="数据输入">数据输入</h2><p><strong>input语句</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;what is your name?&quot;</span>)</span><br><span class="line">name = <span class="built_in">input</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;you name is <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;what is your name?\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;you name is <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>input语句不管输入什么都统统当作字符串看待，可自行进行数据转换</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="built_in">input</span>(<span class="string">&quot;what is your age?\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;age is&quot;</span>, <span class="built_in">type</span>(age))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">what is your age?</span></span><br><span class="line"><span class="string"> 输入： 18</span></span><br><span class="line"><span class="string">age is &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="判断语句">判断语句</h1><h2 id="布尔类型和比较运算符">布尔类型和比较运算符</h2><p>布尔类型的字面量：</p><p>True ：表示真</p><p>False：表示假</p><p>比较运算符：</p><blockquote><p>== , &gt; , &lt; , &gt;= ,&lt;= ,!=</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool_1 = <span class="literal">True</span></span><br><span class="line">bool_2 = <span class="literal">False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;bool1 is<span class="subst">&#123;<span class="built_in">type</span>(bool_1)&#125;</span>,bool2 is <span class="subst">&#123;<span class="built_in">type</span>(bool_2)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">bool1 is&lt;class &#x27;bool&#x27;&gt;,bool2 is &lt;class &#x27;bool&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">num1 = <span class="number">10</span></span><br><span class="line">num2 = <span class="number">10</span></span><br><span class="line">num3 = <span class="number">15</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;num1 == num2 is <span class="subst">&#123;num1 == num2&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;num1 != num3 is <span class="subst">&#123;num1 != num3&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">num1 == num2 is True</span></span><br><span class="line"><span class="string">num1 != num3 is True</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>字符串也可以进行 == ，! = 比较</strong></p><h2 id="if语句">if语句</h2><p>if [条件] ：</p><p>​ 条件成立时执行的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">18</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;my age is <span class="subst">&#123;age&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i am a adult&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i will go to university&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;time fly quickly!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">my age is 18</span></span><br><span class="line"><span class="string">i am a adult</span></span><br><span class="line"><span class="string">i will go to university</span></span><br><span class="line"><span class="string">time fly quickly!</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>缩进！！！</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;my age is <span class="subst">&#123;age&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i am a adult&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i will go to university&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;time fly quickly!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">my age is 10</span></span><br><span class="line"><span class="string">time fly quickly!</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="if-else语句">if else语句</h2><blockquote><p>if 条件：</p><p>​ 条件成立时执行的内容</p><p>else：</p><p>​ 条件不满足时执行的内容</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;my age is <span class="subst">&#123;age&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i am a adult.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i will go to university.&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i am a child.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i am going to senior high school.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;time fly quickly!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">my age is 10</span></span><br><span class="line"><span class="string">i am a child.</span></span><br><span class="line"><span class="string">i am going to senior high school.</span></span><br><span class="line"><span class="string">time fly quickly!</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="if-elif-else语句">if elif else语句</h2><blockquote><p>if 条件：</p><p>​  条件1成立时执行的内容</p><p>elif 条件2:</p><p>     条件2成立时执行的内容</p><p>elif 条件n：      条件 n成立时执行的内容</p><p>else：</p><p>​ 上述条件都不满足时执行的内容</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">height = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你的身高（cm）：&quot;</span>))</span><br><span class="line">vip_level = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;您的vip等级是：&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> height&lt;<span class="number">120</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;小于120cm 可以免费&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> vip_level&gt;<span class="number">3</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;vip&gt;3 可以免费&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;收费10元&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>多条件判断下，条件互斥，只要有一个条件满足，则其他条件不成立，语句不执行</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你的身高（cm）：&quot;</span>))&lt;<span class="number">120</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;小于120cm 可以免费&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;您的vip等级是：&quot;</span>))&gt;<span class="number">3</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;vip&gt;3 可以免费&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;收费10元&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="判断语句的嵌套">判断语句的嵌套</h2><blockquote><p>if 条件1:</p><p>​ 条件1成立时执行的内容</p><p>​ 条件1成立时执行的内容</p><p>​ if 条件2:</p><p>​ 条件2成立时执行的内容</p><p>​ 条件2成立时执行的内容</p></blockquote><p>not表示取反</p><h1 id="循环语句">循环语句</h1><h2 id="while循环">while循环</h2><blockquote><p>while 条件: 条件满足要做的事情1</p><p>​ 条件满足要做的事情2</p><p>​ 条件满足要做的事情3</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i&lt;<span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;this is %d&quot;</span>% i)</span><br><span class="line">    i= i+<span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="built_in">sum</span>=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i&lt;=<span class="number">100</span>:</span><br><span class="line">    <span class="built_in">sum</span>+=i</span><br><span class="line">    i= i+<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sum=%d&quot;</span>%<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure><p>小脚本：</p><p>猜数字，猜错判断大于小于，猜对输出猜的次数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">num = random.randint(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">flag = <span class="literal">True</span></span><br><span class="line"><span class="keyword">while</span> flag:</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">    guess_num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;what is it?&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> guess_num == num:</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;you are right&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> guess_num &gt; num:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;you are bigger&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;you are smaller&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;the times is <span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>嵌套</strong></p><blockquote><p>while 条件1: 条件1满足要做的事情1</p><p>​ 条件1满足要做的事情2</p><p>​ 条件1满足要做的事情3</p><p>​ .....</p><p>​ while 条件2: ​ 条件2满足要做的事情1</p><p>​ 条件2满足要做的事情2</p><p>​ 条件2满足要做的事情3</p><p>​ .....</p></blockquote><p>小脚本：</p><p>打印九九乘法表</p><p>前置知识：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#print输出如何不换行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lh = <span class="number">1</span></span><br><span class="line">rh = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> rh&lt;=<span class="number">9</span>:</span><br><span class="line">    lh=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> lh&lt;=rh:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%d * %d = %d &quot;</span>%(lh,rh,lh*rh), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        lh+=<span class="number">1</span></span><br><span class="line">    rh+=<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>()<span class="comment">#输出空内容 换行</span></span><br></pre></td></tr></table></figure><h2 id="for循环">for循环</h2><blockquote><p>for <strong>临时变量</strong> in 待处理的数据集:</p><p>​ 循环条件满足时候执行的代码</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;abcdefg&quot;</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> name:</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">b</span></span><br><span class="line"><span class="string">c</span></span><br><span class="line"><span class="string">d</span></span><br><span class="line"><span class="string">e</span></span><br><span class="line"><span class="string">f</span></span><br><span class="line"><span class="string">g</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>无法自定义无限循环，数据集不可能无限大</strong></p><p>小脚本： 统计字符串中有多少个字母a</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>(<span class="string">&quot;please input your str&quot;</span>)</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">if</span> x == <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure><p><strong>tips:</strong></p><blockquote><p>关于临时变量的作用范围，规范上，临时变量是不能在<strong>for循环外部</strong>进行访问，但是实际上，是可以访问到的</p></blockquote><p><strong>range语句</strong></p><p>获得一个数字序列，搭配for循环食用</p><blockquote><p>range(num)</p><p>获取一个从0 开始到num结束的数字序列（不包含num本身）</p></blockquote><blockquote><p>range(num1，num2)</p><p>获取一个从num1开始到num2结束的数字序列（不包含num2本身）</p></blockquote><blockquote><p>range(num1，num2，step)</p><p>获取一个从num1开始到num2结束的数字序列（不包含num2本身）,数字间的步长以step为标准，step默认为1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">8</span>):</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">5</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">7</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">8</span>,<span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>for循环嵌套</strong></p><blockquote><p>控制空格缩进</p><p>for <strong>临时变量1</strong> in 待处理的数据集:</p><p>​ 循环条件1满足时候执行的代码</p><p>​ for <strong>临时变量2</strong> in 待处理的数据集:</p><p>​ 循环条件2满足时候执行的代码</p></blockquote><p><strong>for循环和while循环可以互向嵌套</strong></p><p>小脚本： 使用for循环打印九九乘法表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> rh <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> lh <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,rh+<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;lh&#125;</span>*<span class="subst">&#123;rh&#125;</span>=<span class="subst">&#123;lh*rh&#125;</span>\t&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><h2 id="循环中断">循环中断</h2><p><strong>continue</strong></p><blockquote><p>中断所在本层循环，直接进入下一次循环</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">100</span>):</span><br><span class="line">语句<span class="number">1</span></span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">    语句<span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>跳过语句2，不执行</p><p><strong>break</strong></p><blockquote><p>直接结束所在本层循环</p></blockquote><h1 id="函数">函数</h1><p>封装特定功能，实现接口，避免重复性劳动，可以重复使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 内置函数 统计字符串长度</span></span><br><span class="line"><span class="built_in">len</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义函数 实现统计字符串长度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my</span> _<span class="built_in">len</span>(data):</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">        dount+=<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;字符串<span class="subst">&#123;data&#125;</span>的长度是:<span class="subst">&#123;count&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="定义">定义</h2><blockquote><p>def 函数名字(传入参数)<strong>:</strong></p><p>​ 函数体</p><p>​ return 返回值</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say_hi</span>():<span class="comment"># 可以没有传入参数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hi i am klklkl&quot;</span>)</span><br><span class="line">    <span class="comment">#可以没有返回值</span></span><br></pre></td></tr></table></figure><p>先定义，再使用，在程序中调用函数才可以进行工作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say_hi</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hi i am klklkl&quot;</span>)</span><br><span class="line">    </span><br><span class="line">say_hi()</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">hi i am klklkl</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x,y</span>):</span><br><span class="line"><span class="keyword">return</span> x+y</span><br><span class="line">add(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">9</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>上述例子中，x和y是形式参数，4和5是实际参数</p><p>没有返回值，则返回值类型为NoneType，表示空，无意义，false</p><p><strong>None的应用</strong></p><ul><li><p>函数的返回值</p></li><li><p>if判断语句</p></li><li><p>声明无初始内容的变量</p></li></ul><p>函数可以嵌套调用，过程类似于栈</p><h2 id="多个返回值">多个返回值</h2><p>python的函数可以实现一次性返回多个值</p><blockquote><p>return 返回值1，返回值2</p><p>变量1，变量2 = 函数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x-<span class="number">1</span>,y+<span class="number">1</span></span><br><span class="line">res1,res2 = test1(<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(res1)</span><br><span class="line"><span class="built_in">print</span>(res2)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">-1</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="传入参数">传入参数</h2><h3 id="位置参数">位置参数</h3><figure><img src="image-20240124000603415.png" alt="image-20240124000603415" /><figcaption aria-hidden="true">image-20240124000603415</figcaption></figure><h3 id="关键字参数">关键字参数</h3><figure><img src="image-20240124000631318.png" alt="image-20240124000631318" /><figcaption aria-hidden="true">image-20240124000631318</figcaption></figure><h3 id="缺省参数">缺省参数</h3><figure><img src="image-20240124000828120.png" alt="image-20240124000828120" /><figcaption aria-hidden="true">image-20240124000828120</figcaption></figure><h3 id="不定长参数">不定长参数</h3><p><strong>位置传递的不定长</strong></p><figure><img src="image-20240124001036657.png" alt="image-20240124001036657" /><figcaption aria-hidden="true">image-20240124001036657</figcaption></figure><p><strong>关键字传递</strong></p><figure><img src="image-20240124001119731.png" alt="image-20240124001119731" /><figcaption aria-hidden="true">image-20240124001119731</figcaption></figure><h3 id="函数作为参数传递">函数作为参数传递</h3><figure><img src="image-20240124001429469.png" alt="image-20240124001429469" /><figcaption aria-hidden="true">image-20240124001429469</figcaption></figure><p>传递的是计算逻辑</p><h2 id="匿名函数">匿名函数</h2><figure><img src="image-20240124001931614.png" alt="image-20240124001931614" /><figcaption aria-hidden="true">image-20240124001931614</figcaption></figure><blockquote><p>lambda 传入参数: 函数体（只能有一行代码）</p></blockquote><figure><img src="image-20240124002113484.png" alt="image-20240124002113484" /><figcaption aria-hidden="true">image-20240124002113484</figcaption></figure><figure><img src="image-20240124002424908.png" alt="image-20240124002424908" /><figcaption aria-hidden="true">image-20240124002424908</figcaption></figure><h1 id="数据容器">数据容器</h1><blockquote><p>一种可以容纳多份数据的数据类型</p></blockquote><p>根据特点的不同可以划分为</p><ul><li>列表</li><li>元组</li><li>字符串</li><li>集合</li><li>字典</li></ul><h2 id="列表list">列表（list）</h2><h3 id="定义-1">定义</h3><blockquote><p>变量名 = [元素1,元素2,....]</p></blockquote><p><strong>空列表：</strong></p><blockquote><p>变量名 = []</p><p>变量名 = list()</p></blockquote><p><strong>列表中的每个数据叫作元素</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">name_list = [<span class="string">&quot;name1&quot;</span>, <span class="string">&quot;name2&quot;</span>, <span class="string">&quot;name3&quot;</span>]</span><br><span class="line">com_list = [<span class="string">&quot;name1&quot;</span>, <span class="number">14</span>, <span class="number">2004</span>]</span><br><span class="line">none_list = []</span><br><span class="line"><span class="built_in">print</span>(name_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(name_list))</span><br><span class="line"><span class="built_in">print</span>(com_list)</span><br><span class="line"><span class="built_in">print</span>(none_list)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[&#x27;name1&#x27;, &#x27;name2&#x27;, &#x27;name3&#x27;]</span></span><br><span class="line"><span class="string">&lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line"><span class="string">[&#x27;name1&#x27;, 14, 2004]</span></span><br><span class="line"><span class="string">[]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>也可以嵌套列表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_list = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(my_list))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[[1, 2, 3], [4, 5, 6], [7, 8, 9]]</span></span><br><span class="line"><span class="string">&lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="元素索引">元素索引</h3><blockquote><p>利用下标索引进行取用</p><p>正向：从左到右，从前向后，从0开始，依次递增</p><p>负向：从右向左，从后向前，从-1开始，依次递减</p><p>不可以超出范围</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">0</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">zhangsan</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(my_list[-<span class="number">1</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">wangwu</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>嵌套列表</strong></p><blockquote><p>多层下标索引即可遍历,不可以超出范围</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">my_list = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">0</span>][<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(my_list[-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(my_list[-<span class="number">2</span>][-<span class="number">1</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">8</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="常用方法">常用方法</h3><blockquote><p>class中的内置函数</p></blockquote><h4 id="查询">查询</h4><blockquote><p>查询指定元素在列表中的下标(正向索引)，如果找不到就报错</p><p>列表.index(元素)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_list = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">index = my_list.index([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(index)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="修改">修改</h4><blockquote><p>修改指定下标位置的值</p><p>列表[下标] = 值</p><p>可以正向，也可以反向</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">0</span>])</span><br><span class="line">my_list[<span class="number">0</span>] = <span class="string">&quot;zhangsi&quot;</span></span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">0</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">zhangsan</span></span><br><span class="line"><span class="string">zhangsi</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="插入">插入</h4><blockquote><p>在指定下标索引位置插入指定元素</p><p>列表.insert(下标,元素)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>]</span><br><span class="line">my_list.insert(<span class="number">2</span>, <span class="string">&quot;zhaoliu&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[&#x27;zhangsan&#x27;, &#x27;lisi&#x27;, &#x27;zhaoliu&#x27;, &#x27;wangwu&#x27;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="追加">追加</h4><blockquote><p>在列表尾部添加元素</p></blockquote><p><strong>追加一个元素：</strong></p><blockquote><p>列表.append(元素)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>]</span><br><span class="line">my_list.append(<span class="number">1234</span>)</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[&#x27;zhangsan&#x27;, &#x27;lisi&#x27;, &#x27;wangwu&#x27;, 1234]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>]</span><br><span class="line">new_list = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">my_list.append(new_list)</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[&#x27;zhangsan&#x27;, &#x27;lisi&#x27;, &#x27;wangwu&#x27;, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>追加一批元素（新的列表）：</strong></p><blockquote><p>列表1.extend(列表2)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>]</span><br><span class="line">new_list = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">my_list.extend(new_list)</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[&#x27;zhangsan&#x27;, &#x27;lisi&#x27;, &#x27;wangwu&#x27;, [1, 2, 3], [4, 5, 6], [7, 8, 9]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="删除">删除</h4><blockquote><p>del列表[下标]</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>]</span><br><span class="line"><span class="keyword">del</span> my_list[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[&#x27;zhangsan&#x27;, &#x27;wangwu&#x27;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>列表.pop(下标)</p><p>会返回对应下标的元素内容</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(my_list.pop(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">wangwu</span></span><br><span class="line"><span class="string">[&#x27;zhangsan&#x27;, &#x27;lisi&#x27;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>删除某元素在列表中的第一个匹配项</strong></p><blockquote><p>列表.remove(元素)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>]</span><br><span class="line">my_list.remove(<span class="string">&quot;zhangsan&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[&#x27;lisi&#x27;, &#x27;wangwu&#x27;, &#x27;zhangsan&#x27;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>清空</strong></p><blockquote><p>列表.clear()</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>]</span><br><span class="line">my_list.clear()</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>统计元素个数</strong></p><blockquote><p>统计指定元素在列表中的个数</p><p>列表.count(元素)</p><p>返回值即为数量</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(my_list.count(<span class="string">&quot;zhangsan&quot;</span>))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>列表元素的数量</strong></p><blockquote><p>len(列表)</p><p>返回值即为数量</p><p>不是list内部的函数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(my_list))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="特点">特点</h3><ol type="1"><li><strong>列表有上限，但上限很大</strong></li><li><strong>可以容纳不同类型的元素</strong></li><li><strong>数据有序存储</strong></li><li><strong>允许重复数据存在</strong></li><li><strong>可以修改</strong></li></ol><h3 id="循环遍历">循环遍历</h3><p><strong>while循环遍历</strong></p><p><strong>下标索引</strong>的方式进行取用元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>]</span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> index&lt;<span class="built_in">len</span>(my_list):</span><br><span class="line">    x = my_list[index]</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">zhangsan</span></span><br><span class="line"><span class="string">lisi</span></span><br><span class="line"><span class="string">wangwu</span></span><br><span class="line"><span class="string">zhangsan</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>for循环遍历</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> my_list:</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">zhangsan</span></span><br><span class="line"><span class="string">lisi</span></span><br><span class="line"><span class="string">wangwu</span></span><br><span class="line"><span class="string">zhangsan</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="元组">元组</h2><blockquote><p>可以存储多个不同类型的元素，但是<strong>不可以修改</strong></p></blockquote><h3 id="定义-2">定义</h3><blockquote><p>变量 = (元素,元素,元素, ....)</p></blockquote><p>空元组：</p><blockquote><p>变量 = ()</p><p>变量 = tuple()</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">t1 = (<span class="number">1</span>,<span class="string">&quot;hello&quot;</span>,<span class="literal">True</span>)</span><br><span class="line">t2 = ()</span><br><span class="line">t3 = <span class="built_in">tuple</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t1=<span class="subst">&#123;t1&#125;</span>,type= <span class="subst">&#123;<span class="built_in">type</span>(t1)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t2=<span class="subst">&#123;t2&#125;</span>,type= <span class="subst">&#123;<span class="built_in">type</span>(t2)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t3=<span class="subst">&#123;t3&#125;</span>,type= <span class="subst">&#123;<span class="built_in">type</span>(t3)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">t1=(1, &#x27;hello&#x27;, True),type= &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="string">t2=(),type= &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="string">t3=&lt;class &#x27;tuple&#x27;&gt;,type= &lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t4= (<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t4=<span class="subst">&#123;t4&#125;</span>,type= <span class="subst">&#123;<span class="built_in">type</span>(t4)&#125;</span>&quot;</span>)</span><br><span class="line">t5= (<span class="string">&quot;hello,&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t5=<span class="subst">&#123;t5&#125;</span>,type= <span class="subst">&#123;<span class="built_in">type</span>(t5)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">t4=hello,type= &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="string">t5=(&#x27;hello&#x27;,),type= &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>当元组中<strong>只有一个元素</strong>的时候要求在其后<strong>写上一个逗号</strong>否则不是元组</p><h3 id="嵌套元组">嵌套元组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t6= ((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t5=<span class="subst">&#123;t6&#125;</span>,type= <span class="subst">&#123;<span class="built_in">type</span>(t6)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">t5=((1, 2, 3), (4, 5, 6), (7, 8)),type= &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="下标索引">下标索引</h3><p>和list一样，元组也可以通过下标索引进行取用元素，写法相同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t6= ((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(t6[<span class="number">1</span>][<span class="number">2</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="相关操作">相关操作</h3><h4 id="查找指定元素">查找指定元素</h4><p>查找并返回指定元素的下标</p><blockquote><p>元组. index(x)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t6= ((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(t6.index((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="统计元素个数">统计元素个数</h4><p>1.统计并返回元组中<strong>指定元素</strong>的个数</p><blockquote><p>元组.count()</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t6= ((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">7</span>,<span class="number">8</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(t6.count((<span class="number">7</span>,<span class="number">8</span>)))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>2.统计并返回<strong>元组中的元素</strong>个数</p><blockquote><p>len(元组)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t6= ((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">7</span>,<span class="number">8</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(t6))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="遍历">遍历</h4><p><strong>for循环</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t6= ((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">7</span>,<span class="number">8</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> t6:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">(1, 2, 3)</span></span><br><span class="line"><span class="string">(7, 8)</span></span><br><span class="line"><span class="string">(4, 5, 6)</span></span><br><span class="line"><span class="string">(7, 8)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>while循环</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">t6= ((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">7</span>,<span class="number">8</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> index&lt;<span class="built_in">len</span>(t6):</span><br><span class="line">    <span class="built_in">print</span>(t6[index])</span><br><span class="line">    index+=<span class="number">1</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">(1, 2, 3)</span></span><br><span class="line"><span class="string">(7, 8)</span></span><br><span class="line"><span class="string">(4, 5, 6)</span></span><br><span class="line"><span class="string">(7, 8)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>元组里的元素不可以修改，但是在元组里嵌套的list的元素是可以修改的</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t6= ((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">7</span>,<span class="number">8</span>),[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&quot;hello&quot;</span>],(<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(t6[-<span class="number">2</span>])</span><br><span class="line">t6[-<span class="number">2</span>][-<span class="number">1</span>]=<span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(t6[-<span class="number">2</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[1, 2, 3, 4, &#x27;hello&#x27;]</span></span><br><span class="line"><span class="string">[1, 2, 3, 4, &#x27;world&#x27;]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="特点-1">特点</h3><ol type="1"><li><strong>可以容纳不同类型的元素</strong></li><li><strong>数据有序存储</strong></li><li><strong>允许重复数据存在</strong></li><li><strong>不可以修改</strong></li></ol><h2 id="字符串-1">字符串</h2><blockquote><p>字符的容器，一个字符串可以存放任意数量的字符</p></blockquote><p><strong>下标索引在字符串中也可以使用，正向从0开始，负向从-1开始</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;abcdefg&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">g</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>字符串是不可修改的数据容器</strong>，<strong>只读</strong></p><h3 id="常用方法-1">常用方法</h3><h4 id="查找指定元素的下标">查找指定元素的下标</h4><blockquote><p>查找并返回指定元素的下标：字符串.index(x)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;abcdefg&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.index(<span class="string">&quot;bcd&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.index(<span class="string">&quot;g&quot;</span>))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="字符串替换">字符串替换</h4><blockquote><p>将字符串中指定的内容替换成指定内容，并返回替换后新的字符串</p><p><strong>字符串.replace(字符串1,字符串2)</strong> 将字符串1换成2形成新的字符串</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;abcdefg&quot;</span></span><br><span class="line">newstr = <span class="built_in">str</span>.replace(<span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;dcba&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(newstr)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">abcdefg</span></span><br><span class="line"><span class="string">dcbaefg</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="字符串分割">字符串分割</h4><blockquote><p><strong>字符串.split(分隔符字符串)</strong></p></blockquote><blockquote><p>按照指定的分隔符字符串，将字符串划分为多个字符串，并存到列表对象中</p></blockquote><p><strong>字符串本身不变而是得到一个列表对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;hello world i am klklkl&quot;</span></span><br><span class="line">newstr = <span class="built_in">str</span>.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;newstr = <span class="subst">&#123;newstr&#125;</span>,type = <span class="subst">&#123;<span class="built_in">type</span>(newstr)&#125;</span> &quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">hello world i am klklkl</span></span><br><span class="line"><span class="string">newstr = [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;i&#x27;, &#x27;am&#x27;, &#x27;klklkl&#x27;],type = &lt;class &#x27;list&#x27;&gt; </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="规整操作">规整操作</h4><p><strong>去除前后空格</strong></p><blockquote><p>字符串.strip()</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;   hello world i am klklkl  &quot;</span></span><br><span class="line">newstr = <span class="built_in">str</span>.strip()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;newstr = <span class="subst">&#123;newstr&#125;</span> &quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   hello world i am klklkl  </span></span><br><span class="line"><span class="string">newstr = hello world i am klklkl </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>去除前后指定字符串</strong></p><blockquote><p>字符串.strip(字符串) 将传入的字符串划分成小串，只要<strong>头尾</strong>含有就去除</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;12 hello world i am klklkl 21&quot;</span></span><br><span class="line">newstr = <span class="built_in">str</span>.strip(<span class="string">&quot;12&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;newstr = <span class="subst">&#123;newstr&#125;</span> &quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">12 hello world i am klklkl 21</span></span><br><span class="line"><span class="string">newstr =  hello world i am klklkl  </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="统计指定字符串出现的次数">统计指定字符串出现的次数</h4><blockquote><p>字符串.count(字符串)</p></blockquote><h4 id="统计字符串的长度">统计字符串的长度</h4><blockquote><p>len(字符串)</p></blockquote><h4 id="遍历-1">遍历</h4><p><strong>for循环</strong></p><p>同上</p><p><strong>while循环</strong></p><p>同上</p><h3 id="特点-2">特点</h3><ol type="1"><li><strong>只可以存储字符串</strong></li><li><strong>长度有上限，取决于内存大小</strong></li><li><strong>数据有序存储</strong></li><li><strong>允许重复数据存在</strong></li><li><strong>不可以修改</strong></li></ol><h2 id="序列">序列</h2><blockquote><p>内容<strong>连续，有序</strong>，可以<strong>使用下标索引</strong>的一类<strong>数据容器</strong></p></blockquote><blockquote><p>列表、元组、字符串均可以视为序列</p></blockquote><h3 id="切片">切片</h3><blockquote><p>从一个序列中取出一个子序列，形成一个新的序列，不修改原来的序列</p></blockquote><p><strong>语法：</strong></p><blockquote><p><strong>序列[起始下标: 结束下标:步长]</strong></p><p>起始下标：从何处开始，可以留空表示从头</p><p>结束下标：到那里结束，不包含结束下标位置，可以留空表示截去到尾部</p><p>步长：取元素的间隔，默认为1，可以省略不写</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">my_list1 = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">r1 = my_list1[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;r1 = <span class="subst">&#123;r1&#125;</span>&quot;</span>)</span><br><span class="line">my_tuple = (<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">r2 = my_tuple[:]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;r2 = <span class="subst">&#123;r2&#125;</span>&quot;</span>)</span><br><span class="line">my_str = <span class="string">&quot;0123456&quot;</span></span><br><span class="line">r3 = my_str[::<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;r3 = <span class="subst">&#123;r3&#125;</span>&quot;</span>)</span><br><span class="line">r4 = my_str[::-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;r4 = <span class="subst">&#123;r4&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">r1 = [1, 2, 3]</span></span><br><span class="line"><span class="string">r2 = (0, 1, 2, 3, 4, 5, 6)</span></span><br><span class="line"><span class="string">r3 = 0246</span></span><br><span class="line"><span class="string">r4 = 6543210</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="集合">集合</h2><blockquote><p>上述介绍的数据容器：列表、元组、字符串都支持重复元素，而集合<strong>不支持重复元素，顺序无法保证</strong>，自带<strong>去重</strong>功能</p></blockquote><h3 id="定义-3">定义</h3><blockquote><p>变量 = {元素1,元素2,元素3 ,.....}</p></blockquote><p>空集合</p><blockquote><p>变量 = set()</p><p>{}是空字典</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_set = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;my_set=<span class="subst">&#123;my_set&#125;</span>&quot;</span>)</span><br><span class="line">none_set= <span class="built_in">set</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;none_set = <span class="subst">&#123;none_set&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">my_set=&#123;1, 2, 3, 4, 5, 6&#125;</span></span><br><span class="line"><span class="string">none_set = set()</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="常用操作">常用操作</h3><p><strong>不支持下标索引访问，可修改</strong></p><h4 id="添加">添加</h4><blockquote><p>集合.add(元素)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">my_set = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="string">&quot;klklkl&quot;</span>&#125;</span><br><span class="line">my_set.add(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(my_set)</span><br><span class="line">my_set.add(<span class="string">&quot;klklkl&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_set)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;1, 2, 3, 4, 5, 6, 10, &#x27;klklkl&#x27;&#125;</span></span><br><span class="line"><span class="string">&#123;1, 2, 3, 4, 5, 6, 10, &#x27;klklkl&#x27;&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="移除">移除</h4><p><strong>从集合中移除指定元素，同时集合被修改</strong></p><blockquote><p>集合.remove(元素)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my_set = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="string">&quot;klklkl&quot;</span>&#125;</span><br><span class="line">my_set.remove(<span class="string">&quot;klklkl&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_set)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;1, 2, 3, 4, 5, 6&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>从集合中<u>随机取出</u>一个元素，同时集合被修改，返回移除的元素，元素被移除</strong></p><blockquote><p>集合.pop()</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_set = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="string">&quot;klklkl&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(my_set.pop())</span><br><span class="line"><span class="built_in">print</span>(my_set)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">&#123;2, 3, 4, 5, 6, &#x27;klklkl&#x27;&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="清空">清空</h4><blockquote><p>集合.clear()</p></blockquote><h4 id="取差集">取差集</h4><blockquote><p>集合1.differrence(集合2)</p><p>取出集合1和集合2的差集（<strong>集合1有集合2没有的</strong>），返回一个新集合</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">1</span> ,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(set1.difference(set2))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;2, 4&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="去差集">去差集</h4><blockquote><p>集合1.difference_update(集合2)</p><p>消除集合1和集合2内相同的元素，集合1被修改集合2不变</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">1</span> ,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;</span><br><span class="line">set1.difference_update(set2)</span><br><span class="line"><span class="built_in">print</span>(set1)</span><br><span class="line"><span class="built_in">print</span>(set2)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;2, 4&#125;</span></span><br><span class="line"><span class="string">&#123;1, 3, 5, 7&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="集合合并">集合合并</h4><blockquote><p>集合1.union(集合2)</p><p>集合1和2合并成一个新的集合，集合1和2不变</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">1</span> ,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line">set3 = set1.union(set2)</span><br><span class="line"><span class="built_in">print</span>(set1)</span><br><span class="line"><span class="built_in">print</span>(set2)</span><br><span class="line"><span class="built_in">print</span>(set3)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line"><span class="string">&#123;1, 3, 5, 7, 8, 9&#125;</span></span><br><span class="line"><span class="string">&#123;1, 2, 3, 4, 5, 7, 8, 9&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="统计元素数量">统计元素数量</h4><blockquote><p>len(集合)</p></blockquote><h4 id="遍历-2">遍历</h4><p><strong>不支持下标索引，因此不可以用while循环</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set2 = &#123;<span class="number">1</span> ,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> set2:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;集合的元素有 :<span class="subst">&#123;element&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">集合的元素有 :1</span></span><br><span class="line"><span class="string">集合的元素有 :3</span></span><br><span class="line"><span class="string">集合的元素有 :5</span></span><br><span class="line"><span class="string">集合的元素有 :7</span></span><br><span class="line"><span class="string">集合的元素有 :8</span></span><br><span class="line"><span class="string">集合的元素有 :9</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="字典">字典</h2><p>含有两个数据，一个名为key，另一个为Value，字典可以通过key找到与其对应的value</p><p><strong>不允许元素重复，不可以使用下标索引，只可以通过key值取得对应的Value</strong></p><h3 id="定义-4">定义</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">变量 = &#123;key:value , key:value ,....&#125;</span><br><span class="line"><span class="comment">#空字典</span></span><br><span class="line">变量 = &#123;&#125;</span><br><span class="line">变量 = <span class="built_in">dict</span>()</span><br></pre></td></tr></table></figure><p><strong>获取value</strong></p><p>通过key值取得对应的Value</p><blockquote><p>字典.[key]</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dict_1 = &#123;<span class="string">&quot;liming&quot;</span>: <span class="number">56</span>, <span class="string">&quot;wanglikong&quot;</span>: <span class="number">99</span>, <span class="string">&quot;zhoujielin&quot;</span>: <span class="number">88</span>, <span class="string">&quot;lindaju&quot;</span>: <span class="number">77</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(dict_1[<span class="string">&quot;lindaju&quot;</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">77</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>字典的嵌套</strong></p><p><strong>key不能为字典，value可以是任意数据</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">stu_score_date = &#123;</span><br><span class="line">    <span class="string">&quot;wanglihong&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;yuwen&quot;</span>: <span class="number">77</span>,</span><br><span class="line">        <span class="string">&quot;shuxue&quot;</span>:<span class="number">66</span>,</span><br><span class="line">        <span class="string">&quot;yingyu&quot;</span>:<span class="number">99</span></span><br><span class="line">    &#125;,<span class="string">&quot;zhoujielun&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;yuwen&quot;</span>: <span class="number">87</span>,</span><br><span class="line">        <span class="string">&quot;shuxue&quot;</span>:<span class="number">65</span>,</span><br><span class="line">        <span class="string">&quot;yingyu&quot;</span>:<span class="number">89</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(stu_score_date)</span><br><span class="line"><span class="built_in">print</span>(stu_score_date[<span class="string">&quot;zhoujielun&quot;</span>][<span class="string">&quot;shuxue&quot;</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;&#x27;wanglihong&#x27;: &#123;&#x27;yuwen&#x27;: 77, &#x27;shuxue&#x27;: 66, &#x27;yingyu&#x27;: 99&#125;, &#x27;zhoujielun&#x27;: &#123;&#x27;yuwen&#x27;: 87, &#x27;shuxue&#x27;: 65, &#x27;yingyu&#x27;: 89&#125;&#125;</span></span><br><span class="line"><span class="string">65</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="常用操作-1">常用操作</h3><h4 id="增加元素">增加元素</h4><blockquote><p>字典[key] = value</p><p>字典被修改，增加了新元素</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dict_1 = &#123;<span class="string">&quot;liming&quot;</span>: <span class="number">56</span>, <span class="string">&quot;wanglikong&quot;</span>: <span class="number">99</span>, <span class="string">&quot;zhoujielin&quot;</span>: <span class="number">88</span>, <span class="string">&quot;lindaju&quot;</span>: <span class="number">77</span>&#125;</span><br><span class="line">dict_1[<span class="string">&quot;zhangsan&quot;</span>] = <span class="number">88</span></span><br><span class="line"><span class="built_in">print</span>(dict_1)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;&#x27;liming&#x27;: 56, &#x27;wanglikong&#x27;: 99, &#x27;zhoujielin&#x27;: 88, &#x27;lindaju&#x27;: 77, &#x27;zhangsan&#x27;: 88&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="更新元素">更新元素</h4><blockquote><p>字典[key] = value</p><p>字典被修改</p></blockquote><p><strong>如果key存在则为更新，不存在即为修改</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dict_1 = &#123;<span class="string">&quot;liming&quot;</span>: <span class="number">56</span>, <span class="string">&quot;wanglikong&quot;</span>: <span class="number">99</span>, <span class="string">&quot;zhoujielin&quot;</span>: <span class="number">88</span>, <span class="string">&quot;lindaju&quot;</span>: <span class="number">77</span>&#125;</span><br><span class="line">dict_1[<span class="string">&quot;liming&quot;</span>] = <span class="number">88</span></span><br><span class="line"><span class="built_in">print</span>(dict_1)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;&#x27;liming&#x27;: 88, &#x27;wanglikong&#x27;: 99, &#x27;zhoujielin&#x27;: 88, &#x27;lindaju&#x27;: 77&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="删除元素">删除元素</h4><blockquote><p>字典.pop(key)</p><p>删除字典中key的内容，并返回key对应的value</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dict_1 = &#123;<span class="string">&quot;liming&quot;</span>: <span class="number">56</span>, <span class="string">&quot;wanglikong&quot;</span>: <span class="number">99</span>, <span class="string">&quot;zhoujielin&quot;</span>: <span class="number">88</span>, <span class="string">&quot;lindaju&quot;</span>: <span class="number">77</span>&#125;</span><br><span class="line">dict_1.pop(<span class="string">&quot;wanglikong&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(dict_1)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;&#x27;liming&#x27;: 56, &#x27;zhoujielin&#x27;: 88, &#x27;lindaju&#x27;: 77&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="清空元素">清空元素</h4><blockquote><p>字典.clear()</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dict_1 = &#123;<span class="string">&quot;liming&quot;</span>: <span class="number">56</span>, <span class="string">&quot;wanglikong&quot;</span>: <span class="number">99</span>, <span class="string">&quot;zhoujielin&quot;</span>: <span class="number">88</span>, <span class="string">&quot;lindaju&quot;</span>: <span class="number">77</span>&#125;</span><br><span class="line">dict_1.clear()</span><br><span class="line"><span class="built_in">print</span>(dict_1)</span><br></pre></td></tr></table></figure><h4 id="获取全部key">获取全部key</h4><blockquote><p>字典.keys()</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dict_1 = &#123;<span class="string">&quot;liming&quot;</span>: <span class="number">56</span>, <span class="string">&quot;wanglikong&quot;</span>: <span class="number">99</span>, <span class="string">&quot;zhoujielin&quot;</span>: <span class="number">88</span>, <span class="string">&quot;lindaju&quot;</span>: <span class="number">77</span>&#125;</span><br><span class="line">keys=dict_1.keys()</span><br><span class="line"><span class="built_in">print</span>(keys)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">dict_keys([&#x27;liming&#x27;, &#x27;wanglikong&#x27;, &#x27;zhoujielin&#x27;, &#x27;lindaju&#x27;])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="遍历字典">遍历字典</h4><p><strong>方法1:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dict_1 = &#123;<span class="string">&quot;liming&quot;</span>: <span class="number">56</span>, <span class="string">&quot;wanglikong&quot;</span>: <span class="number">99</span>, <span class="string">&quot;zhoujielin&quot;</span>: <span class="number">88</span>, <span class="string">&quot;lindaju&quot;</span>: <span class="number">77</span>&#125;</span><br><span class="line">keys=dict_1.keys()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> keys:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span>对应的键值是<span class="subst">&#123;dict_1[i]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">liming对应的键值是56</span></span><br><span class="line"><span class="string">wanglikong对应的键值是99</span></span><br><span class="line"><span class="string">zhoujielin对应的键值是88</span></span><br><span class="line"><span class="string">lindaju对应的键值是77</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>方法2:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dict_1 = &#123;<span class="string">&quot;liming&quot;</span>: <span class="number">56</span>, <span class="string">&quot;wanglikong&quot;</span>: <span class="number">99</span>, <span class="string">&quot;zhoujielin&quot;</span>: <span class="number">88</span>, <span class="string">&quot;lindaju&quot;</span>: <span class="number">77</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dict_1:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span>对应的键值是<span class="subst">&#123;dict_1[i]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">liming对应的键值是56</span></span><br><span class="line"><span class="string">wanglikong对应的键值是99</span></span><br><span class="line"><span class="string">zhoujielin对应的键值是88</span></span><br><span class="line"><span class="string">lindaju对应的键值是77</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>不支持下标索引，不适用于while循环</strong></p><h4 id="统计元素数量-1">统计元素数量</h4><blockquote><p>len(字典)</p></blockquote><h3 id="特点-3">特点</h3><ol type="1"><li><strong>可以容纳多个数据，容纳不同类型的数据。</strong></li><li><strong>每一份数据是keyvalue键值对</strong></li><li><strong>可以通过key获取value</strong></li><li><strong>不允许重复key存在</strong></li><li><strong>不支持下标索引</strong></li><li><strong>可以修改</strong></li><li><strong>支持for循环不支持while循环</strong></li></ol><h2 id="总结">总结</h2><figure><img src="image-20240123161337038.png" alt="image-20240123161337038" /><figcaption aria-hidden="true">image-20240123161337038</figcaption></figure><figure><img src="image-20240123161352170.png" alt="image-20240123161352170" /><figcaption aria-hidden="true">image-20240123161352170</figcaption></figure><figure><img src="image-20240123161442232.png" alt="image-20240123161442232" /><figcaption aria-hidden="true">image-20240123161442232</figcaption></figure><h2 id="通用操作">通用操作</h2><p>下面对于字典的操作基本是对于key值的操作</p><h3 id="len">len</h3><blockquote><p>统计元素个数</p></blockquote><h3 id="max-和min">max 和min</h3><blockquote><p>获取最大元素，获取最小元素</p></blockquote><p>对于字典，获取的是最大或最小的key</p><h3 id="类型转换">类型转换</h3><ul><li><p>list(容器)</p><p>转列表</p></li><li><p>str(容器)</p><p>转字符串</p></li><li><p>tuple(容器)</p><p>转元组</p></li><li><p>set(容器)</p><p>转集合</p></li></ul><h3 id="sorted">sorted</h3><p>排序，并返回列表对象的结果，字典会丢失value</p><blockquote><p>sorted(容器) 正向排序，从小到大</p><p>sorted(容器，reverse = True) 反向排序</p></blockquote><figure><img src="image-20240123162933181.png" alt="image-20240123162933181" /><figcaption aria-hidden="true">image-20240123162933181</figcaption></figure><h1 id="文件">文件</h1><blockquote><p>文件编码：编码的技术，记录了如何将内容翻译成二进制以及如何解密二进制，不同的编码对同一文本的翻译不同</p></blockquote><p>常见文件编码：</p><ul><li>UTF-8 全球通用 默认编码</li><li>GBK</li><li>Big5</li></ul><h2 id="读取文件">读取文件</h2><ol type="1"><li>打开文件</li><li>读写文件</li><li>关闭文件</li></ol><h2 id="打开文件">打开文件</h2><blockquote><p>open(name,mode,encoding)</p><p>name：文件的名字可以包含路径，字符串表示</p><p>mode：设置打开文件的模式，只读，写入，追加等</p><p>encoding：编码格式（推荐使用UFT-8）</p></blockquote><figure><img src="image-20240124003300313.png" alt="image-20240124003300313" /><figcaption aria-hidden="true">image-20240124003300313</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;D:/桌面/test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding = <span class="string">&quot;UTF-8&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>encoding不是第三个参数，因此要使用关键字参数</strong></p><h2 id="读取文件-1">读取文件</h2><blockquote><p>文件对象.read(num)</p><p>num:表示要读取的数据的长度，单位是字节，如果没有传入num，那么就表示读取文件中所有数据</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;D:/桌面/test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding = <span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(f.read(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(f.read())<span class="comment">#全部内容</span></span><br></pre></td></tr></table></figure><p><strong>连续读取会从上一次读取的末尾开始读取</strong></p><blockquote><p>文件对象.readlines()</p><p>按照行的方法把文件中的内容进行一次性读取，并返回一个列表，其中每一行的数据为一个元素</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;D:/桌面/test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding = <span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">list1 = f.readlines()</span><br></pre></td></tr></table></figure><p><strong>可以使用for循环读取行</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;D:/桌面/test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding = <span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;每一行为<span class="subst">&#123;line&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>连续读取会从上一次读取的末尾开始读取</strong></p><blockquote><p>文件对象.readline()</p><p>一次读取一行内容</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;D:/桌面/test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding = <span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">list1 = f.readline()</span><br></pre></td></tr></table></figure><h2 id="写入文件">写入文件</h2><blockquote><p>文件对象.write()</p><p>把内容写入缓冲区</p></blockquote><blockquote><p>文件对象.flush()</p><p>内容刷新，写入硬盘中的文件</p></blockquote><p><strong>close方法内置了flush功能</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;D:/桌面/test.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,encoding = <span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">f.write(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">f.flush()</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><h2 id="关闭文件">关闭文件</h2><blockquote><p>文件对象.close()</p></blockquote><p>解除文件占用</p><blockquote><p>with open(name,mode,encoding) as 文件对象:</p><p>​ 操作</p></blockquote><p>完成操作后自动关闭文件，避免遗忘close方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;D:/桌面/test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding = <span class="string">&quot;UTF-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    res = f.read()</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h1 id="类">类</h1><h2 id="定义-5">定义</h2><blockquote><p>class 类名:</p><p>​ satement1</p><p>​ satement2</p><p>​ ......</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    school = <span class="string">&quot;null&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, tmp_name, tmp_school, tmp_gener, tmp_id</span>):</span><br><span class="line">        self.school = tmp_school</span><br><span class="line">        self.<span class="built_in">id</span> = tmp_id</span><br><span class="line">        self.name = tmp_name</span><br><span class="line">        self.gener = tmp_gener</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">return_school</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.school</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">&quot;xiaoming&quot;</span>, <span class="string">&quot;guangmingzhongxue&quot;</span>, <span class="string">&quot;girl&quot;</span>, <span class="string">&quot;1992&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s.return_school())</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">guangmingzhongxue</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="初始化函数">初始化函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, tmp_name, tmp_school, tmp_gener, tmp_id</span>):</span><br><span class="line">       self.school = tmp_school</span><br><span class="line">       self.<span class="built_in">id</span> = tmp_id</span><br><span class="line">       self.name = tmp_name</span><br><span class="line">       self.gener = tmp_gener</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">python基础语法记录</summary>
    
    
    
    <category term="Python" scheme="https://klklkl10086.github.io/klklkl10086.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>微积分A3</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2023/11/20/%E5%BE%AE%E7%A7%AF%E5%88%86A3/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2023/11/20/%E5%BE%AE%E7%A7%AF%E5%88%86A3/</id>
    <published>2023-11-20T12:01:38.000Z</published>
    <updated>2024-12-04T10:32:03.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="无穷级数">无穷级数</h1><figure><img src="638408206233530013_snap.png" alt="638408206233530013_snap" /><figcaption aria-hidden="true">638408206233530013_snap</figcaption></figure><figure><img src="638408206234802681_snap.png" alt="638408206234802681_snap" /><figcaption aria-hidden="true">638408206234802681_snap</figcaption></figure><figure><img src="638408206235719021_snap.png" alt="638408206235719021_snap" /><figcaption aria-hidden="true">638408206235719021_snap</figcaption></figure><figure><img src="638408206236580000_snap.png" alt="638408206236580000_snap" /><figcaption aria-hidden="true">638408206236580000_snap</figcaption></figure><figure><img src="638408206237869452_snap.png" alt="638408206237869452_snap" /><figcaption aria-hidden="true">638408206237869452_snap</figcaption></figure><figure><img src="638408206238913676_snap.png" alt="638408206238913676_snap" /><figcaption aria-hidden="true">638408206238913676_snap</figcaption></figure><figure><img src="638408206239800296_snap.png" alt="638408206239800296_snap" /><figcaption aria-hidden="true">638408206239800296_snap</figcaption></figure><figure><img src="638408206241720242_snap.png" alt="638408206241720242_snap" /><figcaption aria-hidden="true">638408206241720242_snap</figcaption></figure><figure><img src="638408206242522972_snap.png" alt="638408206242522972_snap" /><figcaption aria-hidden="true">638408206242522972_snap</figcaption></figure><figure><img src="638408206243413316_snap.png" alt="638408206243413316_snap" /><figcaption aria-hidden="true">638408206243413316_snap</figcaption></figure><figure><img src="638408206245168132_snap.png" alt="638408206245168132_snap" /><figcaption aria-hidden="true">638408206245168132_snap</figcaption></figure><figure><img src="638408206246069990_snap.png" alt="638408206246069990_snap" /><figcaption aria-hidden="true">638408206246069990_snap</figcaption></figure><figure><img src="638408206246872655_snap.png" alt="638408206246872655_snap" /><figcaption aria-hidden="true">638408206246872655_snap</figcaption></figure><figure><img src="638408206248020433_snap.png" alt="638408206248020433_snap" /><figcaption aria-hidden="true">638408206248020433_snap</figcaption></figure><figure><img src="638408206249321765_snap.png" alt="638408206249321765_snap" /><figcaption aria-hidden="true">638408206249321765_snap</figcaption></figure><h1 id="常微分方程">常微分方程</h1><p>课程：<a href="https://www.bilibili.com/video/BV1a24y1a7Sg">3小时讲不完《常微分方程》</a></p><p><img src="0001.jpg" /></p><figure><img src="0002.jpg" alt="0002" /><figcaption aria-hidden="true">0002</figcaption></figure><figure><img src="0003.jpg" alt="0003" /><figcaption aria-hidden="true">0003</figcaption></figure><figure><img src="0004.jpg" alt="0004" /><figcaption aria-hidden="true">0004</figcaption></figure><figure><img src="0005.jpg" alt="0005" /><figcaption aria-hidden="true">0005</figcaption></figure><figure><img src="0006.jpg" alt="0006" /><figcaption aria-hidden="true">0006</figcaption></figure><figure><img src="0007.jpg" alt="0007" /><figcaption aria-hidden="true">0007</figcaption></figure><figure><img src="0008.jpg" alt="0008" /><figcaption aria-hidden="true">0008</figcaption></figure><figure><img src="0009.jpg" alt="0009" /><figcaption aria-hidden="true">0009</figcaption></figure><figure><img src="0010.jpg" alt="0010" /><figcaption aria-hidden="true">0010</figcaption></figure><figure><img src="0011.jpg" alt="0011" /><figcaption aria-hidden="true">0011</figcaption></figure><figure><img src="Inkodo-20231219_141437.png" alt="Inkodo-20231219_141437" /><figcaption aria-hidden="true">Inkodo-20231219_141437</figcaption></figure><figure><img src="638385913390558932_snap.png" alt="638385913390558932_snap" /><figcaption aria-hidden="true">638385913390558932_snap</figcaption></figure><figure><img src="638385913394669519_snap.png" alt="638385913394669519_snap" /><figcaption aria-hidden="true">638385913394669519_snap</figcaption></figure><figure><img src="638385913398852815_snap.png" alt="638385913398852815_snap" /><figcaption aria-hidden="true">638385913398852815_snap</figcaption></figure><figure><img src="638385913403913144_snap.png" alt="638385913403913144_snap" /><figcaption aria-hidden="true">638385913403913144_snap</figcaption></figure><figure><img src="638385913408000479_snap.png" alt="638385913408000479_snap" /><figcaption aria-hidden="true">638385913408000479_snap</figcaption></figure><figure><img src="638385522251274427_snap.png" alt="638385522251274427_snap" /><figcaption aria-hidden="true">638385522251274427_snap</figcaption></figure><figure><img src="638385536354837256_snap.png" alt="638385536354837256_snap" /><figcaption aria-hidden="true">638385536354837256_snap</figcaption></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;无穷级数&quot;&gt;无穷级数&lt;/h1&gt;
&lt;figure&gt;
&lt;img src=&quot;638408206233530013_snap.png&quot; alt=&quot;638408206233530013_snap&quot; /&gt;&lt;figcaption aria-hidden=&quot;true&quot;&gt;638</summary>
      
    
    
    
    <category term="class" scheme="https://klklkl10086.github.io/klklkl10086.github.io/categories/class/"/>
    
    
    <category term="微积分" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2023/10/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2023/10/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2023-10-29T10:47:25.000Z</published>
    <updated>2025-03-29T03:41:37.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性表">线性表</h1><p>同种数据类型的集合，静态列表例如：数组（array），动态列表例如：链表（linked list）</p><h3 id="链表">链表</h3><p>与数组</p><p><strong>区别</strong>：数组更强调于整块大小固定的、连续的内存空间，并且不可以随意的插入数据，<strong>而链表则可以分段并且可以随意改变大小，随意插入数据，更好地利用了内存空间。</strong></p><p>对于链表来讲，我们只需要知道第一个节点的地址，便可以<strong>环环相扣</strong>得到链表上所有的数据。</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">数组</th><th style="text-align: center;">链表</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">内存空间</td><td style="text-align: center;">连续且大小固定</td><td style="text-align: center;">不连续且大小不固定</td></tr><tr class="even"><td style="text-align: center;">访问方式（时间复杂度）</td><td style="text-align: center;">直接（低）</td><td style="text-align: center;">遍历链表（高）</td></tr><tr class="odd"><td style="text-align: center;">内存空间利用</td><td style="text-align: center;">不充分</td><td style="text-align: center;">充分</td></tr><tr class="even"><td style="text-align: center;">总结</td><td style="text-align: center;">更容易实现</td><td style="text-align: center;">易出错</td></tr></tbody></table><h4 id="单链表">单链表</h4><p>定义节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">link</span>;</span><span class="comment">//c++中直接写Node *</span></span><br><span class="line">&#125;;<span class="comment">// 定义节点</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="创建">创建</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Node * A;<span class="comment">//头指针 永远</span></span><br><span class="line">A = <span class="literal">NULL</span>;</span><br><span class="line">Node* temp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));    <span class="comment">//创建节点  对于c++首选new</span></span><br><span class="line">(*temp).data = <span class="number">2</span>;    <span class="comment">//temp-&gt;data=2;</span></span><br><span class="line">(*temp).link = <span class="literal">NULL</span>;    <span class="comment">//temp-&gt;link=NULL;</span></span><br><span class="line">A = temp;</span><br><span class="line">temp = new Node();</span><br><span class="line">temp-&gt;data=<span class="number">4</span>;</span><br><span class="line">temp-&gt;link=<span class="literal">NULL</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="遍历">遍历</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//用循环遍历链表</span></span><br><span class="line">    Node* temp1=A;</span><br><span class="line">    <span class="keyword">while</span>(temp1-&gt;link!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    temp1=temp1-&gt;link;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//末尾添加节点</span></span><br><span class="line">  temp = new Node();</span><br><span class="line">  temp-&gt;data=<span class="number">4</span>;</span><br><span class="line">  temp-&gt;link=<span class="literal">NULL</span>;</span><br><span class="line">  temp1-&gt;link = temp;</span><br></pre></td></tr></table></figure><h5 id="增加节点">增加节点</h5><p>头部</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span>;</span></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">Insert</span><span class="params">(<span class="keyword">struct</span> Node* head,<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* temp = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    temp-&gt;data = x;</span><br><span class="line">    temp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(head!=<span class="literal">NULL</span>) temp-&gt;next = head;</span><br><span class="line">    head = temp;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    head=Insert(head,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任意节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//head=NULL or head!=NULL</span></span><br><span class="line"><span class="comment">//假定链表目前为 2——&gt;4——&gt;6</span></span><br><span class="line"><span class="comment">//要将其变成    2——&gt;4——&gt;8——&gt;6</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">()</span>&#123;...&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(<span class="type">int</span> data,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* temp1 = new Node();</span><br><span class="line">    temp1-&gt;data = data;</span><br><span class="line">    temp1-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)<span class="comment">//如果插入头部</span></span><br><span class="line">&#123;</span><br><span class="line">    temp1-&gt;next = head;</span><br><span class="line">    head = temp1;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">    Node* temp2 = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-2</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    temp2 = temp2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">    temp1-&gt;next=temp2-&gt;next;</span><br><span class="line">    temp2-&gt;next = temp1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    Insert(<span class="number">2</span>,<span class="number">1</span>);<span class="comment">// 2</span></span><br><span class="line">    Insert(<span class="number">3</span>,<span class="number">2</span>);<span class="comment">// 2 3</span></span><br><span class="line">    Insert(<span class="number">4</span>,<span class="number">1</span>);<span class="comment">// 4 2 3</span></span><br><span class="line">    Insert(<span class="number">5</span>,<span class="number">2</span>);<span class="comment">// 4 5 2 3</span></span><br><span class="line">    Print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除节点">删除节点</h5><p>任意节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(<span class="type">int</span> data)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Delete</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp1</span> =</span> head;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        head = temp1-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//（前面有节点后面也有 OR 前面有节点后面没有）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp1 = temp1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp2</span> =</span> temp1-&gt;next;</span><br><span class="line">        temp1-&gt;next = temp2-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp2);<span class="comment">//delete temp2;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    Insert(<span class="number">2</span>);</span><br><span class="line">    Insert(<span class="number">4</span>);</span><br><span class="line">    Insert(<span class="number">6</span>);</span><br><span class="line">    Insert(<span class="number">5</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a position \n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    Delete(n);</span><br><span class="line">    Print();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="反转链表">反转链表</h5><p>方法一：</p><p><strong>遍历，一个节点一个节点的反转</strong></p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(<span class="keyword">struct</span> Node* head)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span> =</span> head;</span><br><span class="line"><span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, temp-&gt;data);</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, temp-&gt;data);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">Insert</span><span class="params">(<span class="keyword">struct</span> Node* head, <span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">temp-&gt;data = x;</span><br><span class="line">temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (head != <span class="literal">NULL</span>) temp-&gt;next = head;</span><br><span class="line">head = temp;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">Reverse</span><span class="params">(<span class="keyword">struct</span> Node* head)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">current</span>,*<span class="title">prev</span>,*<span class="title">next</span>;</span></span><br><span class="line">current = head;</span><br><span class="line">prev = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (current != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">next = current-&gt;next;</span><br><span class="line">current-&gt;next = prev;</span><br><span class="line">prev = current;</span><br><span class="line">current = next;</span><br><span class="line">&#125;</span><br><span class="line">head = prev;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">head=Insert(head, <span class="number">2</span>);</span><br><span class="line">head=Insert(head, <span class="number">4</span>);</span><br><span class="line">head=Insert(head, <span class="number">6</span>);</span><br><span class="line">head=Insert(head, <span class="number">8</span>);</span><br><span class="line">Print(head);</span><br><span class="line">head = Reverse(head);</span><br><span class="line">Print(head);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：</p><p><strong>递归</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Reverse</span><span class="params">(<span class="keyword">struct</span> Node* p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    head = p;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Reverse(p-&gt;next);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">q</span>=</span>p-&gt;next;</span><br><span class="line">q-&gt;next = p;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>利用嵌套关系来代替前指针的作用</u></p><h4 id="双向链表">双向链表</h4><p>特点</p><p>节点有两个指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span> <span class="comment">//指向</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">prev</span>;</span><span class="comment">//指向前节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>优点：可以反向查询</p><p>缺点：增加了额外内存，对于一样的操作相对于单项链表需要更多的步骤</p><p>实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">GetNewNode</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">temp-&gt;data = x;</span><br><span class="line">temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">temp-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertAtHead</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//在链首添加</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newnode</span> =</span> GetNewNode(x);</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">head = newnode;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">head-&gt;prev = newnode;</span><br><span class="line">newnode-&gt;next = head;</span><br><span class="line">newnode-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">head = newnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertAtTail</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//在末尾添加</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newnode</span> =</span> GetNewNode(x);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span> =</span> head;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">head = newnode;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">temp-&gt;next = newnode;</span><br><span class="line">newnode-&gt;prev = temp;</span><br><span class="line">newnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//打印链表</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span> =</span> head;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, temp-&gt;data);</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, temp-&gt;data);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ReversePrint</span><span class="params">()</span> <span class="comment">//逆转链表</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span> =</span> head;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Reverse:%d\n&quot;</span>, temp-&gt;data);</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//当链表只有一个或没有节点时</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Reverse: &quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (temp-&gt;prev != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, temp-&gt;data);</span><br><span class="line">temp = temp-&gt;prev;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,temp-&gt;data);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">head = <span class="literal">NULL</span>; </span><br><span class="line">InsertAtTail(<span class="number">2</span>); Print(); ReversePrint();</span><br><span class="line">InsertAtTail(<span class="number">4</span>); Print(); ReversePrint();</span><br><span class="line">InsertAtHead(<span class="number">6</span>); Print(); ReversePrint();</span><br><span class="line">InsertAtTail(<span class="number">8</span>); Print(); ReversePrint();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环链表">循环链表</h4><h3 id="栈stack">栈（stack）</h3><p><strong>特点 ：封闭性好，使用方便</strong></p><h4 id="顺序存储">顺序存储</h4><p>以存储数字为例，利用数组实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sstack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> top;</span><br><span class="line"><span class="type">char</span>* array;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">sstack</span>(<span class="type">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">top = <span class="number">-1</span>;</span><br><span class="line">size = k;</span><br><span class="line">array = <span class="keyword">new</span> <span class="type">char</span>[k]();</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">sstack</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[]array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">(<span class="type">char</span>&amp; item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">item = array[top];</span><br><span class="line">top--;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">push</span><span class="params">(<span class="type">const</span> <span class="type">char</span> item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (top == size - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">top++;</span><br><span class="line">array[top] = item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">(<span class="type">char</span>&amp; item)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">item = array[top];</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isempty</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isfull</span><span class="params">(<span class="type">void</span>)</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (top == size - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="链式存储">链式存储</h4><p>使用单链表实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SLNode</span><span class="comment">// 节点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T date;</span><br><span class="line">SLNode&lt;T&gt;* next;</span><br><span class="line"><span class="built_in">SLNode</span>() &#123; next = <span class="literal">NULL</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sstack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SLNode</span> &lt;T&gt;* top; <span class="comment">// 栈顶指针指向表头</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">sstack</span>() &#123; top = <span class="literal">NULL</span>; &#125; <span class="comment">// 构造函数</span></span><br><span class="line"></span><br><span class="line">~<span class="built_in">sstack</span>() &#123; <span class="built_in">clear</span>(); &#125; <span class="comment">// 析构函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SLNode</span>&lt;T&gt;* tmp = <span class="keyword">new</span> <span class="built_in">SLNode</span>&lt;T&gt;();</span><br><span class="line">tmp-&gt;date = item;</span><br><span class="line">tmp-&gt;next = top;</span><br><span class="line">top = tmp;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">(T&amp; item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (top == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">item = top-&gt;date;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SLNode</span>&lt;T&gt;* tmp = top;</span><br><span class="line">top = top-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">(T&amp; item)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (top == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">item = top-&gt;date;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isempty</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (top == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SLNode</span>&lt;T&gt;* p;</span><br><span class="line"><span class="keyword">while</span> (top != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">p = top-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> top;</span><br><span class="line">top = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="比较">比较</h4><ol type="1"><li>在空间复杂性上，顺序栈必须初始就申请固定的空间，当栈不满时，必然造成空间的浪费；链式栈所需空间是根据需要随时申请的，其代价是为每个元素提供空间以存储其next指针域。</li><li>在时间复杂性上，对于针对栈顶的基本操作（压入、弹出和栈顶元素存取），顺序栈和链式栈的时间复杂性均为O(1) .</li></ol><h4 id="双栈">*双栈</h4><figure><img src="image-20231023173710839.png" alt="image-20231023173710839" /><figcaption aria-hidden="true">image-20231023173710839</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sstack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* left;</span><br><span class="line">T* right;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line"><span class="type">int</span> lefttop;</span><br><span class="line"><span class="type">int</span> righttop;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">sstack</span>(<span class="type">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">size = k;</span><br><span class="line">left = <span class="keyword">new</span> T[k]();</span><br><span class="line">right = left;</span><br><span class="line">lefttop = <span class="number">-1</span>;</span><br><span class="line">righttop = size;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">sstack</span>() &#123; <span class="keyword">delete</span>[]left; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; item, <span class="type">int</span> num)</span><span class="comment">//num选择的栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (righttop == lefttop + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;full&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//栈已经满</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">lefttop++;</span><br><span class="line">left[lefttop] = item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">righttop--;</span><br><span class="line">right[righttop] = item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">(T&amp; item, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (righttop == size &amp;&amp; lefttop == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;双栈为空无法出栈&quot;</span> &lt;&lt; endl;</span><br><span class="line">item = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (lefttop == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;左栈为空无法出栈&quot;</span> &lt;&lt; endl;</span><br><span class="line">item = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">item = left[lefttop];</span><br><span class="line">lefttop--;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (righttop == size)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;右栈为空无法出栈&quot;</span> &lt;&lt; endl;</span><br><span class="line">item = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">item = right[righttop];</span><br><span class="line">righttop++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">(T&amp; item, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (lefttop == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">item = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">item = left[lefttop];</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (righttop == size) &#123; item = <span class="number">-1</span>; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">item = right[righttop];</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">0</span>) lefttop = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">righttop = size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isempty</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">0</span> &amp;&amp; lefttop == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">1</span> &amp;&amp; righttop == size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isfull</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lefttop + <span class="number">1</span> == righttop)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">int</span> x, chose;</span><br><span class="line"><span class="function">sstack&lt;<span class="type">int</span>&gt; <span class="title">stac</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;选项：push pop peek clear isempty isfull&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; num;</span><br><span class="line"><span class="keyword">switch</span> (num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">case</span>(<span class="number">1</span>): cout &lt;&lt; <span class="string">&quot;push item  chose:&quot;</span> &lt;&lt; endl; cin &gt;&gt; x; cin &gt;&gt; chose; stac.<span class="built_in">push</span>(x, chose); <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">case</span>(<span class="number">2</span>):cout &lt;&lt; <span class="string">&quot;pop chose:&quot;</span> &lt;&lt; endl;  cin &gt;&gt; chose; stac.<span class="built_in">pop</span>(x, chose); cout &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; endl; <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">case</span>(<span class="number">3</span>):cout &lt;&lt; <span class="string">&quot;peek chose:&quot;</span> &lt;&lt; endl; cin &gt;&gt; chose; stac.<span class="built_in">peek</span>(x, chose); cout &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; endl; <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">case</span>(<span class="number">4</span>):cout &lt;&lt; <span class="string">&quot;clear chose:&quot;</span> &lt;&lt; endl; cin &gt;&gt; chose; stac.<span class="built_in">clear</span>(chose); <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">case</span>(<span class="number">5</span>):cout &lt;&lt; <span class="string">&quot;empty chose:&quot;</span> &lt;&lt; endl; cin &gt;&gt; chose; cout &lt;&lt; stac.<span class="built_in">isempty</span>(chose) &lt;&lt; endl; <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">case</span>(<span class="number">6</span>):cout &lt;&lt; <span class="string">&quot;full:&quot;</span> &lt;&lt; endl; cout &lt;&lt; stac.<span class="built_in">isfull</span>() &lt;&lt; endl; <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">case</span>(<span class="number">7</span>):<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="应用">应用</h4><p><strong>括号匹配</strong></p><p><strong>题目一：</strong></p><p><a href="https://leetcode.cn/problems/valid-parentheses/description/">有效的括号</a></p><p><strong>存在三种情况：</strong></p><p>左括号多于右括号</p><p>右括号多于左括号</p><p>括号不匹配（左右括号对不上）。</p><p><strong>题目二：</strong></p><p><a href="https://leetcode.cn/problems/minimum-remove-to-make-valid-parentheses/description/">移除括号使其有效</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">stack&lt;<span class="type">char</span>*&gt; p1;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Solution</span>() &#123;&#125;</span><br><span class="line"><span class="function">string <span class="title">minRemoveToMakeValid</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span>* x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">p1.<span class="built_in">push</span>(&amp;s[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!p1.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">p1.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">s[i] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p1.<span class="built_in">empty</span>() == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">x = p1.<span class="built_in">top</span>();</span><br><span class="line">*x = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">p1.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">string ss;</span><br><span class="line"><span class="keyword">for</span> (string::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*it != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">ss.<span class="built_in">push_back</span>(*it);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ss;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>数制转换</strong></p><p>数制转换</p><p><strong>中缀表达式求值</strong></p><p>已知中缀表达式，求值</p><p><strong>方法一：中后缀转换，后缀表达式求值</strong></p><p>​ 对于高于1位的数字无法处理。</p><p><strong>中后缀转换：</strong></p><blockquote><p>如果检测到<strong>数字</strong>，则直接加入到后缀表达式中</p><p>如果检测到运算符时：</p><ol type="1"><li>若为‘（’，入栈</li><li>若为‘）’，则依次将栈中的运算符加入后缀表达式，直到出现‘（’，并从栈中删除‘（’</li><li>若为‘+’，‘-’，‘*’，‘/’</li></ol><ul><li>栈空，入栈</li><li>栈顶元素为‘（’,入栈</li><li><strong>高于</strong>栈顶元素优先级，入栈</li><li>否则，依次弹出栈顶运算符，直到一个优先级比它低的运算符或‘（’为止</li></ul><p>遍历完成，若栈非空，依次弹出栈中所有元素</p></blockquote><p><strong>方法二：利用两个栈进行计算</strong></p><blockquote><ol type="1"><li>初始化一个操作数栈和一个运算符栈。</li><li>从左到右读入中缀表达式，若读到的是操作数，则将其压入操作数栈中。</li><li>若读到的是运算符，则和运算符栈栈顶的操作符进行比较：如果优先级比栈顶运算符<strong>高</strong>，则入栈；如果优先级比栈顶运算符低或者等于，则弹出栈顶运算符，再从操作数栈中弹出 2 个操作数，对其进行运算，将结果压入操作数栈中,重复，直到当前读到的运算符优先级<strong>高于</strong>运算符栈的栈顶运算符。</li><li>若读到的是左括号，则直接入栈；若读到的是右括号，则弹出栈中第一个左括号前所有的运算符，每次同时弹出 2 个操作数进行运算，并将结果压入操作数栈中，最后将左括号弹出。</li><li>重复以上过程直到遇到结束符，若此时操作数栈不为空，则将所有操作符弹出，进行和上面相同的运算操作，最终栈顶元素即为计算结果。</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">qpow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)        <span class="comment">//如果n的当前末位为1</span></span><br><span class="line">            ans *= a;  <span class="comment">//ans乘上当前的a</span></span><br><span class="line">        a *= a;        <span class="comment">//a自乘</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;       <span class="comment">//n往右移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">midop</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">char</span>&gt; ssop;</span><br><span class="line">stack&lt;<span class="type">long</span> <span class="type">long</span>&gt; ssnum;</span><br><span class="line"><span class="type">bool</span> tag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">littlecalu</span><span class="params">(<span class="type">long</span> <span class="type">long</span> lh, <span class="type">long</span> <span class="type">long</span> rh, <span class="type">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (ch)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">case</span>(<span class="string">&#x27;+&#x27;</span>):</span><br><span class="line">&#123;</span><br><span class="line">ssnum.<span class="built_in">push</span>(lh + rh);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">case</span>(<span class="string">&#x27;-&#x27;</span>):</span><br><span class="line">&#123;</span><br><span class="line">ssnum.<span class="built_in">push</span>(lh - rh);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">case</span>(<span class="string">&#x27;*&#x27;</span>):</span><br><span class="line">&#123;</span><br><span class="line">ssnum.<span class="built_in">push</span>(lh * rh);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">case</span>(<span class="string">&#x27;/&#x27;</span>):</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (rh != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ssnum.<span class="built_in">push</span>(lh / rh);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;INVALID&quot;</span>;</span><br><span class="line">tag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">case</span>(<span class="string">&#x27;^&#x27;</span>):</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res = <span class="built_in">qpow</span>(lh, rh);</span><br><span class="line">ssnum.<span class="built_in">push</span>(res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">op_compare</span><span class="params">(<span class="type">char</span> a, <span class="type">char</span> b)</span><span class="comment">//优先级计算</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> aa = <span class="number">0</span>, bb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="string">&#x27;+&#x27;</span> || a == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">aa = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="string">&#x27;+&#x27;</span> || b == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">bb = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="string">&#x27;*&#x27;</span> || a == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">aa = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="string">&#x27;*&#x27;</span> || b == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">bb = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="string">&#x27;^&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">aa = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="string">&#x27;^&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">bb = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> aa &gt; bb ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="built_in">caclulate</span>(string str)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>;</span><br><span class="line">tag = <span class="number">1</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> len = str.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch = str[i];</span><br><span class="line"><span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">ssnum.<span class="built_in">push</span>(ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">while</span> (str[i] &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; str[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; i &lt;= len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> tmp = ssnum.<span class="built_in">top</span>();</span><br><span class="line">ssnum.<span class="built_in">pop</span>();</span><br><span class="line">tmp = tmp * <span class="number">10</span> + (str[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">ssnum.<span class="built_in">push</span>(tmp);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">ssop.<span class="built_in">push</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (ssop.<span class="built_in">empty</span>() != <span class="literal">true</span> &amp;&amp; ssop.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch1 = ssop.<span class="built_in">top</span>();</span><br><span class="line">ssop.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> lh, rh;</span><br><span class="line">rh = ssnum.<span class="built_in">top</span>();</span><br><span class="line">ssnum.<span class="built_in">pop</span>();</span><br><span class="line">lh = ssnum.<span class="built_in">top</span>();</span><br><span class="line">ssnum.<span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">littlecalu</span>(lh, rh, ch1);</span><br><span class="line"><span class="keyword">if</span> (!tag) <span class="keyword">return</span>;<span class="comment">//无效则结束计算</span></span><br><span class="line">&#125;</span><br><span class="line">ssop.<span class="built_in">pop</span>();</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ssop.<span class="built_in">empty</span>() != <span class="literal">true</span> &amp;&amp; ssop.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span> &amp;&amp; ssop.<span class="built_in">top</span>() != <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">op_compare</span>(ch, ssop.<span class="built_in">top</span>())) <span class="comment">//ch&gt;top</span></span><br><span class="line">&#123;</span><br><span class="line">ssop.<span class="built_in">push</span>(ch);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (ssop.<span class="built_in">empty</span>() != <span class="literal">true</span> &amp;&amp; !<span class="built_in">op_compare</span>(ch, ssop.<span class="built_in">top</span>()))</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch1 = ssop.<span class="built_in">top</span>();</span><br><span class="line">ssop.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> rh = ssnum.<span class="built_in">top</span>();</span><br><span class="line">ssnum.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> lh = ssnum.<span class="built_in">top</span>();</span><br><span class="line">ssnum.<span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">littlecalu</span>(lh, rh, ch1);</span><br><span class="line"><span class="keyword">if</span> (!tag) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ssop.<span class="built_in">push</span>(ch);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!ssop.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch1 = ssop.<span class="built_in">top</span>();</span><br><span class="line">ssop.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> rh = ssnum.<span class="built_in">top</span>();</span><br><span class="line">ssnum.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> lh = ssnum.<span class="built_in">top</span>();</span><br><span class="line">ssnum.<span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">littlecalu</span>(lh, rh, ch1);</span><br><span class="line"><span class="keyword">if</span> (!tag) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ssnum.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>递归</strong></p><blockquote><p><strong>有些情况下，若采用迭代算法或递归算法的非递归实现，将大大提高效率</strong></p></blockquote><p>八皇后</p><p>汉诺塔</p><p>BS找最大最小元素</p><h3 id="队列queue">队列（queue）</h3><p><strong>特点：先进先出，队首删除，队尾插入,与栈类似，队列的封闭性也非常好，使用起来很安全</strong></p><h4 id="顺序存储-1">顺序存储</h4><p><strong>实现: 使用数组实现队列</strong></p><p><strong>初始状态，rear和front均为0</strong></p><p><strong>1.删除队首元素</strong></p><p><strong>方法一：</strong>front=front +1</p><p>​ <strong>问题：会存在无法利用的空间</strong></p><p><strong>方法二：元素向前移动，front始终不变在数组的头部。</strong></p><p>​ <strong>问题：效率低下</strong></p><p><strong>方法三：循环队列</strong></p><p><strong>很好地解决了方法一二的问题。</strong></p><p>​ 但要设置参数count计数器判断队列是否满和空</p><ul><li>front指向队首位置，<strong>删除一个元素</strong>就将front顺时针移动一位；<strong>front初识化为0</strong></li><li>rear指向元素<strong>要插入</strong>的位置，插入一个元素就将rear顺时针移动一位； <strong>rear初始化为0</strong>，<strong>若指向队尾的元素初始化为-1</strong></li><li>count存放队列中元素的个数，当count等于Size时，不可再向队列中插入元素。当count=0时队列为空</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCircularQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> count;<span class="comment">//计数器</span></span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;<span class="comment">//指向队尾的元素初始化为-1</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span>* array;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyCircularQueue</span>(<span class="type">int</span> k) </span><br><span class="line">    &#123;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="type">int</span>[k]();</span><br><span class="line">        size = k;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        front = <span class="number">0</span>; <span class="comment">////</span></span><br><span class="line">        rear = <span class="number">-1</span>;<span class="comment">////</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">enQueue</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == size) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        count++;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % size;</span><br><span class="line">        array[rear] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">deQueue</span><span class="params">()</span><span class="comment">//删除队首元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">front = (front + <span class="number">1</span>) % size;</span><br><span class="line">count--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Front</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> array[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Rear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> array[rear];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == size) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="链式存储-1">链式存储</h4><p><strong>实现：使用链表实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> date;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myqueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>* front;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>* rear;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Myqueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">front = <span class="literal">NULL</span>;</span><br><span class="line">rear = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Node</span>* tmp = <span class="keyword">new</span> <span class="keyword">struct</span> Node;</span><br><span class="line">        tmp-&gt;date = item;</span><br><span class="line"><span class="keyword">if</span> (rear != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">rear-&gt;next = tmp;</span><br><span class="line">rear = rear-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">            front=tmp；</span><br><span class="line">&#125;</span><br><span class="line">        rear=tmp;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (front == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> x = front-&gt;date;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Node</span>* tmp;</span><br><span class="line">tmp = front;</span><br><span class="line">front = front-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line">        <span class="keyword">if</span>(front==<span class="literal">NULL</span>) rear=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (front == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> front-&gt;date;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (front == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="顺序存储和链式存储">顺序存储和链式存储</h4><figure><img src="image-20231025180959906.png" alt="image-20231025180959906" /><figcaption aria-hidden="true">image-20231025180959906</figcaption></figure><h3 id="扩展">扩展</h3><figure><img src="image-20231025181037056.png" alt="image-20231025181037056" /><figcaption aria-hidden="true">image-20231025181037056</figcaption></figure><h4 id="优先队列">优先队列</h4><p><strong>定义与声明</strong></p><p>在C++中，<code>priority_queue</code>是一个用于管理具有优先级的队列的容器适配器。它基于堆（通常是最大堆）实现，其中元素按照优先级排列，优先级高的元素在前，支持高效的插入和删除操作。</p><h5 id="基本功能和特性">基本功能和特性</h5><ul><li><strong>最大堆</strong>：默认情况下，<code>priority_queue</code>是一个最大堆，即元素按降序排列。堆顶（<code>top()</code>）是队列中最大或最优先的元素。</li><li><strong>接口</strong>：<ul><li><code>push()</code>：将元素插入到优先队列中。</li><li><code>pop()</code>：移除堆顶元素（即最大优先级元素）。</li><li><code>top()</code>：返回堆顶元素的引用。</li><li><code>empty()</code>：判断优先队列是否为空。</li><li><code>size()</code>：返回优先队列中元素的数量。</li></ul></li></ul><h5 id="使用示例">使用示例</h5><p>默认情况下，<code>priority_queue</code>使用 <code>std::less&lt;T&gt;</code> 作为比较函数，从而构成最大堆。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line">    </span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Priority Queue Top: &quot;</span> &lt;&lt; pq.<span class="built_in">top</span>() &lt;&lt; std::endl;  <span class="comment">// 输出10，因为它是最大值</span></span><br><span class="line">    </span><br><span class="line">    pq.<span class="built_in">pop</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Priority Queue Top after pop: &quot;</span> &lt;&lt; pq.<span class="built_in">top</span>() &lt;&lt; std::endl;  <span class="comment">// 输出5</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="自定义优先级最小堆">自定义优先级（最小堆）</h5><p>默认是最大堆，要实现最小堆可以通过<code>std::greater&lt;T&gt;</code>或自定义比较函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用std::greater&lt;int&gt;来实现最小堆</span></span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt;&gt; minHeap;</span><br><span class="line">    </span><br><span class="line">    minHeap.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">    minHeap.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    minHeap.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Min Heap Top: &quot;</span> &lt;&lt; minHeap.<span class="built_in">top</span>() &lt;&lt; std::endl;  <span class="comment">// 输出1，因为它是最小值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="自定义结构体和比较规则">自定义结构体和比较规则</h5><p>如果要对自定义类型（如结构体）使用<code>priority_queue</code>，可以定义一个比较规则：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">    std::string name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义比较规则</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Task&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> priority &lt; other.priority;  <span class="comment">// 按优先级从大到小排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::priority_queue&lt;Task&gt; tasks;</span><br><span class="line">    </span><br><span class="line">    tasks.<span class="built_in">push</span>(&#123;<span class="number">3</span>, <span class="string">&quot;Low Priority Task&quot;</span>&#125;);</span><br><span class="line">    tasks.<span class="built_in">push</span>(&#123;<span class="number">10</span>, <span class="string">&quot;High Priority Task&quot;</span>&#125;);</span><br><span class="line">    tasks.<span class="built_in">push</span>(&#123;<span class="number">5</span>, <span class="string">&quot;Medium Priority Task&quot;</span>&#125;);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top Task: &quot;</span> &lt;&lt; tasks.<span class="built_in">top</span>().name &lt;&lt; std::endl;  <span class="comment">// 输出&quot;High Priority Task&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="总结">总结</h5><ul><li><strong>默认最大堆</strong>：<code>priority_queue</code>默认使用<code>std::less&lt;T&gt;</code>，即最大堆。</li><li><strong>自定义堆类型</strong>：可以使用<code>std::greater&lt;T&gt;</code>或自定义比较规则实现最小堆。</li><li><strong>效率</strong>：<code>push()</code>和<code>pop()</code>操作的时间复杂度为O(log n)，适用于需要频繁插入和获取最优先元素的情况。</li></ul><h2 id="字符串">字符串</h2><h4 id="模式匹配问题">模式匹配问题</h4><p><strong>「朴素模式匹配法 」</strong></p><figure><img src="image-20231207212644104.png" alt="image-20231207212644104" /><figcaption aria-hidden="true">image-20231207212644104</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFstringMatching</span><span class="params">(<span class="type">const</span> string str,<span class="type">const</span> string pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=str.<span class="built_in">size</span>()-pattern.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[i]==pattern[j]&amp;&amp;j&lt;pattern.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">if</span>(j==pattern.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i-pattern.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法分析</strong></p><figure><img src="image-20231207213113063.png" alt="image-20231207213113063" /><figcaption aria-hidden="true">image-20231207213113063</figcaption></figure><figure><img src="image-20231207213142891.png" alt="image-20231207213142891" /><figcaption aria-hidden="true">image-20231207213142891</figcaption></figure><p><strong>「快速模式匹配算法」</strong></p><p><a href="https://www.bilibili.com/video/BV1Px411z7Yo/?spm_id_from=333.337.search-card.all.click&amp;vd_source=9a4fe569cfdfb26138828e9c87e1512d">b站 课程kmp1</a></p><p><a href="https://www.bilibili.com/video/BV1hW411a7ys/?spm_id_from=333.999.0.0&amp;vd_source=9a4fe569cfdfb26138828e9c87e1512d">b站 课程kmp2</a></p><p>对于BF算法的改进，BF算法的效率不高是因为进行了重复的字符比较</p><p><strong>算法思想：</strong></p><p>是指针i 只前进不后退，避免重复比较，让模式串向后滑动的距离最大化。</p><p>失败函数的确定： 求模式串的子串的最大相等子串,即计算前缀后缀相等表——next，next数组只和模式串有关系</p><p>next数组表示，当匹配失败的时候应该将j移动到哪个坐标。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">nextfun</span><span class="params">(string pattern, vector&lt;<span class="type">int</span>&gt;&amp; next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//生成前缀表</span></span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>, size = pattern.<span class="built_in">size</span>(), i = <span class="number">1</span>;</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pattern[i] == pattern[len])</span><br><span class="line">&#123;</span><br><span class="line">len++;</span><br><span class="line">next[i] = len;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">len = next[len - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">next[i] = <span class="number">0</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前缀表向右移一位，生成next数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">next[i] = next[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmp_search</span><span class="params">(string text, string pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> pat_size = pattern.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> text_size = text.<span class="built_in">size</span>();</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(pat_size)</span></span>;</span><br><span class="line"><span class="built_in">nextfun</span>(pattern, next);</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;<span class="comment">//text[i],pattern[j]</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; text_size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j == pat_size - <span class="number">1</span> &amp;&amp; text[i] == pattern[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i - j);</span><br><span class="line"><span class="comment">//return (i - j);//只找一个匹配的话</span></span><br><span class="line">j = next[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (text[i] == pattern[j])</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">j = next[j];</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于next数组的求值，仍存在<strong>改进</strong>之处：当匹配失败的时候，当前 j 指向的字符和 next[ j ] 指向的字符相等时，会重复比较</p><p>因此，可以基于next生成一个nextval数组：</p><p>​ 如果位置k的元素与位置next[k]元素<strong>相同</strong>时，nextval[k]=nextval[next[k]]</p><p>​ 如果位置k的元素与位置next[k]元素<strong>不同</strong>时，nextval[k]= next[k]</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">nextfun</span><span class="params">(<span class="built_in">string</span> pattern, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nextval)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//生成前缀表</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;next(nextval.size());</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>, size = pattern.size(), i = <span class="number">1</span>;</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pattern[i] == pattern[len])</span><br><span class="line">&#123;</span><br><span class="line">len++;</span><br><span class="line">next[i] = len;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">len = next[len - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">next[i] = <span class="number">0</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前缀表向右移一位</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">next[i] = next[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">       <span class="comment">//基于next生成nextval数组</span></span><br><span class="line">nextval[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pattern[i] == pattern[next[i]])</span><br><span class="line">nextval[i] = next[next[i]];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">nextval[i] = next[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习</strong>：</p><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">力扣——找出字符串中第一个匹配项的下标</a></p><h1 id="树">树</h1><h2 id="基本操作">基本操作</h2><p><strong>1、判树空：TREEEMPTY(T)</strong></p><p><strong>2、求根结点：ROOT(T)</strong></p><p><strong>3、求树的深度：TREEDEPTH(T)</strong></p><p><strong>4、求结点的兄弟节点：同一双亲的孩子互称</strong></p><p><strong>5、求结点的双亲：PARENT(T, e)</strong></p><p><strong>6、求结点的孩子：CHILD(T, e, i)</strong></p><p><strong>7、建立树：CREATE_TREE(T, T1 , T2 , … , Tm )</strong></p><p><strong>8、遍历树：TRAVERSAL(T)</strong></p><h2 id="二叉树">二叉树</h2><p><strong>树与二叉树</strong></p><ul><li>二叉树每个结点最多有 2 个子结点，树则无此限制；</li><li>二叉树中结点的子树分成左子树和右子树，即使某结点只 有一棵子树，也要指明该子树是左子树，还是右子树，<strong>就是说 二叉树是有序的。</strong></li></ul><h3 id="基本性质">基本性质</h3><p><span class="math display">\[二叉树中层数为 i 的结点至多有2^i个，i≥0。\]</span></p><p><span class="math display">\[高度为k的二叉树中至多有2^{k+1}-1 (k≥0)个结点。\]</span></p><p><span class="math display">\[设T是由n个结点构成的二叉树，其中，叶结点个数为n_0，度为2的结点个数为n_2，则有:n_0＝n_2+1\]</span></p><p><span class="math display">\[满二叉树:一棵非空高度为k ( k &gt;= 0 )的满二叉树，是有2^{k+1} – 1个结点的二叉树\]</span></p><figure><img src="image-20231028203341830.png" alt="image-20231028203341830" /><figcaption aria-hidden="true">image-20231028203341830</figcaption></figure><p><strong>满二叉树的特点是：</strong> <strong>① 叶结点都在第k层上；</strong> <strong>② 每个分支结点都有两个子结点；</strong> <strong>③ 叶结点的个数等于非叶结点个数加1。</strong></p><blockquote><p>一棵有 n 个结点、高为 k 的二叉树 T，一棵高为 k 的满二叉树 T* ， 用正整数按层次顺序分别编号 T 和 T* 的所有结点，如果T 之所有结 点恰好对应于T*的前 n 个结点，则称 T 为<strong>完全二叉树。</strong></p></blockquote><figure><img src="image-20231028203822677.png" alt="image-20231028203822677" /><figcaption aria-hidden="true">image-20231028203822677</figcaption></figure><h3 id="存储结构">存储结构</h3><p><strong>顺序存储</strong></p><figure><img src="image-20231029140215064.png" alt="image-20231029140215064" /><figcaption aria-hidden="true">image-20231029140215064</figcaption></figure><figure><img src="image-20231029140236742.png" alt="image-20231029140236742" /><figcaption aria-hidden="true">image-20231029140236742</figcaption></figure><p><strong>链式存储</strong></p><figure><img src="image-20231029140316009.png" alt="image-20231029140316009" /><figcaption aria-hidden="true">image-20231029140316009</figcaption></figure><figure><img src="image-20231029140327999.png" alt="image-20231029140327999" /><figcaption aria-hidden="true">image-20231029140327999</figcaption></figure><figure><img src="image-20231029140412615.png" alt="image-20231029140412615" /><figcaption aria-hidden="true">image-20231029140412615</figcaption></figure><h3 id="基本操作-1">基本操作</h3><h4 id="中根遍历">中根遍历</h4><p>力扣： https://leetcode.cn/problems/binary-tree-inorder-traversal/description/?envType=study-plan-v2&amp;envId=top-100-liked</p><p><strong>递归算法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">       cout&lt;&lt;root-&gt;val; </span><br><span class="line">       <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>迭代算法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">     TreeNode *left;</span><br><span class="line">     TreeNode *right;</span><br><span class="line">     <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line">stack&lt;TreeNode*&gt; sstack;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span>||(!sstack.<span class="built_in">empty</span>()))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sstack.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* p = sstack.<span class="built_in">top</span>();</span><br><span class="line">        cout&lt;&lt;p-&gt;val;</span><br><span class="line">        sstack.<span class="built_in">pop</span>();</span><br><span class="line">        root = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="先根遍历">先根遍历</h4><p>力扣：https://leetcode.cn/problems/binary-tree-preorder-traversal/submissions/478115880/</p><p><strong>算法基本等同于中根遍历，只是改了输出顺序，先输出根节点再遍历左右子树。</strong></p><p><strong>递归：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       cout&lt;&lt;root-&gt;val; </span><br><span class="line">       <span class="built_in">preorder</span>(root-&gt;left);</span><br><span class="line">       <span class="built_in">preorder</span>(root-&gt;right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>非递归算法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">     TreeNode *left;</span><br><span class="line">     TreeNode *right;</span><br><span class="line">     <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span>||(!sstack.<span class="built_in">empty</span>()))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;root-&gt;val;</span><br><span class="line">            sstack.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* p = sstack.<span class="built_in">top</span>();</span><br><span class="line">        sstack.<span class="built_in">pop</span>();</span><br><span class="line">        root = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="后根遍历">后根遍历</h4><p>力扣：https://leetcode.cn/problems/binary-tree-postorder-traversal/submissions/478118154/</p><p>递归：与先根中根类似</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">       <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">       cout&lt;&lt;root-&gt;val; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>非递归：</strong></p><ul><li><strong>先/中根的非递归算法，一个结点只进出栈一次。结点进栈，表示遍历开始； 结点出栈，表示左子树遍历完毕；输出语句的位置为进/出栈时。</strong></li><li><strong>后根遍历，输出结点需在遍历完右子树之后；若每个结点还是进出栈一次， 无法完成，需多次进出栈。</strong></li></ul><p><strong>准备工作栈：</strong></p><p>​ <img src="image-20231029145156512.png" /></p><figure><img src="image-20231029145238195.png" alt="image-20231029145238195" /><figcaption aria-hidden="true">image-20231029145238195</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line">TreeNode* left;</span><br><span class="line">TreeNode* right;</span><br><span class="line"><span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"><span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"><span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode* left, TreeNode* right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">TreeNode* p;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="built_in">node</span>(TreeNode* root, <span class="type">int</span> num) :<span class="built_in">p</span>(root), <span class="built_in">num</span>(num) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;node&gt; sstack;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">sstack.<span class="built_in">push</span>(<span class="built_in">node</span>(root, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">while</span> (!sstack.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>* tmp;</span><br><span class="line">tmp = &amp;(sstack.<span class="built_in">top</span>());</span><br><span class="line">sstack.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">switch</span> (tmp-&gt;num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">case</span> (<span class="number">0</span>):</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">tmp-&gt;num = <span class="number">1</span>;</span><br><span class="line">sstack.<span class="built_in">push</span>(*tmp);</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;p-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">sstack.<span class="built_in">push</span>(<span class="built_in">node</span>(tmp-&gt;p-&gt;left, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">case</span>(<span class="number">1</span>):</span><br><span class="line">&#123;</span><br><span class="line">tmp-&gt;num = <span class="number">2</span>;</span><br><span class="line">sstack.<span class="built_in">push</span>(*tmp);</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;p-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">sstack.<span class="built_in">push</span>(<span class="built_in">node</span>(tmp-&gt;p-&gt;right, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">case</span> (<span class="number">2</span>):</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; tmp-&gt;p-&gt;val;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><p><strong>力扣官方题解</strong></p><p>​ 没有用标识区别是哪一个状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode *&gt; stk;</span><br><span class="line">        TreeNode *prev = <span class="literal">nullptr</span>;              <span class="comment">///用来记录前一个访问的节点</span></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">///////////////////////////////////////////////////</span></span><br><span class="line">            <span class="comment">//到此为止完全和中序遍历完全相同</span></span><br><span class="line">            <span class="comment">///////////////////////////////////////////////////</span></span><br><span class="line">           <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span> || root-&gt;right == prev)<span class="comment">////判断右子树是否访问过或存不存在</span></span><br><span class="line">           &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(root);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/binary-tree-postorder-traversal/submissions/478118154/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="层次遍历">层次遍历</h4><p>力扣：</p><p>https://leetcode.cn/problems/binary-tree-level-order-traversal/submissions/480155496/</p><p>用队列辅助实现，和广度优先算法有点像，但经过优化，<strong>一次性移除一层的节点</strong></p><blockquote><p>我们可以用一种巧妙的方法修改广度优先搜索：</p><pre><code>首先根元素入队当队列不为空的时候    求当前队列的长度 sis_isi    依次从队列中取 sis_isi 个元素进行拓展，然后进入下一次迭代</code></pre><p>它和普通广度优先搜索的区别在于，普通广度优先搜索每次只取一个元素拓展，而这里每次取 sis_isi 个元素。在上述过程中的第 iii 次迭代就得到了二叉树的第 iii 层的 sis_isi 个元素。</p><p>为什么这么做是对的呢？我们观察这个算法，可以归纳出这样的循环不变式：第 iii 次迭代前，队列中的所有元素就是第 iii 层的所有元素，并且按照从左向右的顺序排列。证明它的三条性质（你也可以把它理解成数学归纳法）：</p><pre><code>初始化：i=1i = 1i=1 的时候，队列里面只有 root，是唯一的层数为 111 的元素，因为只有一个元素，所以也显然满足「从左向右排列」；保持：如果 i=ki = ki=k 时性质成立，即第 kkk 轮中出队 sks_ksk 的元素是第 kkk 层的所有元素，并且顺序从左到右。因为对树进行广度优先搜索的时候由低 kkk 层的点拓展出的点一定也只能是 k+1k + 1k+1 层的点，并且 k+1k + 1k+1 层的点只能由第 kkk 层的点拓展到，所以由这 sks_ksk 个点能拓展到下一层所有的 sk+1s_&#123;k+1&#125;sk+1 个点。又因为队列的先进先出（FIFO）特性，既然第 kkk 层的点的出队顺序是从左向右，那么第 k+1k + 1k+1 层也一定是从左向右。至此，我们已经可以通过数学归纳法证明循环不变式的正确性。终止：因为该循环不变式是正确的，所以按照这个方法迭代之后每次迭代得到的也就是当前层的层次遍历结果。至此，我们证明了算法是正确的。</code></pre><p>作者：力扣官方题解</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector &lt;vector &lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue &lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> currentLevelSize = q.<span class="built_in">size</span>();</span><br><span class="line">            ret.<span class="built_in">push_back</span>(vector &lt;<span class="type">int</span>&gt; ());</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= currentLevelSize; ++i)  &#123;<span class="comment">//移除处理本层所有节点</span></span><br><span class="line">                <span class="keyword">auto</span> node = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                ret.<span class="built_in">back</span>().<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/binary-tree-level-order-traversal/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="创建二叉树">创建二叉树</h4><ul><li><p><strong>先根序列和中根序列可以确定</strong></p><figure><img src="image-20231106185651324.png" alt="image-20231106185651324" /><figcaption aria-hidden="true">image-20231106185651324</figcaption></figure></li><li><p><strong>后根序列和中根序列可以确定</strong></p><figure><img src="image-20231106185722158.png" alt="image-20231106185722158" /><figcaption aria-hidden="true">image-20231106185722158</figcaption></figure></li><li><p><strong>先根序列和后根序列不能确定</strong></p></li></ul><p><strong>已知含空指针的先根序列</strong></p><p><strong>递归实现，规定所给的先序序列如果有空指针则用 ”#“ 标识</strong></p><figure><img src="image-20231106192625787.png" alt="image-20231106192625787" /><figcaption aria-hidden="true">image-20231106192625787</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* root;</span><br><span class="line"><span class="type">char</span>* arry;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line"><span class="type">int</span> point;<span class="comment">//读到字符串的第几个了</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">solution</span>(<span class="type">char</span>* arr, <span class="type">int</span> si) :<span class="built_in">arry</span>(arr), <span class="built_in">size</span>(si)</span><br><span class="line">&#123;</span><br><span class="line">root = <span class="literal">NULL</span>;</span><br><span class="line">point = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* <span class="built_in">creatBinTree</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arry[point] == <span class="string">&#x27;#&#x27;</span> || point &gt; size - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">point++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> TreeNode* tmp = <span class="keyword">new</span> <span class="keyword">struct</span> TreeNode;</span><br><span class="line">tmp-&gt;val = arry[point];</span><br><span class="line"><span class="keyword">if</span> (point == <span class="number">0</span>) root = tmp;</span><br><span class="line">point++;</span><br><span class="line">tmp-&gt;left = <span class="built_in">creatBinTree</span>();</span><br><span class="line">tmp-&gt;right = <span class="built_in">creatBinTree</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>已知中根和后根序列</strong></p><p><strong>pta：</strong></p><p>给定非空二叉树的中根序列和后根序列，请编写程序创建该二叉树，计算其高度和先根序列；如给定的中根和后根序列不合法，则亦能识别。</p><p><strong>合法性</strong></p><blockquote><ul><li>长度要相同，可以都为0</li><li>任一字母的中序序列和后序序列<strong>左右元素相同</strong>，顺序可以不一致，通过递归实现</li></ul></blockquote><p><strong>已知先根和中根序列</strong></p><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/?envType=list&amp;envId=YAlgtJ0f">105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）</a></p><h4 id="复制二叉树">复制二叉树</h4><p>用<strong>遍历</strong>的方式进行复制</p><p>以后序遍历为例子</p><p><strong>复制过程：</strong>先复制子结点，再复制父结点，然后将父结 点与子结点链接起来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* <span class="built_in">copy</span>(<span class="keyword">struct</span> TreeNode* tmp, <span class="keyword">struct</span> TreeNode* tmp1)</span><br><span class="line">&#123;</span><br><span class="line">tmp1 = <span class="keyword">new</span> <span class="keyword">struct</span> TreeNode;</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;left != <span class="literal">NULL</span>) tmp1-&gt;left = <span class="built_in">copy</span>(tmp-&gt;left, tmp1-&gt;left);</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;right != <span class="literal">NULL</span>)    tmp1-&gt;right = <span class="built_in">copy</span>(tmp-&gt;right, tmp1-&gt;right);</span><br><span class="line"></span><br><span class="line">tmp1-&gt;val = tmp-&gt;val;</span><br><span class="line"><span class="keyword">return</span> tmp1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计算树的高度">计算树的高度</h4><p><strong>注意根节点是第0层还是第1层</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">high</span><span class="params">(<span class="keyword">struct</span> Node* root)</span><span class="comment">//根所在的是第一层</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> h1, h2;</span><br><span class="line"><span class="keyword">if</span> (root)</span><br><span class="line">&#123;</span><br><span class="line">h1 = <span class="built_in">high</span>(root-&gt;left);</span><br><span class="line">h2 = <span class="built_in">high</span>(root-&gt;right);</span><br><span class="line"><span class="keyword">return</span> h1 &gt; h2 ? h1 + <span class="number">1</span> : h2 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计算树的路径">计算树的路径</h4><p><strong>练习</strong></p><p><a href="https://leetcode.cn/problems/path-sum/?utm_source=LCUS&amp;utm_medium=ip_redirect&amp;utm_campaign=transfer2china">112. 路径总和 - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode *root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum == root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left, sum - root-&gt;val) || <span class="built_in">hasPathSum</span>(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/path-sum/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归  广度优先搜索</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode *root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode *&gt; que_node;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que_val;</span><br><span class="line">        que_node.<span class="built_in">push</span>(root);</span><br><span class="line">        que_val.<span class="built_in">push</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">while</span> (!que_node.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode *now = que_node.<span class="built_in">front</span>();</span><br><span class="line">            <span class="type">int</span> temp = que_val.<span class="built_in">front</span>();</span><br><span class="line">            que_node.<span class="built_in">pop</span>();</span><br><span class="line">            que_val.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (now-&gt;left == <span class="literal">nullptr</span> &amp;&amp; now-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp == sum) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (now-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                que_node.<span class="built_in">push</span>(now-&gt;left);</span><br><span class="line">                que_val.<span class="built_in">push</span>(now-&gt;left-&gt;val + temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (now-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                que_node.<span class="built_in">push</span>(now-&gt;right);</span><br><span class="line">                que_val.<span class="built_in">push</span>(now-&gt;right-&gt;val + temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/path-sum/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/path-sum-ii/description/">113. 路径总和 II - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">        targetSum -= root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; targetSum == <span class="number">0</span>) &#123;</span><br><span class="line">            ret.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, targetSum);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, targetSum);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> targetSum) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, targetSum);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/path-sum-ii/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/path-sum-iii/description/?utm_source=LCUS&amp;utm_medium=ip_redirect&amp;utm_campaign=transfer2china">437. 路径总和 III - 力扣（LeetCode）</a></p><p>我的思路：暴利破解，遍历每个节点 之后递归搜索有无路径满足</p><p>改进算法：</p><p>前缀和，</p><p><strong>PTA：</strong></p><p>编写程序找出二叉树中和最大的路径，二叉树结点为不等于0的整数。本题的“路径”限定为<strong>以根结点为起点，以叶结点为终点</strong>的路径。路径的和，即该路径所包含的所有结点的数据值之和。</p><p><strong>输入格式:</strong></p><p>输入为一组用空格间隔的整数，个数不超过100个，表示带空指针信息的二叉树先根序列。</p><p><strong>输出格式:</strong></p><p>输出为两行，第一行为该二叉树路径和的最大值，第二行为一组整数，每个整数后一个空格，即该最大路径包含的结点值（按从根的叶的顺序），如果存在多条满足条件路径，则输出最左边一条。</p><p><strong>输入样例1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 0 0 3 0 0</span><br></pre></td></tr></table></figure><p><strong>输出样例1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 3 </span><br></pre></td></tr></table></figure><p><strong>输入样例2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1 2 0 0 3 0 0</span><br></pre></td></tr></table></figure><p><strong>输出样例2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">-1 3 </span><br></pre></td></tr></table></figure><h4 id="查找给定结点的父结点">查找给定结点的父结点</h4><p>遍历的同时进行比较</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* <span class="built_in">Father</span>(<span class="keyword">struct</span> TreeNode* root,<span class="type">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root || (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == root-&gt;left-&gt;val) <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == root-&gt;right-&gt;val) <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* res = <span class="built_in">Father</span>(root-&gt;left, value);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* res1 = <span class="built_in">Father</span>(root-&gt;right, value);</span><br><span class="line">    <span class="keyword">if</span> (res != <span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> res1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找符合数据域条件的结点">查找符合数据域条件的结点</h4><p>遍历的同时进行比较</p><p>例如：采用递归前序遍历进行查找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* <span class="built_in">Find</span>(<span class="keyword">struct</span> TreeNode*root,<span class="type">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)&#123;<span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line"><span class="keyword">if</span> (value == root-&gt;val) <span class="keyword">return</span> root;</span><br><span class="line"><span class="built_in">findpreorder</span>(root-&gt;left, value);</span><br><span class="line"><span class="built_in">findpreorder</span>(root-&gt;right, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="释放二叉树">释放二叉树</h4><p>遍历的同时进行释放</p><p>如：采用层次遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteTree</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">struct</span> TreeNode*&gt; list;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    list.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* tmp;</span><br><span class="line">    <span class="keyword">while</span> (!list.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = list.<span class="built_in">front</span>();</span><br><span class="line">        list.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;left != <span class="literal">NULL</span>) list.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;right != <span class="literal">NULL</span>) list.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入结点">插入结点</h4><ul><li>在二叉树中插入结点，要<strong>确定待插入结点与插入位置结点的父子关系</strong>。</li><li>设p为指向待插入结点的指针，简称结点 p；s为指向插入位置结点 的指针，简称结点s. 即要确定 p 作为 s 的左儿子还是右儿子，以 及如何维护 s 原来的父子关系。</li></ul><p>指定为左儿子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">struct</span> TreeNode* s,<span class="keyword">struct</span> TreeNode* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>||p==<span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    p-&gt;left=s-&gt;left;</span><br><span class="line">    p-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">    s-&gt;left=p;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除给定结点及其左右子树">删除给定结点及其左右子树</h4><p>相较于释放二叉树，我们还需要改变父节点的内容。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(<span class="keyword">struct</span> TreeNode* root,<span class="keyword">struct</span> TreeNode* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>||p==<span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(root==p) &#123;<span class="built_in">deleteTree</span>(root); <span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* father=<span class="built_in">Father</span>(p);<span class="comment">//查找p的父节点</span></span><br><span class="line">    <span class="keyword">if</span>(father-&gt;left==q) father-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> father-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">deleteTree</span>(p);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="表达式树">表达式树</h4><p><strong>概念</strong></p><p>表达式有一个内在二叉树结构，即表达式(a+b) * (c−d)−e对应的二叉树，二叉树中叶结点是表达式中的变量或常数（如：a，b），非叶结点是操作符。</p><figure><img src="image-20231106213745029.png" alt="image-20231106213745029" /><figcaption aria-hidden="true">image-20231106213745029</figcaption></figure><p><strong>后缀表达式构造对应的表达式树</strong></p><figure><img src="image-20231106214008659.png" alt="image-20231106214008659" /><figcaption aria-hidden="true">image-20231106214008659</figcaption></figure><p>实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* <span class="built_in">creatBinTree</span>(<span class="type">char</span>* array, <span class="type">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* tmp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> point = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (point &lt;= size - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (array[point] == <span class="string">&#x27;+&#x27;</span> || array[point] == <span class="string">&#x27;-&#x27;</span> || array[point] == <span class="string">&#x27;*&#x27;</span> || array[point] == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">tmp = <span class="keyword">new</span> <span class="keyword">struct</span> <span class="built_in">TreeNode</span>(array[point]);</span><br><span class="line">tmp-&gt;left = ss.<span class="built_in">top</span>();</span><br><span class="line">ss.<span class="built_in">pop</span>();</span><br><span class="line">tmp-&gt;right = ss.<span class="built_in">top</span>();</span><br><span class="line">ss.<span class="built_in">pop</span>();</span><br><span class="line">ss.<span class="built_in">push</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tmp = <span class="keyword">new</span> <span class="keyword">struct</span> <span class="built_in">TreeNode</span>(array[point]);</span><br><span class="line">ss.<span class="built_in">push</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line">point++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ss.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>已知表达式树，计算其对应的值</strong></p><p>将表达式树转换为后缀表达式，再利用栈计算后缀表达式的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">double</span>&gt; cacu;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* root;</span><br><span class="line">vector&lt;<span class="type">char</span>&gt; v;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tree2array</span><span class="params">(<span class="keyword">struct</span> TreeNode* tmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (tmp-&gt;left != <span class="literal">NULL</span>) <span class="built_in">Tree2array</span>(tmp-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (tmp-&gt;right != <span class="literal">NULL</span>) <span class="built_in">Tree2array</span>(tmp-&gt;right);</span><br><span class="line">    v.<span class="built_in">push_back</span>(tmp-&gt;val);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Treecaculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> lh = <span class="number">0</span>, rh = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Tree2array</span>(root);</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">char</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it &lt; v.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*it == <span class="string">&#x27;+&#x27;</span> || *it == <span class="string">&#x27;-&#x27;</span> || *it == <span class="string">&#x27;*&#x27;</span> || *it == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (*it)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">case</span>(<span class="string">&#x27;+&#x27;</span>):</span><br><span class="line">                    &#123;rh = cacu.<span class="built_in">top</span>();</span><br><span class="line">                     cacu.<span class="built_in">pop</span>();</span><br><span class="line">                     lh = cacu.<span class="built_in">top</span>();</span><br><span class="line">                     cacu.<span class="built_in">pop</span>();</span><br><span class="line">                     cacu.<span class="built_in">push</span>(lh + rh);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="built_in">case</span>(<span class="string">&#x27;-&#x27;</span>):</span><br><span class="line">                    &#123;rh = cacu.<span class="built_in">top</span>();</span><br><span class="line">                     cacu.<span class="built_in">pop</span>(); </span><br><span class="line">                     lh = cacu.<span class="built_in">top</span>(); </span><br><span class="line">                     cacu.<span class="built_in">pop</span>(); </span><br><span class="line">                     cacu.<span class="built_in">push</span>(lh - rh); </span><br><span class="line">                     <span class="keyword">break</span>; &#125;</span><br><span class="line">                <span class="built_in">case</span>(<span class="string">&#x27;*&#x27;</span>): </span><br><span class="line">                    &#123;rh = cacu.<span class="built_in">top</span>(); </span><br><span class="line">                     cacu.<span class="built_in">pop</span>(); </span><br><span class="line">                     lh = cacu.<span class="built_in">top</span>();</span><br><span class="line">                     cacu.<span class="built_in">pop</span>(); </span><br><span class="line">                     cacu.<span class="built_in">push</span>(lh * rh);</span><br><span class="line">                     <span class="keyword">break</span>; &#125;</span><br><span class="line">                <span class="built_in">case</span>(<span class="string">&#x27;/&#x27;</span>): </span><br><span class="line">                    &#123;rh = cacu.<span class="built_in">top</span>();</span><br><span class="line">                     cacu.<span class="built_in">pop</span>(); </span><br><span class="line">                     lh = cacu.<span class="built_in">top</span>();</span><br><span class="line">                     cacu.<span class="built_in">pop</span>();</span><br><span class="line">                     cacu.<span class="built_in">push</span>(lh / rh);</span><br><span class="line">                     <span class="keyword">break</span>; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cacu.<span class="built_in">push</span>(*it - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (cacu.<span class="built_in">top</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线索化二叉树">*线索化二叉树</h2><p><strong>概念</strong></p><blockquote><p>通过遍历二叉树可得到结点的一个线性序列，在<strong>线性序列</strong>中，除第一个结点外，每个结点有且仅有一个前驱， 除最后一个结点外，每个结点有且仅有一个后继。 但在二叉树中只能找到结点的左孩子、右孩子，结点在<strong>线性序列中的前驱和后继</strong>只有在遍历过程中才能得到</p></blockquote><p>为了与结点在二叉树中所具有的前驱（即父结点）和后继即子结 点）区别开来，通常把某种序列中结点的前驱或后继冠以某种遍历 的名称，如把中根序列中结点的前驱称作中根前驱，结点的后继称 作中根后继。</p><p><strong>节点变化：</strong></p><figure><img src="image-20231107190809887.png" alt="image-20231107190809887" /><figcaption aria-hidden="true">image-20231107190809887</figcaption></figure><figure><img src="image-20231107190947535.png" alt="image-20231107190947535" /><figcaption aria-hidden="true">image-20231107190947535</figcaption></figure><figure><img src="image-20231107191653826.png" alt="image-20231107191653826" /><figcaption aria-hidden="true">image-20231107191653826</figcaption></figure><p><strong>[目的]</strong></p><p>​ 在<strong>中序线索二叉树</strong>中不需要对二叉树进行遍历就可以方便地找到给定结点的<strong>中序前驱和中序后继结点</strong>，并且不需要太多额外的空间。</p><p><strong><u>线索二叉树中一个结点是叶结点的充要条件为：左、 右标识(LThread、RThread)均为1。</u></strong></p><h4 id="相关操作">相关操作</h4><p><strong>搜索以t为根的线索二叉树的中根序列的第一个结点</strong></p><p><strong>【算法思想】：</strong></p><ol type="1"><li>若t有左子树，则第一个节点是左子树最左下的节点。</li><li>若t无左子树，则第一个节点是t。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> Lthread;</span><br><span class="line">    <span class="type">bool</span> Rthread;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* left;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">returnfirst</span>(<span class="keyword">struct</span> ThreadBinTree* root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* p=root;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;Lthread==<span class="number">0</span>) p=p-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>搜索以t为根的线索二叉树的中根序列的最后一个结点</strong></p><p><strong>『算法思想』</strong></p><ol type="1"><li>若t有右子树则最后一个为最右下方的节点</li><li>若没有，则t即为最后一个</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">returnlast</span>(<span class="keyword">struct</span> ThreadBinTree* root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* p=root;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;Rthread==<span class="number">0</span>) p=p-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在中序线索二叉树中,查找结点p的<u>中根前驱</u>结点</strong></p><p><strong>『算法思想』</strong></p><ol type="1"><li>若p节点的Lthread=1，则left指向的即为中序前驱节点</li><li>若为Lthread=0，则p的左子树的中根序列最后一个结点即为p的中根前驱节点</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">returnlast</span>(<span class="keyword">struct</span> ThreadBinTree* root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">returnpre</span>(<span class="keyword">struct</span> ThreadBinTree* p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;Lthread) <span class="keyword">return</span> p-&gt;left;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span>(<span class="built_in">returnlast</span>(p-&gt;left));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在中序线索二叉树中,查找结点p的<u>中根后继</u>结点</strong></p><p><strong>『算法思想』</strong></p><ol type="1"><li>若p节点的Rthread=1，则right指向的即为中序前驱节点</li><li>若为Rthread=0，则p的右子树的中根序列第一个结点即为p的中根前驱节点</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">returnfirst</span>(<span class="keyword">struct</span> ThreadBinTree* root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">returnafter</span>(<span class="keyword">struct</span> ThreadBinTree* p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;Rthread) <span class="keyword">return</span> p-&gt;right;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span>(<span class="built_in">returnlast</span>(p-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>中序遍历线索二叉树</strong></p><p>正向遍历</p><p><strong>『算法思想』</strong></p><p>只要先找到中序序列中的<strong>第一个结点</strong>，然后依次找结点的<strong>中序后继</strong>直至其为 空时止</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">returnfirst</span>(<span class="keyword">struct</span> ThreadBinTree* root);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">returnafter</span>(<span class="keyword">struct</span> ThreadBinTree* p);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(<span class="keyword">struct</span> ThreadBinTree* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* first=<span class="built_in">returnfirst</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(first!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;first-&gt;val;</span><br><span class="line">        first=<span class="built_in">returnafter</span>(first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>反向遍历</strong></p><p><strong>『算法思想』</strong></p><p>只要先找到中序序列中的<strong>最后一个结点</strong>，然后依次找结点的<strong>中序前驱</strong>直至其为空时止</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">returnlast</span>(<span class="keyword">struct</span> ThreadBinTree* root);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">returnpre</span>(<span class="keyword">struct</span> ThreadBinTree* p);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deinorder</span><span class="params">(<span class="keyword">struct</span> ThreadBinTree* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* last=<span class="built_in">returnpre</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(last!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;last-&gt;val;</span><br><span class="line">        last=<span class="built_in">returnpre</span>(last);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>中根序列线索二叉树插入节点</strong></p><p><strong>例如：</strong>在线索二叉树中插入结点p作为结点s的右子结点，</p><p><strong>『算法思想』</strong></p><ol type="1"><li><p><strong>s没有右子节点</strong></p><p>​ <img src="image-20231109190718789.png" alt="image-20231109190718789" /></p></li></ol><p>此时对于结点s我们需要改变以下内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;Rthread=s-&gt;Rthread;</span><br><span class="line">p-&gt;right=s-&gt;right;</span><br><span class="line">s-&gt;right=p;</span><br><span class="line">s-&gt;Rthread=<span class="number">0</span>;</span><br><span class="line">p-&gt;Lthread=<span class="number">1</span>;</span><br><span class="line">p-&gt;left=s;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li><strong>s有右子节点</strong></li></ol><figure><img src="image-20231109191109896.png" alt="image-20231109191109896" /><figcaption aria-hidden="true">image-20231109191109896</figcaption></figure><p>此时对于结点s我们需要改变以下内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;Rthread=s-&gt;Rthread;</span><br><span class="line">p-&gt;right=s-&gt;right;</span><br><span class="line">p-&gt;Lthread=<span class="number">1</span>;</span><br><span class="line">p-&gt;left=s;</span><br><span class="line">s-&gt;right=p;</span><br><span class="line">q=p-&gt;right;</span><br><span class="line">q=<span class="built_in">returnfirst</span>(q);</span><br><span class="line">q-&gt;left=p;</span><br></pre></td></tr></table></figure><p>综上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">struct</span> ThreadBinTree* s,<span class="keyword">struct</span> ThreadBinTree* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;right=s-&gt;right;</span><br><span class="line">    p-&gt;Rthread=s-&gt;Rthread;</span><br><span class="line">    p-&gt;left=s;</span><br><span class="line">    p-&gt;Lthread=<span class="number">1</span>;</span><br><span class="line">    s-&gt;right=p;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(s-&gt;Rthread==<span class="number">1</span>)<span class="comment">//s没有右子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;Rthread=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有右子树</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* tmp=p-&gt;right;</span><br><span class="line">    tmp=<span class="built_in">returnfirst</span>(tmp);</span><br><span class="line">    tmp-&gt;left=p;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线索二叉树删除节点</strong></p><p><strong>以删除右孩子为例讨论删除算法：</strong></p><p>即：在一棵中序线索二叉树中，结点 s 的右子结点 p 存在，删除 p</p><p><strong>『算法思想』</strong></p><p><strong>分类：</strong></p><ol type="1"><li><p>p为叶子节点，没有左右子树</p><figure><img src="image-20231109193435838.png" alt="image-20231109193435838" /><figcaption aria-hidden="true">image-20231109193435838</figcaption></figure></li><li><p>p没有左子树，但有右子树</p><figure><img src="image-20231109193507445.png" alt="image-20231109193507445" /><figcaption aria-hidden="true">image-20231109193507445</figcaption></figure></li><li><p>p没有右子树，但有左子树</p><figure><img src="image-20231109193631495.png" alt="image-20231109193631495" /><figcaption aria-hidden="true">image-20231109193631495</figcaption></figure></li><li><p>p既有左子树，又有右子树</p></li></ol><p>​ <img src="image-20231109193648175.png" alt="image-20231109193648175" /></p><p><strong>线索化二叉树</strong></p><p>遍历的同时复制并修改结点域</p><p>例如：中序线索化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">BinTree2ThreadTree</span>(<span class="keyword">struct</span> TreeNode* root,)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">BinTree2ThreadTree</span>(root-&gt;left);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哈夫曼树">哈夫曼树</h2><figure><img src="image-20231109200421248.png" alt="image-20231109200421248" /><figcaption aria-hidden="true">image-20231109200421248</figcaption></figure><figure><img src="image-20231109200432792.png" alt="image-20231109200432792" /><figcaption aria-hidden="true">image-20231109200432792</figcaption></figure><p><strong>预备知识</strong></p><figure><img src="image-20231109200554739.png" alt="image-20231109200554739" /><figcaption aria-hidden="true">image-20231109200554739</figcaption></figure><blockquote><p><strong>「定义5.6」</strong> 扩充二叉树的外通路长度定义为<strong>从根到每个外结点的路径长度之 和</strong>，内通路长度定义为从根到<strong>每个内结点的路径长度之和</strong>。</p></blockquote><figure><img src="image-20231109200749078.png" alt="image-20231109200749078" /><figcaption aria-hidden="true">image-20231109200749078</figcaption></figure><blockquote><p><strong>「定义5.7」</strong></p><p>给扩充二叉树的 n 个外结点分别赋上一个实数权。扩充二叉树 的加权外通路长度定义为: <span class="math display">\[WPL=\sum\limits_{i=1}^{n}w_iL_i\]</span> 其中 n 表示外结点的个数，wi 和 Li 分别 表示外结点 ki的权值和根到 ki的路径长度。</p></blockquote><figure><img src="image-20231109201819723.png" alt="image-20231109201819723" /><figcaption aria-hidden="true">image-20231109201819723</figcaption></figure><blockquote><p><strong>「定义5.8」</strong></p><p>在外结点权值分别为 w1 , w2 , … , wn的所有扩充二叉树中，加权外通路长度最小的扩充二叉树称为最优二叉树</p></blockquote><figure><img src="image-20231109201854960.png" alt="image-20231109201854960" /><figcaption aria-hidden="true">image-20231109201854960</figcaption></figure><p><strong>构造哈夫曼树</strong></p><p><strong>「算法思想」</strong></p><figure><img src="image-20231109202023891.png" alt="image-20231109202023891" /><figcaption aria-hidden="true">image-20231109202023891</figcaption></figure><figure><img src="image-20231109202220497.png" alt="image-20231109202220497" /><figcaption aria-hidden="true">image-20231109202220497</figcaption></figure><figure><img src="image-20231109202410225.png" alt="image-20231109202410225" /><figcaption aria-hidden="true">image-20231109202410225</figcaption></figure><blockquote><p>在外结点权值分别为w1 ,w2 ,…,wn的扩充二叉树中，由哈 夫曼算法构造出的哈夫曼树的带权路径长度最小，因此哈夫曼树为<strong>最优二叉树</strong>。</p></blockquote><blockquote><p>由观察可知，字符集中的字符所在的结点均是哈夫曼树中的外结点。哈夫曼树中<strong>没有度为 1 的结点</strong></p></blockquote><blockquote><p>在构造哈夫曼树的过程中，没有一片树叶是其他树叶的 祖先，所以<strong>每个叶结点对应的编码不可能是其他叶结点 对应的编码的前缀，</strong>由此可知哈夫曼编码是二进制的前缀码。</p></blockquote><p><strong>「代码实现」</strong></p><figure><img src="image-20231109203436647.png" alt="image-20231109203436647" /><figcaption aria-hidden="true">image-20231109203436647</figcaption></figure><p>假设给定m个实数（代表权值）对应结点的地址存于一维数组H[1: m+1]中，该数组已按结点的Weight域排序，即： <span class="math display">\[Weight(H[1])\leq..\leq  Weight(H[m])\leq  Weightleq\leq +\infty\]</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HuffmanTreeNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HuffmanTreeNode</span>* Llink;</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line"><span class="comment">//也可以加一个info字段代表是什么字符</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HuffmanTreeNode</span>* Rlink;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HuffmanTreeNode</span>* <span class="built_in">createHuffmanTree</span>(<span class="type">int</span>* arr, <span class="type">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> root;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HuffmanTreeNode</span>* H = <span class="keyword">new</span> <span class="keyword">struct</span> HuffmanTreeNode[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= size - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">H[i].Llink = <span class="literal">NULL</span>;</span><br><span class="line">H[i].Rlink = <span class="literal">NULL</span>;</span><br><span class="line">H[i].weight = arr[i];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= size - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HuffmanTreeNode</span> tmp;</span><br><span class="line">tmp.weight = H[i].weight + H[i + <span class="number">1</span>].weight;</span><br><span class="line">tmp.Llink = &amp;H[i];</span><br><span class="line">tmp.Rlink = &amp;H[i + <span class="number">1</span>];</span><br><span class="line"><span class="comment">//插入排序，将tmp插入原来的序列并保持有序</span></span><br><span class="line">root = i + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (tmp.weight &gt; H[root].weight)</span><br><span class="line">&#123;</span><br><span class="line">H[root - <span class="number">1</span>] = H[root];</span><br><span class="line">root++;</span><br><span class="line">&#125;</span><br><span class="line">H[root - <span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;H[root];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="image-20231109211156143.png" alt="image-20231109211156143" /><figcaption aria-hidden="true">image-20231109211156143</figcaption></figure><figure><img src="image-20231109211225493.png" alt="image-20231109211225493" /><figcaption aria-hidden="true">image-20231109211225493</figcaption></figure><p><strong>PTA</strong></p><blockquote><p>编写一个哈夫曼编码译码程序。针对一段文本，根据文本中字符出现频率构造哈夫曼树，给出每个字符的哈夫曼编码，并进行译码，计算编码前后文本大小。 为确保构建的哈夫曼树唯一，本题做如下限定：</p><ol type="1"><li>选择根结点权值最小的两棵二叉树时，选取<strong>权值较小者作为左子树</strong>。</li><li>若多棵二叉树根结点权值相等，则<strong>先生成的作为左子树</strong>，后生成的作为右子树，具体来说：i) 对于单结点二叉树，优先选择根结点对应字母在文本中最先出现者，如文本为cba，三个字母均出现1次，但c在文本中最先出现，b第二出现，故则选择c作为左子树，b作为右子树。ii) 对于非单结点二叉树，先生成的二叉树作为左子树，后生成的二叉树作为右子树。iii. 若单结点和非单结点二叉树根结点权值相等，优先选择单结点二叉树。</li><li>生成哈夫曼编码时，哈夫曼树<strong>左分支标记为0，右分支标记为1</strong>。</li></ol><p><strong>输入格式:</strong></p><p>输入为3行。第1行为一个字符串，包含不超过5000个字符，至少包含两个不同的字符，每个字符为a-z的小写字母。第2、3行为两个由0、1组成的字符串，表示待译码的哈夫曼编码。</p><p><strong>输出格式:</strong></p><p>输出第一行为用空格间隔的2个整数，分别为压缩前后文本大小，以字节为单位，一个字符占1字节，8个二进制位占1字节，若压缩后文本不足8位，则按1字节算。输出从第二行开始，每行为1个字符的哈夫曼编码，按各字符在文本中出现次数递增顺序输出，若多个字符出现次数相同，则按其在文本出现先后排列。每行格式为“字母:编码”。最后两行为两行字符串，表示译码结果，若译码失败，则输出INVALID。</p><p><strong>输入样例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cbaxyyzz</span><br><span class="line">0100</span><br><span class="line">011</span><br></pre></td></tr></table></figure><p><strong>输出样例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">8 3</span><br><span class="line">c:100</span><br><span class="line">b:101</span><br><span class="line">a:110</span><br><span class="line">x:111</span><br><span class="line">y:00</span><br><span class="line">z:01</span><br><span class="line">zy</span><br><span class="line">INVALID</span><br></pre></td></tr></table></figure></blockquote><p><strong>扩展:k进制编码</strong></p><p><a href="https://www.acwing.com/activity/content/problem/content/384/">荷马史诗</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,<span class="type">int</span>&gt; PLI;<span class="comment">//权值 所在的深度</span></span><br><span class="line">priority_queue&lt;PLI,vector&lt;PLI&gt;,greater&lt;PLI&gt;&gt; heap;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> K = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        LL w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;w);</span><br><span class="line">        heap.<span class="built_in">push</span>(&#123;w,<span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>((n<span class="number">-1</span>)%(k<span class="number">-1</span>)!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    LL res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LL s=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> depth=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)<span class="comment">//取出前k个</span></span><br><span class="line">        &#123;</span><br><span class="line">            PLI tmp=heap.<span class="built_in">top</span>();</span><br><span class="line">            heap.<span class="built_in">pop</span>();</span><br><span class="line">            s+=tmp.first;</span><br><span class="line">            depth=<span class="built_in">max</span>(depth,tmp.second);</span><br><span class="line">        &#125;</span><br><span class="line">        res+=s;<span class="comment">//合并就会导致节点加一层</span></span><br><span class="line">        heap.<span class="built_in">push</span>(&#123;s,depth+<span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   cout&lt;&lt;res&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;heap.<span class="built_in">top</span>().second&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树的存储与操作">树的存储与操作</h2><p>略</p><p>待更新</p><h2 id="等价类与并查集">等价类与并查集</h2><figure><img src="image-20231109211344638.png" alt="image-20231109211344638" /><figcaption aria-hidden="true">image-20231109211344638</figcaption></figure><p>学习途径：<a href="https://zhuanlan.zhihu.com/p/93647900">并查集——Pecco 知乎详解</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>* left;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>* right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DSU</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; parent;<span class="comment">//一开始，我们先将它们的父节点设为自己</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; rank; <span class="comment">//每个节点对应的树的高度，初值为1</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">DSU</span>(<span class="type">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">parent.<span class="built_in">resize</span>(size + <span class="number">1</span>);</span><br><span class="line">rank.<span class="built_in">resize</span>(size + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size + <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">parent[i] = i;</span><br><span class="line">rank[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">// 寻找x所在的树的根节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (parent[x] == x)<span class="comment">//自己就是父节点即找到了根节点则返回</span></span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">parent[x] = <span class="built_in">find</span>(parent[x]);<span class="comment">//找父亲的父节点</span></span><br><span class="line"><span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">find</span>(i), y = <span class="built_in">find</span>(j);</span><br><span class="line"><span class="keyword">if</span> (rank[x] &lt;= rank[y]) <span class="comment">//x高度低于y或相等时，把i挂在j的树上</span></span><br><span class="line">&#123;</span><br><span class="line">parent[x] = y;<span class="comment">//i所在树的根节点x 的父节点是j所在树的根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">parent[y] = x;<span class="comment">//j所在树的根节点的父节点是i所在树的根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rank[x] == rank[y] &amp;&amp; x != y) <span class="comment">//如果高度相等并且 i和j所在的树不相同 则j的树高度要加一</span></span><br><span class="line">&#123;</span><br><span class="line">rank[y]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="图">图</h1><h2 id="存储结构-1">存储结构</h2><h3 id="邻接矩阵">邻接矩阵</h3><figure><img src="image-20231112090728805.png" alt="image-20231112090728805" /><figcaption aria-hidden="true">image-20231112090728805</figcaption></figure><figure><img src="image-20231112090748991.png" alt="image-20231112090748991" /><figcaption aria-hidden="true">image-20231112090748991</figcaption></figure><figure><img src="image-20231112090816704.png" alt="image-20231112090816704" /><figcaption aria-hidden="true">image-20231112090816704</figcaption></figure><blockquote><p>无向图的邻接矩阵对称，可压缩存储；有n个顶点的无向图所需存储空间为n(n+1)/2；</p><p>有向图的邻接矩阵不一定对称；有n个顶点的有向图所需存储空间为n²</p></blockquote><h3 id="邻接表">邻接表</h3><figure><img src="image-20231112091633952.png" alt="image-20231112091633952" /><figcaption aria-hidden="true">image-20231112091633952</figcaption></figure><blockquote><p>边链表里VerAdj是与顶点相连的节点编号，cost是权值，link指向下一个与顶点相连的节点</p></blockquote><blockquote><p>VerName是顶点名字，adjacent指向与其相连的节点链表</p></blockquote><figure><img src="image-20231112091849162.png" alt="image-20231112091849162" /><figcaption aria-hidden="true">image-20231112091849162</figcaption></figure><figure><img src="image-20231112091952212.png" alt="image-20231112091952212" /><figcaption aria-hidden="true">image-20231112091952212</figcaption></figure><blockquote><p>对于边很多的图（也称稠密图），适于用邻接矩阵存储，因为占用的空间少。</p><p>而对于顶点多而边少的图（也称稀疏图），若用邻接矩阵存储， 对应的邻接矩阵将是一个稀疏矩阵，存储利用率很低。因此，顶点多而边少的图适于用邻接表存储</p></blockquote><h3 id="其他存储结构">其他存储结构</h3><figure><img src="image-20231112092304534.png" alt="image-20231112092304534" /><figcaption aria-hidden="true">image-20231112092304534</figcaption></figure><figure><img src="image-20231112092317950.png" alt="image-20231112092317950" /><figcaption aria-hidden="true">image-20231112092317950</figcaption></figure><h2 id="图的遍历">图的遍历</h2><p><a href="https://www.luogu.com.cn/problem/P3916">图的遍历 洛谷</a></p><h3 id="深度优先遍历">深度优先遍历</h3><p><strong>递归算法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> VerAdj;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>* link;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> name;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>* adjacent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DepthFirstSearch</span><span class="params">(<span class="keyword">struct</span> Node* head,<span class="type">int</span> v,<span class="type">int</span>* visit,<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; head[v].name&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">visit[v] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>* p = head[v].adjacent;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (visit[p-&gt;VerAdj] != <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DepthFirstSearch</span>(head, p-&gt;VerAdj, visit, size);</span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;link;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">struct</span> Node* head,<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* visited=<span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= size<span class="number">-1</span>; i++) visited[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= size<span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (visited[i] != <span class="number">0</span>)</span><br><span class="line"><span class="built_in">DepthFirstSearch</span>(head, i, visited, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="image-20231112165358070.png" alt="image-20231112165358070" /><figcaption aria-hidden="true">image-20231112165358070</figcaption></figure><p><strong>迭代算法</strong></p><p>利用栈进行访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> VerAdj;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span>* link;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> name;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span>* adjacent;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">struct</span> Node* head, <span class="type">int</span> size,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* visited = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; ss;</span><br><span class="line">    ss.<span class="built_in">push</span>(v);</span><br><span class="line">    <span class="keyword">while</span> (!ss.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Node</span> p = head[ss.<span class="built_in">top</span>()];</span><br><span class="line">        <span class="keyword">if</span> (visited[p.name] != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; p.name &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            visited[p.name] = <span class="number">1</span>;</span><br><span class="line">            ss.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">edge</span>* q = p.adjacent;</span><br><span class="line">            <span class="keyword">while</span> (q != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited[q-&gt;VerAdj] != <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ss.<span class="built_in">push</span>(q-&gt;VerAdj);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                q = q-&gt;link;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="image-20231112175225401.png" alt="image-20231112175225401" /><figcaption aria-hidden="true">image-20231112175225401</figcaption></figure><h3 id="广度优先遍历">广度优先遍历</h3><p>使用<strong>队列</strong>实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> VerAdj;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span>* link;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> name;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span>* adjacent;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">struct</span> Node* head, <span class="type">int</span> size, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* visited = <span class="keyword">new</span> <span class="type">int</span>[size + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= size; i++)  visited[i] = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">    cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    list.<span class="built_in">push</span>(v);</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!list.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">edge</span>* p = head[list.<span class="built_in">front</span>()].adjacent;</span><br><span class="line">        list.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[p-&gt;VerAdj] != <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; p-&gt;VerAdj &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                visited[p-&gt;VerAdj] = <span class="number">1</span>;</span><br><span class="line">                list.<span class="built_in">push</span>(p-&gt;VerAdj);</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="image-20231112181329874.png" alt="image-20231112181329874" /><figcaption aria-hidden="true">image-20231112181329874</figcaption></figure><figure><img src="image-20231112181406328.png" alt="image-20231112181406328" /><figcaption aria-hidden="true">image-20231112181406328</figcaption></figure><figure><img src="image-20231112181546799.png" alt="image-20231112181546799" /><figcaption aria-hidden="true">image-20231112181546799</figcaption></figure><h2 id="拓扑排序">拓扑排序</h2><blockquote><p><strong>AOV</strong>网：<strong>在有向图中</strong>，用顶点表示活动，用有向边表示活动之间的<strong>先后关系</strong>，称这样的有向图为AOV网(Activity On Vertex Network)。重点在于研究结点Verterx</p></blockquote><blockquote><p>在AOV网络中，如果活动Vi 必须在活动Vj 之前进行，则存在有向边，<strong>AOV网络中不能出现有向回路，</strong>即有向环。 在AOV网络中如果出现了有向环，则意味着某项活动应以自己作为先决条件。 因此，对给定的AOV网络，应判断它是否存在有向环</p></blockquote><figure><img src="image-20231112182247852.png" alt="image-20231112182247852" /><figcaption aria-hidden="true">image-20231112182247852</figcaption></figure><blockquote><p>如果通过拓扑排序能将AOV网络的所有顶点都排入一个拓扑有序的序列中，则该AOV网络中必定不会出现有向环；<strong>相反，如果得不到满足要求的拓扑有序序列，则说明AOV网络中存在有向环</strong>， 此AOV网络所代表的工程是不可行的</p></blockquote><p><strong>「算法思想」</strong></p><ol type="1"><li>从网中选择一个入度为0的顶点并将其输出。</li><li>从网中删除该顶点及其所有出边。</li><li>执行1 、2 ，直至所有顶点都已输出，或者网中剩余顶点的度均不为0（说明网中存在回路，无法继续拓扑排序）。</li></ol><p><strong>注意：对于任何无回路的AOV网，其顶点均可排成拓扑序列，但其拓扑序列未必唯一</strong></p><figure><img src="image-20231114200441806.png" alt="image-20231114200441806" /><figcaption aria-hidden="true">image-20231114200441806</figcaption></figure><figure><img src="image-20231114200505007.png" alt="image-20231114200505007" /><figcaption aria-hidden="true">image-20231114200505007</figcaption></figure><figure><img src="image-20231114200610199.png" alt="image-20231114200610199" /><figcaption aria-hidden="true">image-20231114200610199</figcaption></figure><p><strong>入栈时：count[i]记录当前的栈顶，top赋值为新的栈顶</strong></p><p><strong>出栈时：top即为栈顶的编号，count[top]为栈顶下面的元素编号</strong></p><p><strong>实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TopoOrder</span><span class="params">(<span class="keyword">struct</span> Node* Head,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* count = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n<span class="number">-1</span>; i++)<span class="comment">//初始化count数组</span></span><br><span class="line">&#123;</span><br><span class="line">count[n] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i++)<span class="comment">//初始化count数组</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>* p = Head[i].adjacent;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">count[p-&gt;VerAdj]++;</span><br><span class="line">p = p-&gt;link;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> top = <span class="number">-1</span>; <span class="comment">// 将数组变成虚拟栈</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (count[i] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">count[i] = top;</span><br><span class="line">top=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i++)<span class="comment">//已经无 有向环 的前提下</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (top == <span class="number">-1</span>) <span class="keyword">return</span> ;<span class="comment">//无度为0的结点</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp = <span class="number">-1</span>;</span><br><span class="line">temp = top;</span><br><span class="line">top = count[top];</span><br><span class="line">std::cout &lt;&lt; temp&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>* p = Head[temp].adjacent;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)<span class="comment">//更新count数组和虚拟栈</span></span><br><span class="line">&#123;</span><br><span class="line">count[p-&gt;VerAdj]--;</span><br><span class="line"><span class="keyword">if</span> (count[p-&gt;VerAdj] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">count[p-&gt;VerAdj] = top;</span><br><span class="line">top = p-&gt;VerAdj;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">                p = p-&gt;link;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习一：</strong></p><p><a href="https://leetcode.cn/problems/course-schedule/description/">课程表</a></p><p><strong>要注意判断是否有有向环</strong></p><p>官方题解：</p><p>一：深度优先搜索</p><p>深度优先搜索，将拓扑排序与深度优先搜索联系在一起，二者都是先完成前一个结点再完成后一个结点</p><blockquote><p>对于图中的任意一个节点，它在搜索的过程中有三种状态，即：</p><ul><li><p>「未搜索」：我们还没有搜索到这个节点；</p></li><li><p>「搜索中」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成；</p></li><li><p>「已完成」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的<strong>更底部的位置</strong>，满足拓扑排序的要求。</p></li></ul><p>通过上述的三种状态，我们就可以给出使用深度优先搜索得到拓扑排序的算法流程，在每一轮的搜索搜索开始时，我们任取一个「未搜索」的节点开始进行深度优先搜索。</p><ul><li><p>我们将当前搜索的节点 u 标记为「搜索中」，遍历该节点的每一个相邻节点 v：</p></li><li><p>​ 如果 v为「未搜索」，那么我们开始搜索 v，待搜索完成回溯到 u；</p></li><li><p>​ 如果 v为「搜索中」，那么我们就找到了图中的一个环，因此是不存在拓扑排序的；</p></li><li><p>​ 如果 v为「已完成」，那么说明 v已经在栈中了，而 u还不在栈中，因此 u 无论何时入栈都不会影响到 (u,v) 之前的拓扑关系，以及不用进行任何操作。</p></li><li><p>当 u 的所有相邻节点都为「已完成」时，我们将 u 放入栈中，并将其标记为「已完成」。</p></li></ul><p>在整个深度优先搜索的过程结束后，如果我们没有找到图中的环，那么栈中存储这所有的 n个节点，从栈顶到栈底的顺序即为一种拓扑排序。</p></blockquote><blockquote><p><strong>优化</strong></p><p>由于我们只需要判断是否存在一种拓扑排序，而栈的作用仅仅是存放最终的拓扑排序结果，因此我们可以只记录每个节点的状态，而省去对应的栈。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; visited;</span><br><span class="line">    <span class="type">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        visited[u] = <span class="number">1</span>;<span class="comment">//将本结点标记为搜索中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v: edges[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>)</span><br><span class="line">            &#123;<span class="comment">//如果邻接结点未搜索，则开始搜索</span></span><br><span class="line">                <span class="built_in">dfs</span>(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;<span class="comment">//搜索完V发现有环，结束,上面几层均是结束</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;<span class="comment">//如果结点在搜索中存在环，记录并返回</span></span><br><span class="line">                valid = <span class="literal">false</span>;<span class="comment">//记录</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//不存在环则邻接结点完全搜索完，将本结点标记</span></span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">resize</span>(numCourses);<span class="comment">//初始化边结点的数目</span></span><br><span class="line">        visited.<span class="built_in">resize</span>(numCourses);<span class="comment">//初始化访问标记的数目</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;<span class="comment">//结点状态为0则开始搜索</span></span><br><span class="line">                <span class="built_in">dfs</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/course-schedule/description/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>二：广度优先搜索</p><p>这个方法类似与课本上的解法，只不过是用队列进行实现。</p><p><strong>重点是判断能否产生拓扑序列</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; indeg;<span class="comment">//入度记录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        indeg.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]);</span><br><span class="line">            ++indeg[info[<span class="number">0</span>]];<span class="comment">//更新入度表</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;<span class="comment">//建立度为0的队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> visited = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;<span class="comment">//计算可以去掉的结点有多少个</span></span><br><span class="line">            ++visited;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v: edges[u]) &#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> visited == numCourses;<span class="comment">//如果全可以去掉则不存在有向环则可以产生拓扑序列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/course-schedule/description/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>练习二：</p><p><a href="https://leetcode.cn/problems/course-schedule-ii/description/">课程表二</a></p><h2 id="关键路径">关键路径</h2><blockquote><p>如果在<strong>有向无环</strong>的<strong>带权</strong>图中 ：</p><ul><li>用有向边表示一个工程中的各项活动(Activity) •</li><li>用边上的权值表示活动的持续时间(Duration)</li><li>用顶点表示事件(Event)</li></ul><p>则这样的有向图叫做用边表示活动的网络，简称AOE (Activity On <strong>Edges</strong>)网络。</p></blockquote><blockquote><p>● 源点：表示整个工程的开始（入度为零）。</p><p>● 汇点：表示整个工程的结束（出度为零）</p></blockquote><figure><img src="image-20231115170037611.png" alt="image-20231115170037611" /><figcaption aria-hidden="true">image-20231115170037611</figcaption></figure><blockquote><p>在AOE网络中, 有些活动必须顺序进行，有些活动可以并行进行。</p><p>从源点到各个顶点，以至从源点到汇点的有向路径可能不止一条。 这些路径的长度也可能不同。完成不同路径的活动所需的时间虽 然不同，但<strong>只有各条路径上的所有活动都完成了，整个工程才算完成</strong>。</p><p>因此，<strong>完成整个工程所需的时间</strong>取决于从源点到汇点的最长路径长度，<strong>即路径上所有活动的持续时间之和</strong>。路径长度最长的路径被称为<strong>关键路径</strong>(Critical Path)。</p></blockquote><figure><img src="image-20231115170628128.png" alt="image-20231115170628128" /><figcaption aria-hidden="true">image-20231115170628128</figcaption></figure><figure><img src="image-20231115172253166.png" alt="image-20231115172253166" /><figcaption aria-hidden="true">image-20231115172253166</figcaption></figure><figure><img src="image-20231115172306261.png" alt="image-20231115172306261" /><figcaption aria-hidden="true">image-20231115172306261</figcaption></figure><p><strong>事件——结点</strong></p><p>最早事件<strong>发生</strong>时间 ve(i) 源点到i点的最长路径长度，即前一个邻接结点的ve加上路径权值最大的那一个</p><p>最晚事件<strong>发生</strong>时间 vl(i) 即后一个邻接结点的vl减去路径权值取最小的那一个，即减去了<strong>时间最长的活动</strong>（“关键活动”）的时长</p><p><strong>活动——边</strong></p><p>最早活动<strong>开始</strong>时间 e(i)</p><p>最晚活动<strong>开始</strong>时间 e(i)</p><p><strong>「算法」</strong></p><ol type="1"><li><strong>判断是否存在有向环</strong>，通过拓扑排序进行判断，如果有有向环则中止算法，如果没有，则<strong>按照拓扑排序的顺序</strong>求出各个事件的最早发生时间ve</li><li>按照拓扑排序的<strong>逆序列</strong>求出每个事件的最晚发生事件vl</li><li>根据ve和vl确定活动的最早开始时间e(i)和最晚开始时间l(i)，如果<strong>二者相等则为关键活动</strong></li></ol><p><strong>「实现」</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> name;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span>* link;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> Veradj;</span><br><span class="line">    <span class="type">int</span> cost;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span>* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AOE</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>* Head;<span class="comment">//经过拓扑排序后的结点序列</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    vector&lt;<span class="keyword">struct</span> edge&gt; critical;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">criticalPath</span><span class="params">(<span class="keyword">struct</span> Node* Head, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//求关键路径之前先判断是否存在有向环，不存在则将结点按拓扑排序排好送入Head</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ve</span><span class="params">(num)</span>, <span class="title">vl</span><span class="params">(num)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= num - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ve[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num - <span class="number">1</span>; i++)<span class="comment">//汇点不在范围内,因为没有出边</span></span><br><span class="line">        &#123;<span class="comment">//按拓扑序列进行计算</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">edge</span>* p = Head[i].link;</span><br><span class="line">            <span class="type">int</span> k = Head[i].name;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">NULL</span>)<span class="comment">//求事件最早happen时间</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;cost + ve[k] &gt; ve[p-&gt;Veradj])</span><br><span class="line">                &#123;</span><br><span class="line">                    ve[p-&gt;Veradj] = p-&gt;cost + ve[i];</span><br><span class="line">                &#125;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= num - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vl[i] = ve[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = num - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;<span class="comment">//求事件最晚发生时间</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">edge</span>* p = Head[i].link;</span><br><span class="line">            <span class="type">int</span> k = p-&gt;Veradj;</span><br><span class="line">            <span class="keyword">while</span> (p)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (vl[k] - p-&gt;cost &lt; vl[Head[i].name])</span><br><span class="line">                &#123;</span><br><span class="line">                    vl[Head[i].name] = vl[k] - p-&gt;cost;</span><br><span class="line">                &#125;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= num - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;<span class="comment">//求活动的最晚最早开始事件</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">edge</span>* p = Head[i].link;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>, e = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> k = p-&gt;Veradj;</span><br><span class="line">                e = ve[Head-&gt;name];</span><br><span class="line">                l = vl[k] - p-&gt;cost;</span><br><span class="line">                <span class="keyword">if</span> (e == l)<span class="comment">//相等即为关键活动</span></span><br><span class="line">                &#123;</span><br><span class="line">                    critical.<span class="built_in">push_back</span>(*p);</span><br><span class="line">                &#125;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>「时间复杂度」</strong></p><figure><img src="image-20231115223943001.png" alt="image-20231115223943001" /><figcaption aria-hidden="true">image-20231115223943001</figcaption></figure><blockquote><p>定理 6.3 任意的非空AOE网<strong>至少</strong>存在一条关键路径。</p></blockquote><blockquote><p>推论 6.1 假设&lt;Ti,Tj&gt;边属于AOE网，则有 <span class="math display">\[vl[j]-ve[i]\geq weight(&lt;Ti,Tj&gt;)\]</span> 如果属于关键路径则： <span class="math display">\[vl[j]-ve[i]= weight(&lt;Ti,Tj&gt;)\]</span></p></blockquote><h2 id="最短路径问题">最短路径问题</h2><p><a href="https://www.luogu.com.cn/training/5312#problems">洛谷最短路径问题题单</a></p><h3 id="单源最短路径">单源最短路径</h3><p><strong>单源：即只有一个出发点</strong></p><p><strong>1.无权最短路径</strong></p><blockquote><p>无权：即每条边的权值都为1</p></blockquote><blockquote><p>源点到各顶点的路径<strong>所经历的边的数目</strong>就是路径的长度</p><p>相对于源点<strong>由近及远</strong>依次求各顶点的最短路径</p></blockquote><p><strong>「算法思想」</strong></p><blockquote><p>Di 为源点S到顶点 i 的最短路径长度;初始：Ds =0 ∀i ≠ S，Di = -1</p><ol type="1"><li>访问初始顶点S，对S的所有邻接顶点w, 若Dw = -1，则Dw =Ds+1</li><li>v是当前被访问的顶点，对于v的所有邻接顶点w, 若Dw = -1，则 Dw =Dv +1</li><li>处理完v的所有邻接顶点后，访问另一个满足Du =Dv的顶点u，若不存 在这样的顶点，则访问满足Du =Dv +1的顶点u，若仍不存在，算法结束.</li></ol></blockquote><p><strong>图的广度优先遍历。</strong></p><figure><img src="image-20231116163259067.png" alt="image-20231116163259067" /><figcaption aria-hidden="true">image-20231116163259067</figcaption></figure><figure><img src="image-20231116163444506.png" alt="image-20231116163444506" /><figcaption aria-hidden="true">image-20231116163444506</figcaption></figure><p><strong>「实现」</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">noValueMap</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;<span class="keyword">struct</span> Node&gt;Head;<span class="comment">//邻接表的首节点</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; list;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShortestPath</span><span class="params">(<span class="type">int</span> v)</span><span class="comment">//v是起点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">path</span><span class="params">(Head.size())</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(Head.size())</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= Head.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">path[i] = <span class="number">-1</span>;</span><br><span class="line">dist[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">dist[v] = <span class="number">0</span>;</span><br><span class="line">list.<span class="built_in">push</span>(v);</span><br><span class="line"><span class="keyword">while</span> (!list.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tmp = list.<span class="built_in">front</span>();</span><br><span class="line">list.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>* p = Head[tmp].adjacent;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> k = p-&gt;VerAdj;</span><br><span class="line"><span class="keyword">if</span> (dist[k] == <span class="number">-1</span>)<span class="comment">//没被访问过</span></span><br><span class="line">&#123;</span><br><span class="line">dist[k] = dist[tmp]+<span class="number">1</span>;</span><br><span class="line">list.<span class="built_in">push</span>(k);</span><br><span class="line">path[k] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;link;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>「复杂度」</strong></p><figure><img src="image-20231116165054100.png" alt="image-20231116165054100" /><figcaption aria-hidden="true">image-20231116165054100</figcaption></figure><p><strong>2.正权最短路径</strong></p><p><strong>「前提」</strong></p><p><strong>每条边的权值为正数</strong></p><figure><img src="image-20231116165552262.png" alt="image-20231116165552262" /><figcaption aria-hidden="true">image-20231116165552262</figcaption></figure><p><strong>迪杰斯特拉算法</strong></p><p><strong>「算法思想」</strong></p><blockquote><p>把图中所有顶点分成两个集合，</p><p>​ 第一个集合 包含已确定最短路径的顶点，</p><p>​ 第二个集合 包含尚未确定最短路径的顶点。</p><p>按照<strong>最短路径长度递增</strong>的顺序逐 个把第二个集合的顶点加到第一个集合中去，直至从源点出发可以到达的所有顶点都包含到第一个集合中</p></blockquote><blockquote><p>步骤：</p><ol type="1"><li>初始时( S为初始顶点） D[s] =0 (<strong>起点的距离</strong>为0)且∀ i ≠ S 有D[ i ] =MAX(无穷，根据题目换成权值的最大值+1)。</li><li>在未访问的顶点中选择<strong>D值最小</strong>的顶点v，访问v，令 S[v]=1（表示已被访问）。</li><li>依次考察v的<strong>邻接顶点</strong>w，若 D[ v ]+weight(&lt;v，w&gt;) &lt; Dw ， 则改变Dw的值，使Dw = Dv + weight(&lt;v，w&gt;) 。</li><li>重复 2、3，直至所有顶点皆被访问（找到源点到该顶点的最短路径）</li></ol></blockquote><figure><img src="image-20231119105737954.png" alt="image-20231119105737954" /><figcaption aria-hidden="true">image-20231119105737954</figcaption></figure><p><strong>「实现」</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> VerAdj;</span><br><span class="line"><span class="type">int</span> cost;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>* link;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> name;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>* adjacent;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PositiveValuePath</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;<span class="keyword">struct</span> Node&gt; Head;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dist;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> Max = <span class="number">1000</span>;<span class="comment">//取决于题目权值的约束条件，一定要比最大值大</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DshortsPath</span><span class="params">(<span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dist.<span class="built_in">resize</span>(Head.<span class="built_in">size</span>());</span><br><span class="line">path.<span class="built_in">resize</span>(Head.<span class="built_in">size</span>());</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(Head.size())</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= Head.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">dist[i] = Max;</span><br><span class="line">path[i] = <span class="number">-1</span>;</span><br><span class="line">visited[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">dist[start] = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> next = start;</span><br><span class="line">visited[next] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= Head.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>* p = Head[next].adjacent;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> k = p-&gt;VerAdj;</span><br><span class="line"><span class="keyword">if</span> (visited[k] == <span class="number">0</span> &amp;&amp; dist[next] + p-&gt;cost &lt; dist[k])</span><br><span class="line">&#123;</span><br><span class="line">dist[k] = dist[next] + p-&gt;cost;</span><br><span class="line">path[k] = next;<span class="comment">//在源点到k点的最短路中，k的上一个节点是next</span></span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;link;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> min = Max;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= Head.<span class="built_in">size</span>() - <span class="number">1</span>; i++)<span class="comment">//更新next，在未访问节点中选取距离最近的节点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dist[i] &lt; min &amp;&amp; visited[i] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">next = i;</span><br><span class="line">min = dist[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">visited[next] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure><img src="image-20231119111932519.png" alt="image-20231119111932519" /><figcaption aria-hidden="true">image-20231119111932519</figcaption></figure><p><strong><u>算法结束时</u>，dist[x]将包括所有最短路径的长度。</strong></p><p><strong>「练习」</strong></p><p><a href="https://leetcode.cn/problems/network-delay-time/description/">网络延迟时间</a></p><figure><img src="image-20231119122232538.png" alt="image-20231119122232538" /><figcaption aria-hidden="true">image-20231119122232538</figcaption></figure><p>对于<strong>稀疏图</strong>，即边的个数远小于点的个数时，<strong>时间效率不高</strong>，可以采用<strong>优先队列</strong>进行改进。</p><p>优先队列相关内容见线性表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DshortsPath</span><span class="params">(<span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; plist;</span><br><span class="line">       <span class="comment">//优先队列，按照piar的第一个数据升序排列</span></span><br><span class="line">dist[start] = <span class="number">0</span>;</span><br><span class="line">plist.<span class="built_in">push</span>(&#123; <span class="number">0</span>,start &#125;);<span class="comment">//&lt;距离，节点号&gt;</span></span><br><span class="line"><span class="type">int</span> node_size = date.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span> (plist.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> t = plist.<span class="built_in">top</span>();</span><br><span class="line">plist.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">int</span> tindex = t.second, distance = t.first;</span><br><span class="line"><span class="keyword">if</span> (visited[tindex])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">visited[tindex] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EDGE</span>* p = date[tindex].next;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> index = p-&gt;adj_index;</span><br><span class="line"><span class="keyword">if</span> (!visited[index] &amp;&amp; dist[tindex] + p-&gt;val &lt; dist[index])</span><br><span class="line">&#123;</span><br><span class="line">dist[index] = dist[tindex] + p-&gt;val;</span><br><span class="line">plist.<span class="built_in">push</span>(&#123; dist[index],index &#125;);<span class="comment">//将求过距离的节点放入优先队列中排序，以便生成下次访问的节点</span></span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; node_size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dist[i] != Max)<span class="comment">//可以到达</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, dist[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="每对顶点之间的最短路径">每对顶点之间的最短路径</h3><p><strong>Floyd算法</strong></p><p><strong>「基本思想」</strong></p><figure><img src="image-20231121215600271.png" alt="image-20231121215600271" /><figcaption aria-hidden="true">image-20231121215600271</figcaption></figure><figure><img src="image-20231121220114159.png" alt="image-20231121220114159" /><figcaption aria-hidden="true">image-20231121220114159</figcaption></figure><figure><img src="image-20231121220247584.png" alt="image-20231121220247584" /><figcaption aria-hidden="true">image-20231121220247584</figcaption></figure><p><strong>「实现」</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myMap</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edge;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dist;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> MAX ;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AllLength</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">A</span>(edge.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;=edge.<span class="built_in">size</span>()<span class="number">-1</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= edge.<span class="built_in">size</span>() - <span class="number">1</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                A[i][j] = edge[i][j];</span><br><span class="line">                <span class="keyword">if</span> (edge[i][j] &lt; MAX &amp;&amp; i != j) path[i][j] = i;<span class="comment">//i到j的路上前一个节点是i</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    path[i][j] = <span class="number">-1</span>;<span class="comment">//无路可走</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= edge.<span class="built_in">size</span>() - <span class="number">1</span>; k++)<span class="comment">//不断添加经过的范围</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= edge.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j&lt;= edge.<span class="built_in">size</span>() - <span class="number">1</span>; j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (j != k &amp;&amp; j != i &amp;&amp; A[i][k] &lt; MAX &amp;&amp; A[k][j] &lt; MAX &amp;&amp; A[i][k] + A[k][j] &lt; A[i][j])</span><br><span class="line">                            <span class="comment">//i到k可及，k到j可及</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            A[i][j] = A[i][k] + A[k][j];</span><br><span class="line">                            path[i][j] = path[k][j];<span class="comment">//i经由k到j的路上前一个节点是 k到j上的前一个节点</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> myMap::MAX = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p><strong>「复杂度」</strong></p><figure><img src="image-20231121222347936.png" alt="image-20231121222347936" /><figcaption aria-hidden="true">image-20231121222347936</figcaption></figure><p><strong>「练习」</strong></p><p><a href="https://leetcode.cn/problems/evaluate-division/description/?utm_source=LCUS&amp;utm_medium=ip_redirect&amp;utm_campaign=transfer2china">力扣 除法求值</a></p><h3 id="满足约束的最短路径">*满足约束的最短路径</h3><figure><img src="image-20231125110927125.png" alt="image-20231125110927125" /><figcaption aria-hidden="true">image-20231125110927125</figcaption></figure><p><strong>「算法思路」</strong></p><figure><img src="image-20231125111316497.png" alt="image-20231125111316497" /><figcaption aria-hidden="true">image-20231125111316497</figcaption></figure><figure><img src="image-20231125112146476.png" alt="image-20231125112146476" /><figcaption aria-hidden="true">image-20231125112146476</figcaption></figure><figure><img src="image-20231125112206584.png" alt="image-20231125112206584" /><figcaption aria-hidden="true">image-20231125112206584</figcaption></figure><h2 id="最小支撑树">最小支撑树</h2><blockquote><p>对于一个无向网络——无向加权连通图N=(V, E, C)（C表示该图为 权图），其顶点个数为|V|=n，图中边的个数为|E|，可以从它的|E|条边 中选出n-1条边，使之满足：</p><ol type="1"><li><p>这n-1条边和图的n个顶点构成一个连通图。</p></li><li><p>该连通图的代价（n-1条边上的权值之和）是所有满足条件(1)的 连通图的代价的最小值。</p></li></ol><p>这样的连通图被称为网络的最小支撑树</p></blockquote><figure><img src="image-20231125112342879.png" alt="image-20231125112342879" /><figcaption aria-hidden="true">image-20231125112342879</figcaption></figure><h3 id="prim算法">Prim算法</h3><p><strong>「算法思路」</strong></p><figure><img src="image-20231125112558260.png" alt="image-20231125112558260" /><figcaption aria-hidden="true">image-20231125112558260</figcaption></figure><p>​ <img src="image-20231125144316659.png" alt="image-20231125144316659" /></p><p><strong>「实现」</strong></p><p>假定编号从1开始</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">EDGE</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> head;</span><br><span class="line"><span class="type">int</span> tail;</span><br><span class="line"><span class="type">int</span> cost;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myMap</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> MAX;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adjcent;<span class="comment">//邻接矩阵</span></span><br><span class="line">vector&lt;<span class="keyword">struct</span> EDGE&gt; TE;<span class="comment">//最小支撑树边的集合</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prim</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TE.<span class="built_in">resize</span>(adjcent.<span class="built_in">size</span>());</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">closedge</span>(adjcent.<span class="built_in">size</span>());<span class="comment">//lowcost vex 权值和U中的顶点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= adjcent.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">closedge[i].first = adjcent[<span class="number">1</span>][i];<span class="comment">// 初始状态U中只有起点1</span></span><br><span class="line">closedge[i].second = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">closedge[<span class="number">1</span>].second = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= adjcent.<span class="built_in">size</span>(); j++)<span class="comment">//有n个点，n-1条边加入TE</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> v = <span class="number">0</span>, min = MAX;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= adjcent.<span class="built_in">size</span>(); i++)<span class="comment">//找最短的</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (closedge[i].second != <span class="number">-1</span> &amp;&amp; closedge[i].first &lt; min)</span><br><span class="line">&#123;</span><br><span class="line">v = i;</span><br><span class="line">min = closedge[i].first;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (v != <span class="number">0</span>)<span class="comment">//找到了</span></span><br><span class="line">&#123;</span><br><span class="line">TE[count].head = closedge[v].second;</span><br><span class="line">TE[count].tail = v;</span><br><span class="line">TE[count].cost = closedge[v].first;</span><br><span class="line">count++;</span><br><span class="line">closedge[v].first = <span class="number">0</span>;<span class="comment">//v is putted in group U</span></span><br><span class="line">closedge[v].second = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= adjcent.<span class="built_in">size</span>(); k++)<span class="comment">//更新closedge数组</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (closedge[k].second != <span class="number">-1</span> &amp;&amp; adjcent[v][k] &lt; closedge[k].first)</span><br><span class="line">&#123;</span><br><span class="line">closedge[k].first = adjcent[v][k];</span><br><span class="line">closedge[k].second = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//图不连通</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;NOT CONNECTED&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> myMap::MAX = <span class="number">100</span>;<span class="comment">/////</span></span><br></pre></td></tr></table></figure><p><strong>注意MAX的值一定要大于边界条件</strong></p><figure><img src="image-20231125163221574.png" alt="image-20231125163221574" /><figcaption aria-hidden="true">image-20231125163221574</figcaption></figure><p><strong>「练习」</strong></p><p><a href="https://leetcode.cn/problems/min-cost-to-connect-all-points/description/">力扣 连接所有点的最小费用</a></p><h3 id="kruskal算法">Kruskal算法</h3><p><strong>「算法思路」</strong></p><figure><img src="image-20231125162612696.png" alt="image-20231125162612696" /><figcaption aria-hidden="true">image-20231125162612696</figcaption></figure><p><del>Prim是重点在于已知一个点在U中找与其相邻的最小权值边，而Kruskal算法在于已知所有点在不同的连通分量里找权值最小的边</del></p><figure><img src="image-20231125162944745.png" alt="image-20231125162944745" /><figcaption aria-hidden="true">image-20231125162944745</figcaption></figure><figure><img src="image-20231125163134781.png" alt="image-20231125163134781" /><figcaption aria-hidden="true">image-20231125163134781</figcaption></figure><p><strong>「实现」</strong></p><p>依旧要借用辅助数组TE来记录支撑树的边,还要由数组E保存图中的边</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">EDGE</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> head;</span><br><span class="line"><span class="type">int</span> tail;</span><br><span class="line"><span class="type">int</span> cost;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myMap</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> T;<span class="comment">//连通分量，初识也是点的个数</span></span><br><span class="line">vector&lt;EDGE&gt; E;<span class="comment">//图中所有边集合</span></span><br><span class="line">vector&lt;<span class="keyword">struct</span> EDGE&gt; TE;<span class="comment">//最小支撑树边的集合</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(EDGE a, EDGE b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.cost &lt;= b.cost;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TE.<span class="built_in">resize</span>(E.<span class="built_in">size</span>());</span><br><span class="line">std::<span class="built_in">sort</span>(E.<span class="built_in">begin</span>(), E.<span class="built_in">end</span>(),cmp);</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (T &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> v1 = E[j].head;</span><br><span class="line"><span class="type">int</span> v2 = E[j].tail;</span><br><span class="line"><span class="type">int</span> cost = E[j].cost;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Find</span>(v1) != <span class="built_in">Find</span>(v2))<span class="comment">//不在一个连通分支中</span></span><br><span class="line">&#123;</span><br><span class="line">TE[count].head = v1;</span><br><span class="line">TE[count].tail = v2;</span><br><span class="line">TE[count].cost = cost;</span><br><span class="line">count++;</span><br><span class="line"><span class="built_in">merge</span>(v1, v2);</span><br><span class="line">T--;</span><br><span class="line">&#125;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="图的应用">图的应用</h2><h3 id="可及性与传递闭包">可及性与传递闭包</h3><p><strong>warshall算法</strong></p><p><strong>「基本概念」</strong></p><figure><img src="image-20231125170212022.png" alt="image-20231125170212022" /><figcaption aria-hidden="true">image-20231125170212022</figcaption></figure><blockquote><p><strong>沃尔肖（Warshall）算法：</strong> 求有向图G可及矩阵的算法，递推公式如下： <span class="math display">\[WSM^{(K)}[i][j]=WSM^{(k-1)}[i][j]\quad OR\quad(WSM^{(k-1)}[i][k]\quad AND\quad WSM^{(K-1)}[k][j])\\ \qquad \qquad 1\leq k \leq n\]</span> 其中 <span class="math display">\[WSM^0 = A\quad (加上主对角线元素1) \quad A是有向图G的邻接矩阵\\WSM^{(k)}[i][j]表示定点i只经过顶点1,2,...,k到达j的可及性\]</span></p></blockquote><p><strong>「实现」</strong></p><figure><img src="image-20231130191358878.png" alt="image-20231130191358878" /><figcaption aria-hidden="true">image-20231130191358878</figcaption></figure><figure><img src="image-20231130192912825.png" alt="image-20231130192912825" /><figcaption aria-hidden="true">image-20231130192912825</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myMAP</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">Warshall</span>()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; wsm = A;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= A.<span class="built_in">size</span>() - <span class="number">1</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= A.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (wsm[i][k] = <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= A.<span class="built_in">size</span>() - <span class="number">1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">wsm[i][j] = wsm[i][j] + wsm[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> wsm;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>拓扑逆序算法</strong></p><p><strong>「算法思想」</strong></p><figure><img src="image-20231130193447217.png" alt="image-20231130193447217" /><figcaption aria-hidden="true">image-20231130193447217</figcaption></figure><figure><img src="image-20231130193415347.png" alt="image-20231130193415347" /><figcaption aria-hidden="true">image-20231130193415347</figcaption></figure><p>「实现」</p><figure><img src="image-20231130194254569.png" alt="image-20231130194254569" /><figcaption aria-hidden="true">image-20231130194254569</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myMAP</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;Node&gt; head;<span class="comment">//图的邻接表已经按照拓扑序列排列过</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tranclo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; REACH;</span><br><span class="line">vector&lt;<span class="type">int</span> &gt; Breach;</span><br><span class="line">Breach.<span class="built_in">resize</span>(head.<span class="built_in">size</span>());</span><br><span class="line">REACH.<span class="built_in">resize</span>(head.<span class="built_in">size</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= head.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">Breach[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = head.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">Breach[i] = <span class="number">1</span>;</span><br><span class="line">REACH[i].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EDGE</span>* p = head[i].link;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = p-&gt;num;</span><br><span class="line"><span class="keyword">if</span> (Breach[j] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= REACH[j].<span class="built_in">size</span>() - <span class="number">1</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Breach[k] ==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">REACH[i].<span class="built_in">push_back</span>(k);</span><br><span class="line">Breach[k] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= head.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">Breach[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="连通分量">连通分量</h3><p><strong>「算法思想」</strong></p><figure><img src="image-20231130202654827.png" alt="image-20231130202654827" /><figcaption aria-hidden="true">image-20231130202654827</figcaption></figure><p><strong>在求出可及性的基础上进行计算，wsm[ i ] [ j ] =1&amp;&amp;wsm[ j ] [ i ]=1 成立即i和j在一个连通分量里。</strong></p><h1 id="排序">排序</h1><h2 id="基本概念和指标">基本概念和指标</h2><blockquote><p>关键字域（key）：排序依据</p><p>主关键词：如果在数据表中各个对象的关键词互不相同，这种关键词即主关键词。按照主关键词进行排序，排序的结果是唯一的。</p><p>次关键词：数据表中有些对象的关键词可能相同，这种关键词称为次关键词。按照次关键词进行排序，排序的结果不一定唯一</p></blockquote><blockquote><p>稳定性：对于一开始表中主关键词域相同的对象，排序前后相对顺序不变</p><p>排序的时间开销：即排序算法的时间复杂度，是衡量算法好坏的 最重要的标志，可用算法执行过程中关键词的比较次数与记录的 移动次数来衡量。</p></blockquote><blockquote><p>有些排序算法的时间复杂度受记录关键词序列初始排列及记录个数影响较大，此时，按最好情况、最坏情况及平均情况，分别估算比较次数和移动次数。</p><p>算法执行时所需的附加存储空间，是评价排序算法好坏的另外一 个指标</p></blockquote><figure><img src="image-20231130203508041.png" alt="image-20231130203508041" /><figcaption aria-hidden="true">image-20231130203508041</figcaption></figure><h2 id="插入排序">插入排序</h2><h3 id="直接插入排序">直接插入排序</h3><p><strong>「算法思想」</strong></p><p>将一个记录插入到已经排好序的有序表中，从而获得一个新的、记录数增加1的有序表。</p><p><strong>「实现」</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>「分析」</strong></p><figure><img src="image-20231228185940386.png" alt="image-20231228185940386" /><figcaption aria-hidden="true">image-20231228185940386</figcaption></figure><p><strong>「稳定性」</strong></p><p><strong>具有稳定性。</strong></p><p>「改进」</p><p>将<strong>顺序查找</strong>改为<strong>二分查找</strong>，构造二分/对半插入排序算法</p><p>也是个稳定的排序方法</p><h3 id="希尔排序">希尔排序</h3><p>对直接插入排序的改进</p><p><strong>「算法思想」</strong></p><figure><img src="image-20231228190556468.png" alt="image-20231228190556468" /><figcaption aria-hidden="true">image-20231228190556468</figcaption></figure><figure><img src="image-20231228190623271.png" alt="image-20231228190623271" /><figcaption aria-hidden="true">image-20231228190623271</figcaption></figure><figure><img src="image-20231228190713082.png" alt="image-20231228190713082" /><figcaption aria-hidden="true">image-20231228190713082</figcaption></figure><figure><img src="image-20231228190809518.png" alt="image-20231228190809518" /><figcaption aria-hidden="true">image-20231228190809518</figcaption></figure><p><strong>「实现」</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>「增量的取法」</strong></p><figure><img src="image-20231228190906374.png" alt="image-20231228190906374" /><figcaption aria-hidden="true">image-20231228190906374</figcaption></figure><p><strong>「复杂度」</strong></p><figure><img src="image-20231228191037103.png" alt="image-20231228191037103" /><figcaption aria-hidden="true">image-20231228191037103</figcaption></figure><figure><img src="image-20231228191043450.png" alt="image-20231228191043450" /><figcaption aria-hidden="true">image-20231228191043450</figcaption></figure><figure><img src="image-20231228191246262.png" alt="image-20231228191246262" /><figcaption aria-hidden="true">image-20231228191246262</figcaption></figure><p><strong>「稳定性」</strong></p><p><strong>不稳定</strong></p><h2 id="交换排序">交换排序</h2><h3 id="冒泡排序">冒泡排序</h3><p><strong>「算法思想」</strong></p><p>从左到右/从上到下 比较相邻记录的关键词，交换存在逆序的记录</p><blockquote><p>经过一次冒泡排序可以把最大关键词的记录移动到最后</p><p>经过n-1次，就可以对所有记录排序</p><p>发生一次记录交换，反序对少一个</p></blockquote><p><strong>「实现」</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>「改进」</strong></p><p>某趟扫描没有任何记录交换的时候就算法终止</p><p><strong>「复杂度」</strong></p><figure><img src="image-20231228191947851.png" alt="image-20231228191947851" /><figcaption aria-hidden="true">image-20231228191947851</figcaption></figure><figure><img src="image-20231228192251995.png" alt="image-20231228192251995" /><figcaption aria-hidden="true">image-20231228192251995</figcaption></figure><p><strong>「稳定性」</strong></p><p><strong>稳定</strong></p><h3 id="快速排序分划交换排序">快速排序(分划交换排序)</h3><p><strong>「算法思想」</strong></p><figure><img src="image-20231228192527737.png" alt="image-20231228192527737" /><figcaption aria-hidden="true">image-20231228192527737</figcaption></figure><p><strong>「实现」</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>「复杂度」</strong></p><figure><img src="image-20231228193524847.png" alt="image-20231228193524847" /><figcaption aria-hidden="true">image-20231228193524847</figcaption></figure><p><strong>改进：</strong> <img src="image-20231228194055159.png" alt="image-20231228194055159" /></p><figure><img src="image-20231228194133557.png" alt="image-20231228194133557" /><figcaption aria-hidden="true">image-20231228194133557</figcaption></figure><p><strong>「稳定性」</strong></p><p><strong>不稳定</strong></p><h2 id="选择排序">选择排序</h2><h3 id="直接选择排序">直接选择排序</h3><p><strong>「算法思想」</strong></p><figure><img src="image-20231228200101145.png" alt="image-20231228200101145" /><figcaption aria-hidden="true">image-20231228200101145</figcaption></figure><p><strong>「实现」</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>「复杂度」</strong></p><figure><img src="image-20231228200243718.png" alt="image-20231228200243718" /><figcaption aria-hidden="true">image-20231228200243718</figcaption></figure><figure><img src="image-20231228200411426.png" alt="image-20231228200411426" /><figcaption aria-hidden="true">image-20231228200411426</figcaption></figure><p><strong>改进：</strong></p><blockquote><p>选择排序的关键是找最大或者最小记录，利用树形保存前面的比较结果，下一次选择时直接利用，可以大大减少比较次数</p><figure><img src="image-20231228200859044.png" alt="image-20231228200859044" /><figcaption aria-hidden="true">image-20231228200859044</figcaption></figure><p><strong>相关概念</strong></p><p>比赛树：每次两两比较的结果把关键词大者作为优胜者上升到父结点，，称 这种树为比赛树 外结点：位于最底层的叶结点 内结点：非叶结点</p><figure><img src="image-20231228201249293.png" alt="image-20231228201249293" /><figcaption aria-hidden="true">image-20231228201249293</figcaption></figure><figure><img src="image-20231228201415248.png" alt="image-20231228201415248" /><figcaption aria-hidden="true">image-20231228201415248</figcaption></figure></blockquote><p><strong>「稳定性」</strong></p><p><strong>不稳定</strong></p><h3 id="堆排序">堆排序</h3><blockquote><p>堆：：<strong>完全二叉树</strong>中的任意结点的关键词大于等于它的两个子结点的关键词，把这样的数据结构称为堆（<strong>大根堆</strong> ）</p><p>大根堆中根结点的关键词最大，小根堆中根结点的关键词最小。</p></blockquote><figure><img src="image-20231228201723577.png" alt="image-20231228201723577" /><figcaption aria-hidden="true">image-20231228201723577</figcaption></figure><p><strong>「算法思想」</strong></p><figure><img src="image-20231228201835198.png" alt="image-20231228201835198" /><figcaption aria-hidden="true">image-20231228201835198</figcaption></figure><p><strong>过程：</strong></p><ol type="1"><li><p>建堆</p></li><li><p>交换再重建堆</p><figure><img src="image-20231228202751553.png" alt="image-20231228202751553" /><figcaption aria-hidden="true">image-20231228202751553</figcaption></figure></li></ol><figure><img src="image-20231228202716431.png" alt="image-20231228202716431" /><figcaption aria-hidden="true">image-20231228202716431</figcaption></figure><p>​ <img src="image-20231228203139519.png" alt="image-20231228203139519" /></p><p><strong>「实现」</strong></p><p><strong>堆存储于顺序线性表（数组）中</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>「复杂度」</strong></p><figure><img src="image-20231228204228279.png" alt="image-20231228204228279" /><figcaption aria-hidden="true">image-20231228204228279</figcaption></figure><p><strong>「稳定性」</strong></p><p><strong>不稳定</strong></p><h2 id="合并排序">合并排序</h2><blockquote><ol type="1"><li>合并/归并：把两个或多个有序文件组成一个单一的有序文件。</li><li>基于合并操作完成排序。</li></ol></blockquote><blockquote><p>当 i 和 j 分别在两个表内变化时，通过比较A[i]与B[j]的关键词大小，依次把 <strong>关键词小</strong>的对象放到新表X[k]中；</p><p>当 i与 j中有一个<strong>超出表长</strong>时，将另一个表中的<strong>剩余部分</strong>照抄到新表X中</p></blockquote><figure><img src="image-20231228204800031.png" alt="image-20231228204800031" /><figcaption aria-hidden="true">image-20231228204800031</figcaption></figure><p><strong>「实现」</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>改进：</strong></p><blockquote><p>分析合并排序算法，不难发现它的两个缺点：</p><ol type="1"><li>当数据集非常小 时，比如只有2个元素，仍然采用分治策略，影响效率。</li><li>Merge算法基于元素移动，当元素比较大时，移动操作比较费时</li></ol><p>➢针对这两个问题的解决办法：</p><ol type="1"><li>对于小数据集以及前几趟合并操作，调用直接插入排序算法 。</li><li>将数组存储改为链表存储，这样记录移动变为指针移动</li></ol></blockquote><p><strong>「复杂度」</strong></p><figure><img src="image-20231228210738722.png" alt="image-20231228210738722" /><figcaption aria-hidden="true">image-20231228210738722</figcaption></figure><p><strong>「稳定性」</strong></p><p><strong>稳定</strong></p><h2 id="基于关键词比较的排序算法分析">基于关键词比较的排序算法分析</h2><figure><img src="image-20231228211003577.png" alt="image-20231228211003577" /><figcaption aria-hidden="true">image-20231228211003577</figcaption></figure><h2 id="分治排序的一般方法">分治排序的一般方法</h2><blockquote><p>快速排序、合并排序，应用了分治策略</p></blockquote><figure><img src="image-20231228211507430.png" alt="image-20231228211507430" /><figcaption aria-hidden="true">image-20231228211507430</figcaption></figure><h2 id="分布排序">分布排序</h2><figure><img src="image-20231228211613438.png" alt="image-20231228211613438" /><figcaption aria-hidden="true">image-20231228211613438</figcaption></figure><p><strong>「复杂度」</strong></p><p>时间复杂度可以达到线性阶。</p><h3 id="基数分布排序">基数分布排序</h3><figure><img src="image-20231228212050722.png" alt="image-20231228212050722" /><figcaption aria-hidden="true">image-20231228212050722</figcaption></figure><blockquote><p><strong>基于基数分布的排序（基数排序）</strong></p><ol type="1"><li>最高次序位法 ：先按高位分桶，然后桶内进行排序 如：英文单词，扑克牌</li><li>最低次序位法 ：先按最低位排序，然后按下一个次低位排序，…， 最后按最高位排序。</li></ol></blockquote><figure><img src="image-20231228212242265.png" alt="image-20231228212242265" /><figcaption aria-hidden="true">image-20231228212242265</figcaption></figure><p><strong>「实现」</strong></p><figure><img src="image-20240106192844493.png" alt="image-20240106192844493" /><figcaption aria-hidden="true">image-20240106192844493</figcaption></figure><h3 id="值分布排序">值分布排序</h3><figure><img src="image-20231228212717956.png" alt="image-20231228212717956" /><figcaption aria-hidden="true">image-20231228212717956</figcaption></figure><p><strong>「实现」</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>例如：堆三元组表存储的稀疏矩阵，求转置矩阵，可以利用值排序</p><figure><img src="image-20231228213101065.png" alt="image-20231228213101065" /><figcaption aria-hidden="true">image-20231228213101065</figcaption></figure><figure><img src="image-20231228213111411.png" alt="image-20231228213111411" /><figcaption aria-hidden="true">image-20231228213111411</figcaption></figure><h1 id="查找">查找</h1><h2 id="线性表的查找">线性表的查找</h2><h3 id="顺序查找">顺序查找</h3><p><strong>「无序表顺序查找」</strong></p><p>查找失败的查找长度：n+1</p><p>分析：</p><figure><img src="image-20240101220318755.png" alt="image-20240101220318755" /><figcaption aria-hidden="true">image-20240101220318755</figcaption></figure><p>改进： 自组织表</p><figure><img src="image-20240101220409170.png" alt="image-20240101220409170" /><figcaption aria-hidden="true">image-20240101220409170</figcaption></figure><p><strong>「有序表的顺序查找」</strong></p><blockquote><p>但如果只对表查找一次，则顺序查找要比排序快； 如果要在同一个文件中不断查找，将表按序排列再查找是个很好的方法</p></blockquote><h3 id="对半查找">对半查找</h3><p><strong>算法思想</strong></p><figure><img src="image-20240103223229203.png" alt="image-20240103223229203" /><figcaption aria-hidden="true">image-20240103223229203</figcaption></figure><p><strong>算法分析</strong></p><figure><img src="image-20240103223348132.png" alt="image-20240103223348132" /><figcaption aria-hidden="true">image-20240103223348132</figcaption></figure><figure><img src="image-20240103225607803.png" alt="image-20240103225607803" /><figcaption aria-hidden="true">image-20240103225607803</figcaption></figure><h4 id="一致对半查找">一致对半查找</h4><figure><img src="image-20240103230244102.png" alt="image-20240103230244102" /><figcaption aria-hidden="true">image-20240103230244102</figcaption></figure><figure><img src="image-20240103230341008.png" alt="image-20240103230341008" /><figcaption aria-hidden="true">image-20240103230341008</figcaption></figure><figure><img src="image-20240103230837327.png" alt="image-20240103230837327" /><figcaption aria-hidden="true">image-20240103230837327</figcaption></figure><figure><img src="image-20240103230908047.png" alt="image-20240103230908047" /><figcaption aria-hidden="true">image-20240103230908047</figcaption></figure><h3 id="斐波那契查找">斐波那契查找</h3><figure><img src="image-20240103231158412.png" alt="image-20240103231158412" /><figcaption aria-hidden="true">image-20240103231158412</figcaption></figure><figure><img src="image-20240103231110183.png" alt="image-20240103231110183" /><figcaption aria-hidden="true">image-20240103231110183</figcaption></figure><figure><img src="image-20240103231126829.png" alt="image-20240103231126829" /><figcaption aria-hidden="true">image-20240103231126829</figcaption></figure><figure><img src="image-20240103231302067.png" alt="image-20240103231302067" /><figcaption aria-hidden="true">image-20240103231302067</figcaption></figure><figure><img src="image-20240103231518508.png" alt="image-20240103231518508" /><figcaption aria-hidden="true">image-20240103231518508</figcaption></figure><h3 id="插值查找">插值查找</h3><figure><img src="image-20240105222143570.png" alt="image-20240105222143570" /><figcaption aria-hidden="true">image-20240105222143570</figcaption></figure><p><strong>算法思想</strong></p><figure><img src="image-20240105222226192.png" alt="image-20240105222226192" /><figcaption aria-hidden="true">image-20240105222226192</figcaption></figure><figure><img src="image-20240105222431296.png" alt="image-20240105222431296" /><figcaption aria-hidden="true">image-20240105222431296</figcaption></figure><h2 id="树形结构的查找">树形结构的查找</h2><h3 id="字典树trie树">字典树（trie树）</h3><p><strong>常用来解决根据前缀查询字符串的问题</strong></p><figure><img src="image-20240310165419879.png" alt="image-20240310165419879" /><figcaption aria-hidden="true">image-20240310165419879</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TrieNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TrieNode</span>* next[<span class="number">36</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">     <span class="type">bool</span> end=<span class="literal">false</span>;</span><br><span class="line"><span class="type">char</span> word[<span class="number">30</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉查找树bst">二叉查找树（BST）</h3><blockquote><p>一棵<strong>二叉查找树</strong>是一棵可能为空的二叉树形，并且关键词 各不相同。二叉查找树中的任一结点P，它的左子树中结点的关键 词都小于KEY(P)，而右子树中结点的关键词都大于KEY(P)</p></blockquote><blockquote><p>二叉查找树 （或称二叉搜索树、排序树）是一棵可能为空 的二叉树形，一棵非空的二叉查找树中的所有结点在<strong>中根次序</strong>下 按其关键词由<strong>小到大</strong>排序，并且<strong>关键词各不相同</strong></p></blockquote><figure><img src="image-20240105222809843.png" alt="image-20240105222809843" /><figcaption aria-hidden="true">image-20240105222809843</figcaption></figure><figure><img src="image-20240105222820415.png" alt="image-20240105222820415" /><figcaption aria-hidden="true">image-20240105222820415</figcaption></figure><p><strong>查找</strong></p><p>走过每层</p><figure><img src="image-20240105223017035.png" alt="image-20240105223017035" /><figcaption aria-hidden="true">image-20240105223017035</figcaption></figure><p>实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BSTNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BSTnode</span>* left;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BSTnode</span>* right;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="function">BSTnode* <span class="title">Search</span><span class="params">(BSTnode* root,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="literal">NULL</span>||root-&gt;key==k) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;root-&gt;key) <span class="keyword">return</span> <span class="built_in">Search</span>(root-&gt;left,k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Search</span>(root-&gt;right,k);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代版本****时间复杂度O(h)  h为树的高度******</span></span><br><span class="line"><span class="function">BSTnode* <span class="title">Search</span><span class="params">(BSTnode* root,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BSTnode* p =root;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;p-&gt;key) p=p-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k&gt;p-&gt;key) p=p-&gt;right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入</strong></p><figure><img src="image-20240105223155417.png" alt="image-20240105223155417" /><figcaption aria-hidden="true">image-20240105223155417</figcaption></figure><figure><img src="image-20240105223457083.png" alt="image-20240105223457083" /><figcaption aria-hidden="true">image-20240105223457083</figcaption></figure><figure><img src="image-20240105223523711.png" alt="image-20240105223523711" /><figcaption aria-hidden="true">image-20240105223523711</figcaption></figure><figure><img src="image-20240310174139175.png" alt="image-20240310174139175" /><figcaption aria-hidden="true">image-20240310174139175</figcaption></figure><figure><img src="image-20240310174614936.png" alt="image-20240310174614936" /><figcaption aria-hidden="true">image-20240310174614936</figcaption></figure><p><strong>实现</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(BSTnode* &amp;root,<span class="type">int</span> k )</span>    <span class="comment">//返回值为空，采用引用的方法进行修改根节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>) root = <span class="keyword">new</span> <span class="built_in">BSTnode</span>(k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&lt;root-&gt;key) <span class="built_in">Insert</span>(root-&gt;left,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&gt;root-&gt;key) <span class="built_in">Insert</span>(root-&gt;right,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BSTnode* <span class="title">Insert</span><span class="params">(BSTnode* root,<span class="type">int</span> k)</span>  <span class="comment">//返回值为指针，采用值传递的方法更改</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>) root = <span class="keyword">new</span> <span class="built_in">BSTnode</span>(k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&lt;root-&gt;key) root-&gt;left = <span class="built_in">Insert</span>(root-&gt;left,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&gt;root-&gt;key)root-&gt;right = <span class="built_in">Insert</span>(root-&gt;right,k);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除</strong></p><figure><img src="image-20240105223607737.png" alt="image-20240105223607737" /><figcaption aria-hidden="true">image-20240105223607737</figcaption></figure><figure><img src="image-20240105223651585.png" alt="image-20240105223651585" /><figcaption aria-hidden="true">image-20240105223651585</figcaption></figure><figure><img src="image-20240105223731685.png" alt="image-20240105223731685" /><figcaption aria-hidden="true">image-20240105223731685</figcaption></figure><figure><img src="image-20240105223832556.png" alt="image-20240105223832556" /><figcaption aria-hidden="true">image-20240105223832556</figcaption></figure><figure><img src="image-20240105224144290.png" alt="image-20240105224144290" /><figcaption aria-hidden="true">image-20240105224144290</figcaption></figure><figure><img src="image-20240310185938404.png" alt="image-20240310185938404" /><figcaption aria-hidden="true">image-20240310185938404</figcaption></figure><p>其实只用分成三类</p><p>没有孩子：不做操作</p><p>有一个孩子：子承父业</p><p>有两个孩子：右子树的中序顺序的第一个（即右子树的最小的一个或者说是k的中序后继）换到k的位置</p><p><strong>算法分析</strong></p><figure><img src="image-20240105224222452.png" alt="image-20240105224222452" /><figcaption aria-hidden="true">image-20240105224222452</figcaption></figure><h3 id="最优二叉查找树">最优二叉查找树</h3><figure><img src="image-20240105224454142.png" alt="image-20240105224454142" /><figcaption aria-hidden="true">image-20240105224454142</figcaption></figure><h3 id="高度平衡树avl">高度平衡树（AVL）</h3><p>上述所介绍的二叉查找树各个操作的时间复杂度由树的高度决定的，因此我们希望树的高度越低越好，即树矮胖是好的，效率是高的，但达到完全二叉树或者是满二叉树条件较为苛刻，所以我们引入了高度平衡树：</p><figure><img src="image-20240106094728254.png" alt="image-20240106094728254" /><figcaption aria-hidden="true">image-20240106094728254</figcaption></figure><figure><img src="image-20240106094807446.png" alt="image-20240106094807446" /><figcaption aria-hidden="true">image-20240106094807446</figcaption></figure><p><strong>高度的粗略计算</strong></p><figure><img src="image-20240310202636483.png" alt="image-20240310202636483" /><figcaption aria-hidden="true">image-20240310202636483</figcaption></figure><figure><img src="image-20240310202742527.png" alt="image-20240310202742527" /><figcaption aria-hidden="true">image-20240310202742527</figcaption></figure><p><strong>实现</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AVLnode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    AVLnode* left,*right;</span><br><span class="line">    <span class="built_in">AVLnode</span>(<span class="type">int</span> k) &#123;key=k;height=<span class="number">0</span>;left=right=<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Height</span><span class="params">(AVLnode* t )</span></span>&#123;<span class="keyword">return</span> (t==<span class="literal">NULL</span>)? <span class="number">-1</span>:t-&gt;height;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;<span class="keyword">return</span> (a&gt;b)?  a:b;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpdateHeight</span><span class="params">(ALVnode* t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t-&gt;height = <span class="number">1</span>+<span class="built_in">max</span>(<span class="built_in">Height</span>(t-&gt;left),<span class="built_in">Height</span>(t-&gt;right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查找</strong></p><p><strong>与普通的二叉查找树一致</strong></p><p><strong>插入</strong></p><p>为了保持树仍是<strong>高度平衡树</strong>会有以下四种插入情况</p><blockquote><p>LL型(R旋转): 新结点P插到A的左子树的左子树上</p><p>RR型(L旋转): 新结点P插入到A的右子树的右子树上</p><p>LR型(LR旋转): 结点P 插入到A的左子树的右子树上</p><p>RL型(RL旋转): 结点P插入到A的右子树的左子树上</p></blockquote><figure><img src="image-20240106095023563.png" alt="image-20240106095023563" /><figcaption aria-hidden="true">image-20240106095023563</figcaption></figure><p>实现</p><figure><img src="image-20240310204430867.png" alt="image-20240310204430867" /><figcaption aria-hidden="true">image-20240310204430867</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LL</span><span class="params">(AVLndoe* &amp;A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AVLnode*B = A-&gt;left;</span><br><span class="line">    A-&gt;left = B-&gt;right;</span><br><span class="line">    <span class="built_in">UpdateHeight</span>(A);</span><br><span class="line">    <span class="built_in">UpdateHright</span>(B);</span><br><span class="line">    A=B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="image-20240106095039512.png" alt="image-20240106095039512" /><figcaption aria-hidden="true">image-20240106095039512</figcaption></figure><p>实现： <img src="image-20240310204602220.png" alt="image-20240310204602220" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RR</span><span class="params">(AVLnode* &amp;A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ALVnode*B = A-&gt;right;</span><br><span class="line">    A-&gt;right=B-&gt;left;</span><br><span class="line">    B-&gt;left = A;</span><br><span class="line">    <span class="built_in">UpdateHeight</span>(A);</span><br><span class="line">    <span class="built_in">UpdateHeight</span>(B);</span><br><span class="line">    A=B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="image-20240106095216226.png" alt="image-20240106095216226" /><figcaption aria-hidden="true">image-20240106095216226</figcaption></figure><p>实现：</p><figure><img src="image-20240310205153288.png" alt="image-20240310205153288" /><figcaption aria-hidden="true">image-20240310205153288</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><figure><img src="image-20240106095504100.png" alt="image-20240106095504100" /><figcaption aria-hidden="true">image-20240106095504100</figcaption></figure><figure><img src="image-20240310205424816.png" alt="image-20240310205424816" /><figcaption aria-hidden="true">image-20240310205424816</figcaption></figure><p><strong>通过上述四种操作，在插入前后数的高度和平衡性不受影响</strong></p><figure><img src="image-20240310210443974.png" alt="image-20240310210443974" /><figcaption aria-hidden="true">image-20240310210443974</figcaption></figure><figure><img src="image-20240310210827325.png" alt="image-20240310210827325" /><figcaption aria-hidden="true">image-20240310210827325</figcaption></figure><p><strong>删除</strong></p><figure><img src="image-20240106095744779.png" alt="image-20240106095744779" /><figcaption aria-hidden="true">image-20240106095744779</figcaption></figure><p>先采用二叉查找树的删除算法删除，再调整平衡性</p><figure><img src="image-20240310211117006.png" alt="image-20240310211117006" /><figcaption aria-hidden="true">image-20240310211117006</figcaption></figure><figure><img src="image-20240310211217942.png" alt="image-20240310211217942" /><figcaption aria-hidden="true">image-20240310211217942</figcaption></figure><figure><img src="image-20240106100430797.png" alt="image-20240106100430797" /><figcaption aria-hidden="true">image-20240106100430797</figcaption></figure><figure><img src="image-20240106100814938.png" alt="image-20240106100814938" /><figcaption aria-hidden="true">image-20240106100814938</figcaption></figure><h3 id="红黑树">红黑树</h3><figure><img src="image-20240310211647955.png" alt="image-20240310211647955" /><figcaption aria-hidden="true">image-20240310211647955</figcaption></figure><figure><img src="image-20240310212033556.png" alt="image-20240310212033556" /><figcaption aria-hidden="true">image-20240310212033556</figcaption></figure><figure><img src="image-20240310212238453.png" alt="image-20240310212238453" /><figcaption aria-hidden="true">image-20240310212238453</figcaption></figure><figure><img src="image-20240310212437504.png" alt="image-20240310212437504" /><figcaption aria-hidden="true">image-20240310212437504</figcaption></figure><figure><img src="image-20240310212659183.png" alt="image-20240310212659183" /><figcaption aria-hidden="true">image-20240310212659183</figcaption></figure><p><strong>插入</strong></p><p>1.原本为空树，插入后将根涂成黑色，不用做其他操作</p><p>2.插入节点的<strong>父节点是黑色</strong>，插入节点染成红色，不影响红黑树的性质，不用做任何操作</p><p>3.当<strong>父节点为红色，插入节点也为红色</strong>，为满足性质2，在不同的前提条件下要做不同的修改：</p><ul><li>如果<strong>当前节点的叔叔节点是红色</strong>，则父节点和叔叔节点都变为黑色，祖父染成红色</li><li>如果<strong>当前节点的叔叔节点是黑色或者叔叔节点不存在</strong>：则按照路径进行RL LR LL RR 旋转，最后根染成黑色，子节点染成红色。</li></ul><figure><img src="image-20240310213236445.png" alt="image-20240310213236445" /><figcaption aria-hidden="true">image-20240310213236445</figcaption></figure><figure><img src="image-20240310213215470.png" alt="image-20240310213215470" /><figcaption aria-hidden="true">image-20240310213215470</figcaption></figure><figure><img src="image-20240310213404065.png" alt="image-20240310213404065" /><figcaption aria-hidden="true">image-20240310213404065</figcaption></figure><figure><img src="image-20240310213524549.png" alt="image-20240310213524549" /><figcaption aria-hidden="true">image-20240310213524549</figcaption></figure><figure><img src="image-20240310213637500.png" alt="image-20240310213637500" /><figcaption aria-hidden="true">image-20240310213637500</figcaption></figure><figure><img src="image-20240310214037548.png" alt="image-20240310214037548" /><figcaption aria-hidden="true">image-20240310214037548</figcaption></figure><figure><img src="image-20240310214405411.png" alt="image-20240310214405411" /><figcaption aria-hidden="true">image-20240310214405411</figcaption></figure><p><strong>删除：</strong></p><figure><img src="image-20240312110640554.png" alt="image-20240312110640554" /><figcaption aria-hidden="true">image-20240312110640554</figcaption></figure><p>1.<strong>删除含有两个孩子的节点</strong>，可以归结为删除一个孩子的节点或者删除叶子节点（用中根后继的值替换被删除的节点的值，再删除中根后继）。</p><p>2<strong>.删除一个孩子的节点或者是叶子节点</strong>：</p><ul><li><p>​ <strong>x为红色</strong>，则一定是叶子节点，直接删除</p></li><li><p>​ <strong>x为黑色</strong>，<strong>替换的节点为红色</strong>，用r替换x，并将r染成黑色</p></li><li><p>​ x为黑色，r为黑色，即<strong>双黑缺陷</strong>，又可以分为三种情况</p></li></ul><p>​ <img src="image-20240312111328699.png" alt="image-20240312111328699" /></p><figure><img src="image-20240312111649302.png" alt="image-20240312111649302" /><figcaption aria-hidden="true">image-20240312111649302</figcaption></figure><figure><img src="image-20240312111836712.png" alt="image-20240312111836712" /><figcaption aria-hidden="true">image-20240312111836712</figcaption></figure><figure><img src="image-20240312112005940.png" alt="image-20240312112005940" /><figcaption aria-hidden="true">image-20240312112005940</figcaption></figure><figure><img src="image-20240312112241241.png" alt="image-20240312112241241" /><figcaption aria-hidden="true">image-20240312112241241</figcaption></figure><figure><img src="image-20240312112410625.png" alt="image-20240312112410625" /><figcaption aria-hidden="true">image-20240312112410625</figcaption></figure><figure><img src="image-20240312112539622.png" alt="image-20240312112539622" /><figcaption aria-hidden="true">image-20240312112539622</figcaption></figure><figure><img src="image-20240312112622044.png" alt="image-20240312112622044" /><figcaption aria-hidden="true">image-20240312112622044</figcaption></figure><figure><img src="image-20240312112829179.png" alt="image-20240312112829179" /><figcaption aria-hidden="true">image-20240312112829179</figcaption></figure><figure><img src="image-20240312113017077.png" alt="image-20240312113017077" /><figcaption aria-hidden="true">image-20240312113017077</figcaption></figure><h3 id="b树及其变形树">B树及其变形树</h3><p><strong>外查找</strong></p><figure><img src="image-20240106100852098.png" alt="image-20240106100852098" /><figcaption aria-hidden="true">image-20240106100852098</figcaption></figure><p>B树</p><figure><img src="image-20240106100930019.png" alt="image-20240106100930019" /><figcaption aria-hidden="true">image-20240106100930019</figcaption></figure><figure><img src="image-20240106101133799.png" alt="image-20240106101133799" /><figcaption aria-hidden="true">image-20240106101133799</figcaption></figure><figure><img src="image-20240106101153223.png" alt="image-20240106101153223" /><figcaption aria-hidden="true">image-20240106101153223</figcaption></figure><figure><img src="image-20240106101329481.png" alt="image-20240106101329481" /><figcaption aria-hidden="true">image-20240106101329481</figcaption></figure><figure><img src="image-20240106101651230.png" alt="image-20240106101651230" /><figcaption aria-hidden="true">image-20240106101651230</figcaption></figure><p><strong>插入</strong></p><figure><img src="image-20240106101936483.png" alt="image-20240106101936483" /><figcaption aria-hidden="true">image-20240106101936483</figcaption></figure><p><strong>删除</strong></p><figure><img src="image-20240106103136080.png" alt="image-20240106103136080" /><figcaption aria-hidden="true">image-20240106103136080</figcaption></figure><figure><img src="image-20240106103155393.png" alt="image-20240106103155393" /><figcaption aria-hidden="true">image-20240106103155393</figcaption></figure><figure><img src="image-20240106103307884.png" alt="image-20240106103307884" /><figcaption aria-hidden="true">image-20240106103307884</figcaption></figure><p><strong>B+树</strong></p><figure><img src="image-20240106103352250.png" alt="image-20240106103352250" /><figcaption aria-hidden="true">image-20240106103352250</figcaption></figure><figure><img src="image-20240106103453737.png" alt="image-20240106103453737" /><figcaption aria-hidden="true">image-20240106103453737</figcaption></figure><figure><img src="image-20240106103503815.png" alt="image-20240106103503815" /><figcaption aria-hidden="true">image-20240106103503815</figcaption></figure><figure><img src="image-20240106103529896.png" alt="image-20240106103529896" /><figcaption aria-hidden="true">image-20240106103529896</figcaption></figure><h3 id="数字查找">数字查找</h3><figure><img src="image-20240106104151508.png" alt="image-20240106104151508" /><figcaption aria-hidden="true">image-20240106104151508</figcaption></figure><figure><img src="image-20240106104418518.png" alt="image-20240106104418518" /><figcaption aria-hidden="true">image-20240106104418518</figcaption></figure><figure><img src="image-20240106104511300.png" alt="image-20240106104511300" /><figcaption aria-hidden="true">image-20240106104511300</figcaption></figure><figure><img src="image-20240106104549177.png" alt="image-20240106104549177" /><figcaption aria-hidden="true">image-20240106104549177</figcaption></figure><h2 id="散列">散列</h2><blockquote><p>前面所介绍的查找方法有两种，一种是<strong>基于表中关键词</strong>与给定 变元K的比较, 另一种是进行<strong>数字的匹配</strong>。这两种方法，在找到以 给定K为关键词的记录之前都要检查若干数目的关键词。</p></blockquote><blockquote><p>但散列方法却几乎完全免去了对表的搜索。以给定变元K为自变 量，通过<strong>某种函数h(K)</strong> 直接计算出函数值，此值被解释为存放以 K为关键词的记录的地址。查找时，用相同方法计算出与给定变 元K对应之记录的存储地址A，进而到A所指的存储单元中取出要 查的记录</p></blockquote><figure><img src="image-20240106104706595.png" alt="image-20240106104706595" /><figcaption aria-hidden="true">image-20240106104706595</figcaption></figure><figure><img src="image-20240106104923458.png" alt="image-20240106104923458" /><figcaption aria-hidden="true">image-20240106104923458</figcaption></figure><figure><img src="image-20240106104941486.png" alt="image-20240106104941486" /><figcaption aria-hidden="true">image-20240106104941486</figcaption></figure><figure><img src="image-20240106105012495.png" alt="image-20240106105012495" /><figcaption aria-hidden="true">image-20240106105012495</figcaption></figure><h3 id="冲突调节">冲突调节</h3><p><strong>拉链法</strong></p><figure><img src="image-20240106110042989.png" alt="image-20240106110042989" /><figcaption aria-hidden="true">image-20240106110042989</figcaption></figure><figure><img src="image-20240106110126481.png" alt="image-20240106110126481" /><figcaption aria-hidden="true">image-20240106110126481</figcaption></figure><figure><img src="image-20240106110229273.png" alt="image-20240106110229273" /><figcaption aria-hidden="true">image-20240106110229273</figcaption></figure><figure><img src="image-20240106110252632.png" alt="image-20240106110252632" /><figcaption aria-hidden="true">image-20240106110252632</figcaption></figure><h3 id="删除"><strong>删除</strong></h3><figure><img src="image-20240106111448484.png" alt="image-20240106111448484" /><figcaption aria-hidden="true">image-20240106111448484</figcaption></figure><figure><img src="image-20240106111742833.png" alt="image-20240106111742833" /><figcaption aria-hidden="true">image-20240106111742833</figcaption></figure><figure><img src="image-20240106112145372.png" alt="image-20240106112145372" /><figcaption aria-hidden="true">image-20240106112145372</figcaption></figure>]]></content>
    
    
    <summary type="html">数据结构笔记</summary>
    
    
    
    <category term="class" scheme="https://klklkl10086.github.io/klklkl10086.github.io/categories/class/"/>
    
    
    <category term="数据结构" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Linux课程复习笔记</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2023/09/26/Linux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2023/09/26/Linux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</id>
    <published>2023-09-26T14:30:07.000Z</published>
    <updated>2024-09-12T02:12:15.605Z</updated>
    
    <content type="html"><![CDATA[<p><strong>声明：本篇文章参考和引用了2023下半年吉林大学郭东老师的PPT，如有侵权，请联系我，我将会立马删除</strong></p><h1 id="一unix操作系统">一、UNIX操作系统</h1><h2 id="历史简介">1.历史简介</h2><p>1969年诞生于AT&amp;T贝尔试验室</p><p>开发者是Ken Thompson 和 Dennis Ritchie</p><p>最初使用汇编语言开发，后用C语言重写UNIX源码，UNIX和C完美地结合成一个统一的整体</p><p>UNIX以源代码的形式发行，形成了两个重要的流派: UNIX SYSTEM V （AT&amp;T）和 Berkeley UNIX(UCB)</p><h2 id="标准化">2.标准化</h2><p>即对每种实现必须定义的各种限制进行说明</p><p>有两个重要的UNXI标准：</p><ol type="1"><li>系统V接口定义 SVID 例如： at&amp;t</li><li>可移植操作系统接口 POSIX 例如：IEEE、 ISO</li></ol><h2 id="其他的unix系统">3.其他的UNIX系统</h2><h3 id="linux">1&gt; Linux</h3><p>目前应用最为广泛的<strong>类UNIX系统</strong></p><h4 id="背景">背景</h4><h5 id="两个人">「两个人」：</h5><p>Richard Stallman和 Linus Torvalds，前者启动GNU项目 创建FSF组织 提出copyleft理念 制订GPL协议 发起开源运动</p><h5 id="四个一"><strong>「四个一」</strong>：</h5><ul><li>一个项目 GNU</li></ul><p>​ <strong>G</strong>NU's NOT <strong>U</strong>NIX</p><p>​ <strong>目标</strong>：</p><p>​ 创建一个自有共享 可以被任何人修改的类UNIX操作系统</p><p>​ 与UNIX系统兼容</p><p>​ 不受UNIX名字和源代码私有权限制</p><p>​ 能运行UNIX程序</p><p>​ GNU项目完成了许多UNIX系统上应用程序的仿制品</p><p>​ GNU项目开发的重要软件工具有：</p><p>​ GCC:GNU编译器套件，包括GNU c编译器</p><p>​ G++：C++编译器 是GCC的一部分</p><p>​ GDB：源代码级的调试器，支持多种语言</p><p>​ GNU make: UNUX make命令的免费版本</p><p>​ bash: 命令解释器（shell）</p><p>​ GNU Emacs : 文本编辑器及环境</p><p>​ <strong>未成功开发操纵系统内核</strong></p><ul><li><p>一个组织 FSF</p><p>自由软件基金会</p><p>目标： 执行GNU计划</p><p>​ 提供技术 法律以及财政支持</p><p>​ 开发更多的自有软件</p></li><li><p>一个理念 Copy<strong>left</strong></p></li><li><p>一个许可证 GPL</p><p><strong>背景：</strong> 发行大型软件需要的合适许可协议</p><p>已经有的许可协议：</p><figure><img src="image-20231125202333757.png" alt="image-20231125202333757" /><figcaption aria-hidden="true">image-20231125202333757</figcaption></figure><blockquote><p>Copyright(C)：版权所有，即软件的一切权利归软件作者私有，用户只有使用权没有其他权利包括复制软件的权利</p></blockquote></li></ul><p>​ Richard Stallman提出Copyleft的概念（著<strong>左</strong>权）</p><figure><img src="image-20231125202957871.png" alt="image-20231125202957871" /><figcaption aria-hidden="true">image-20231125202957871</figcaption></figure><blockquote><p>利用现有的著作体制来保护所有用户和二次开发者的自由授权方式</p><p>它赋予所有人运行程序，复制程序，修改程序和发行修改程序的权限，但是使用者不能在修改后的软件上添加限制</p></blockquote><p>​ 基于copyleft Stallman提出来了GPL许可证，GNU通用的公共许可证</p><blockquote><p>GPL授予程序接受人以下权利，或称“自由”：</p><ul><li>赋予所有人运行程序，复制程序，修改程序和发行修改程序的自有</li><li>重新发行软件的人不能在修改后的软件上添加限制</li></ul></blockquote><p>GNU开发的工具都在GPL下发行</p><p>意义： <img src="image-20231125203240445.png" alt="image-20231125203240445" /></p><p><strong>其他开源许可证：</strong> Apache ,BSD,MIT,Mozilla</p><figure><img src="image-20231125203426215.png" alt="image-20231125203426215" /><figcaption aria-hidden="true">image-20231125203426215</figcaption></figure><h4 id="linux的诞生">Linux的诞生</h4><p>内核在GPL协议下发布，参与了开源运动，Linux内核更新速度极其快</p><p>吉祥物：tux</p><figure><img src="image-20231125203724965.png" alt="image-20231125203724965" /><figcaption aria-hidden="true">image-20231125203724965</figcaption></figure><p>Linux的含义：操作系统内核或者是基于linux内核的操作系统</p><p><strong>Linux操作系统版本：包括内核版本和发行版本</strong></p><p>[内核版本]：有Linux内核社区统一进行发布，包括主版本号 次版本号和修订次数，奇数表示开发版本，偶数表示稳定版本，修订次数标明内核被修改的次数</p><figure><img src="image-20231125204046584.png" alt="image-20231125204046584" /><figcaption aria-hidden="true">image-20231125204046584</figcaption></figure><p>「发行版本」 发行版的名称或版本号是由发行版的维护者决定</p><figure><img src="image-20231125204139444.png" alt="image-20231125204139444" /><figcaption aria-hidden="true">image-20231125204139444</figcaption></figure><figure><img src="image-20231125204157090.png" alt="image-20231125204157090" /><figcaption aria-hidden="true">image-20231125204157090</figcaption></figure><h3 id="unix操作系统概要">2&gt; UNIX操作系统概要</h3><p>计算机系统= 硬件+系统软件+应用软件</p><p>UNIX操作系统是包含了文本编辑器 编译器 和其他系统工具程序的程序集</p><p>UNIX操作系统是按照分层软件模型实现的</p><figure><img src="image-20231125204400373.png" alt="image-20231125204400373" /><figcaption aria-hidden="true">image-20231125204400373</figcaption></figure><p>内核：</p><figure><img src="image-20231125204440090.png" alt="image-20231125204440090" /><figcaption aria-hidden="true">image-20231125204440090</figcaption></figure><figure><img src="image-20231125204501355.png" alt="image-20231125204501355" /><figcaption aria-hidden="true">image-20231125204501355</figcaption></figure><figure><img src="image-20231125204515488.png" alt="image-20231125204515488" /><figcaption aria-hidden="true">image-20231125204515488</figcaption></figure><figure><img src="image-20231125204551016.png" alt="image-20231125204551016" /><figcaption aria-hidden="true">image-20231125204551016</figcaption></figure><h5 id="相关概念">「相关概念」</h5><p>虚拟计算机：UNIX向系统中每个用户指定一个执行环境，这个环境称为虚拟计算机，包括一个用户接口终端和共享的其他计算机资源，UNIX是多用户操作系统 虚拟计算机的集合，而从用户视角是独想计算机</p><p>进程：UNUX系统通过进程向用户分配资源</p><h5 id="特征">「特征」</h5><p>可移植性（c语言保证）</p><p>多用户性：多用户同时共同使用计算机，各个用户执行不同的程序，提供安全机制隔离用户</p><p>多任务性：启动一个任务后继续执行其他任务，允许用户在前台和后台多个任务之间进行切换</p><p>分级文件系统：对数据和程序文件进行分组管理，便于查找文件和程序</p><p>与设备独立的输入输出操作：</p><p>用户界面shell：</p><p>​ 命令解释器： 控制用户与系统的交互，实现用户命令输入与结果输出</p><p>​ shell脚本： UNIX Shell是一种成熟的编程语言，Shell 脚本 包含一系列命令， 实现较为复杂 的功能</p><p>系统工具与服务：UNIX系统包括100多个系统工具程序（命令），标准的UNIX系统组成部分完成用户所需要的各种功能</p><h1 id="二linux入门">二、Linux入门</h1><h2 id="登录系统">1.登录系统</h2><h3 id="登录作用">「登录作用」</h3><ol type="1"><li>UNIX是一个多用户操作系统。</li><li>用户在使用UNIX系统前必须进行登录</li></ol><h3 id="登录方式">「登录方式」</h3><ol type="1"><li>本地登录：在本地输入用户名和密码登录</li><li>远程登录：使用远程登录软件登录 eg: ssh</li></ol><h3 id="命令提示符">「命令提示符」</h3><p>最简单的命令提示符只有一个字符，一般root根用户是#，普通用户是$，用户可以设置提示符，显示丰富系统信息。</p><figure><img src="image-20231128105235339.png" alt="image-20231128105235339" /><figcaption aria-hidden="true">image-20231128105235339</figcaption></figure><p>普通用户</p><h3 id="修改口令">「修改口令」</h3><p><strong>passwd命令</strong>来修改或创建口令</p><p>1.可以修改自己的口令:</p><figure><img src="image-20231128105425593.png" alt="image-20231128105425593" /><figcaption aria-hidden="true">image-20231128105425593</figcaption></figure><p>2.修改别人的口令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd username</span><br></pre></td></tr></table></figure><p>只有root可以</p><p>3.创建口令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd username</span><br></pre></td></tr></table></figure><p>应用场景：root创建普通用户后，为其分配初始口令</p><h3 id="退出系统">「退出系统」</h3><p>用户完成工作后离开系统的过程，退出意味着和系统断开连接结束对话</p><p>三种方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br><span class="line">[Ctrl-d]</span><br><span class="line"><span class="built_in">logout</span></span><br></pre></td></tr></table></figure><p>logout需要在登录shell中</p><h2 id="命令">2.命令</h2><ul><li>UNIX系统有几百条命令/系统工具</li><li>绝大多数命令格式相同</li><li>大部分UNIX提供在线帮助 help man info</li><li>通过输入命令告诉系统要做什么事</li><li>命令行中回车键解释为命令行的结束符</li></ul><p>例子： <img src="image-20231128110218045.png" alt="image-20231128110218045" /></p><h3 id="命令格式">「命令格式」</h3><h4 id="基本格式">基本格式</h4><figure><img src="image-20231128110252691.png" alt="image-20231128110252691" /><figcaption aria-hidden="true">image-20231128110252691</figcaption></figure><figure><img src="image-20231128110324019.png" alt="image-20231128110324019" /><figcaption aria-hidden="true">image-20231128110324019</figcaption></figure><p>命令本身 和 命令+选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#命令+选项</span></span><br><span class="line"><span class="built_in">ls</span> -a     <span class="comment">#显示目录中的隐藏文件</span></span><br><span class="line"><span class="built_in">ls</span> -a -l  <span class="comment">#将隐含的文件用长格式形式显示</span></span><br><span class="line"><span class="built_in">ls</span> -la    <span class="comment">#作用同上，写法不同</span></span><br><span class="line"><span class="comment">#命令+参数</span></span><br><span class="line"><span class="built_in">ls</span> /home  <span class="comment">#显示指定目录的文件 </span></span><br><span class="line"><span class="comment">#命令+选项+参数</span></span><br><span class="line"><span class="built_in">ls</span> -a /home  <span class="comment">#命令+选项+参数</span></span><br></pre></td></tr></table></figure><figure><img src="image-20231128110819617.png" alt="image-20231128110819617" /><figcaption aria-hidden="true">image-20231128110819617</figcaption></figure><figure><img src="image-20231128111034774.png" alt="image-20231128111034774" /><figcaption aria-hidden="true">image-20231128111034774</figcaption></figure><h4 id="不同流派">不同流派</h4><figure><img src="image-20231128111303688.png" alt="image-20231128111303688" /><figcaption aria-hidden="true">image-20231128111303688</figcaption></figure><figure><img src="image-20231128111426160.png" alt="image-20231128111426160" /><figcaption aria-hidden="true">image-20231128111426160</figcaption></figure><figure><img src="image-20231128111413828.png" alt="image-20231128111413828" /><figcaption aria-hidden="true">image-20231128111413828</figcaption></figure><figure><img src="image-20231128111346324.png" alt="image-20231128111346324" /><figcaption aria-hidden="true">image-20231128111346324</figcaption></figure><figure><img src="image-20231128111534508.png" alt="image-20231128111534508" /><figcaption aria-hidden="true">image-20231128111534508</figcaption></figure><h3 id="日期和时间的显示">「日期和时间的显示」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span></span><br></pre></td></tr></table></figure><figure><img src="image-20231128111633306.png" alt="image-20231128111633306" /><figcaption aria-hidden="true">image-20231128111633306</figcaption></figure><p><strong>UNIX使用24小时制</strong></p><h3 id="用户信息">「用户信息」</h3><p><strong>who命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">who</span></span><br></pre></td></tr></table></figure><figure><img src="image-20231128111741085.png" alt="image-20231128111741085" /><figcaption aria-hidden="true">image-20231128111741085</figcaption></figure><p>第一列：登录用户名，登录用户名</p><p>第二列：登录终端号，登录到哪里</p><p>第三列：登录时间</p><p>第四列：登录主机，从哪里登录的</p><h3 id="终端">「终端」</h3><p><strong>物理终端</strong>：一套输入输出设备，用于用户登录和使用计算机，如连接在计算机上的显示器，鼠标，键盘与名词主机对应</p><p><strong>虚拟终端</strong>（tty）</p><p><strong>本地</strong>的linux系统提供的，例如虚拟机或者是linux系统服务器之类的，</p><figure><img src="image-20231128112152987.png" alt="image-20231128112152987" /><figcaption aria-hidden="true">image-20231128112152987</figcaption></figure><figure><img src="image-20231128112440981.png" alt="image-20231128112440981" /><figcaption aria-hidden="true">image-20231128112440981</figcaption></figure><figure><img src="image-20231128142651757.png" alt="虚拟机登录" /><figcaption aria-hidden="true">虚拟机登录</figcaption></figure><p>使用虚拟机登录终端为tty</p><figure><img src="capture_20231128142808500.bmp" alt="capture_20231128142808500" /><figcaption aria-hidden="true">capture_20231128142808500</figcaption></figure><p>对于Ununtu图形化界面</p><figure><img src="image-20231128151721044.png" alt="image-20231128151721044" /><figcaption aria-hidden="true">image-20231128151721044</figcaption></figure><p><strong>伪终端</strong>（pty）</p><p>由<strong>远程登录软件或终端模拟软件</strong>模拟出的终端</p><figure><img src="image-20231128141759139.png" alt="image-20231128141759139" /><figcaption aria-hidden="true">image-20231128141759139</figcaption></figure><figure><img src="image-20231128141823390.png" alt="image-20231128141823390" /><figcaption aria-hidden="true">image-20231128141823390</figcaption></figure><figure><img src="image-20231128142451870.png" alt="手机软件远程登录" /><figcaption aria-hidden="true">手机软件远程登录</figcaption></figure><h3 id="常用其他命令">「常用其他命令」</h3><h4 id="who-am-i和whoami命令">who am i和whoami命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">who</span> am i</span><br><span class="line"><span class="built_in">who</span> am I</span><br></pre></td></tr></table></figure><p>显示终端上登录的用户信息</p><figure><img src="image-20231128152126549.png" alt="image-20231128152126549" /><figcaption aria-hidden="true">image-20231128152126549</figcaption></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">whoami</span></span><br></pre></td></tr></table></figure><p>显示用户名</p><figure><img src="image-20231128153157246.png" alt="image-20231128153157246" /><figcaption aria-hidden="true">image-20231128153157246</figcaption></figure><h4 id="显示日历-cal命令">显示日历 cal命令</h4><p>默认显示当月日历</p><figure><img src="image-20231128152807363.png" alt="image-20231128152807363" /><figcaption aria-hidden="true">image-20231128152807363</figcaption></figure><p>参数中可以指定年和月，显示指定年月的日历表</p><h4 id="help命令-man命令-info命令">help命令 man命令 info命令</h4><p>「内部命令」 shell代码中的一部分，shell启动后驻留内存，执行速度快</p><p>「外部命令」保存在文件系统中的程序，被调用时才载入内存执行</p><figure><img src="image-20231128154054687.png" alt="image-20231128154054687" /><figcaption aria-hidden="true">image-20231128154054687</figcaption></figure><figure><img src="image-20231128154113516.png" alt="image-20231128154113516" /><figcaption aria-hidden="true">image-20231128154113516</figcaption></figure><figure><img src="image-20231128154124919.png" alt="image-20231128154124919" /><figcaption aria-hidden="true">image-20231128154124919</figcaption></figure><figure><img src="image-20231128154138497.png" alt="image-20231128154138497" /><figcaption aria-hidden="true">image-20231128154138497</figcaption></figure><figure><img src="image-20231128154231499.png" alt="image-20231128154231499" /><figcaption aria-hidden="true">image-20231128154231499</figcaption></figure><h4 id="last命令">last命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">last</span><br></pre></td></tr></table></figure><p>它用来展示关于系统用户最后登录会话的信息</p><figure><img src="capture_20231128153410861.bmp" alt="capture_20231128153410861" /><figcaption aria-hidden="true">capture_20231128153410861</figcaption></figure><blockquote><p>输出的每一行从左到右包含的列分别是：</p><ul><li>用户名。 当系统重启或者关闭时，<code>last</code>显示指定用户为<code>reboot</code>或者<code>shutdown</code>。</li><li>会话占用的 tty。<code>:0</code>通常意味着用户登录了一个桌面环境</li><li>IP 地址或者用户登录的主机名</li><li>会话开始时间和停止时间</li><li>会话时长。如果会话仍然是激活的，或者用户没有登出，last 将会显示信息，而不是时长</li></ul></blockquote><h4 id="history">history</h4><p>显示输入的所有命令记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span></span><br></pre></td></tr></table></figure><figure><img src="image-20231128153900626.png" alt="image-20231128153900626" /><figcaption aria-hidden="true">image-20231128153900626</figcaption></figure><h3 id="命令行快捷键与命令补齐">「命令行快捷键与命令补齐」</h3><figure><img src="image-20231128154332308.png" alt="image-20231128154332308" /><figcaption aria-hidden="true">image-20231128154332308</figcaption></figure><h2 id="shell">3.shell</h2><figure><img src="image-20231128154719823.png" alt="image-20231128154719823" /><figcaption aria-hidden="true">image-20231128154719823</figcaption></figure><figure><img src="image-20231128154736510.png" alt="image-20231128154736510" /><figcaption aria-hidden="true">image-20231128154736510</figcaption></figure><figure><img src="image-20231129211049340.png" alt="image-20231129211049340" /><figcaption aria-hidden="true">image-20231129211049340</figcaption></figure><figure><img src="image-20231129211156849.png" alt="image-20231129211156849" /><figcaption aria-hidden="true">image-20231129211156849</figcaption></figure><figure><img src="image-20231129211302220.png" alt="image-20231129211302220" /><figcaption aria-hidden="true">image-20231129211302220</figcaption></figure><h2 id="软件的安装与卸载">4.软件的安装与卸载</h2><h4 id="安装软件">「安装软件」</h4><p><strong>1.两种方法</strong></p><ul><li><p>下载软件源代码后编译安装</p></li><li><p>基于网络存储库安装/更新软件</p><p>两种基于网络存储库的软件安装方法：</p><p>1.yum后继为dnf eg：Redhat OpenEluer</p><p>2.apt eg:Ubuntu Debian</p></li></ul><p><strong>2.使用yum（dnf）安装软件包</strong></p><figure><img src="image-20231129211838221.png" alt="image-20231129211838221" /><figcaption aria-hidden="true">image-20231129211838221</figcaption></figure><blockquote><p>软件包集合：服务于一个共同的目的一组软件包，例如系统工具集等</p></blockquote><p><strong>使用dnf可以对软件包组进行安装和删除等操作，使相关操作更高效</strong></p><figure><img src="image-20231129212018114.png" alt="image-20231129212018114" /><figcaption aria-hidden="true">image-20231129212018114</figcaption></figure><h2 id="登录过程">5.登录过程</h2><h3 id="启动过程">启动过程</h3><p><strong>操作系统常驻部分载入内存</strong>其余部分保留在磁盘上，用户请求时候再载入内存，用户登录时 shell程序载入内存。</p><p><strong>[init进程]</strong>：UNIX系统所有进程的祖先进程，启动所有系统服务和后台进程，系统启动后init创建虚拟终端为用户登录做准备</p><h1 id="三vi编辑器">三、vi编辑器</h1><blockquote><p>工具软件，文本编辑器，用于创建新文件或修改旧文本文件，编辑对象是文本文件，相对简化的字处理器</p></blockquote><figure><img src="image-20231129213205077.png" alt="image-20231129213205077" /><figcaption aria-hidden="true">image-20231129213205077</figcaption></figure><h3 id="工作模式">1.工作模式</h3><h4 id="命令模式">「命令模式」</h4><p>启动后默认进入，所有的输入都被看作命令，不显示，被执行，通过按键删除字 行 段落，移动光标或者执行其他操作</p><h4 id="末行模式">「末行模式」</h4><p>按下冒号，在最后一行输入命令，回车结束命令</p><h4 id="文本输入模式">「文本输入模式」</h4><p>键盘输入文本字符，屏幕显示用户输入</p><h4 id="模式切换">「模式切换」</h4><figure><img src="image-20231129213525501.png" alt="image-20231129213525501" /><figcaption aria-hidden="true">image-20231129213525501</figcaption></figure><p><strong>注意大小写和英文字符</strong></p><h3 id="基本操作">2.基本操作</h3><h3 id="打开或创建文件">「打开或创建文件」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi     <span class="comment">#在当前工作目录新建一个文件并打开</span></span><br><span class="line"></span><br><span class="line">vi myfirst <span class="comment">#存在myfirst文件则为打开文件，不存在则新建并打开</span></span><br></pre></td></tr></table></figure><figure><img src="image-20231129213840486.png" alt="image-20231129213840486" /><figcaption aria-hidden="true">image-20231129213840486</figcaption></figure><figure><img src="image-20231129213850965.png" alt="image-20231129213850965" /><figcaption aria-hidden="true">image-20231129213850965</figcaption></figure><h3 id="编辑文件">「编辑文件」</h3><ul><li>按下小写字母 i 进入文本输入模式</li><li>通过键盘进行输入文本</li><li>按下 BackSpace或者Ctrl+h删除字符</li><li>每行结束后按Enter进入下一行</li></ul><h3 id="保存文件与退出">「保存文件与退出」</h3><p>按下ESC退出文本编辑模式进入命令模式，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:wq</span><br><span class="line">:x</span><br><span class="line">ZZ</span><br></pre></td></tr></table></figure><p>上述三种的其中一种，按下回车即为保存并退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:q</span><br></pre></td></tr></table></figure><p>若文件没被修改即为退出，已经被修改未保存则无法退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:q!</span><br></pre></td></tr></table></figure><p>不保存文件直接退出</p><h3 id="存储缓冲区">「存储缓冲区」</h3><figure><img src="image-20231129214521276.png" alt="image-20231129214521276" /><figcaption aria-hidden="true">image-20231129214521276</figcaption></figure><h3 id="光标的移动">「光标的移动」</h3><p><strong>命令模式下</strong></p><figure><img src="image-20231129214614398.png" alt="image-20231129214614398" /><figcaption aria-hidden="true">image-20231129214614398</figcaption></figure><p><strong>命令模式进入文本输入模式不同的命令键有不同的效果：</strong></p><figure><img src="image-20231129214707433.png" alt="image-20231129214707433" /><figcaption aria-hidden="true">image-20231129214707433</figcaption></figure><p><strong>光标移动键(命令模式)</strong></p><figure><img src="image-20231129215354489.png" alt="image-20231129215354489" /><figcaption aria-hidden="true">image-20231129215354489</figcaption></figure><p><strong>精准定位</strong></p><p>命令模式：</p><figure><img src="image-20231129215414056.png" alt="image-20231129215414056" /><figcaption aria-hidden="true">image-20231129215414056</figcaption></figure><p>末行模式：</p><figure><img src="image-20231129215526241.png" alt="image-20231129215526241" /><figcaption aria-hidden="true">image-20231129215526241</figcaption></figure><p><strong>翻页：</strong></p><figure><img src="image-20231129215624206.png" alt="image-20231129215624206" /><figcaption aria-hidden="true">image-20231129215624206</figcaption></figure><p><strong>文件修改：</strong></p><p>命令模式下：</p><figure><img src="image-20231130144409680.png" alt="image-20231130144409680" /><figcaption aria-hidden="true">image-20231130144409680</figcaption></figure><p>删除字符：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除单个字符</span></span><br><span class="line">x</span><br><span class="line"><span class="comment">#数字n+x删除n个字符</span></span><br><span class="line">2x</span><br><span class="line"><span class="comment">#撤销当前行的修改</span></span><br><span class="line">U</span><br><span class="line"><span class="comment">#撤销最近的修改</span></span><br><span class="line">u</span><br></pre></td></tr></table></figure><p>删除行和单词</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除光标所在行</span></span><br><span class="line"><span class="built_in">dd</span></span><br><span class="line"><span class="comment">#数字n+dd删除n行</span></span><br><span class="line">2dd<span class="comment">#删除两行</span></span><br><span class="line"><span class="comment">#删除光标所在单词</span></span><br><span class="line">dw</span><br></pre></td></tr></table></figure><p>重复上一次操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.</span><br></pre></td></tr></table></figure><p>替换字符</p><figure><img src="image-20231130145148593.png" alt="image-20231130145148593" /><figcaption aria-hidden="true">image-20231130145148593</figcaption></figure><p>载入文本</p><p>从其他文件中载入文本内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:r 文件名</span><br><span class="line"><span class="comment">#指定文本副本插入当前文件光标的下一行</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:a,b w file</span><br><span class="line">#把文件的a到b行写到file中</span><br></pre></td></tr></table></figure><p><strong>文件重排：</strong></p><figure><img src="image-20231130150229039.png" alt="image-20231130150229039" /><figcaption aria-hidden="true">image-20231130150229039</figcaption></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#复制当前行</span></span><br><span class="line">yy</span><br><span class="line"><span class="comment">#删除当前行</span></span><br><span class="line"><span class="built_in">dd</span></span><br></pre></td></tr></table></figure><p>使用<strong>操作符和域控制键</strong>修改/重排文本</p><figure><img src="image-20231130152354930.png" alt="image-20231130152354930" /><figcaption aria-hidden="true">image-20231130152354930</figcaption></figure><h3 id="定制vi">3.定制vi</h3><figure><img src="image-20231130152759807.png" alt="image-20231130152759807" /><figcaption aria-hidden="true">image-20231130152759807</figcaption></figure><h3 id="选项格式">「选项格式」</h3><figure><img src="image-20231130152856213.png" alt="image-20231130152856213" /><figcaption aria-hidden="true">image-20231130152856213</figcaption></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#只显示修改过的选项</span></span><br><span class="line">:<span class="built_in">set</span></span><br><span class="line"><span class="comment">#显示X的值</span></span><br><span class="line">:<span class="built_in">set</span> X?</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#显示行号</span></span><br><span class="line">:<span class="built_in">set</span> nu</span><br><span class="line"><span class="comment">#取消显示行号</span></span><br><span class="line">:<span class="built_in">set</span> nonu</span><br></pre></td></tr></table></figure><h3 id="vim配置文件">「vim配置文件」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/.exrc</span><br><span class="line">~/.vimrc</span><br></pre></td></tr></table></figure><p>vi编辑器中使用命令设置的所有选项都是临时的，退出vi就会失效</p><p>在用户主目录创建 ~/.exrc 或 ~/.vimrc 配置文件，设置选项后，可使每次启动时选项保持不变</p><h3 id="搜索替换与命令执行">4.搜索替换与命令执行</h3><h4 id="搜索">「搜索」</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#命令模式下输入</span></span><br><span class="line">/+要搜索的字符即为从光标所在的位置查找字符</span><br><span class="line"><span class="comment">#例如：</span></span><br><span class="line">/A</span><br></pre></td></tr></table></figure><p><strong>按下N是下一个匹配与命令搜索方向相反，按下n为下一个匹配，与命令搜索方向相同</strong></p><h4 id="搜索并替换">「搜索并替换」</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:「行范围」 s/被替换单词/新单词/[g]</span><br><span class="line"><span class="comment">#g是全行替换，行范围默认为当前行</span></span><br></pre></td></tr></table></figure><figure><img src="image-20231202185736902.png" alt="image-20231202185736902" /><figcaption aria-hidden="true">image-20231202185736902</figcaption></figure><h4 id="运行shell命令">「运行shell命令」</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#: ! command</span></span><br><span class="line">: ! <span class="built_in">date</span></span><br><span class="line"><span class="comment">#将命令执行结果加到文本中：</span></span><br><span class="line">:r! <span class="built_in">command</span></span><br></pre></td></tr></table></figure><h1 id="四linux文件系统">四、Linux文件系统</h1><h2 id="磁盘组织">1.磁盘组织</h2><blockquote><p>目录：Linux文件系统的组织单元</p></blockquote><p>Linux文件系统通过目录对文件进行组织管理，</p><h2 id="文件类型">2.文件类型</h2><p>UNIX文件视角：</p><ul><li>文件是字节序列，一切都是文件</li><li>文件可以分为，普通文件、目录文件、特殊文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看文件类型</span></span><br><span class="line">file 文件名</span><br></pre></td></tr></table></figure><figure><img src="image-20231202191624635.png" alt="image-20231202191624635" /><figcaption aria-hidden="true">image-20231202191624635</figcaption></figure><figure><img src="image-20231202191641349.png" alt="image-20231202191641349" /><figcaption aria-hidden="true">image-20231202191641349</figcaption></figure><h2 id="目录详述">3.目录详述</h2><p><strong>目录结构以层次结构进行组织</strong></p><figure><img src="image-20231202191741582.png" alt="image-20231202191741582" /><figcaption aria-hidden="true">image-20231202191741582</figcaption></figure><blockquote><p>父子关系：相邻两层目录间的关系</p><p>上层目录是下层目录的父目录，下层目录是上层目录的子目录</p></blockquote><figure><img src="image-20231202191842230.png" alt="image-20231202191842230" /><figcaption aria-hidden="true">image-20231202191842230</figcaption></figure><blockquote><p>重要目录：Linux系统的标准目录</p></blockquote><figure><img src="image-20231202192035623.png" alt="image-20231202192035623" /><figcaption aria-hidden="true">image-20231202192035623</figcaption></figure><h3 id="重要目录作用"><strong>「重要目录作用」</strong></h3><figure><img src="image-20231202192347215.png" alt="image-20231202192347215" /><figcaption aria-hidden="true">image-20231202192347215</figcaption></figure><figure><img src="image-20231202192539500.png" alt="image-20231202192539500" /><figcaption aria-hidden="true">image-20231202192539500</figcaption></figure><figure><img src="image-20231202192558821.png" alt="image-20231202192558821" /><figcaption aria-hidden="true">image-20231202192558821</figcaption></figure><figure><img src="image-20231202192723221.png" alt="image-20231202192723221" /><figcaption aria-hidden="true">image-20231202192723221</figcaption></figure><h3 id="主目录"><strong>「主目录」</strong></h3><blockquote><p>主目录：管理员在创建用户的时候为其分配的特定目录</p></blockquote><ul><li>用户登录时，自动进入主目录</li><li>用户在其主目录拥有读、写和执行权限</li><li>用户在其主目录可以创建任意多的子目录</li><li>主目录名字通常和用户名相同</li></ul><h3 id="工作目录">「工作目录」</h3><blockquote><p>工作目录：用户先在在文件系统中的目录</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br><span class="line"><span class="comment">#查看目前的工作目录</span></span><br></pre></td></tr></table></figure><h3 id="路径">「路径」</h3><blockquote><p>路径：文件在文件系统中的位置描述方式</p></blockquote><p><strong>路径名用来定义文件。</strong></p><blockquote><p>绝对路径：从根目录开始到文件的路径</p></blockquote><figure><img src="image-20231202193349892.png" alt="image-20231202193349892" /><figcaption aria-hidden="true">image-20231202193349892</figcaption></figure><blockquote><p>相对路径：从当前目录开始到达文件的路径</p></blockquote><figure><img src="image-20231202193359114.png" alt="image-20231202193359114" /><figcaption aria-hidden="true">image-20231202193359114</figcaption></figure><h3 id="特殊符号"><strong>「特殊符号」</strong></h3><p><strong>点（.）：表示当前目录</strong></p><p><strong>点点（..）：表示当前目录的父目录</strong></p><h3 id="命名约束">「命名约束」</h3><p>文件和目录如何命名。</p><figure><img src="image-20231202193529448.png" alt="image-20231202193529448" /><figcaption aria-hidden="true">image-20231202193529448</figcaption></figure><h2 id="目录操作命令">4.目录操作命令</h2><h3 id="cd命令">「cd命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> [目录名]</span><br><span class="line"><span class="comment">#改变工作目录</span></span><br></pre></td></tr></table></figure><figure><img src="image-20231202193744996.png" alt="image-20231202193744996" /><figcaption aria-hidden="true">image-20231202193744996</figcaption></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span></span><br><span class="line"><span class="comment">#返回用户主目录</span></span><br><span class="line"><span class="built_in">cd</span> .</span><br><span class="line"><span class="comment">#进入当前目录</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="comment">#进入上一级目录</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="comment">#进入当前用户的主目录</span></span><br><span class="line"><span class="built_in">cd</span> ~tux</span><br><span class="line"><span class="comment">#进入tux主目录，前提是你有权限进入</span></span><br></pre></td></tr></table></figure><h3 id="mkdir命令">「mkdir命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> 目录名</span><br><span class="line"><span class="comment">#创建目录</span></span><br><span class="line"><span class="built_in">mkdir</span> 目录名1 目录名2 目录名3</span><br><span class="line"><span class="comment">#创建多个目录</span></span><br></pre></td></tr></table></figure><figure><img src="image-20231202194116992.png" alt="image-20231202194116992" /><figcaption aria-hidden="true">image-20231202194116992</figcaption></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一次创建多层目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p xx/yy/zz</span><br></pre></td></tr></table></figure><h3 id="rmdir命令">「rmdir命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除目录，只能删除空目录，即目录中只含有.和..</span></span><br><span class="line"><span class="built_in">rmdir</span> 「目录名」</span><br></pre></td></tr></table></figure><h3 id="ls命令">「ls命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#显示指定目录内容</span></span><br><span class="line"><span class="built_in">ls</span> 「目录名」</span><br></pre></td></tr></table></figure><figure><img src="image-20231202194341628.png" alt="image-20231202194341628" /><figcaption aria-hidden="true">image-20231202194341628</figcaption></figure><p><strong>选项 -l：</strong></p><figure><img src="image-20231202194434138.png" alt="image-20231202194434138" /><figcaption aria-hidden="true">image-20231202194434138</figcaption></figure><figure><img src="image-20231202194520579.png" alt="image-20231202194520579" /><figcaption aria-hidden="true">image-20231202194520579</figcaption></figure><p>第二列：文件的链接数</p><p>第三列：文件的所有者，通常与文件创建者用户名相同，文件的所有者发生转移，则两者不同</p><p>第四列：文件所属的组，管理员创建用户时，指定用户隶属于某个组，用户创建文件时，文件属于用户默认隶属的组</p><p>第五列：文件大小，单位字节</p><p>第六列：文件上一次修改的日期和时间</p><p>第七列：文件的名称</p><p><strong>选项 -a：</strong> 查看隐藏文件</p><figure><img src="image-20231202194822252.png" alt="image-20231202194822252" /><figcaption aria-hidden="true">image-20231202194822252</figcaption></figure><h3 id="cat命令">「cat命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#显示一个或多个文件的内容</span></span><br><span class="line"><span class="built_in">cat</span> 文件名1 文件名2 </span><br></pre></td></tr></table></figure><figure><img src="image-20231202194922602.png" alt="image-20231202194922602" /><figcaption aria-hidden="true">image-20231202194922602</figcaption></figure><h3 id="rm命令">「rm命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除文件</span></span><br><span class="line"><span class="built_in">rm</span> 文件名</span><br></pre></td></tr></table></figure><figure><img src="image-20231202194955122.png" alt="image-20231202194955122" /><figcaption aria-hidden="true">image-20231202194955122</figcaption></figure><figure><img src="image-20231202195022506.png" alt="image-20231202195022506" /><figcaption aria-hidden="true">image-20231202195022506</figcaption></figure><h1 id="五unix文件系统高级操作">五、UNIX文件系统高级操作</h1><h2 id="shell重定向">1.shell重定向</h2><figure><img src="image-20231202195437195.png" alt="image-20231202195437195" /><figcaption aria-hidden="true">image-20231202195437195</figcaption></figure><h3 id="输出重定向">「输出重定向」</h3><p>输出重定向允许用户将命令（进程）的输出保存到文件中</p><p>shell使用&gt;和&gt;&gt;作为输出重定向操作符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> &gt; filename <span class="comment">#覆盖重定向</span></span><br><span class="line"><span class="built_in">command</span> &gt;&gt; filename  <span class="comment">#追加重定向</span></span><br></pre></td></tr></table></figure><figure><img src="image-20231202200457240.png" alt="image-20231202200457240" /><figcaption aria-hidden="true">image-20231202200457240</figcaption></figure><h3 id="输入重定向">「输入重定向」</h3><p>输入重定向允许用户从指定文件得到输入来运行命令</p><figure><img src="image-20231202200542587.png" alt="image-20231202200542587" /><figcaption aria-hidden="true">image-20231202200542587</figcaption></figure><p><strong>shell使用&lt;和 &lt;&lt;作为输出重定向操作符</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">comand &lt; filename <span class="comment">#命令行中使用</span></span><br><span class="line"><span class="built_in">command</span> &lt;&lt; 分界符<span class="comment">#脚本编程中使用</span></span><br></pre></td></tr></table></figure><h2 id="文件操作命令">2.文件操作命令</h2><h3 id="cat命令-1">「cat命令」</h3><figure><img src="image-20231202200855618.png" alt="image-20231202200855618" /><figcaption aria-hidden="true">image-20231202200855618</figcaption></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> filename <span class="comment">#命令参数</span></span><br><span class="line"><span class="built_in">cat</span> &lt; filename <span class="comment">#输入重定向</span></span><br></pre></td></tr></table></figure><figure><img src="image-20231202200950422.png" alt="image-20231202200950422" /><figcaption aria-hidden="true">image-20231202200950422</figcaption></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; filename <span class="comment">#使用cat和输出重定向可以创建文件</span></span><br></pre></td></tr></table></figure><figure><img src="image-20231202201039530.png" alt="image-20231202201039530" /><figcaption aria-hidden="true">image-20231202201039530</figcaption></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt;&gt; filename <span class="comment"># 若文件不存在则会创建文件并将键盘输入内容输入到文件中，如存在则追加输入</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> filename &gt; filename.copy <span class="comment">#复制文件</span></span><br><span class="line"><span class="built_in">cat</span> filename1 filename2 &gt; filename.copy <span class="comment">#复制多个到一个</span></span><br></pre></td></tr></table></figure><figure><img src="image-20231202201447583.png" alt="image-20231202201447583" /><figcaption aria-hidden="true">image-20231202201447583</figcaption></figure><h3 id="cp命令">「cp命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> 文件名1 文件名2 <span class="comment">#创建文件副本</span></span><br><span class="line"><span class="built_in">cp</span>  filename1 filename2 目录名 <span class="comment">#将一个或多个文件复制到指定目录</span></span><br></pre></td></tr></table></figure><figure><img src="image-20231202201742015.png" alt="image-20231202201742015" /><figcaption aria-hidden="true">image-20231202201742015</figcaption></figure><figure><img src="image-20231202201803414.png" alt="image-20231202201803414" /><figcaption aria-hidden="true">image-20231202201803414</figcaption></figure><figure><img src="image-20231202201823928.png" alt="image-20231202201823928" /><figcaption aria-hidden="true">image-20231202201823928</figcaption></figure><p><strong>命令选项：</strong></p><blockquote><p><strong>-i</strong>：如果目标文件已经存在要求确认</p></blockquote><figure><img src="image-20231202201932935.png" alt="image-20231202201932935" /><figcaption aria-hidden="true">image-20231202201932935</figcaption></figure><blockquote><p><strong>-r</strong>：将目录复制到新的目录</p></blockquote><figure><img src="image-20231202202013511.png" alt="image-20231202202013511" /><figcaption aria-hidden="true">image-20231202202013511</figcaption></figure><h3 id="mv命令">「mv命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> 文件名（s） 目录 <span class="comment">#将文件移到其他目录（非文件所在目录）</span></span><br><span class="line"><span class="built_in">mv</span> 文件名1 文件名2 <span class="comment">#移动并改变文件名 </span></span><br></pre></td></tr></table></figure><figure><img src="image-20231202204134259.png" alt="image-20231202204134259" /><figcaption aria-hidden="true">image-20231202204134259</figcaption></figure><figure><img src="image-20231202204154232.png" alt="image-20231202204154232" /><figcaption aria-hidden="true">image-20231202204154232</figcaption></figure><figure><img src="image-20231202204205615.png" alt="image-20231202204205615" /><figcaption aria-hidden="true">image-20231202204205615</figcaption></figure><p><strong>命令选项：</strong></p><blockquote><p><strong>-i</strong> ：如果目标文件已经存在要求确认</p></blockquote><figure><img src="image-20231202204258626.png" alt="image-20231202204258626" /><figcaption aria-hidden="true">image-20231202204258626</figcaption></figure><h3 id="ln-命令">「ln 命令」</h3><p><strong>在已存在和新文件名之间创建链接，为已存在的文件起新名字，使用不同的名字引用同一文件</strong></p><ul><li>在不同目录中频繁操作同一文件</li><li>在每个目录中建立该文件的链接文件，通过链接文件对原文件进行操作</li><li>链接文件不占用过多的磁盘空间</li></ul><p>涉及文件存储的三个部分</p><figure><img src="image-20231202204606759.png" alt="image-20231202204606759" /><figcaption aria-hidden="true">image-20231202204606759</figcaption></figure><figure><img src="image-20231203102033260.png" alt="image-20231203102033260" /><figcaption aria-hidden="true">image-20231203102033260</figcaption></figure><figure><img src="image-20231203102140610.png" alt="image-20231203102140610" /><figcaption aria-hidden="true">image-20231203102140610</figcaption></figure><p>「wc命令」</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#计算一个或者多个文件的行数、字数和字符数</span></span><br><span class="line"><span class="built_in">wc</span> [文件名]</span><br><span class="line"><span class="comment">#无参数默认键盘输入</span></span><br><span class="line"><span class="built_in">wc</span></span><br><span class="line"><span class="comment">#统计多个文件</span></span><br><span class="line"><span class="built_in">wc</span> [文件名] [文件名]</span><br></pre></td></tr></table></figure><figure><img src="image-20231203102458849.png" alt="image-20231203102458849" /><figcaption aria-hidden="true">image-20231203102458849</figcaption></figure><p>选项：</p><blockquote><p>-l ：统计行数</p><p>-c：统计字符数</p><p>-w：统计字数</p></blockquote><figure><img src="image-20231203102721023.png" alt="image-20231203102721023" /><figcaption aria-hidden="true">image-20231203102721023</figcaption></figure><figure><img src="image-20231203102735066.png" alt="image-20231203102735066" /><figcaption aria-hidden="true">image-20231203102735066</figcaption></figure><h2 id="文件名替换">3.文件名替换</h2><figure><img src="image-20231203103037503.png" alt="image-20231203103037503" /><figcaption aria-hidden="true">image-20231203103037503</figcaption></figure><p>「?通配符」</p><blockquote><p>代表单个字符,不可为空</p></blockquote><figure><img src="image-20231203103420980.png" alt="image-20231203103420980" /><figcaption aria-hidden="true">image-20231203103420980</figcaption></figure><p>「*通配符」</p><blockquote><p>文件名中的任意个字符（包括0个）</p></blockquote><figure><img src="image-20231203103547461.png" alt="image-20231203103547461" /><figcaption aria-hidden="true">image-20231203103547461</figcaption></figure><figure><img src="image-20231203103559206.png" alt="image-20231203103559206" /><figcaption aria-hidden="true">image-20231203103559206</figcaption></figure><p>「[] 通配符」</p><blockquote><p>包含括号中指定的任一<strong>字符</strong></p></blockquote><figure><img src="image-20231203103837817.png" alt="image-20231203103837817" /><figcaption aria-hidden="true">image-20231203103837817</figcaption></figure><figure><img src="image-20231203103924092.png" alt="image-20231203103924092" /><figcaption aria-hidden="true">image-20231203103924092</figcaption></figure><h2 id="其它文件操作命令">4.其它文件操作命令</h2><h3 id="find命令">「find命令」</h3><blockquote><p>在多层目录中搜索指定文件，快速查看文件指定部分</p></blockquote><figure><img src="image-20231203104202314.png" alt="image-20231203104202314" /><figcaption aria-hidden="true">image-20231203104202314</figcaption></figure><figure><img src="image-20231203104329792.png" alt="image-20231203104329792" /><figcaption aria-hidden="true">image-20231203104329792</figcaption></figure><p>搜索选项：</p><figure><img src="image-20231203104352656.png" alt="image-20231203104352656" /><figcaption aria-hidden="true">image-20231203104352656</figcaption></figure><blockquote><p>-name : 通过文件名查找文件</p></blockquote><figure><img src="image-20231203104459455.png" alt="image-20231203104459455" /><figcaption aria-hidden="true">image-20231203104459455</figcaption></figure><blockquote><p>-type: 通过文件类型查找文件</p></blockquote><figure><img src="image-20231203104629325.png" alt="image-20231203104629325" /><figcaption aria-hidden="true">image-20231203104629325</figcaption></figure><p>动作选项：</p><figure><img src="image-20231203104715277.png" alt="image-20231203104715277" /><figcaption aria-hidden="true">image-20231203104715277</figcaption></figure><blockquote><p>-exec:用户给出命令，对找到的文件进行操作</p></blockquote><figure><img src="image-20231203104903043.png" alt="image-20231203104903043" /><figcaption aria-hidden="true">image-20231203104903043</figcaption></figure><blockquote><p>-ok:用户执行命令前需要确认</p></blockquote><figure><img src="image-20231203105155036.png" alt="image-20231203105155036" /><figcaption aria-hidden="true">image-20231203105155036</figcaption></figure><h3 id="head命令">「head命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#显示文件头部若干行</span></span><br><span class="line"><span class="built_in">head</span> [filenames]  <span class="comment">#默认显示前10行</span></span><br></pre></td></tr></table></figure><blockquote><p>-n： 显示文件前n行</p></blockquote><figure><img src="image-20231204090519119.png" alt="image-20231204090519119" /><figcaption aria-hidden="true">image-20231204090519119</figcaption></figure><h3 id="tail命令">「tail命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#显示文件尾部若干行</span></span><br><span class="line"><span class="built_in">tail</span> [filenames] <span class="comment">#默认后10行</span></span><br></pre></td></tr></table></figure><blockquote><p>-n ： 显示文件后n行</p></blockquote><figure><img src="image-20231204090715118.png" alt="image-20231204090715118" /><figcaption aria-hidden="true">image-20231204090715118</figcaption></figure><h3 id="cut命令">「cut命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从文件中取出指定域或列</span></span><br><span class="line"><span class="built_in">cut</span> 选项 文件名</span><br></pre></td></tr></table></figure><blockquote><p>-f : 指定域位置 ，1，3，5 1-3，5</p></blockquote><figure><img src="image-20231204091146132.png" alt="image-20231204091146132" /><figcaption aria-hidden="true">image-20231204091146132</figcaption></figure><figure><img src="image-20231204091217513.png" alt="image-20231204091217513" /><figcaption aria-hidden="true">image-20231204091217513</figcaption></figure><blockquote><p>-c ：指定字符的位置</p></blockquote><figure><img src="image-20231204091313084.png" alt="image-20231204091313084" /><figcaption aria-hidden="true">image-20231204091313084</figcaption></figure><blockquote><p>-d ：指定域分隔字符</p></blockquote><figure><img src="image-20231204091403924.png" alt="image-20231204091403924" /><figcaption aria-hidden="true">image-20231204091403924</figcaption></figure><h3 id="paste命令">「paste命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逐行连接两个或多个文件</span></span><br><span class="line"><span class="built_in">paste</span> file1 file2+（s）</span><br></pre></td></tr></table></figure><blockquote><p>-d：指定具体分隔符，默认为制表符</p></blockquote><figure><img src="image-20231204091627160.png" alt="image-20231204091627160" /><figcaption aria-hidden="true">image-20231204091627160</figcaption></figure><figure><img src="image-20231204091647719.png" alt="image-20231204091647719" /><figcaption aria-hidden="true">image-20231204091647719</figcaption></figure><h3 id="more命令">「more命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#另页查看工具</span></span><br><span class="line">more filename</span><br></pre></td></tr></table></figure><blockquote><p>-lines :每屏显示的行数</p><p>+line-number :从第line-number 行开始显示</p><p>+/pattern : 从包含pattern的行的上两行开始显示</p><p>-c :在显示每页之前清屏</p><p>-d :显示提示[Press space to continue, ‘q’ to quit]</p></blockquote><figure><img src="image-20231204091933287.png" alt="image-20231204091933287" /><figcaption aria-hidden="true">image-20231204091933287</figcaption></figure><h3 id="less命令">「less命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#分页查看工具，允许在文件中向后和向前移动</span></span><br><span class="line">less filename</span><br></pre></td></tr></table></figure><p>基于more 和 vi 更高级的工具</p><h2 id="unix-内部文件系统">5.UNIX 内部：文件系统</h2><figure><img src="image-20231204092210032.png" alt="image-20231204092210032" /><figcaption aria-hidden="true">image-20231204092210032</figcaption></figure><figure><img src="image-20231204092224326.png" alt="image-20231204092224326" /><figcaption aria-hidden="true">image-20231204092224326</figcaption></figure><figure><img src="image-20231204092310347.png" alt="image-20231204092310347" /><figcaption aria-hidden="true">image-20231204092310347</figcaption></figure><h1 id="六探索shell">六、探索shell</h1><h2 id="启动shell">1.启动shell</h2><p>用户成功登录系统，shell启动，用户退出，shell进程结束</p><p>系统中每个用户都有一个默认的shell，在系统口令文件/etc/passwd指定</p><figure><img src="image-20231204093910980.png" alt="image-20231204093910980" /><figcaption aria-hidden="true">image-20231204093910980</figcaption></figure><figure><img src="image-20231204093928448.png" alt="image-20231204093928448" /><figcaption aria-hidden="true">image-20231204093928448</figcaption></figure><figure><img src="image-20231204094005033.png" alt="image-20231204094005033" /><figcaption aria-hidden="true">image-20231204094005033</figcaption></figure><h2 id="shell的主要功能">2.shell的主要功能</h2><figure><img src="image-20231204094146647.png" alt="image-20231204094146647" /><figcaption aria-hidden="true">image-20231204094146647</figcaption></figure><figure><img src="image-20231204094215586.png" alt="image-20231204094215586" /><figcaption aria-hidden="true">image-20231204094215586</figcaption></figure><h3 id="正则表达式">「正则表达式」</h3><figure><img src="image-20231204133415834.png" alt="image-20231204133415834" /><figcaption aria-hidden="true">image-20231204133415834</figcaption></figure><figure><img src="image-20231204133446879.png" alt="image-20231204133446879" /><figcaption aria-hidden="true">image-20231204133446879</figcaption></figure><figure><img src="image-20231204133543972.png" alt="image-20231204133543972" /><figcaption aria-hidden="true">image-20231204133543972</figcaption></figure><p>例子：</p><figure><img src="image-20231204133732850.png" alt="image-20231204133732850" /><figcaption aria-hidden="true">image-20231204133732850</figcaption></figure><p><strong>POSIX标准正则表达式：</strong></p><figure><img src="image-20231204133904964.png" alt="image-20231204133904964" /><figcaption aria-hidden="true">image-20231204133904964</figcaption></figure><p><strong>扩展正则表达式：仅在部分程序中支持，例如 egrep、awk 等</strong></p><figure><img src="image-20231204134201536.png" alt="image-20231204134201536" /><figcaption aria-hidden="true">image-20231204134201536</figcaption></figure><p>例子：</p><figure><img src="image-20231204134254841.png" alt="image-20231204134254841" /><figcaption aria-hidden="true">image-20231204134254841</figcaption></figure><p><strong>正则表达式与通配符区别：</strong> <img src="image-20231204134330146.png" alt="image-20231204134330146" /></p><h3 id="echo命令">「echo命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将消息参数显示在用户终端上，没有参数输出空行</span></span><br><span class="line"><span class="built_in">echo</span> message</span><br></pre></td></tr></table></figure><figure><img src="image-20231204094319850.png" alt="image-20231204094319850" /><figcaption aria-hidden="true">image-20231204094319850</figcaption></figure><blockquote><p>-n ：禁止换行，输出后不换行</p></blockquote><figure><img src="image-20231204135140526.png" alt="image-20231204135140526" /><figcaption aria-hidden="true">image-20231204135140526</figcaption></figure><blockquote><p>-e ：解释反斜杠引导的转义字符（用于控制消息格式的字符，字符串的一部分，以）</p></blockquote><figure><img src="image-20231204094459579.png" alt="image-20231204094459579" /><figcaption aria-hidden="true">image-20231204094459579</figcaption></figure><figure><img src="image-20231204133102241.png" alt="image-20231204133102241" /><figcaption aria-hidden="true">image-20231204133102241</figcaption></figure><figure><img src="image-20231204133128633.png" alt="image-20231204133128633" /><figcaption aria-hidden="true">image-20231204133128633</figcaption></figure><figure><img src="image-20231204135012223.png" alt="image-20231204135012223" /><figcaption aria-hidden="true">image-20231204135012223</figcaption></figure><figure><img src="image-20231204133213407.png" alt="image-20231204133213407" /><figcaption aria-hidden="true">image-20231204133213407</figcaption></figure><h3 id="消除元字符的特殊含义">「消除元字符的特殊含义」</h3><blockquote><p>元字符：shell中具有特殊含义和用途的字符，在shell中出现时不代表字面含义</p></blockquote><p>如： <img src="image-20231204135653676.png" alt="image-20231204135653676" /></p><p>消除元字符特殊含义的<strong>元字符</strong>：</p><figure><img src="image-20231204135735214.png" alt="image-20231204135735214" /><figcaption aria-hidden="true">image-20231204135735214</figcaption></figure><blockquote><p> :后面的元字符按照字符的字面量解释</p></blockquote><blockquote><p>" " ： 取消除$、`、。双引号中保留空白字符（空格、制表和换行符等）</p></blockquote><figure><img src="image-20231204140215379.png" alt="image-20231204140215379" /><figcaption aria-hidden="true">image-20231204140215379</figcaption></figure><blockquote><p>' ' ： 单引号中任何字符都失去特殊含义，单引号中保留空白字符（空格、制表和换行符等）</p></blockquote><figure><img src="image-20231204140531736.png" alt="image-20231204140531736" /><figcaption aria-hidden="true">image-20231204140531736</figcaption></figure><h2 id="shell变量">3.shell变量</h2><blockquote><ul><li>shell为响应用户请求，保存一些信息到shell变量中</li><li>变量有名称，可以通过赋值来控制或定制系统环境</li></ul></blockquote><figure><img src="image-20231204140700159.png" alt="image-20231204140700159" /><figcaption aria-hidden="true">image-20231204140700159</figcaption></figure><h3 id="显示和清除变量set和unset">「显示和清除变量：set和unset」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看当前使用的shell变量（环境变量和局部变量）</span></span><br><span class="line"><span class="built_in">set</span></span><br></pre></td></tr></table></figure><figure><img src="image-20231204140851846.png" alt="image-20231204140851846" /><figcaption aria-hidden="true">image-20231204140851846</figcaption></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除不需要的变量</span></span><br><span class="line"><span class="built_in">unset</span></span><br></pre></td></tr></table></figure><figure><img src="image-20231204141227863.png" alt="image-20231204141227863" /><figcaption aria-hidden="true">image-20231204141227863</figcaption></figure><p><strong>赋值时，等号左右无空格</strong></p><h3 id="给变量赋值">「给变量赋值」</h3><figure><img src="image-20231204141317503.png" alt="image-20231204141317503" /><figcaption aria-hidden="true">image-20231204141317503</figcaption></figure><h3 id="显示shell变量的值">「显示shell变量的值」</h3><figure><img src="image-20231204141350586.png" alt="image-20231204141350586" /><figcaption aria-hidden="true">image-20231204141350586</figcaption></figure><blockquote><p>shell变量可用于在命令行中帮助保存复杂选项或参数</p></blockquote><figure><img src="image-20231204142142961.png" alt="image-20231204142142961" /><figcaption aria-hidden="true">image-20231204142142961</figcaption></figure><h3 id="shell的标准变量">「shell的标准变量」</h3><figure><img src="image-20231204142211346.png" alt="image-20231204142211346" /><figcaption aria-hidden="true">image-20231204142211346</figcaption></figure><p><strong>标准变量：</strong></p><blockquote><p>HOME:保存用户主目录；用于其他命令定位主目录</p></blockquote><figure><img src="image-20231204142314306.png" alt="image-20231204142314306" /><figcaption aria-hidden="true">image-20231204142314306</figcaption></figure><blockquote><p>PATH : 设置shell载入外部命令（程序）时所要查找的目录</p></blockquote><figure><img src="image-20231204142634082.png" alt="image-20231204142634082" /><figcaption aria-hidden="true">image-20231204142634082</figcaption></figure><p><strong>路径间的分隔符是 ：</strong></p><figure><img src="image-20231204143119671.png" alt="image-20231204143119671" /><figcaption aria-hidden="true">image-20231204143119671</figcaption></figure><blockquote><p>PS1 : 设置作为命令提示符的字符串</p></blockquote><figure><img src="image-20231204143511681.png" alt="image-20231204143511681" /><figcaption aria-hidden="true">image-20231204143511681</figcaption></figure><figure><img src="image-20231204143529264.png" alt="image-20231204143529264" /><figcaption aria-hidden="true">image-20231204143529264</figcaption></figure><figure><img src="image-20231204143619476.png" alt="image-20231204143619476" /><figcaption aria-hidden="true">image-20231204143619476</figcaption></figure><figure><img src="image-20231204143657006.png" alt="image-20231204143657006" /><figcaption aria-hidden="true">image-20231204143657006</figcaption></figure><blockquote><p>PS2 : 多行输入一条命令时，设置第二行及以后行的提示符，默认为&gt;</p></blockquote><figure><img src="image-20231204144200378.png" alt="image-20231204144200378" /><figcaption aria-hidden="true">image-20231204144200378</figcaption></figure><figure><img src="image-20231204144144616.png" alt="image-20231204144144616" /><figcaption aria-hidden="true">image-20231204144144616</figcaption></figure><figure><img src="image-20231204144216316.png" alt="image-20231204144216316" /><figcaption aria-hidden="true">image-20231204144216316</figcaption></figure><blockquote><p>SHELL：设置登录的shell的完整路径</p></blockquote><figure><img src="image-20231204144325814.png" alt="image-20231204144325814" /><figcaption aria-hidden="true">image-20231204144325814</figcaption></figure><blockquote><p>TERM ： 设置终端类型</p></blockquote><figure><img src="image-20231204144401392.png" alt="image-20231204144401392" /><figcaption aria-hidden="true">image-20231204144401392</figcaption></figure><h2 id="其他元字符">4.其他元字符</h2><h3 id="执行命令使用重音符号">「执行命令：使用重音符号 ` 」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># `告诉shell先执行重音符号扩起来的命令，结果替换命令行中原来扩起来的命令，也称命令替换符</span></span><br></pre></td></tr></table></figure><figure><img src="image-20231204150134375.png" alt="image-20231204150134375" /><figcaption aria-hidden="true">image-20231204150134375</figcaption></figure><figure><img src="image-20231204150428115.png" alt="image-20231204150428115" /><figcaption aria-hidden="true">image-20231204150428115</figcaption></figure><h3 id="命令序列使用分号">「命令序列：使用分号 ; 」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在一个命令行中分隔多个命令，shell从左到右执行</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><figure><img src="image-20231204150612587.png" alt="image-20231204150612587" /><figcaption aria-hidden="true">image-20231204150612587</figcaption></figure><h3 id="命令编组使用括号">「命令编组：使用括号 ( )」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#几个命令放在一对括号中，编为一组执行，编组命令可以被重定向</span></span><br><span class="line">()</span><br></pre></td></tr></table></figure><figure><img src="image-20231204150730847.png" alt="image-20231204150730847" /><figcaption aria-hidden="true">image-20231204150730847</figcaption></figure><h3 id="后台处理使用-符号">「后台处理：使用 &amp; 符号」</h3><blockquote><p>UNIX 是多任务系统，允许同时执行多个程序</p></blockquote><figure><img src="image-20231204151039451.png" alt="image-20231204151039451" /><figcaption aria-hidden="true">image-20231204151039451</figcaption></figure><figure><img src="image-20231204151240267.png" alt="image-20231204151240267" /><figcaption aria-hidden="true">image-20231204151240267</figcaption></figure><h3 id="链接命令使用管道操作符">「链接命令：使用管道操作符 | 」</h3><blockquote><div class="line-block">： 将一个命令的标准输出作为另一个命令的标准输入</div></blockquote><figure><img src="image-20231204151409765.png" alt="image-20231204151409765" /><figcaption aria-hidden="true">image-20231204151409765</figcaption></figure><h2 id="其他unix系统工具">5.其他UNIX系统工具</h2><h3 id="sleep命令">「sleep命令」</h3><blockquote><p>sleep：使执行该命令的进程延时指定的秒数</p></blockquote><h3 id="ps-命令">「ps 命令」</h3><blockquote><p>ps：查看进程详细信息</p></blockquote><figure><img src="image-20231204151807585.png" alt="image-20231204151807585" /><figcaption aria-hidden="true">image-20231204151807585</figcaption></figure><p>选项： &gt;-e：显示所有进程 &gt;-f： 显示信息的完整列表（包括完整的命令行）</p><h3 id="kill命令">「kill命令」</h3><blockquote><p>kill ：发信号给指定进程，进行进程间的通信</p></blockquote><figure><img src="image-20231204152126562.png" alt="image-20231204152126562" /><figcaption aria-hidden="true">image-20231204152126562</figcaption></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> [-signal] PID</span><br></pre></td></tr></table></figure><figure><img src="image-20231204152231320.png" alt="image-20231204152231320" /><figcaption aria-hidden="true">image-20231204152231320</figcaption></figure><figure><img src="image-20231204152509331.png" alt="image-20231204152509331" /><figcaption aria-hidden="true">image-20231204152509331</figcaption></figure><h3 id="tee命令">「tee命令」</h3><figure><img src="image-20231204152538886.png" alt="image-20231204152538886" /><figcaption aria-hidden="true">image-20231204152538886</figcaption></figure><figure><img src="image-20231204152651165.png" alt="image-20231204152651165" /><figcaption aria-hidden="true">image-20231204152651165</figcaption></figure><figure><img src="image-20231204152757094.png" alt="image-20231204152757094" /><figcaption aria-hidden="true">image-20231204152757094</figcaption></figure><p><strong>注意：覆盖式输出。</strong></p><p><strong>选项：</strong></p><blockquote><p>-a ： 追加而非覆盖</p></blockquote><h3 id="grep命令">「grep命令」</h3><blockquote><p>在一个或多个文件中查找满足特定格式的行</p></blockquote><figure><img src="image-20231204152855243.png" alt="image-20231204152855243" /><figcaption aria-hidden="true">image-20231204152855243</figcaption></figure><figure><img src="image-20231204152908288.png" alt="image-20231204152908288" /><figcaption aria-hidden="true">image-20231204152908288</figcaption></figure><figure><img src="image-20231204152945454.png" alt="image-20231204152945454" /><figcaption aria-hidden="true">image-20231204152945454</figcaption></figure><h3 id="sort命令">「sort命令」</h3><blockquote><p>对文件内容按照字母或者数字顺序排序</p></blockquote><figure><img src="image-20231204153040406.png" alt="image-20231204153040406" /><figcaption aria-hidden="true">image-20231204153040406</figcaption></figure><figure><img src="image-20231204153056280.png" alt="image-20231204153056280" /><figcaption aria-hidden="true">image-20231204153056280</figcaption></figure><h2 id="启动文件">6.启动文件</h2><h3 id="shell环境配置文件">「shell环境配置文件」</h3><figure><img src="image-20231204153205012.png" alt="image-20231204153205012" /><figcaption aria-hidden="true">image-20231204153205012</figcaption></figure><h3 id="登录shell与非登录shell">「登录shell与非登录shell」</h3><figure><img src="image-20231204153352222.png" alt="image-20231204153352222" /><figcaption aria-hidden="true">image-20231204153352222</figcaption></figure><h3 id="配置文件功能">「配置文件功能」</h3><figure><img src="image-20231204153421749.png" alt="image-20231204153421749" /><figcaption aria-hidden="true">image-20231204153421749</figcaption></figure><figure><img src="image-20231204153515457.png" alt="image-20231204153515457" /><figcaption aria-hidden="true">image-20231204153515457</figcaption></figure><figure><img src="image-20231204153646249.png" alt="image-20231204153646249" /><figcaption aria-hidden="true">image-20231204153646249</figcaption></figure><figure><img src="image-20231204153736701.png" alt="image-20231204153736701" /><figcaption aria-hidden="true">image-20231204153736701</figcaption></figure><figure><img src="image-20231204153748650.png" alt="image-20231204153748650" /><figcaption aria-hidden="true">image-20231204153748650</figcaption></figure><h3 id="alias命令">「alias命令」</h3><figure><img src="image-20231204153904462.png" alt="image-20231204153904462" /><figcaption aria-hidden="true">image-20231204153904462</figcaption></figure><figure><img src="image-20231204153958644.png" alt="image-20231204153958644" /><figcaption aria-hidden="true">image-20231204153958644</figcaption></figure><h2 id="unix进程管理">7.UNIX进程管理</h2><figure><img src="image-20231204154021259.png" alt="image-20231204154021259" /><figcaption aria-hidden="true">image-20231204154021259</figcaption></figure><figure><img src="image-20231204154035124.png" alt="image-20231204154035124" /><figcaption aria-hidden="true">image-20231204154035124</figcaption></figure><figure><img src="image-20231204154101766.png" alt="image-20231204154101766" /><figcaption aria-hidden="true">image-20231204154101766</figcaption></figure><figure><img src="image-20231204154119984.png" alt="image-20231204154119984" /><figcaption aria-hidden="true">image-20231204154119984</figcaption></figure><figure><img src="image-20231204154131717.png" alt="image-20231204154131717" /><figcaption aria-hidden="true">image-20231204154131717</figcaption></figure><h1 id="七程序开发">七、程序开发</h1><h2 id="程序的编辑翻译与执行">1.程序的编辑、翻译与执行</h2><h3 id="建立可执行程序的步骤">「建立可执行程序的步骤」</h3><ol type="1"><li>编写源文件（源代码）</li><li>建立目标文件（目标代码/目标模块）</li><li>建立可执行文件（可执行代码/载入模块）</li></ol><figure><img src="image-20231204160927261.png" alt="image-20231204160927261" /><figcaption aria-hidden="true">image-20231204160927261</figcaption></figure><h3 id="编译解释程序">「编译/解释程序」</h3><figure><img src="image-20231204161014316.png" alt="image-20231204161014316" /><figcaption aria-hidden="true">image-20231204161014316</figcaption></figure><h2 id="编译链接cc程序">2.编译、链接C/C++程序</h2><blockquote><p>gcc ： GNU C 编译器，Linux通用 C 语言编译器</p><p>g++：GNU C++ 语言编译器</p></blockquote><h3 id="gcc-g-执行编译的步骤">「gcc / g++ 执行编译的步骤」</h3><ol type="1"><li><p>预处理：把头文件展开，去掉注释，宏替换，条件编译等；</p><p>​ 生成 <strong>.i</strong> 文件</p></li><li><p>编 译：将预处理后的文件转换成<strong>汇编语言</strong></p><p>​ 生成 <strong>.s</strong> 文件</p></li><li><p>汇 编：由汇编语言变为<strong>目标代码（机器代码）</strong></p><p>​ 生成 <strong>.o</strong> 文件</p></li><li><p>链 接：链接目标代码，生成<strong>可执行程序</strong></p></li></ol><figure><img src="image-20231204161322195.png" alt="image-20231204161322195" /><figcaption aria-hidden="true">image-20231204161322195</figcaption></figure><h3 id="gcc-g编译程序">「gcc / g++编译程序」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc [选项] 源文件名</span><br></pre></td></tr></table></figure><p>选项：</p><blockquote><p>-c ：只进行<strong>预处理、编译和汇编</strong>，只生成程序的目标代码文件</p><p>-o ： 指定<strong>生成的可执行程序名</strong>，缺省时候生成的可执行程序名是 a.out ；语法: -o 文件名</p></blockquote><figure><img src="image-20231204161547150.png" alt="image-20231204161547150" /><figcaption aria-hidden="true">image-20231204161547150</figcaption></figure><figure><img src="image-20231204161612641.png" alt="image-20231204161612641" /><figcaption aria-hidden="true">image-20231204161612641</figcaption></figure><h2 id="重定向程序输出与出错信息">3.重定向程序输出与出错信息</h2><figure><img src="image-20231204161657044.png" alt="image-20231204161657044" /><figcaption aria-hidden="true">image-20231204161657044</figcaption></figure><figure><img src="image-20231204161829042.png" alt="image-20231204161829042" /><figcaption aria-hidden="true">image-20231204161829042</figcaption></figure><h2 id="make工具看不懂原理">4.make工具（<u>看不懂原理</u>）</h2><blockquote><p>make工具 ： GNU工程化编译工具，用于编译众多相互关联的源代码文件</p></blockquote><figure><img src="image-20231204161934418.png" alt="image-20231204161934418" /><figcaption aria-hidden="true">image-20231204161934418</figcaption></figure><figure><img src="image-20231204161949121.png" alt="image-20231204161949121" /><figcaption aria-hidden="true">image-20231204161949121</figcaption></figure><figure><img src="image-20231204162001606.png" alt="image-20231204162001606" /><figcaption aria-hidden="true">image-20231204162001606</figcaption></figure><figure><img src="image-20231204162333300.png" alt="image-20231204162333300" /><figcaption aria-hidden="true">image-20231204162333300</figcaption></figure><h1 id="八shell编程">八、shell编程</h1><h2 id="unix-shell编程语言简介">1.UNIX shell编程语言简介</h2><figure><img src="image-20231204163613672.png" alt="image-20231204163613672" /><figcaption aria-hidden="true">image-20231204163613672</figcaption></figure><figure><img src="image-20231204163747359.png" alt="image-20231204163747359" /><figcaption aria-hidden="true">image-20231204163747359</figcaption></figure><figure><img src="image-20231204163848400.png" alt="image-20231204163848400" /><figcaption aria-hidden="true">image-20231204163848400</figcaption></figure><p><strong>前提条件：</strong></p><ol type="1"><li><strong>对于使用sh命令的方法：脚本中的命令要与使用的shell兼容</strong></li><li><strong>对于第二种方法：要先使文件对于用户或所有者具有可执行权限</strong></li></ol><figure><img src="image-20231204164023952.png" alt="image-20231204164023952" /><figcaption aria-hidden="true">image-20231204164023952</figcaption></figure><figure><img src="image-20231204164102844.png" alt="image-20231204164102844" /><figcaption aria-hidden="true">image-20231204164102844</figcaption></figure><figure><img src="image-20231204164242380.png" alt="image-20231204164242380" /><figcaption aria-hidden="true">image-20231204164242380</figcaption></figure><figure><img src="image-20231204164437159.png" alt="image-20231204164437159" /><figcaption aria-hidden="true">image-20231204164437159</figcaption></figure><h3 id="退出shell的方法">「退出shell的方法」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br><span class="line">Ctrl -d</span><br></pre></td></tr></table></figure><h3 id="执行脚本">「执行脚本」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh program  <span class="comment">#不需要执行权限，在子shell中进行，脚本文件需要与所用shell兼容</span></span><br><span class="line">./program   <span class="comment">#要具有可执行的权限，在子shell中进行</span></span><br><span class="line">. program   <span class="comment">#不需要可执行权限，在当前shell中执行</span></span><br></pre></td></tr></table></figure><figure><img src="image-20231205100059587.png" alt="image-20231205100059587" /><figcaption aria-hidden="true">image-20231205100059587</figcaption></figure><h2 id="编程基础">2.编程基础</h2><h3 id="命令置换-命令">「命令置换 ``命令」</h3><blockquote><p>将一个命令的输出作为另一个命令的参数(重音符号)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="built_in">command</span>`</span><br></pre></td></tr></table></figure><figure><img src="image-20231205100259221.png" alt="image-20231205100259221" /><figcaption aria-hidden="true">image-20231205100259221</figcaption></figure><h3 id="读取输入-read命令">「读取输入 read命令」</h3><blockquote><p>从标准输入设备读入字符串存入变量中</p></blockquote><p><strong>多变量输入</strong>：输入中第1个字符串存入第1个变量，第2个字符串存入第2个变量，…，字符串数多于变量数，所有剩余字符存入最后一个变量</p><figure><img src="image-20231205100411909.png" alt="image-20231205100411909" /><figcaption aria-hidden="true">image-20231205100411909</figcaption></figure><h3 id="自定义变量">「自定义变量」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名=变量值</span><br></pre></td></tr></table></figure><ul><li><p><strong>shell不支持数据类型，赋给变量的值解释成字符串</strong></p></li><li><p><strong>变量名遵守与文件命名同样的语法规则</strong></p></li><li><p><strong>变量可以在shell提示符下定义并使用</strong></p></li></ul><p>生存周期：变量保存在内存中，直到脚本结束或终止</p><h3 id="清除变量"><strong>「清除变量」：</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> 变量名</span><br></pre></td></tr></table></figure><h3 id="显示变量值">「显示变量值」：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $变量名</span><br></pre></td></tr></table></figure><h3 id="命令行参数">「命令行参数」：</h3><blockquote><p>又称位置变量，用户输入命令时后面跟的数据项，空格分隔</p></blockquote><ol type="1"><li><strong>参数传递给程序，可以改变程序行为或执行顺序</strong></li><li><strong>按顺序命令行参数被命名为$0、$1、…$9</strong></li><li>**命令行参数多于9个，第9个之后的被忽略，但可通过$*获得**</li></ol><figure><img src="image-20231205100834762.png" alt="image-20231205100834762" /><figcaption aria-hidden="true">image-20231205100834762</figcaption></figure><h3 id="set-命令">「set 命令」</h3><blockquote><p>给位置变量赋值，set参数依次赋值给位置变量</p></blockquote><figure><img src="image-20231205100950854.png" alt="image-20231205100950854" /><figcaption aria-hidden="true">image-20231205100950854</figcaption></figure><h3 id="exit">「exit」</h3><blockquote><p>shell内部命令，立即终止程序运行</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span> n</span><br></pre></td></tr></table></figure><ul><li><strong>n是退出状态，也称返回码</strong></li><li><strong>没有提供返回码，使用shell执行最后一条命令的退出值</strong></li><li><strong>为与其他UNIX程序/命令完成时返回一个退出状态，保持一致，编写shell脚本，返回给父进程一个退出状态</strong></li></ul><h2 id="条件与测试语句">3.条件与测试语句</h2><h3 id="if-then">「if-then」</h3><figure><img src="image-20231205101350833.png" alt="image-20231205101350833" /><figcaption aria-hidden="true">image-20231205101350833</figcaption></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure><img src="image-20231205101431498.png" alt="image-20231205101431498" /><figcaption aria-hidden="true">image-20231205101431498</figcaption></figure><h3 id="if-then-else">「if-then-else」</h3><figure><img src="image-20231205101530279.png" alt="image-20231205101530279" /><figcaption aria-hidden="true">image-20231205101530279</figcaption></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure><img src="image-20231205101603297.png" alt="image-20231205101603297" /><figcaption aria-hidden="true">image-20231205101603297</figcaption></figure><p>「if -then-eif」</p><figure><img src="image-20231205101637201.png" alt="image-20231205101603297" /><figcaption aria-hidden="true">image-20231205101603297</figcaption></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition1 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> [ condition2 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> [condition3 ]</span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="test">「test」</h3><blockquote><p>内部命令，它计算作为其参数的表达式的真假</p></blockquote><ul><li><strong><em>真返回0，</em>假返回非0值</strong></li><li><strong>[ condition ]是test命令的一种特殊写法</strong></li></ul><figure><img src="image-20231205103608624.png" alt="image-20231205103608624" /><figcaption aria-hidden="true">image-20231205103608624</figcaption></figure><figure><img src="image-20231205103641272.png" alt="image-20231205103641272" /><figcaption aria-hidden="true">image-20231205103641272</figcaption></figure><p><strong>判断数值：</strong></p><figure><img src="image-20231205103654191.png" alt="image-20231205103654191" /><figcaption aria-hidden="true">image-20231205103654191</figcaption></figure><p><strong>判断字符串：</strong></p><figure><img src="image-20231205103707192.png" alt="image-20231205103707192" /><figcaption aria-hidden="true">image-20231205103707192</figcaption></figure><figure><img src="image-20231205103733801.png" alt="image-20231205103733801" /><figcaption aria-hidden="true">image-20231205103733801</figcaption></figure><figure><img src="image-20231205103751538.png" alt="image-20231205103751538" /><figcaption aria-hidden="true">image-20231205103751538</figcaption></figure><p><strong>文件检测：</strong></p><figure><img src="image-20231205103934119.png" alt="image-20231205103934119" /><figcaption aria-hidden="true">image-20231205103934119</figcaption></figure><figure><img src="image-20231205104022879.png" alt="image-20231205104022879" /><figcaption aria-hidden="true">image-20231205104022879</figcaption></figure><h2 id="算术运算">4.算术运算</h2><h3 id="expr">「expr 」</h3><figure><img src="image-20231205104139324.png" alt="image-20231205104139324" /><figcaption aria-hidden="true">image-20231205104139324</figcaption></figure><figure><img src="image-20231205104225736.png" alt="image-20231205104225736" /><figcaption aria-hidden="true">image-20231205104225736</figcaption></figure><figure><img src="image-20231205104242409.png" alt="image-20231205104242409" /><figcaption aria-hidden="true">image-20231205104242409</figcaption></figure><h3 id="let">「let」</h3><figure><img src="image-20231205104313227.png" alt="image-20231205104313227" /><figcaption aria-hidden="true">image-20231205104313227</figcaption></figure><h2 id="循环">5.循环</h2><h3 id="for">「for」</h3><figure><img src="image-20231205104412482.png" alt="image-20231205104412482" /><figcaption aria-hidden="true">image-20231205104412482</figcaption></figure><figure><img src="image-20231205104428159.png" alt="image-20231205104428159" /><figcaption aria-hidden="true">image-20231205104428159</figcaption></figure><h3 id="while循环">「while循环」</h3><h1 id="九系统管理">九、系统管理</h1><h2 id="文件系统管理">1.文件系统管理</h2><figure><img src="image-20231205104731672.png" alt="image-20231205104731672" /><figcaption aria-hidden="true">image-20231205104731672</figcaption></figure><h3 id="fdisk-命令">「fdisk 命令」</h3><figure><img src="image-20231205104812741.png" alt="image-20231205104812741" /><figcaption aria-hidden="true">image-20231205104812741</figcaption></figure><h3 id="mkfs">「mkfs」</h3><figure><img src="image-20231205104853625.png" alt="image-20231205104853625" /><figcaption aria-hidden="true">image-20231205104853625</figcaption></figure><h3 id="mount">「mount」</h3><figure><img src="image-20231205104922676.png" alt="image-20231205104922676" /><figcaption aria-hidden="true">image-20231205104922676</figcaption></figure><figure><img src="image-20231205104945923.png" alt="image-20231205104945923" /><figcaption aria-hidden="true">image-20231205104945923</figcaption></figure><h3 id="df">「df」</h3><figure><img src="image-20231205105013868.png" alt="image-20231205105013868" /><figcaption aria-hidden="true">image-20231205105013868</figcaption></figure><h3 id="du">「du」</h3><figure><img src="image-20231205105036834.png" alt="image-20231205105036834" /><figcaption aria-hidden="true">image-20231205105036834</figcaption></figure><h2 id="存档和压缩文件">2.存档和压缩文件</h2><h3 id="tar">「tar」</h3><figure><img src="image-20231205105131143.png" alt="image-20231205105131143" /><figcaption aria-hidden="true">image-20231205105131143</figcaption></figure><figure><img src="image-20231205105225215.png" alt="image-20231205105225215" /><figcaption aria-hidden="true">image-20231205105225215</figcaption></figure><figure><img src="image-20231205105302202.png" alt="image-20231205105302202" /><figcaption aria-hidden="true">image-20231205105302202</figcaption></figure><figure><img src="image-20231205105317906.png" alt="image-20231205105317906" /><figcaption aria-hidden="true">image-20231205105317906</figcaption></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;声明：本篇文章参考和引用了2023下半年吉林大学郭东老师的PPT，如有侵权，请联系我，我将会立马删除&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;一unix操作系统&quot;&gt;一、UNIX操作系统&lt;/h1&gt;
&lt;h2 id=&quot;历史简介&quot;&gt;1.历史简介&lt;/h2&gt;
&lt;</summary>
      
    
    
    
    <category term="class" scheme="https://klklkl10086.github.io/klklkl10086.github.io/categories/class/"/>
    
    
    <category term="Linux" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>学习生活随记</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2023/07/28/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2023/07/28/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</id>
    <published>2023-07-28T07:43:29.000Z</published>
    <updated>2025-10-01T06:42:36.107Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大一上学期">大一上学期</h2><p>c语言</p><p>蓝桥杯省三</p><h2 id="大一下学期">大一下学期</h2><p>c++面向对象程序设计</p><p>初识CTF REVERSE</p><h2 id="大一暑假">大一暑假</h2><p>CTF REVERSE</p><p>数据结构</p><p>matlab</p><p>python</p><p>hexo搭建博客</p><p>微积分</p><p>暑假过得稀碎，啥也不是，好像学了又好像没学。</p><h2 id="大二上学期">大二上学期</h2><p>课程： 计算机组成原理 数据结构 离散2 微积分3 c++设计</p><p>参加数学建模比赛，真的很难绷，选c题做的稀烂。</p><p>加了百度菁英班，算法题全是数论相关，欧拉函数真的很迷，做完全都忘记了。</p><p>计组原理和数据结构全是硬菜，前者与数电紧密相联，并且内容很多，后者则是需要实践与学习相结合 。离散数学也不好过 ，概念很多，逻辑关系很强，老师讲课也很赶（虽然不是老师的错）——2023.9.26</p><p>今天中午尝试了中午提前到教室，在阶梯教室睡午觉然后继续学习，感觉梦回高三睡在合堂，不知道什么时候能轻松一点。上周六的CTF校赛没有参加，还是好好学习准备期末考试吧。</p><p>——2023/10/24</p><p>​ 离散数学和面向对象程序设计都是4/4，蛮开心的 ，继续前进吧。——2023/11/13</p><p>期末考试还可以，总算拯救了绩点，得了一千奖学金和数模省三等奖（水），以及六级没过（悲）——2024/2/28</p><h2 id="大二暑假">大二暑假</h2><p>美赛</p><p>python pandas</p><p>很摆烂</p><h2 id="大二下">大二下</h2><p>专业课很多的一个学期</p><p>完蛋啦，今天上午那个数据结构(1.5学分)上机《手撕sort进阶版》一个点都没答对，上周的红黑树也是,有一个点没过,又一次想死了，悲。下午上完毛概冲去蜜雪冰城买了一杯饮料喝了喝,好喝,但还是难受, ≧ ﹏ ≦ ,自己是不是不适合这个专业呢? ——2024/03/18</p><p>暑假来了已经彻底放弃保研了——2024/7/5</p><h2 id="大三下">大三下</h2><p>转眼就大三下了,考研在有条不紊的进行,虽然保不上研,但仍在为必修课而努力,说不清是垂死挣扎还是善始善终,无论别人怎么样,我的路始终是要扎扎实实地走,科研这条路不能说还没进去就开始害怕。----------2025/04/15</p><h2 id="大四上">大四上</h2><p>运气好,保研成功,昨天参加完小组会,今天决定看看实习然后学点东西——2025/10/1</p>]]></content>
    
    
    <summary type="html">一些关于学习的简单记录</summary>
    
    
    
    <category term="life" scheme="https://klklkl10086.github.io/klklkl10086.github.io/categories/life/"/>
    
    
    <category term="随记" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/%E9%9A%8F%E8%AE%B0/"/>
    
  </entry>
  
</feed>
