<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>klklkl&#39;s blogs</title>
  
  <subtitle>学习笔记和一些思考</subtitle>
  <link href="https://klklkl10086.github.io/klklkl10086.github.io/atom.xml" rel="self"/>
  
  <link href="https://klklkl10086.github.io/klklkl10086.github.io/"/>
  <updated>2024-07-19T08:36:55.571Z</updated>
  <id>https://klklkl10086.github.io/klklkl10086.github.io/</id>
  
  <author>
    <name>klklkl</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初识爬虫</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2024/07/19/%E5%88%9D%E8%AF%86%E7%88%AC%E8%99%AB/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2024/07/19/%E5%88%9D%E8%AF%86%E7%88%AC%E8%99%AB/</id>
    <published>2024-07-19T08:32:52.000Z</published>
    <updated>2024-07-19T08:36:55.571Z</updated>
    
    <content type="html"><![CDATA[<h1 id="http请求">HTTP请求</h1><h2 id="结构">结构</h2><p><img src="%E5%88%9D%E8%AF%86%E7%88%AC%E8%99%AB/image-20240719163429962.png" alt="image-20240719163429962"></p><p><img src="%E5%88%9D%E8%AF%86%E7%88%AC%E8%99%AB/image-20240719163529224.png" alt="image-20240719163529224"></p><p><img src="%E5%88%9D%E8%AF%86%E7%88%AC%E8%99%AB/image-20240719163554857.png" alt="image-20240719163554857"></p><p><img src="%E5%88%9D%E8%AF%86%E7%88%AC%E8%99%AB/image-20240719163654513.png" alt="image-20240719163654513"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;http请求&quot;&gt;HTTP请求&lt;/h1&gt;
&lt;h2 id=&quot;结构&quot;&gt;结构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;%E5%88%9D%E8%AF%86%E7%88%AC%E8%99%AB/image-20240719163429962.png&quot; alt=&quot;image-20</summary>
      
    
    
    
    
    <category term="python" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>算法基础</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2024/07/11/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2024/07/11/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</id>
    <published>2024-07-11T14:03:08.000Z</published>
    <updated>2024-08-08T12:18:33.887Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://www.acwing.com/activity/content/introduction/11/">课程</a></strong></p><h1 id="排序">排序</h1><h2 id="快速排序">快速排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">//用j的情况下应当保证x取不到左边界，用i要保证取不到右边界，</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/blog/content/277/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h2 id="归并排序">归并排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/blog/content/277/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h1 id="二分">二分</h1><p><strong>有单调性一定可以二分，没有单调性也可能可以二分</strong></p><h2 id="整数二分">整数二分</h2><p><img src="image-20240808190812596-1723119355203-2.png" alt="image-20240808190812596"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/blog/content/277/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h2 id="浮点数二分">浮点数二分</h2><p>控制精度来控制循环，精度要比题目所要求的多2（y总经验）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="高精度">高精度</h1><h2 id="加法">加法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/blog/content/277/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h2 id="减法">减法</h2><h2 id="乘法">乘法</h2><h2 id="除法">除法</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.acwing.com/activity/content/introduction/11/&quot;&gt;课程&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;排序&quot;&gt;排序&lt;/h1&gt;
&lt;h2 id=&quot;快速排序&quot;&gt;快速排序&lt;/h2</summary>
      
    
    
    
    
    <category term="算法" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>「吉林大学软件学院」操作系统实验</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2024/06/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2024/06/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/</id>
    <published>2024-06-05T02:38:09.000Z</published>
    <updated>2024-06-11T09:57:00.590Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写在前面的话：</p><p>本课程一共有四个实验，最后一个选做，由于时间原因，我只写了三个，并且每个都参考了老师所给的参考代码，建议还是要自己先试一试，构思一下，然后和参考代码作对比。至于实验环境的配置请自己搜索，我这里不再赘述。</p><p>前置知识部分，有的我借助了chatgpt进行生成，也许有不对的，欢迎指出，可以以邮件的形式发送给我。</p></blockquote><p><strong>实验环境： centos 7</strong></p><h1 id="实验一-：进程与线程-linux-进程与线程通讯">实验一 ：进程与线程——Linux  进程与线程通讯</h1><h2 id="实验内容">实验内容</h2><blockquote><p>•以Linux系统进程和线程机制为背景，掌握fork()和clone()系统调用的形式和功能，以及与其相适应的高级通讯方式。由fork派生的子进程之间通过pipe通讯，由clone创建的线程之间通过共享内存通讯，对于后者需要考虑互斥问题。</p><p>•以生产者/消费者问题为例，通过实验理解fork()和clone()两个系统调用的区别。程序要求能够创建4个进程或线程，其中包括两个生产者和两个消费者，生产者和消费者之间能够传递数据。</p></blockquote><h2 id="前置知识">前置知识</h2><h3 id="fork">fork()</h3><p><strong>函数定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//创建进程成功：在父进程中返回子进程的PID，在子进程中返回0</span></span><br><span class="line"><span class="comment">//创建失败返回-1</span></span><br></pre></td></tr></table></figure><p>作用：通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事情。</p><ul><li><p>一个进程调用fork函数之后，系统会先给新的进程分配资源，如存储数据、代码空间，然后将原来进程的所有值都<strong>复制</strong>给新的进程中，相当于克隆了一个自己。</p></li><li><p>子进程是父进程的几乎完全拷贝，包括代码段、数据段、堆和栈等。</p></li><li><p>虽然子进程和父进程的地址空间相同，但它们是独立的；修改子进程的内存不会影响父进程，反之亦然。</p></li><li><p>使用 <code>fork</code> 创建子进程之后，父进程和子进程会并发运行</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> tag=<span class="number">1</span>;</span><br><span class="line"> <span class="type">pid_t</span> pid;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;tag is %d now\n&quot;</span>,tag);</span><br><span class="line"> pid=fork();</span><br><span class="line"> <span class="keyword">if</span>(pid==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;there is error!\n&quot;</span>);</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;i am father\n&quot;</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;我是父亲,my pid is %d，我将修改tag，由%d变为%d\n&quot;</span>,getpid(),tag,tag+<span class="number">1</span>);</span><br><span class="line">     tag++;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;father:%d\n&quot;</span>,tag);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;i am son\n&quot;</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;我是儿子，my pid is%d,my father&#x27;s pid is %d,我将修改tag，由%d变为%d\n&quot;</span>,getpid(),getppid(),tag,tag<span class="number">-10</span>);</span><br><span class="line">     tag-=<span class="number">10</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;son:%d\n&quot;</span>,tag);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//tag is 1 now</span></span><br><span class="line"><span class="comment">//i am son</span></span><br><span class="line"><span class="comment">//我是儿子，my pid is56935,my father&#x27;s pid is 2467,我将修改tag，由1变为-9</span></span><br><span class="line"><span class="comment">//son:-9</span></span><br><span class="line"><span class="comment">//i am father</span></span><br><span class="line"><span class="comment">//我是父亲,my pid is 56936，我将修改tag，由1变为2</span></span><br><span class="line"><span class="comment">//father:2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由上述输出可以见得：</p><ul><li><strong>父进程和子进程虽然共用地址空间，但是互相不影响</strong></li><li><strong>子进程会从fork处开始运行</strong></li></ul><h3 id="clone">clone()</h3><p><strong>函数定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">clone</span> <span class="params">(<span class="type">int</span> ( *fn ) (<span class="type">void</span>  *arg) ,<span class="type">void</span> *<span class="built_in">stack</span> ,<span class="type">int</span> flag ,<span class="type">void</span>  *arg)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong><code>fn</code></strong>: 指向新进程将要执行的函数的指针。</li><li><strong><code>stack</code></strong>: 为新进程分配的栈空间的指针。新进程将从该栈开始执行。</li><li><strong><code>flag</code></strong>: 用于指定新进程的行为和资源共享方式的标志位。不同的标志位允许控制是否共享虚拟内存、文件描述符、信号处理等资源。</li><li><strong><code>arg</code></strong>: 传递给新进程的参数</li></ul><p><strong>常用flag：</strong></p><ul><li><strong><code>CLONE_VM</code></strong>: 新进程与父进程共享同一个内存空间。这意味着对内存的任何修改在两个进程中都是可见的。这通常用于创建线程，因为线程通常需要访问相同的内存。</li><li><strong><code>CLONE_FS</code></strong>: 新进程与父进程共享文件系统信息。父进程和子进程将共享文件系统相关的信息，包括当前工作目录和根目录。这意味着对 <code>chdir</code> 或 <code>chroot</code> 的调用将对两个进程同时生效。</li><li><strong><code>CLONE_FILES</code></strong>: 新进程与父进程共享文件描述符表。父进程和子进程将共享文件描述符表。关闭一个进程中的文件描述符将使该文件描述符在另一个进程中也不可用。</li><li><strong><code>CLONE_SIGHAND</code></strong>: 新进程与父进程共享信号处理器。父进程和子进程将共享信号处理函数。这意味着信号处理函数的设置对两个进程都是有效的，信号处理的变化会互相影响。</li><li><strong><code>CLONE_THREAD</code></strong>: 新进程与父进程属于同一个线程组。新进程将与父进程在同一个线程组（同一个进程的不同线程）中，这意味着它们作为一个单元协同工作，共享相同的线程组 ID (TGID)。</li></ul><p><strong>作用：</strong></p><p>和fork一样也是用于创建当前进程的一个新进程（也可以创建线程），但更佳灵活，可以<strong>更精细地</strong>控制新进程的行为和父进程的资源共享方式,关键就在<strong>flag的组合</strong></p><h3 id="pipe">pipe()</h3><p><strong>函数定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;<span class="comment">//创建管道</span></span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li><strong><code>pipefd</code></strong>：这是一个包含两个整数的数组。<code>pipefd[0]</code> 是用于读取的文件描述符，<code>pipefd[1]</code> 是用于写入的文件描述符。</li></ul><p><strong>返回值</strong></p><ul><li>成功时返回 0。</li><li>失败时返回 -1，并设置 <code>errno</code> 以指示错误。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//chatgpt生成</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">pid_t</span> cpid;</span><br><span class="line">    <span class="type">char</span> buf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建管道</span></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    cpid = fork();</span><br><span class="line">    <span class="keyword">if</span> (cpid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cpid == <span class="number">0</span>) &#123;    <span class="comment">// 子进程</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);  <span class="comment">// 关闭写端</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从管道读取数据并输出到标准输出</span></span><br><span class="line">        <span class="keyword">while</span> (read(pipefd[<span class="number">0</span>], &amp;buf, <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            write(STDOUT_FILENO, &amp;buf, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        _exit(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;            <span class="comment">// 父进程</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);  <span class="comment">// 关闭读端</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向管道写入数据</span></span><br><span class="line">        write(pipefd[<span class="number">1</span>], <span class="string">&quot;Hello from parent\n&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        </span><br><span class="line">        close(pipefd[<span class="number">1</span>]);  <span class="comment">// 关闭写端</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);        <span class="comment">// 等待子进程结束</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>管道是单向的</strong></p><p><strong>作用</strong>：实现父进程与子进程之间的简单通信</p><h3 id="sem-wait"><strong>sem_wait()</strong></h3><p>P操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li><strong><code>sem</code></strong>：指向信号量对象的指针。</li></ul><p><strong>返回值</strong></p><ul><li>成功时返回 0。</li><li>失败时返回 -1，并设置 <code>errno</code> 以指示错误。</li></ul><p><strong>功能</strong></p><ul><li>如果信号量的值大于0，<code>sem_wait</code> 将信号量的值减1并立即返回。</li><li>如果信号量的值为0，<code>sem_wait</code> 将阻塞，直到信号量的值大于0。</li></ul><h3 id="sem-post">**sem_post() **</h3><p>V操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li><strong><code>sem</code></strong>：指向信号量对象的指针。</li></ul><p><strong>返回值</strong></p><ul><li>成功时返回 0。</li><li>失败时返回 -1，并设置 <code>errno</code> 以指示错误。</li></ul><p><strong>功能</strong></p><ul><li>将信号量的值增加1。如果有其他进程或线程在等待这个信号量，<code>sem_post</code> 会唤醒其中一个等待者。</li></ul><h3 id="sem-init"><strong>sem_init()</strong></h3><p>初始化信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ol><li><p><strong><code>sem</code></strong>：指向信号量对象的指针。</p></li><li><p><code>pshared</code></p><p>：指定信号量是否在进程间共享。</p><ul><li><strong><code>0</code></strong>：信号量用于进程内的线程同步。</li><li><strong>非零值</strong>：信号量在进程间共享。</li></ul></li><li><p><strong><code>value</code></strong>：信号量的初始值。通常表示资源的初始数量。</p></li></ol><p><strong>返回值</strong></p><ul><li><strong><code>0</code></strong>：成功。</li><li><strong><code>-1</code></strong>：失败，并设置 <code>errno</code> 以指示错误。</li></ul><h3 id="pthread-mutex-lock">pthread_mutex_lock()</h3><blockquote><p>用于实现互斥锁。互斥锁是一种用于<strong>线程间</strong>同步的机制，它可以确保在任何时候只有一个线程能够访问共享资源，从而防止竞态条件的发生。</p></blockquote><p><strong>函数定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li><code>mutex</code>：一个指向互斥锁对象的指针，用于对其进行加锁操作。</li></ul><p><strong>返回值</strong></p><ul><li>若成功，返回0。</li><li>若失败，返回一个非零的错误码，表示出现了错误。</li></ul><p><strong>作用</strong></p><ul><li><code>pthread_mutex_lock()</code> 用于尝试对指定的互斥锁进行加锁操作。</li><li>如果互斥锁已经被其他线程锁定，调用线程将会被阻塞，直到该互斥锁可用为止。</li><li>如果当前线程已经持有了该互斥锁，再次调用 <code>pthread_mutex_lock()</code> 会导致死锁</li></ul><h3 id="pthread-mutex-unlock">pthread_mutex_unlock()</h3><blockquote><p>用于释放互斥锁的函数之一</p></blockquote><p><strong>函数定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li><code>mutex</code>：一个指向互斥锁对象的指针，用于对其进行解锁操作。</li></ul><p><strong>返回值</strong></p><ul><li>若成功，返回0。</li><li>若失败，返回一个非零的错误码，表示出现了错误。</li></ul><p><strong>作用</strong></p><ul><li><code>pthread_mutex_unlock()</code> 用于释放指定的互斥锁。</li><li>当一个线程拥有互斥锁时，调用 <code>pthread_mutex_unlock()</code> 可以将该互斥锁释放，以允许其他线程访问受保护的临界区。</li></ul><p><strong>确保每次 <code>pthread_mutex_unlock()</code> 都是由之前成功调用的 <code>pthread_mutex_lock()</code> 进行匹配，避免出现死锁等问题。</strong></p><h3 id="pthread-mutex-init">pthread_mutex_init</h3><blockquote><p>用于初始化互斥锁的函数。在使用互斥锁之前，需要通过该函数对互斥锁进行初始化。</p></blockquote><p><strong>函数定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li><code>mutex</code>：指向要初始化的互斥锁对象的指针。</li><li><code>attr</code>：指向包含互斥锁属性的指针，通常设置为 <code>NULL</code>，表示使用默认属性。</li></ul><p><strong>返回值</strong></p><ul><li>若成功，返回0。</li><li>若失败，返回一个非零的错误码，表示出现了错误。</li></ul><h3 id="生产者消费者问题">生产者消费者问题</h3><blockquote><p><strong>生产者消费者问题</strong>（英语：Producer-consumer problem），也称<strong>有限缓冲问题</strong>（Bounded-buffer problem），是一个<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E8%BF%9B%E7%A8%8B">多进程</a><a href="https://zh.wikipedia.org/wiki/%E5%90%8C%E6%AD%A5">同步</a>问题的经典案例。该问题描述了共享固定大小<a href="https://zh.wikipedia.org/wiki/%E7%BC%93%E5%86%B2%E5%8C%BA">缓冲区</a>的两个进程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</p><p>要解决该问题，就必须让生产者在缓冲区满时休眠（要么干脆就放弃数据），等到下次消费者消耗缓冲区中的数据的时候，生产者才能被唤醒，开始往缓冲区添加数据。同样，也可以让消费者在缓冲区空时进入休眠，等到生产者往缓冲区添加数据之后，再唤醒消费者。通常采用<a href="https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1">进程间通信</a>的方法解决该问题，常用的方法有<a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E5%8F%B7%E9%87%8F">信号灯法</a>[<a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98#cite_note-1">1]</a>等。如果解决方法不够完善，则容易出现死锁的情况。出现死锁时，两个线程都会陷入休眠，等待对方唤醒自己。该问题也能被推广到多个生产者和消费者的情形。</p><p>----维基百科</p></blockquote><h2 id="代码1">代码1</h2><blockquote><p>使用了pipe函数 frok函数实现生产者消费者问题</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">producer</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">consumer</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> r_buf[<span class="number">4</span>],w_buf[<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> pipfd[<span class="number">2</span>];</span><br><span class="line"><span class="type">pid_t</span> pid_p1,pid_p2,pid_c1,pid_c2;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pipe(pipfd)==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;管道创建失败！\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;管道创建成功！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pid_p1=fork()==<span class="number">0</span>)<span class="comment">// 子进程</span></span><br><span class="line">producer(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(pid_p2=fork()==<span class="number">0</span>)<span class="comment">//子进程</span></span><br><span class="line">producer(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(pid_c1=fork()==<span class="number">0</span>)<span class="comment">//子进程</span></span><br><span class="line">consumer(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">if</span>(pid_c2=fork()==<span class="number">0</span>)<span class="comment">//子进程</span></span><br><span class="line">consumer(<span class="number">2</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">close(pipfd[<span class="number">0</span>]),close(pipfd[<span class="number">1</span>]);</span><br><span class="line"><span class="type">int</span> status,pid,i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)<span class="comment">//等待子进程结束</span></span><br><span class="line">pid=wait(&amp;status); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">producer</span><span class="params">(<span class="type">int</span> id)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;生产者 %d ing ing\n&quot;</span>,id) ;</span><br><span class="line">close(pipfd[<span class="number">0</span>]);<span class="comment">//关闭读</span></span><br><span class="line"><span class="keyword">for</span>( i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;producer %d &#x27;s %dth\n&quot;</span>,id,i);</span><br><span class="line"><span class="keyword">if</span>(id==<span class="number">1</span>)<span class="comment">//生产者1号</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(w_buf,<span class="string">&quot;p1\0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(w_buf,<span class="string">&quot;p2\0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(write(pipfd[<span class="number">1</span>],w_buf,<span class="number">4</span>)==<span class="number">-1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;生产者写入管道失败!\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;producer %d write %s\n&quot;</span>,id,w_buf);</span><br><span class="line">&#125;</span><br><span class="line">close(pipfd[<span class="number">1</span>]);<span class="comment">//关闭写 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;生产者 %d 结束！\n&quot;</span>,id);</span><br><span class="line"><span class="built_in">exit</span>(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">consumer</span><span class="params">(<span class="type">int</span> id)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;消费者 %d inging...\n&quot;</span>,id);</span><br><span class="line">close(pipfd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(read(pipfd[<span class="number">0</span>],r_buf,<span class="number">4</span>)==<span class="number">0</span>)</span><br><span class="line"> <span class="keyword">break</span>;<span class="comment">//读完了</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;消费者 %d 得到了 %s\n&quot;</span>,id,r_buf) ;</span><br><span class="line">&#125;</span><br><span class="line">close(pipfd[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;消费者%d 结束了\n&quot;</span>,id);</span><br><span class="line"><span class="built_in">exit</span>(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输出1">输出1</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">管道创建成功！</span><br><span class="line">消费者 <span class="number">2</span> inging...</span><br><span class="line">生产者 <span class="number">1</span> ing ing</span><br><span class="line">producer <span class="number">1</span> <span class="string">&#x27;s 1th</span></span><br><span class="line"><span class="string">producer 1 write p1</span></span><br><span class="line"><span class="string">producer 1 &#x27;</span>s <span class="number">2</span>th</span><br><span class="line">producer <span class="number">1</span> write p1</span><br><span class="line">producer <span class="number">1</span> <span class="string">&#x27;s 3th</span></span><br><span class="line"><span class="string">producer 1 write p1</span></span><br><span class="line"><span class="string">producer 1 &#x27;</span>s <span class="number">4</span>th</span><br><span class="line">producer <span class="number">1</span> write p1</span><br><span class="line">producer <span class="number">1</span> <span class="string">&#x27;s 5th</span></span><br><span class="line"><span class="string">producer 1 write p1</span></span><br><span class="line"><span class="string">生产者 1 结束！</span></span><br><span class="line"><span class="string">生产者 2 ing ing</span></span><br><span class="line"><span class="string">producer 2 &#x27;</span>s <span class="number">1</span>th</span><br><span class="line">producer <span class="number">2</span> write p2</span><br><span class="line">producer <span class="number">2</span> <span class="string">&#x27;s 2th</span></span><br><span class="line"><span class="string">producer 2 write p2</span></span><br><span class="line"><span class="string">producer 2 &#x27;</span>s <span class="number">3</span>th</span><br><span class="line">producer <span class="number">2</span> write p2</span><br><span class="line">producer <span class="number">2</span> <span class="string">&#x27;s 4th</span></span><br><span class="line"><span class="string">producer 2 write p2</span></span><br><span class="line"><span class="string">producer 2 &#x27;</span>s <span class="number">5</span>th</span><br><span class="line">producer <span class="number">2</span> write p2</span><br><span class="line">生产者 <span class="number">2</span> 结束！</span><br><span class="line">消费者 <span class="number">1</span> inging...</span><br><span class="line">消费者 <span class="number">2</span> 得到了 p1</span><br><span class="line">消费者 <span class="number">1</span> 得到了 p1</span><br><span class="line">消费者 <span class="number">2</span> 得到了 p1</span><br><span class="line">消费者 <span class="number">1</span> 得到了 p1</span><br><span class="line">消费者 <span class="number">2</span> 得到了 p1</span><br><span class="line">消费者 <span class="number">1</span> 得到了 p2</span><br><span class="line">消费者 <span class="number">2</span> 得到了 p2</span><br><span class="line">消费者 <span class="number">1</span> 得到了 p2</span><br><span class="line">消费者 <span class="number">2</span> 得到了 p2</span><br><span class="line">消费者 <span class="number">1</span> 得到了 p2</span><br><span class="line">消费者<span class="number">2</span> 结束了</span><br><span class="line">消费者<span class="number">1</span> 结束了</span><br></pre></td></tr></table></figure><h2 id="代码2">代码2</h2><blockquote><p>使用clone函数通过信号量和互斥锁实现</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>  <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* args)</span>;</span><br><span class="line"><span class="type">int</span>  <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* args)</span>;</span><br><span class="line"><span class="type">pid_t</span> pid_p[<span class="number">2</span>],pid_c[<span class="number">2</span>];<span class="comment">//p1,p2,c1,c2</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">sem_t</span> products,empty;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">8</span>][<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> buf_size=<span class="number">8</span>,top=<span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line"> sem_init(&amp;products,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"> sem_init(&amp;empty,<span class="number">0</span>,<span class="number">8</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="type">int</span> i=<span class="number">0</span>,flag=CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND| SIGCHLD;</span><br><span class="line">    <span class="comment">//一定要加上SIGCHLD</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span>( i=<span class="number">0</span>;i&lt;=<span class="number">1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>*id=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (<span class="type">int</span>));</span><br><span class="line"> *(id)=i+<span class="number">1</span>;</span><br><span class="line"><span class="type">char</span>* <span class="built_in">stack</span> = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">4096</span>);</span><br><span class="line">pid_p[i] = clone(producer, <span class="built_in">stack</span> + <span class="number">4095</span>, flag, id);</span><br><span class="line">        <span class="keyword">if</span> (pid_p[i] == <span class="number">-1</span>) </span><br><span class="line">&#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;Failed to create producer process!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;producer %d is created!\n&quot;</span>, *id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( i=<span class="number">0</span>;i&lt;=<span class="number">1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>*id=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (<span class="type">int</span>)); *(id)=i+<span class="number">1</span>;</span><br><span class="line"><span class="type">char</span>* <span class="built_in">stack</span>= (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">4096</span>);</span><br><span class="line">pid_c[i]=clone(consumer,<span class="built_in">stack</span>+<span class="number">4095</span>,flag,id);</span><br><span class="line"><span class="keyword">if</span> (pid_p[i] == <span class="number">-1</span>) </span><br><span class="line">&#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;Failed to create consumer process!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;consumer %d is created!\n&quot;</span>,*id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> status=<span class="number">0</span>,pid;</span><br><span class="line">    <span class="comment">//一定要写这个 否则父进程会先于子进程结束</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line">pid=wait(&amp;status);</span><br><span class="line">    <span class="comment">//销毁锁和信号量</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">sem_destroy(&amp;products);</span><br><span class="line">sem_destroy(&amp;empty);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* args)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>,id=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;producer %d is running!\n&quot;</span>,id=*((<span class="type">int</span>*)args));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  sleep(i);</span><br><span class="line">  sem_wait(&amp;empty);</span><br><span class="line">  pthread_mutex_lock(&amp;mutex);</span><br><span class="line">  top=top+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(id==<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">strcpy</span>(buf[top],<span class="string">&quot;p1\0&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">     <span class="built_in">strcpy</span>(buf[top],<span class="string">&quot;p2\0&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;producer %d put %s into buf[%d]\n&quot;</span>,id,buf[top],top);</span><br><span class="line"></span><br><span class="line">  pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">  sem_post(&amp;products);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;producer %d is deaded\n&quot;</span>,id);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* args)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>,id=*((<span class="type">int</span>*)args);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;consumer %d is running!\n&quot;</span>,id);</span><br><span class="line"><span class="keyword">for</span>( i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">10</span>-i);</span><br><span class="line"></span><br><span class="line">sem_wait(&amp;products);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;consumer %d gets %s from buf[%d]\n&quot;</span>,id,buf[top],top);</span><br><span class="line">top--;</span><br><span class="line"></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">sem_post(&amp;empty);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;consumer %d is deaded\n&quot;</span>,id);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h3 id="为什么需要-sigchld">为什么需要 <code>SIGCHLD</code></h3><ul><li><strong>通知机制</strong>：<code>SIGCHLD</code> 信号用于通知父进程其子进程已经终止。这允许父进程通过 <code>wait</code> 或 <code>waitpid</code> 函数来获取子进程的终止状态，并进行相应的处理。</li><li><strong>避免僵尸进程</strong>：当子进程终止时，如果父进程没有使用 <code>wait</code> 或 <code>waitpid</code> 获取子进程的终止状态，子进程会变成僵尸进程。<code>SIGCHLD</code> 信号可以触发父进程调用这些函数，从而防止僵尸进程的产生。</li></ul></blockquote><blockquote><p><strong>为什么要在主函数最后写<code>wait</code></strong></p><h3 id="1-避免僵尸进程">1. <strong>避免僵尸进程</strong></h3><ul><li>当一个子进程终止时，它不会立即被完全清除。子进程的终止状态（如退出代码等）仍然保留在系统中，直到父进程调用 <code>wait</code> 或 <code>waitpid</code> 函数来获取这个状态。</li><li>如果父进程没有调用 <code>wait</code> 或 <code>waitpid</code>，这些终止的子进程会变成僵尸进程，占用系统资源。通过调用 <code>wait</code> 或 <code>waitpid</code>，父进程可以清理这些子进程，释放相关的资源。</li></ul><h3 id="2-同步父子进程">2. <strong>同步父子进程</strong></h3><ul><li>使用 <code>wait</code> 或 <code>waitpid</code> 可以确保父进程在继续执行之前等待子进程完成。这对于确保所有子进程执行完毕并且所有资源都被正确释放是必要的。</li><li>这也可以<u><strong>防止父进程在所有子进程完成之前退出，从而保证所有任务都能正确执行完毕</strong></u>。</li></ul><h3 id="3-获取子进程的退出状态">3. <strong>获取子进程的退出状态</strong></h3><ul><li><code>wait</code> 或 <code>waitpid</code> 可以让父进程获取子进程的退出状态，这对于调试、日志记录或者根据子进程的执行结果采取相应的措施非常重要。</li></ul></blockquote><h2 id="输出2">输出2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">producer <span class="number">1</span> is created!</span><br><span class="line">producer <span class="number">2</span> is created!</span><br><span class="line">consumer <span class="number">1</span> is created!</span><br><span class="line">consumer <span class="number">2</span> is created!</span><br><span class="line">consumer <span class="number">2</span> is running!</span><br><span class="line">producer <span class="number">1</span> is running!</span><br><span class="line">producer <span class="number">2</span> is running!</span><br><span class="line">consumer <span class="number">1</span> is running!</span><br><span class="line">producer <span class="number">1</span> put p1 into buf[<span class="number">0</span>]</span><br><span class="line">producer <span class="number">2</span> put p2 into buf[<span class="number">1</span>]</span><br><span class="line">producer <span class="number">1</span> put p1 into buf[<span class="number">2</span>]</span><br><span class="line">producer <span class="number">2</span> put p2 into buf[<span class="number">3</span>]</span><br><span class="line">producer <span class="number">1</span> put p1 into buf[<span class="number">4</span>]</span><br><span class="line">producer <span class="number">2</span> put p2 into buf[<span class="number">5</span>]</span><br><span class="line">consumer <span class="number">2</span> gets p2 from buf[<span class="number">5</span>]</span><br><span class="line">consumer <span class="number">1</span> gets p1 from buf[<span class="number">4</span>]</span><br><span class="line">producer <span class="number">1</span> put p1 into buf[<span class="number">4</span>]</span><br><span class="line">producer <span class="number">2</span> put p2 into buf[<span class="number">5</span>]</span><br><span class="line">producer <span class="number">1</span> put p1 into buf[<span class="number">6</span>]</span><br><span class="line">producer <span class="number">2</span> put p2 into buf[<span class="number">7</span>]</span><br><span class="line">consumer <span class="number">2</span> gets p2 from buf[<span class="number">7</span>]</span><br><span class="line">consumer <span class="number">1</span> gets p1 from buf[<span class="number">6</span>]</span><br><span class="line">producer <span class="number">1</span> put p1 into buf[<span class="number">6</span>]</span><br><span class="line">producer <span class="number">2</span> put p2 into buf[<span class="number">7</span>]</span><br><span class="line">consumer <span class="number">2</span> gets p2 from buf[<span class="number">7</span>]</span><br><span class="line">consumer <span class="number">1</span> gets p1 from buf[<span class="number">6</span>]</span><br><span class="line">producer <span class="number">1</span> put p1 into buf[<span class="number">6</span>]</span><br><span class="line">producer <span class="number">2</span> put p2 into buf[<span class="number">7</span>]</span><br><span class="line">consumer <span class="number">2</span> gets p2 from buf[<span class="number">7</span>]</span><br><span class="line">consumer <span class="number">1</span> gets p1 from buf[<span class="number">6</span>]</span><br><span class="line">consumer <span class="number">2</span> gets p2 from buf[<span class="number">5</span>]</span><br><span class="line">consumer <span class="number">1</span> gets p1 from buf[<span class="number">4</span>]</span><br><span class="line">producer <span class="number">1</span> put p1 into buf[<span class="number">4</span>]</span><br><span class="line">producer <span class="number">2</span> put p2 into buf[<span class="number">5</span>]</span><br><span class="line">consumer <span class="number">2</span> gets p2 from buf[<span class="number">5</span>]</span><br><span class="line">consumer <span class="number">1</span> gets p1 from buf[<span class="number">4</span>]</span><br><span class="line">consumer <span class="number">2</span> gets p2 from buf[<span class="number">3</span>]</span><br><span class="line">consumer <span class="number">1</span> gets p1 from buf[<span class="number">2</span>]</span><br><span class="line">consumer <span class="number">2</span> gets p2 from buf[<span class="number">1</span>]</span><br><span class="line">consumer <span class="number">1</span> gets p1 from buf[<span class="number">0</span>]</span><br><span class="line">producer <span class="number">1</span> put p1 into buf[<span class="number">0</span>]</span><br><span class="line">producer <span class="number">2</span> put p2 into buf[<span class="number">1</span>]</span><br><span class="line">consumer <span class="number">1</span> gets p2 from buf[<span class="number">1</span>]</span><br><span class="line">consumer <span class="number">1</span> gets p1 from buf[<span class="number">0</span>]</span><br><span class="line">consumer <span class="number">1</span> is deaded</span><br><span class="line">producer <span class="number">1</span> put p1 into buf[<span class="number">0</span>]</span><br><span class="line">producer <span class="number">1</span> is deaded</span><br><span class="line">producer <span class="number">2</span> put p2 into buf[<span class="number">1</span>]</span><br><span class="line">producer <span class="number">2</span> is deaded</span><br><span class="line">consumer <span class="number">2</span> gets p2 from buf[<span class="number">1</span>]</span><br><span class="line">consumer <span class="number">2</span> gets p1 from buf[<span class="number">0</span>]</span><br><span class="line">consumer <span class="number">2</span> is deaded </span><br></pre></td></tr></table></figure><h2 id="拓展">拓展</h2><h3 id="shm">shm</h3><h3 id="msg">msg</h3><h1 id="实验二：处理机调度-实时调度算法edf和rms">实验二：处理机调度——实时调度算法EDF和RMS</h1><h2 id="实验内容">实验内容</h2><blockquote><p>在Linux环境中采用用户级线程模拟实现EDF和RMS两种实时调度算法。给定一组实时任务，按照EDF算法和RMS算法分别判断是否可调度，在可调度的情况下，创建一组用户级线程，分别代表各个实时任务，并按算法确定的调度次序安排各个线程运行，运行时在终端上画出其Gantt图。为避免图形绘制冲淡算法，Gantt图可用字符表示。</p></blockquote><h2 id="前置知识">前置知识</h2><h3 id="edf算法">EDF算法</h3><blockquote><p>EDF算法（Earliest Deadline First）是一种实时任务调度算法，它的核心思想是优先调度最紧迫的任务，即 <strong>将截止时间最早的任务优先分配处理器时间片</strong>。EDF算法适用于实时系统，其中任务有明确的截止时间，并且必须在截止时间之前完成。</p></blockquote><h4 id="调度规则"><strong>调度规则</strong></h4><ul><li>系统在每个时刻会检查所有已到达但未完成的任务，并选择截止期限最早的任务进行执行。</li><li>如果新的任务到达且其截止期限早于当前正在执行的任务，系统会进行任务切换，将新的任务置于当前任务之前执行。</li></ul><h4 id="特点">特点</h4><ol><li><strong>最优性</strong>：<ul><li>EDF算法在理想条件下（如任务可抢占、无上下文切换开销、系统负载不超过100%）是最优的单处理器实时调度算法。这意味着，如果有一种方法能按时完成所有任务，EDF就能做到这一点。</li></ul></li><li><strong>动态优先级</strong>：<ul><li>任务的优先级是动态的，随着时间的推移和新任务的到来而变化。</li></ul></li><li><strong>简单性</strong>：<ul><li>实现相对简单，只需维护一个任务列表，并在任务到达或完成时更新列表排序。</li></ul></li><li><strong>可抢先性调度算法</strong></li></ol><h4 id="优点">优点</h4><ul><li><strong>高效性</strong>：在可抢占的环境中，EDF能够高效地利用处理器资源，最大限度地减少任务的等待时间。</li><li><strong>灵活性</strong>：适用于不同类型的任务，包括周期性任务和单次任务。</li></ul><h4 id="缺点">缺点</h4><ul><li><strong>开销问题</strong>：频繁的任务切换和排序操作可能带来一定的开销，尤其是在任务数量较多时。</li><li><strong>负载限制</strong>：在系统负载接近或超过100%时，EDF可能会无法确保所有任务都能按时完成，这时需要其他机制来处理超载情况。</li></ul><h4 id="例子">例子</h4><p>假设有三个任务，它们的执行时间和截止期限如下：</p><ul><li>任务A：执行时间为2，截止期限为4</li><li>任务B：执行时间为1，截止期限为3</li><li>任务C：执行时间为2，截止期限为5</li></ul><p>任务按照以下顺序到达：A、B、C</p><ol><li>系统开始执行任务A，因为此时只有任务A在队列中。</li><li>任务B到达，截止期限比任务A早，因此系统切换到任务B。</li><li>任务B完成后系统继续执行任务A。</li><li>任务C到达，但任务A仍然是最早截止的任务，因此系统继续执行任务A。</li><li>任务A完成后系统执行任务C。</li></ol><p>通过上述例子可以看出，EDF算法始终选择最紧急的任务来执行，从而尽量保证所有任务都能按时完成。</p><p>总的来说，Earliest Deadline First算法是实时系统中非常重要的一种调度策略，广泛应用于需要高实时性和确定性的领域。</p><h4 id="调度条件">调度条件</h4><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><mo stretchy="false">(</mo><mfrac><msub><mi>C</mi><mi>i</mi></msub><msub><mi>T</mi><mi>i</mi></msub></mfrac><mo stretchy="false">)</mo><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum(\frac{C_{i}}{T_{i}})\leq1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.19633em;vertical-align:-0.8360000000000001em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p><p><code>Ci</code>是任务i需要的工作时间，<code>Ti</code>是任务i的周期， 该条件表明任务系统的总CPU利用率不超过100%。</p><h3 id="rms算法">RMS算法</h3><blockquote><p>Rate Monotonic Scheduling (RMS) 是一种用于实时系统的优先级调度算法，主要用于调度周期性任务。它是一种固定优先级（static priority）的调度算法，每个任务的优先级在系统运行期间保持不变。</p></blockquote><h4 id="调度规则"><strong>调度规则</strong></h4><ul><li>任务的优先级是根据其周期来确定的：周期越短，优先级越高。</li></ul><h4 id="特点">特点</h4><ol><li><strong>固定优先级</strong>：<ul><li>任务的优先级在整个系统运行期间保持不变，这与动态优先级调度算法（如EDF）不同。</li></ul></li><li><strong>周期性任务优化</strong>：<ul><li>RMS专门针对周期性任务进行优化，确保周期性任务能够在其周期内按时完成。</li></ul></li><li><strong>理论基础</strong>：<ul><li>RMS有严格的数学证明支持，证明了在某些条件下，RMS是最优的固定优先级调度算法。</li></ul></li><li><strong>不可抢先性调度算法。</strong></li></ol><h4 id="优点">优点</h4><ul><li><strong>简单性</strong>：由于优先级是固定的，实现起来相对简单。</li><li><strong>可预测性</strong>：固定优先级使得任务调度行为易于预测和分析。</li><li><strong>理论保证</strong>：对于周期性任务，RMS具有良好的理论基础和最优性保证。</li></ul><h4 id="缺点">缺点</h4><ul><li><strong>利用率限制</strong>：RMS在任务的总CPU利用率达到一定限度时，可能无法保证所有任务都能按时完成。具体来说，对于 nnn 个任务的系统，最大CPU利用率上限为 Umax=n(21/n−1)U_{max} = n(2^{1/n} - 1)Umax=n(21/n−1)。当任务数增加时，这个上限趋近于 ln⁡(2)≈0.693\ln(2) \approx 0.693ln(2)≈0.693 或者 69.3%。</li><li><strong>不适合非周期性任务</strong>：RMS主要针对周期性任务，非周期性任务可能无法得到有效调度。</li></ul><h4 id="例子">例子</h4><p>假设有三个任务，它们的执行时间和周期如下：</p><ul><li>任务A：执行时间 CA=1C_A = 1CA=1，周期 PA=4P_A = 4PA=4</li><li>任务B：执行时间 CB=1C_B = 1CB=1，周期 PB=5P_B = 5PB=5</li><li>任务C：执行时间 CC=2C_C = 2CC=2，周期 PC=8P_C = 8PC=8</li></ul><p>根据RMS规则，任务的优先级顺序为：A &gt; B &gt; C（周期越短，优先级越高）。</p><p>调度过程：</p><ol><li>从时间0开始，任务A、B、C均到达。由于A优先级最高，执行任务A。</li><li>时间1，任务A完成，执行任务B（下一个优先级最高的任务）。</li><li>时间2，任务B完成，执行任务C。</li><li>时间4，任务A的下一个周期到来，打断任务C，执行任务A。</li><li>时间5，继续执行任务C。</li><li>时间8，任务A和B的下一个周期同时到来，首先执行任务A，然后执行任务B，任务C被打断。</li></ol><p>通过上述例子可以看出，RMS算法总是优先执行周期最短的任务，确保高优先级任务按时完成。</p><h4 id="调度条件">调度条件</h4><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><mo stretchy="false">(</mo><mfrac><msub><mi>C</mi><mi>i</mi></msub><msub><mi>T</mi><mi>i</mi></msub></mfrac><mo stretchy="false">)</mo><mo>≤</mo><mi>n</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mfrac><mn>1</mn><mi>n</mi></mfrac></msup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum(\frac{C_{i}}{T_{i}})\leq n(2^{\frac{1}{n}}-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.19633em;vertical-align:-0.8360000000000001em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2540200000000001em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0040200000000001em;"><span style="top:-3.4130000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p><p>这里 <code>n</code> 是任务的数量。这个条件表明任务系统的总CPU利用率的上限随着任务数量的增加而变化，并且随着任务数量的增加，这个上限趋近 69.3%。</p><h3 id="rms与edf对比">RMS与EDF对比</h3><ul><li><strong>优先级类型</strong>：RMS使用固定优先级，EDF使用动态优先级。</li><li><strong>适用任务</strong>：RMS适用于周期性任务，EDF适用于周期性和非周期性任务。</li><li><strong>CPU利用率</strong>：EDF在理想条件下可以实现100%的CPU利用率，而RMS的利用率上限为69.3%（对于较多任务）。</li></ul><h3 id="pthread-create">pthread_create()</h3><blockquote><p><code>pthread_create</code> 是 POSIX 线程库 (pthread) 中的一个函数，用于创建一个新的线程。这个函数是多线程编程的基础之一，允许程序在并发执行中创建和管理多个线程。</p></blockquote><h4 id="函数定义">函数定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数详解</strong></p><ol><li><strong>pthread_t *thread</strong>:<ul><li>这是一个指向 <code>pthread_t</code> 类型变量的指针。这个变量将保存新创建线程的 ID（线程句柄），用于后续对该线程的操作（如等待线程结束、取消线程等）。</li></ul></li><li><strong>const pthread_attr_t *attr</strong>:<ul><li>这是一个指向线程属性对象的指针，用于设置新线程的属性。如果传递 <code>NULL</code>，则使用默认属性。</li><li>线程属性可以包括堆栈大小、调度策略、优先级等。属性对象通过 <code>pthread_attr_init</code>、<code>pthread_attr_set*</code> 和 <code>pthread_attr_destroy</code> 函数进行管理。</li></ul></li><li><strong>void *(*start_routine)(void *)</strong>:<ul><li>这是一个函数指针，指向新线程的起始例程（函数）。新线程开始时将执行这个函数。</li><li>这个函数必须符合特定的签名，即接收一个 <code>void *</code> 类型的参数并返回一个 <code>void *</code> 类型的值。</li></ul></li><li><strong>void *arg</strong>:<ul><li>这是传递给 <code>start_routine</code> 函数的参数。可以传递任意类型的数据，但必须通过 <code>void *</code> 进行类型转换。</li><li>如果不需要传递参数，可以传递 <code>NULL</code>。</li></ul></li></ol><p><strong>返回值</strong></p><ul><li>成功时，<code>pthread_create</code> 返回 0。</li><li>失败时，返回一个非零的错误代码，表示失败原因，如 <code>EAGAIN</code>（资源临时不可用）、<code>EINVAL</code>（无效的属性设置）或 <code>EPERM</code>（无权限设置指定的属性）。</li></ul><h4 id="特点">特点</h4><ul><li><strong>共享地址空间</strong>：线程之间共享相同的地址空间（全局变量、堆等）。</li><li><strong>轻量级</strong>：线程的创建和销毁比进程开销小。</li><li><strong>并发执行</strong>：多个线程可以并发执行，提高性能。</li><li><strong>同步机制</strong>：需要使用同步机制（如互斥锁、条件变量）来防止共享资源竞争。</li></ul><h2 id="代码">代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> task_id;<span class="comment">//任务id</span></span><br><span class="line">  <span class="type">int</span> call_num;<span class="comment">//发生次数</span></span><br><span class="line">  <span class="type">int</span> c_left;<span class="comment">//剩余工作时间</span></span><br><span class="line">  <span class="type">int</span> t_left;<span class="comment">//剩余周期时间</span></span><br><span class="line">  <span class="type">int</span> c;<span class="comment">// 工作时间</span></span><br><span class="line">  <span class="type">int</span> t; <span class="comment">//周期</span></span><br><span class="line">  <span class="type">int</span> flag;<span class="comment">//状态 1活跃 2不活跃</span></span><br><span class="line">  <span class="type">int</span> arg;<span class="comment">//参数</span></span><br><span class="line">  <span class="type">pthread_t</span> th;<span class="comment">//对应线程</span></span><br><span class="line">&#125; task;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">proc</span><span class="params">(<span class="type">void</span>* a)</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">idle</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">select_proc</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> task_num=<span class="number">0</span>,idle_num=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> choice;<span class="comment">//1 is EDF 2 is RMS</span></span><br><span class="line"><span class="type">int</span> curr_proc=<span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> demo_time=<span class="number">100</span>;</span><br><span class="line">task* tasks;</span><br><span class="line"><span class="type">pthread_mutex_t</span> proc_wait[<span class="number">100</span>];<span class="comment">//每个任务对应一个等待互斥锁</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> main_wait,idle_wait;<span class="comment">//main  闲逛进程</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> idle_proc;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化互斥锁</span></span><br><span class="line">    pthread_mutex_init(&amp;main_wait,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_lock(&amp;main_wait);</span><br><span class="line">    pthread_mutex_init(&amp;idle_wait,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_lock(&amp;idle_wait);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读入任务</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;有多少任务：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;task_num);</span><br><span class="line">    tasks=(task*)<span class="built_in">malloc</span>(task_num*<span class="keyword">sizeof</span>(task));</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;task_num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_init(&amp;proc_wait[i],<span class="literal">NULL</span>);</span><br><span class="line">        pthread_mutex_lock(&amp;proc_wait[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;task_num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入任务id C和T\n&quot;</span>);</span><br><span class="line">    getchar();<span class="comment">//一定要写</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c %d %d&quot;</span>,&amp;tasks[i].task_id,&amp;tasks[i].c,&amp;tasks[i].t);</span><br><span class="line">        tasks[i].c_left=tasks[i].c;</span><br><span class="line">        tasks[i].t_left=tasks[i].t;</span><br><span class="line">        tasks[i].flag=<span class="number">2</span>;</span><br><span class="line">        tasks[i].arg=i;</span><br><span class="line">        tasks[i].call_num=<span class="number">1</span>;</span><br><span class="line">        sum+=(<span class="type">float</span>)tasks[i].c/(<span class="type">float</span>)tasks[i].t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//选择调度 判断是否满足条件</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;用什么调度1.EDF 2.RMS\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;choice);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;想要运行多长时间\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;demo_time);</span><br><span class="line">    <span class="type">double</span> r=<span class="number">1</span>;<span class="comment">//EDF 为1</span></span><br><span class="line">    <span class="keyword">if</span>(choice==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r=((<span class="type">double</span>)task_num)*(<span class="built_in">exp</span>(<span class="built_in">log</span>(<span class="number">2</span>)/(<span class="type">double</span>)task_num)<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;r = %f\n&quot;</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum&gt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;不满足条件，不能调度\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建闲逛进程</span></span><br><span class="line">    pthread_create(&amp;idle_proc,<span class="literal">NULL</span>,(<span class="type">void</span>*)idle,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 创建实时任务线程</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;task_num;i++) </span><br><span class="line">        pthread_create(&amp;tasks[i].th,<span class="literal">NULL</span>,proc,(<span class="type">void</span>*)&amp;tasks[i].arg);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//运行</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;demo_time;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="comment">//选择线程</span></span><br><span class="line">        <span class="keyword">if</span>((curr_proc=select_proc(choice))!=<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;proc_wait[curr_proc]);</span><br><span class="line">            pthread_mutex_lock(&amp;main_wait);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//没有任务了 上闲逛线程</span></span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;idle_wait);</span><br><span class="line">            pthread_mutex_lock(&amp;main_wait);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;task_num;j++)<span class="comment">//执行完一个时间片 更新剩余周期时间</span></span><br><span class="line">        &#123;</span><br><span class="line">            tasks[j].t_left--;</span><br><span class="line">            <span class="keyword">if</span>(tasks[j].t_left==<span class="number">0</span>)<span class="comment">//周期到了 又来了一个</span></span><br><span class="line">            &#123;</span><br><span class="line">                tasks[j].t_left=tasks[j].t;</span><br><span class="line">            tasks[j].c_left=tasks[j].c;</span><br><span class="line">            pthread_create(&amp;tasks[j].th,<span class="literal">NULL</span>,(<span class="type">void</span>*)proc,&amp;tasks[j].arg);</span><br><span class="line">                tasks[j].flag=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">proc</span><span class="params">(<span class="type">void</span>* a)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span>* args=(<span class="type">int</span>*)a;</span><br><span class="line">    <span class="keyword">while</span>(tasks[*args].c_left&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;proc_wait[*args]);</span><br><span class="line">        <span class="keyword">if</span>(idle_num!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;idle:%d\n&quot;</span>,idle_num);</span><br><span class="line">            idle_num=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c is running,已被调用%d 次\n&quot;</span>,tasks[*args].task_id,tasks[*args].call_num);</span><br><span class="line">        tasks[*args].c_left--;<span class="comment">//剩余执行减一</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(tasks[*args].c_left==<span class="number">0</span>)<span class="comment">//执行完了</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;task %c over(it&#x27;s work time is%d)\n&quot;</span>,tasks[*args].task_id,tasks[*args].c);</span><br><span class="line">            tasks[*args].flag=<span class="number">0</span>;</span><br><span class="line">            tasks[*args].call_num++;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;main_wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">idle</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;idle_wait);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&gt;&quot;</span>); </span><br><span class="line">        idle_num++;</span><br><span class="line">        pthread_mutex_unlock(&amp;main_wait); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">select_proc</span><span class="params">(<span class="type">int</span> choice)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(choice==<span class="number">2</span>&amp;&amp;curr_proc!=<span class="number">-1</span>&amp;&amp;tasks[curr_proc].flag!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> curr_proc;<span class="comment">// RMS算法的优先级不会发生改变</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> j,tmp1=<span class="number">1000</span>,index=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;task_num;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tasks[j].flag==<span class="number">2</span>)<span class="comment">//当前任务活跃</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(choice==<span class="number">1</span>)<span class="comment">//EDF</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp1&gt;tasks[j].c_left) </span><br><span class="line">                    &#123;</span><br><span class="line">                        tmp1=tasks[j].c_left;</span><br><span class="line">                        index=j;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//RMS</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp1&gt;tasks[j].t)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp1=tasks[j].t;</span><br><span class="line">                    index=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>tips：</strong><br><strong>编译的时候要加上-pthread -lm选项</strong></p><h1 id="实验三：存储管理-动态不等长存储资源分配算法">实验三：存储管理——动态不等长存储资源分配算法</h1><h2 id="实验内容">实验内容</h2><blockquote><p>•分析UNIX最先适应(FF)存储分配算法，即map数据结构、存储分配函数malloc()和存储释放函数mfree()，找出与算法有关的成分。</p><p>• 修改上述与算法有关的成分，使其<strong>分别体现BF分配原则和WF分配原则</strong>。</p></blockquote><h2 id="前置知识">前置知识</h2><h3 id="最先适应存储分配算法">最先适应存储分配算法</h3><blockquote><p><strong>工作原理：</strong></p><ol><li><strong>维护空闲内存块</strong>：操作系统维护一个空闲内存块的链表（或其他数据结构）（ <code>按地址由低到高排列</code>），这些内存块表示可用的内存空间。</li><li><strong>按顺序查找</strong>：当有进程需要分配内存时，从链表的开始位置按顺序查找，寻找第一个能够满足该进程所需大小的空闲内存块。</li><li><strong>分配内存</strong>：找到合适的内存块后，将这块内存分配给进程。如果空闲内存块大于所需大小，则将该块分割成两部分，一部分分配给进程，另一部分继续作为空闲内存块保留在链表中。</li><li><strong>更新链表</strong>：分配完成后，更新空闲内存块链表。</li></ol><p><strong>优点</strong>：</p><ul><li><strong>简单易实现</strong>：最先适应算法实现简单，遍历链表寻找合适的空闲块即可。</li><li><strong>较低的开销</strong>：由于从头开始查找第一个符合要求的块，通常能快速找到适合的内存块。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>外部碎片化</strong>：长期运行后，系统会出现大量的小而零散的空闲块，导致无法有效利用内存。</li><li><strong>非最佳选择</strong>：最先适应算法可能不会总是选择最优的内存块，例如选择一个较大的块来满足小需求，从而留下更多的内存碎片。</li></ul></blockquote><h3 id="最佳分配算法">最佳分配算法</h3><blockquote><h4 id="工作原理"><strong>工作原理</strong></h4><ol><li><strong>维护空闲块列表</strong>：操作系统维护一个空闲内存块的链表（或其他数据结构）（按照<code>容量递增</code>的次序排列）。</li><li><strong>查找合适的块</strong>：当有内存分配请求时，遍历整个空闲块列表，找到能满足请求的<code>最小块</code>。</li><li><strong>分割和分配</strong>：如果找到的空闲块比请求的大小大，进行分割；否则直接分配整个块。</li><li><strong>更新空闲块列表</strong>：分配后更新空闲块列表，确保空闲块的管理和跟踪。</li></ol><p><strong>优点</strong></p><ul><li><strong>减少碎片</strong>：由于选择最小的能满足请求的块，最佳分配算法往往能减少内存碎片。</li><li><strong>高效利用内存</strong>：优化内存块的利用率，提高内存分配的效率。</li></ul><p><strong>缺点</strong></p><ul><li><strong>时间复杂度高</strong>：每次分配内存时都需要遍历整个空闲块列表，时间复杂度较高。</li><li><strong>维护复杂</strong>：需要频繁维护和更新空闲块列表，管理复杂度较高。</li></ul></blockquote><h3 id="最坏分配算法">最坏分配算法</h3><blockquote><p><strong>工作原理</strong></p><ol><li><strong>维护空闲块列表</strong>：操作系统维护一个空闲内存块的链表或其他数据结构（<code>按照容量由高到低排列</code>）。</li><li><strong>查找最大的块</strong>：当有内存分配请求时，遍历整个空闲块列表，找到最大的空闲块。</li><li><strong>分割和分配</strong>：如果找到的空闲块比请求的大小大，进行分割；否则直接分配整个块。</li><li><strong>更新空闲块列表</strong>：分配后更新空闲块列表，确保空闲块的管理和跟踪。</li></ol><p><strong>优点</strong></p><ul><li><strong>减少外部碎片</strong>：最坏分配算法通过分割最大的块来避免产生许多小块，从而减少外部碎片的数量。</li><li><strong>简单实现</strong>：该算法易于实现，因为只需找到最大的块进行分配。</li></ul><p><strong>缺点</strong></p><ul><li><strong>时间复杂度高</strong>：每次分配内存时都需要遍历整个空闲块列表以找到最大的块，时间复杂度较高。</li><li><strong>可能导致大的块被频繁分割</strong>：这可能导致大块内存变得稀缺，对于需要大块内存的请求来说可能会变得困难。</li></ul></blockquote><h3 id="malloc">malloc()</h3><blockquote><p><code>malloc</code>函数用于在堆上动态分配指定大小的内存块，并返回指向该内存块的指针。</p></blockquote><p><strong>原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><h4 id="参数"><strong>参数</strong></h4><ul><li><code>size</code>: 要分配的内存块的大小（以字节为单位）。</li></ul><p><strong>返回值</strong></p><ul><li>成功时：返回指向分配内存块的指针。</li><li>失败时：返回<code>NULL</code>，表示内存分配失败（例如内存不足）。</li></ul><h3 id="free">free()</h3><blockquote><p><code>free</code>函数用于释放之前由<code>malloc</code>、<code>calloc</code>或<code>realloc</code>函数分配的内存块，避免内存泄漏。</p></blockquote><p><strong>原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li><code>ptr</code>: 指向要释放的内存块的指针。如果<code>ptr</code>为<code>NULL</code>，则<code>free</code>函数什么也不做。</li></ul><p><strong>返回值</strong></p><ul><li>无返回值。</li></ul><h3 id="register">*register</h3><blockquote><p>在C语言中，<code>register</code>关键字用于提示编译器将变量尽量存储在处理器的寄存器中，而不是在内存中。这样可以提高变量的访问速度，因为寄存器比内存访问速度快得多。需要注意的是，这只是一个建议，最终是否将变量存储在寄存器中取决于编译器。</p></blockquote><p><strong>语法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="type">int</span> counter;</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sum: %d\n&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>tips</strong></p><ol><li><p><strong>仅用于自动变量</strong>：<code>register</code>关键字只能用于自动变量（局部变量）和函数参数。全局变量和静态变量不能使用<code>register</code>关键字。</p></li><li><p><strong>限制数量</strong>：由于寄存器数量有限，不可能所有的<code>register</code>变量都被存储在寄存器中。编译器会根据寄存器的使用情况决定是否将变量存储在寄存器中。</p></li><li><p><strong>无法获取地址</strong></p><p>由于寄存器可能不在内存中，因此不能对register变量使用取地址运算符（&amp;），即不能获取register变量的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="type">int</span> counter;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;counter;  <span class="comment">// 错误：无法获取register变量的地址</span></span><br></pre></td></tr></table></figure></li><li><p><strong>现代编译器优化</strong>：现代编译器已经具备非常先进的优化技术，能够自动选择哪些变量应该放在寄存器中。因此，在大多数情况下，不需要显式使用<code>register</code>关键字。编译器通常会比手动指定做得更好。</p></li></ol><h2 id="代码">代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAPSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MAP</span>//存储资源表项</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> addr;<span class="comment">//起始地址</span></span><br><span class="line"><span class="type">int</span> map_size; <span class="comment">//</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MAP</span> <span class="title">map</span>[<span class="title">MAPSIZE</span>];</span><span class="comment">//</span></span><br><span class="line"><span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> alg;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">BF_distru</span><span class="params">(<span class="type">int</span> apply_size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">WF_distru</span><span class="params">(<span class="type">int</span> apply_size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mfree</span><span class="params">(<span class="type">int</span> addr,<span class="type">int</span> rsize)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b is BF,w is WF:\n&quot;</span>);</span><br><span class="line">getchar();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;alg);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1代表申请，2代表释放，0代表退出：\n&quot;</span>);</span><br><span class="line"><span class="type">int</span> option;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;option);</span><br><span class="line"><span class="keyword">if</span>(option==<span class="number">0</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(option==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;你想申请多大的空间：\n&quot;</span>);</span><br><span class="line"><span class="type">int</span> apply_size,res;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;apply_size);</span><br><span class="line"><span class="keyword">if</span>(alg==<span class="string">&#x27;b&#x27;</span>) res=BF_distru(apply_size);</span><br><span class="line"><span class="keyword">else</span> res=WF_distru(apply_size);</span><br><span class="line"><span class="keyword">if</span>(res==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;空间不足，申请失败!\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;申请成功，起始地址为%d 大小为%d \n&quot;</span>,res,apply_size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;你想释放空间的起始地址和大小：\n&quot;</span>);</span><br><span class="line"><span class="type">int</span> addr,rsize;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;addr,&amp;rsize);</span><br><span class="line">mfree(addr,rsize);</span><br><span class="line">&#125;</span><br><span class="line">show();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> addr,_size,i=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;starting address and total size: \n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;addr,&amp;_size);</span><br><span class="line"><span class="built_in">map</span>[<span class="number">0</span>].addr=addr;</span><br><span class="line"><span class="built_in">map</span>[<span class="number">0</span>].map_size=_size;</span><br><span class="line"><span class="built_in">map</span>[<span class="number">1</span>].map_size=<span class="number">0</span>;</span><br><span class="line">num=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">BF_distru</span><span class="params">(<span class="type">int</span> apply_size)</span><span class="comment">//找最小空闲分配，更新表，按容量递增排序</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>,addr=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[i].map_size&gt;=apply_size)</span><br><span class="line">&#123;</span><br><span class="line">addr=<span class="built_in">map</span>[i].addr;</span><br><span class="line"><span class="built_in">map</span>[i].addr+=apply_size;</span><br><span class="line"><span class="built_in">map</span>[i].map_size-=apply_size;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[i].map_size==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">num--;</span><br><span class="line"><span class="type">int</span> j=i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=i+<span class="number">1</span>;j&lt;num;j++) <span class="built_in">map</span>[j<span class="number">-1</span>]=<span class="built_in">map</span>[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j=i<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[j].map_size&gt;<span class="built_in">map</span>[i].map_size) </span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MAP</span> <span class="title">tmp</span>;</span></span><br><span class="line">tmp=<span class="built_in">map</span>[j]; <span class="built_in">map</span>[j]=<span class="built_in">map</span>[i];<span class="built_in">map</span>[i]=tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> addr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">WF_distru</span><span class="params">(<span class="type">int</span> apply_size)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>,addr=<span class="number">-1</span>; </span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[<span class="number">0</span>].map_size&lt;apply_size) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>( i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[i].map_size&gt;=apply_size)</span><br><span class="line">&#123;</span><br><span class="line">addr=<span class="built_in">map</span>[i].addr;</span><br><span class="line"><span class="built_in">map</span>[i].addr+=apply_size;</span><br><span class="line"><span class="built_in">map</span>[i].map_size-=apply_size;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[i].map_size==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">num--;</span><br><span class="line"><span class="type">int</span> j=i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=i+<span class="number">1</span>;j&lt;num;j++) <span class="built_in">map</span>[j<span class="number">-1</span>]=<span class="built_in">map</span>[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j=i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;num;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[j].map_size&gt;<span class="built_in">map</span>[i].map_size) </span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MAP</span> <span class="title">tmp</span>;</span></span><br><span class="line">tmp=<span class="built_in">map</span>[j]; <span class="built_in">map</span>[j]=<span class="built_in">map</span>[i];<span class="built_in">map</span>[i]=tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mfree</span><span class="params">(<span class="type">int</span> addr,<span class="type">int</span> rsize)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[i].addr+<span class="built_in">map</span>[i].map_size==addr)<span class="comment">//upper</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">map</span>[i].map_size+=rsize;</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[i].addr-rsize==addr)<span class="comment">//lower</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">map</span>[i].map_size+=rsize;</span><br><span class="line"><span class="built_in">map</span>[i].addr=addr;</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j;j&lt;num;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(j!=i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[j].addr+<span class="built_in">map</span>[j].map_size==<span class="built_in">map</span>[i].addr) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">map</span>[j].map_size+=<span class="built_in">map</span>[i].map_size;</span><br><span class="line"><span class="type">int</span> k=i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(k;k&lt;num;k++) <span class="built_in">map</span>[k<span class="number">-1</span>]=<span class="built_in">map</span>[k];</span><br><span class="line">num--;</span><br><span class="line">i=j;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[i].addr+<span class="built_in">map</span>[i].map_size==<span class="built_in">map</span>[j].addr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">map</span>[i].map_size+=<span class="built_in">map</span>[j].map_size;</span><br><span class="line"><span class="type">int</span> k=j+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(k;k&lt;num;k++) <span class="built_in">map</span>[k<span class="number">-1</span>]=<span class="built_in">map</span>[k];</span><br><span class="line">num--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(alg==<span class="string">&#x27;b&#x27;</span>)<span class="comment">//BF</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j=i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(j;j&lt;num;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[j].map_size&lt;<span class="built_in">map</span>[i].map_size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MAP</span> <span class="title">tmp</span>;</span></span><br><span class="line">tmp=<span class="built_in">map</span>[j]; <span class="built_in">map</span>[j]=<span class="built_in">map</span>[i];<span class="built_in">map</span>[i]=tmp;</span><br><span class="line">i=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j=i<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(j;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[j].map_size&lt;<span class="built_in">map</span>[i].map_size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MAP</span> <span class="title">tmp</span>;</span></span><br><span class="line">tmp=<span class="built_in">map</span>[j]; <span class="built_in">map</span>[j]=<span class="built_in">map</span>[i];<span class="built_in">map</span>[i]=tmp;</span><br><span class="line">j=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">num++;</span><br><span class="line"><span class="built_in">map</span>[num<span class="number">-1</span>].addr=addr;</span><br><span class="line"><span class="built_in">map</span>[num<span class="number">-1</span>].map_size=rsize;</span><br><span class="line"><span class="keyword">if</span>(alg==<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j;j&lt;num;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[j].map_size&gt;rsize) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j!=num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> k=num<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(k;k&gt;=j+<span class="number">1</span>;k--) <span class="built_in">map</span>[k]=<span class="built_in">map</span>[k<span class="number">-1</span>];</span><br><span class="line"><span class="built_in">map</span>[j].addr=addr;</span><br><span class="line"><span class="built_in">map</span>[j].map_size=rsize;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j;j&lt;num;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[j].map_size&lt;rsize) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j!=num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> k=num<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(k;k&gt;=j+<span class="number">1</span>;k--) <span class="built_in">map</span>[k]=<span class="built_in">map</span>[k<span class="number">-1</span>];</span><br><span class="line"><span class="built_in">map</span>[j].addr=addr;</span><br><span class="line"><span class="built_in">map</span>[j].map_size=rsize;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&lt;%d , %d&gt;\n&quot;</span>,<span class="built_in">map</span>[i].addr,<span class="built_in">map</span>[i].map_size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>s</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;写在前面的话：&lt;/p&gt;
&lt;p&gt;本课程一共有四个实验，最后一个选做，由于时间原因，我只写了三个，并且每个都参考了老师所给的参考代码，建议还是要自己先试一试，构思一下，然后和参考代码作对比。至于实验环境的配置请自己搜索，我这里不再赘述。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="class record" scheme="https://klklkl10086.github.io/klklkl10086.github.io/categories/class-record/"/>
    
    
    <category term="操作系统" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Database</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2024/05/07/Database/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2024/05/07/Database/</id>
    <published>2024-05-07T11:03:11.000Z</published>
    <updated>2024-06-05T02:23:40.515Z</updated>
    
    <content type="html"><![CDATA[<p><strong>肯定有错，PPT来源于学校，如果侵权请通过邮箱告知</strong></p><h1 id="sql初步">SQL初步</h1><p><strong>Structed Query Language 结构化查询语言</strong></p><p><img src="Screenshot_20240507_190655_com.huawei.hinote.png" alt="Screenshot_20240507_190655_com.huawei.hinote"></p><h2 id="属性域的类型">属性域的类型</h2><blockquote><ul><li>char(n) 固定长度字符串，用户指定长度为n，若输入为短于n的字符串，自动补空格</li><li>varchar(n)   可变长度字符串，最大长度为n，由用户指定</li><li>int      整数型</li><li>smallint     小整数</li><li>numeric(p,d)     定点小数，长度一共为p其中有d位小数，p与d由用户指定</li><li>real,double precision    浮点数 双精度浮点数</li><li>float(n)  精度为n的浮点数</li></ul></blockquote><h2 id="完整性约束">完整性约束</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#非空约束：</span><br><span class="line">not null</span><br><span class="line">#主键约束  非空且唯一</span><br><span class="line">primary key(A1,A2,...,An)</span><br><span class="line">#外码约束</span><br><span class="line">foreign key(A1,A3,...An) references r</span><br></pre></td></tr></table></figure><h2 id="创建表">创建表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE r(A1 D1,A2 D2,....,An Dn,</span><br><span class="line">              (完整性约束1)，</span><br><span class="line">              (完整性约束2)，</span><br><span class="line">               .....，</span><br><span class="line">               (完整性约束n)，</span><br><span class="line">              )</span><br></pre></td></tr></table></figure><p><strong>r是关系名字，A是属性名字，D是属性域类型</strong></p><p><img src="Screenshot_20240507_202654_com.huawei.hinote.png" alt="Screenshot_20240507_202654_com.huawei.hinote"></p><p><img src="image-20240507203933365.png" alt="image-20240507203933365"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">create table department(</span><br><span class="line">    dept_name varchar(20),</span><br><span class="line">    building varchar(15),</span><br><span class="line">    budget numeric(12,2),</span><br><span class="line">    primary key(dept_name)</span><br><span class="line">);</span><br><span class="line">create table instructor(</span><br><span class="line">    ID char(5),</span><br><span class="line">    _name varchar(20) not null,</span><br><span class="line">    dept_name varchar(20),</span><br><span class="line">    salary numeric(8,2),</span><br><span class="line">    primary key(ID),</span><br><span class="line">    foreign key(dept_name) references department(dept_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="insert">Insert</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into R values (&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,...,&#x27;&#x27;);</span><br><span class="line"></span><br><span class="line">insert into department values(&#x27;Biology&#x27;,&#x27;biology&#x27;,&#x27;15000&#x27;);</span><br></pre></td></tr></table></figure><h2 id="delete">Delete</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#保留关系，移除所有元组</span><br><span class="line">delete from R</span><br><span class="line"></span><br><span class="line">delete from student</span><br></pre></td></tr></table></figure><h2 id="drop">Drop</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#删除关系r</span><br><span class="line">drop table r</span><br></pre></td></tr></table></figure><h2 id="alter">Alter</h2><p>增删属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alter table r add A D </span><br><span class="line">alter table students add parent varchar(10);</span><br><span class="line"></span><br><span class="line">alter table r drop A</span><br><span class="line">alter table students drop parent;</span><br></pre></td></tr></table></figure><p><strong>也可以用于创建表之后对表进行新的主码约束和非空限制等操作</strong></p><h2 id="查询">查询</h2><p><img src="Screenshot_20240507_205222_com.huawei.hinote.png" alt="Screenshot_20240507_205222_com.huawei.hinote"></p><p><strong>返回结果为关系</strong></p><p><strong>Select</strong></p><p>关系代数中的投影运算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#选取所有列</span><br><span class="line">select * </span><br><span class="line">from instructor;</span><br><span class="line"></span><br><span class="line">select &#x27;2011&#x27;;</span><br><span class="line"></span><br><span class="line">select &#x27;2011&#x27; as year;</span><br><span class="line"></span><br><span class="line">select &#x27;A&#x27; </span><br><span class="line">from instructor;</span><br></pre></td></tr></table></figure><p><img src="image-20240507205828047.png" alt="image-20240507205828047"></p><p><img src="image-20240507205844996.png" alt="image-20240507205844996"></p><p><img src="image-20240507205758202.png" alt="image-20240507205758202"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select ID,name,salary/12 </span><br><span class="line">from instructor;</span><br><span class="line"></span><br><span class="line"> select ID,name,salary/12 as monthly_salary</span><br><span class="line"> from instructor;</span><br></pre></td></tr></table></figure><p><strong>tips：</strong></p><ol><li><strong>在sql中是不区分大小写的</strong></li><li><strong>sql中查询默认不会自动去重，想要去重需要加上distinct关键字，想要显示地不去重，可以使用all关键字</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct dept_name from instructor</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select all dept_name from instructor</span><br></pre></td></tr></table></figure><p>​3.<strong>select  语句中可以包含算术表达式，比如= ,-,*,/作用于属性上</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select ID, name, salary/12 from instructor</span><br><span class="line"></span><br><span class="line">select ID, name, salary/12 as monthly_salary from instructor</span><br></pre></td></tr></table></figure><p><strong>where</strong></p><ul><li><strong>限制选取元组的条件</strong>，类似于关系代数的选择操作</li><li><strong>可以使用 and or not 进行多个条件的连接，只有让where语句为true的元组才能被选中</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select name</span><br><span class="line">from instructor</span><br><span class="line">where dept_name=&#x27;Biology&#x27;;</span><br><span class="line"></span><br><span class="line">select name</span><br><span class="line">from instructor</span><br><span class="line">where dept_name=&#x27;Biology&#x27; and salary&gt;80;# and ,or, not</span><br></pre></td></tr></table></figure><ul><li><strong>between 比较运算符表  [   ]（数学上的左闭右闭）</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name from instructor where salary between 90000 and 100000</span><br></pre></td></tr></table></figure><ul><li><strong>元组比较</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select name, course_id</span><br><span class="line">from instructor, teaches</span><br><span class="line">where (instructor.ID, dept_name) = (teaches.ID, &#x27;Biology&#x27;);</span><br></pre></td></tr></table></figure><p><strong>from</strong></p><ul><li><strong>若from后面有多个关系，则是对多个关系进行笛卡尔乘积</strong>，在进行where的判断，最后执行select</li><li><strong>支持重命名操作</strong></li></ul><h2 id="更名">更名</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">oldname as newname</span><br><span class="line">select ID,name,salary/12 as monthly_salary</span><br><span class="line">  from instructor;</span><br></pre></td></tr></table></figure><h2 id="字符串">字符串</h2><p><strong>like关键字</strong></p><blockquote><p>% :匹配任意字符串</p><p>_ : 匹配任意字符</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select name </span><br><span class="line">from instructor </span><br><span class="line">where name like &#x27;%dar%&#x27; #选择含有dar的字符串</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>escape关键字</strong></p><p>表转义字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">like &#x27;100 \%&#x27;  escape  &#x27;\&#x27; </span><br><span class="line">#匹配“100%”字符串</span><br></pre></td></tr></table></figure><p><strong>运算</strong></p><ul><li><p>连接运算    ||  表连接</p></li><li><p>字符串匹配对大小写敏感</p></li><li><p>大小写转换</p></li><li><p>计算字符串长度等</p></li></ul><h2 id="排序">排序</h2><p><strong>order by</strong></p><p>排列元组的<strong>显示</strong>顺序</p><p><strong>默认为升序，加上desc关键字表降序，也可以加asc显式地指出为升序</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select distinct name</span><br><span class="line">from instructor</span><br><span class="line">order by name#根据name进行升序排序</span><br><span class="line"></span><br><span class="line">select distinct name</span><br><span class="line">from instructor</span><br><span class="line">order by name desc#根据name进行降序排序</span><br><span class="line"></span><br><span class="line">order by dept_name, name#多个属性为排序依据</span><br><span class="line">order by dept_name desc, name asc</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="image-20240508222044255.png" alt="image-20240508222044255"></p><h2 id="集合运算">集合运算</h2><p><strong>并  union</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(select course_id from section where sem = ‘Fall&#x27; and year = 2009)</span><br><span class="line">union</span><br><span class="line">(select course_id from section where sem = ‘Spring&#x27; and year = 2010)</span><br></pre></td></tr></table></figure><p><strong>交 intersect</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(select course_id from section where sem = ‘Fall&#x27; and year = 2009)</span><br><span class="line">intersect</span><br><span class="line">(select course_id from section where sem = ‘Spring&#x27; and year = 2010)</span><br></pre></td></tr></table></figure><p><strong>差 except</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(select course_id from section where sem = ‘Fall&#x27; and year = 2009)</span><br><span class="line">except</span><br><span class="line">(select course_id from section where sem = ‘Spring&#x27; and year = 2010)</span><br></pre></td></tr></table></figure><p><strong>sql上的集合运算自动去重</strong></p><p><strong>若想要保留重复元组，则要显式地指出，union all, intersect all  except all</strong></p><h2 id="null-空值">Null 空值</h2><ul><li><p><strong>表未知 unkonwn</strong></p></li><li><p><strong>空值参与任何算术表达式的结果都是空值</strong></p></li><li><p><strong>is null 可以用来检验是否是空值，如果是空值则返回true</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select name</span><br><span class="line">from instructor</span><br><span class="line">where salary is null</span><br></pre></td></tr></table></figure></li><li><p><strong>空值与逻辑运算</strong></p><p><img src="image-20240508223215396.png" alt="image-20240508223215396"></p></li><li><p><strong>如果where子句的谓词计算出的结果为false或者是unkonwn则元组不可出现在结果中</strong></p></li></ul><h2 id="聚集函数">聚集函数</h2><blockquote><ul><li><strong>avg:</strong> average value</li><li><strong>min:</strong> minimum value</li><li><strong>max:</strong> maximum value</li><li><strong>sum:</strong> sum of values</li><li><strong>count:</strong> number of values</li></ul><p><strong>输入元组集合返回单个值</strong></p></blockquote><ul><li><p><strong>avg，min，max，sum的作用对象必须是数字集</strong></p></li><li><p><strong>除了count其他函数面对空值都视而不见，如果表中只有空值，count会返回0，其他函数范围null</strong></p></li><li><p><strong>聚集函数只可以出现在select子句和having子句中，不可以出现在where中</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select avg (salary)</span><br><span class="line">from instructor</span><br><span class="line">where dept_name= &#x27;Comp. Sci.&#x27;;</span><br><span class="line"></span><br><span class="line">select count (distinct ID)</span><br><span class="line">from teaches</span><br><span class="line">where semester = &#x27;Spring&#x27; and year = 2010;</span><br></pre></td></tr></table></figure><h2 id="分组">分组</h2><p><strong>group by</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#分组聚合</span><br><span class="line">select dept_name, avg (salary) as avg_salary</span><br><span class="line">from instructor</span><br><span class="line">group by dept_name;</span><br></pre></td></tr></table></figure><p><strong>没有出现在select聚集函数中的属性必须出现在group by中，出现在group by中的属性不一定出现在select中</strong></p><h2 id="having">having</h2><ul><li><p><strong>无group by无having，形成分组之后再应用having语句</strong></p></li><li><p><strong>from -&gt; where -&gt; group by -&gt; having -&gt; select -&gt;order by</strong></p></li><li><p><strong>任何出现在having语句中但未被聚集的属性必须出现在group by语句中</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select dept_name, avg (salary)</span><br><span class="line">from instructor</span><br><span class="line">group by dept_name</span><br><span class="line">having avg (salary) &gt; 42000;</span><br></pre></td></tr></table></figure><h2 id="嵌套子查询">嵌套子查询</h2><p><strong>where</strong></p><ul><li><p><strong>集合成员资格</strong></p><p><strong>in</strong>：若在则true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select count (distinct ID)</span><br><span class="line">from takes</span><br><span class="line">where (course_id, sec_id, semester, year) in   </span><br><span class="line">(select course_id, sec_id, semester, year</span><br><span class="line">                                 from teaches</span><br><span class="line">                                 where teaches.ID= 10101);</span><br></pre></td></tr></table></figure><p><strong>not in</strong>：不在则true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select distinct course_id</span><br><span class="line">from section</span><br><span class="line">where semester = &#x27;Fall&#x27; and year= 2009 and</span><br><span class="line">course_id  not in (select course_id</span><br><span class="line">                                        from section</span><br><span class="line">                                        where semester = &#x27;Spring&#x27;and year= 2010);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>集合比较</strong></p><p><strong>some</strong>：至少有一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select name</span><br><span class="line">from instructor</span><br><span class="line">where salary &gt; some (select salary</span><br><span class="line">                      from instructor</span><br><span class="line">                      where dept name = &#x27;Biology&#x27;);</span><br><span class="line">#查询工资比同部门至少一个人高的生物系教授的名字</span><br></pre></td></tr></table></figure><p><img src="image-20240510195352004.png" alt="image-20240510195352004"></p><p><strong>all</strong>：全都</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select name</span><br><span class="line">from instructor</span><br><span class="line">where salary &gt; all (select salary</span><br><span class="line">                   from instructor</span><br><span class="line">                   where dept name = &#x27;Biology&#x27;);</span><br><span class="line"> #查找生物系教授中工资最大（比同系其他教授都高）的教授名字</span><br></pre></td></tr></table></figure><p><img src="image-20240510195712732.png" alt="image-20240510195712732"></p></li><li><p><strong>集合约束</strong></p></li></ul><p>​<strong>空关系验证 exists</strong></p><p>​<img src="image-20240510200104835.png" alt="image-20240510200104835"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select course_id</span><br><span class="line">from section as S#S被称作为相关名称</span><br><span class="line">where semester = &#x27;Fall&#x27; and year = 2009 and </span><br><span class="line">exists (select * #内查询叫作相关子查询</span><br><span class="line">                from section as T</span><br><span class="line">                        where semester = &#x27;Spring&#x27;  </span><br><span class="line">                        and year= 2010  and S.course_id = T.course_id);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Find all students who have taken all courses offered in the Biology department.</span><br><span class="line">select distinct S.ID, S.name</span><br><span class="line">from student as S</span><br><span class="line">where not exists ( (select course_id  from course</span><br><span class="line">                                 where dept_name = &#x27;Biology&#x27;)</span><br><span class="line">                               except</span><br><span class="line">                                 (select T.course_id  from takes as T</span><br><span class="line">                                   where S.ID = T.ID));</span><br></pre></td></tr></table></figure><p>​<strong>检查是否存在重复元组 unique</strong></p><p>​unique：<strong>存在重复返回false，不存在则返回true</strong></p><p>​not unique：<strong>反之</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#Find all courses that were offered at most once in 2009</span><br><span class="line">select T.course_id</span><br><span class="line">from course as T</span><br><span class="line">where unique (select R.course_id  from section as R</span><br><span class="line">where T.course_id= R.course_id  and R.year = 2009);</span><br></pre></td></tr></table></figure><p><strong>from</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select dept_name, avg_salary</span><br><span class="line">from (select dept_name, avg (salary) as avg_salary</span><br><span class="line">      from instructor</span><br><span class="line">      group by dept_name)</span><br><span class="line">      where avg_salary &gt; 42000;</span><br><span class="line">或者</span><br><span class="line">select dept_name, avg_salary</span><br><span class="line">from (select dept_name, avg (salary) </span><br><span class="line">      from instructor</span><br><span class="line">      group by dept_name) as dept_avg (dept_name, avg_salary)</span><br><span class="line">    where avg_salary &gt; 42000;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong>with</strong></p><blockquote><p><strong>定义临时关系，只能在同一查询的后面使用</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">with max_budget (value) as  #max_budget 是临时关系</span><br><span class="line">    (select max(budget)</span><br><span class="line">     from department)</span><br><span class="line">select department.name</span><br><span class="line">from department, max_budget</span><br><span class="line">where department.budget = max_budget.value;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Find all departments where the total salary is greater than the average of the total salary at all departments</span><br><span class="line">with dept _total (dept_name, value) as</span><br><span class="line">        (select dept_name, sum(salary)</span><br><span class="line">         from instructor</span><br><span class="line">         group by dept_name),</span><br><span class="line">        dept_total_avg(value) as</span><br><span class="line">        ( select avg(value)</span><br><span class="line">          from dept_total )</span><br><span class="line">select dept_name</span><br><span class="line">from dept_total, dept_total_avg</span><br><span class="line">where dept_total.value &gt; dept_total_avg.value;</span><br></pre></td></tr></table></figure><p><strong>select</strong></p><blockquote><p><strong>标量子查询：用在 只返回一个包含单个属性的元组的查询 的地方</strong></p><p><strong>如果子查询返回多于一个结果的元组会出现error</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select dept_name, ( select count(*)  from instructor                                 where department.dept_name = instructor.dept_name)                               as num_instructors</span><br><span class="line">from department;</span><br></pre></td></tr></table></figure><h2 id="删除">删除</h2><p><strong>delete</strong></p><blockquote><ul><li><strong>delet只能删除元组</strong></li><li><strong>一个delete只能作用与一个关系上</strong></li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#Delete all instructors</span><br><span class="line">delete from instructor </span><br><span class="line"></span><br><span class="line">#Delete all instructors from the Finance department</span><br><span class="line">delete from instructor where dept_name= &#x27;Finance&#x27;;</span><br><span class="line"></span><br><span class="line">#Delete all tuples in the instructor relation for those instructors associated with a department located in the Watson building.</span><br><span class="line">delete from instructor</span><br><span class="line">where dept_name in ( select dept name</span><br><span class="line">                    from department</span><br><span class="line">                    where building = &#x27;Watson&#x27;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#a funny example:</span><br><span class="line">delete from instructor</span><br><span class="line">where salary &lt; (select avg (salary) </span><br><span class="line">                           from instructor);</span><br><span class="line">#Problem:  as we delete tuples from deposit, the average salary changes,边删除平均值边改变</span><br><span class="line">#Solution used in SQL:</span><br><span class="line">#1.   First, compute avg (salary) and find all tuples to delete</span><br><span class="line">#2.   Next, delete all tuples found above (without recomputing  avg or retesting the tuples) </span><br></pre></td></tr></table></figure><h2 id="插入">插入</h2><p><strong>insert</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insert into course</span><br><span class="line">values (&#x27;CS-437&#x27;, &#x27;Database Systems&#x27;, &#x27;Comp. Sci.&#x27;, 4);</span><br><span class="line">#or equivalently</span><br><span class="line">insert into course (course_id, title, dept_name, credits)</span><br><span class="line">values (&#x27;CS-437&#x27;, &#x27;Database Systems&#x27;, &#x27;Comp. Sci.&#x27;, 4);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#Add a new tuple to student with tot_creds set to null</span><br><span class="line">insert into student</span><br><span class="line">values (&#x27;3003&#x27;, &#x27;Green&#x27;, &#x27;Finance&#x27;, null);</span><br></pre></td></tr></table></figure><blockquote><p><strong>系统在执行任何插入之前先执行完select语句十分重要</strong></p><p><strong>Otherwise</strong> queries like</p><p>​     <strong>insert into</strong> <em>table</em>1 <strong>select</strong> * <strong>from</strong> <em>table</em>1</p><p>would cause problem</p></blockquote><h2 id="更新">更新</h2><p><strong>update</strong></p><blockquote><p>改变某个元组的某个属性的值</p><p>update table1</p><p>​set  attribute1 [ ]</p><p>​where</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#Increase salaries of instructors whose salary is over $100,000 by 3%, and all others by a 5% </span><br><span class="line">update instructor</span><br><span class="line">set salary = salary * 1.03</span><br><span class="line">where salary &gt; 100000;</span><br><span class="line">update instructor</span><br><span class="line">set salary = salary * 1.05</span><br><span class="line">where salary &lt;= 100000;</span><br><span class="line">#顺序很重要，不能两次更新不能交换位置</span><br></pre></td></tr></table></figure><p><strong>case</strong></p><blockquote><p>case</p><p>​when  predict1  then  result1</p><p>​when predict2  then  result2</p><p>​…</p><p>​else result</p><p>end</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#可以用case语句进行书写</span><br><span class="line">update instructor</span><br><span class="line">set salary = case</span><br><span class="line">when salary &lt;= 100000 then salary * 1.05</span><br><span class="line">else salary * 1.03</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>update 与标量子查询</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#Recompute and update tot_creds value for all students</span><br><span class="line">update student S </span><br><span class="line">set tot_cred = ( select sum(credits)</span><br><span class="line">                from takes, course</span><br><span class="line">                where takes.course_id = course.course_id and </span><br><span class="line">                S.ID= takes.ID.and  takes.grade &lt;&gt; &#x27;F&#x27; and </span><br><span class="line">                                              takes.grade is not null );</span><br><span class="line">#Instead of sum(credits), use:</span><br><span class="line">case</span><br><span class="line">when sum(credits) is not null then sum(credits)</span><br><span class="line">else 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h1 id="sql进阶">SQL进阶</h1><h2 id="连接">连接</h2><blockquote><p>join ：输入两个关系返回一个关系</p><p><img src="image-20240513103308652.png" alt="image-20240513103308652"></p></blockquote><p><img src="image-20240513103317354.png" alt="image-20240513103317354"></p><h3 id="自然连接">自然连接</h3><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自然连接基于相同的属性名称和数据类型连接两个表。结果表将包含两个表的所有属性，但每个公共列仅保留一份副本</span><br></pre></td></tr></table></figure></blockquote><h3 id="内连接">内连接</h3><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内连接基于在 ON 子句中明确指定的列连接两个表。结果表将包含两个表中的所有属性，包括公共列。</span><br></pre></td></tr></table></figure></blockquote><h3 id="左外连接">左外连接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">course natural left outer join prereq</span><br></pre></td></tr></table></figure><p>出现在左边的元组一定会出现在结果之中，对于没有右边信息的用null填充</p><p><img src="image-20240513103326108.png" alt="image-20240513103326108"></p><h3 id="右外连接">右外连接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">course natural right outer join prereq</span><br></pre></td></tr></table></figure><p>出现在右边关系中的元组一定会出现在结果之中，对于没有左边信息的用null填充</p><p><img src="image-20240513103334101.png" alt="image-20240513103334101"></p><h3 id="全外连接">全外连接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">course natural full outer join prereq</span><br></pre></td></tr></table></figure><p>出现在两个关系的元组都会出现在结果中，无信息用null填充</p><p><img src="image-20240513103544065.png" alt="image-20240513103544065"></p><h3 id="连接条件">连接条件</h3><blockquote><p>只有满足条件的元组才能进行连接，并且条件中的属性在结果中会被重复保留</p></blockquote><p><img src="image-20240513104154472.png" alt="image-20240513104154472"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">course inner join prereq on course.course_id = prereq.course_id</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="image-20240513103744413.png" alt="image-20240513103744413"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">course left outer join prereq on course.course_id = prereq.course_id</span><br></pre></td></tr></table></figure><p><img src="image-20240513104107848.png" alt="image-20240513104107848"></p><p><img src="image-20240513104238809.png" alt="image-20240513104238809"></p><p><img src="image-20240513104340385.png" alt="image-20240513104340385"></p><h2 id="视图">视图</h2><blockquote><p>A <strong>view</strong> provides a mechanism <strong>to hide certain data from the view of certain users</strong>.</p><p>Any relation that is not of the conceptual model but is made visible to a user as a “virtual relation” is called a <strong>view</strong>.</p></blockquote><h3 id="视图的定义">视图的定义</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v <span class="keyword">as</span> <span class="operator">&lt;</span> query expression <span class="operator">&gt;</span></span><br><span class="line"># <span class="keyword">where</span> <span class="operator">&lt;</span>query expression<span class="operator">&gt;</span> <span class="keyword">is</span> <span class="keyword">any</span> legal <span class="keyword">SQL</span> expression.  The <span class="keyword">view</span> name <span class="keyword">is</span> represented <span class="keyword">by</span> v.</span><br></pre></td></tr></table></figure><ul><li>一旦视图被定义，那么这个视图的名字可以用来代指视图产生的<strong>虚拟关系</strong></li><li>数据库系统存储的是与视图关系相关联的<strong>查询表达式</strong></li><li>视图关系概念上包含了查询结果的元组但<strong>不进行预先计算和存储</strong></li><li>视图一旦被创建，在被显示删除之前一直可用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create view faculty as</span><br><span class="line">select ID, name, dept_name</span><br><span class="line">from instructor</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Find all instructors in the Biology department</span><br><span class="line">select name</span><br><span class="line">from faculty</span><br><span class="line">where dept_name = &#x27;Biology&#x27;</span><br><span class="line">#Create a view of department salary totals</span><br><span class="line">create view departments_total_salary( dept_name,total_salary) as </span><br><span class="line">select dept_name, sum (salary)</span><br><span class="line">                 from instructor</span><br><span class="line">                 group by dept_name;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="用视图定义视图">用视图定义视图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create view physics_fall_2009 as</span><br><span class="line">select course.course_id, sec_id, building, room_number</span><br><span class="line">from course, section</span><br><span class="line">where course.course_id = section.course_id  and course.dept_name = &#x27;Physics&#x27;and section.semester = &#x27;Fall&#x27; and section.year = &#x27;2009&#x27;;</span><br><span class="line"></span><br><span class="line">create view physics_fall_2009_watson as</span><br><span class="line">select course_id, room_number</span><br><span class="line">from physics_fall_2009</span><br><span class="line">where building= &#x27;Watson&#x27;;</span><br></pre></td></tr></table></figure><blockquote><ul><li>若视图v1在定义的时候使用了视图v2，则v1直接依赖于v2</li><li>若视图v1在定义的时候使用了视图v2，或者视图v1到视图v2之间存在依赖路径，则v1依赖于v2</li><li>A view relation <em>v</em> is said to be <em>recursive</em> if it depends on itself.</li></ul></blockquote><p><strong>判断闭包的方法</strong></p><blockquote><p><strong>repeat<br>**  Find any view relation *v</strong>i* in <em>e</em>1<br>Replace the view relation <em>v**i</em> by the expression defining <em>v**i</em><br><strong>until</strong> no more view relations are present in <em>e</em>1</p></blockquote><p>As long as the view definitions are not recursive, this loop will terminate</p><h3 id="视图更新">视图更新</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#向视图中添加新的元组</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> faculty <span class="keyword">values</span> (<span class="string">&#x27;30765&#x27;</span>, <span class="string">&#x27;Green&#x27;</span>, <span class="string">&#x27;Music&#x27;</span>);</span><br><span class="line">#This insertion must be represented <span class="keyword">by</span> the insertion <span class="keyword">of</span> the tuple</span><br><span class="line">#(<span class="string">&#x27;30765&#x27;</span>, <span class="string">&#x27;Green&#x27;</span>, <span class="string">&#x27;Music&#x27;</span>, <span class="keyword">null</span>)</span><br><span class="line">#<span class="keyword">into</span> the instructor relation</span><br></pre></td></tr></table></figure><p><strong>sql视图是可更新（插入 删除 更新），若满足下列条件</strong></p><blockquote><p>The <strong>from</strong> clause has only one database relation.</p><p>The <strong>select</strong> clause contains only attribute names of the relation, and does not have any expressions, aggregates, or <strong>distinct</strong> specification.</p><p>Any attribute not listed in the <strong>select</strong> clause can be set to null</p><p>The query does not have a <strong>group</strong> <strong>by</strong> or <strong>having</strong> clause.</p></blockquote><h3 id="物化视图">物化视图</h3><blockquote><p>create a physical table containing all the tuples in the result of the query defining the view</p></blockquote><p><strong>tips：</strong></p><ul><li><p>If relations used in the query are updated, the materialized view result becomes out of date</p></li><li><p>Need to <strong>maintain</strong> the view, by updating the view whenever the underlying relations are updated.</p></li><li><p>视图是一种“虚关系”，实际查询时需要根据定义查询底层关系，当存在大量这样的查询时会有较高的成本。</p></li><li><p>某些数据库支持物化视图，像存储表一样将创建的视图关系“物化”存储在数据库中。</p></li><li><p>物化视图的创建、修改与删除语法同视图类似，区别是多了关键字 <strong>MATERIALIZED</strong></p></li></ul><h2 id="完整性约束">完整性约束</h2><blockquote><p>保护数据的一致性</p></blockquote><p><strong>单个关系上的完整性约束</strong></p><blockquote><p>**not null ** 非空</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">Declare</span> name <span class="keyword">and</span> budget <span class="keyword">to</span> be <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>       </span><br><span class="line">budget <span class="type">numeric</span>(<span class="number">12</span>,<span class="number">2</span>) <span class="keyword">not</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>primary key</strong>主码</p></blockquote><p>既要非空又要保证唯一性</p><blockquote><p>**unique**唯一性</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unique</span> ( A1, A2, …, Am)</span><br></pre></td></tr></table></figure><ul><li><strong>让A1,A2,…,Am，成为了超码</strong></li><li><strong>声明了唯一性的属性允许为空</strong></li></ul><blockquote><p><strong>check</strong> §, where P is a predicate</p></blockquote><p><strong>关系中的每个元组都要满足谓词P</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#ensure that semester <span class="keyword">is</span> <span class="keyword">one</span> <span class="keyword">of</span> fall, winter, spring <span class="keyword">or</span> summer:</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> section (</span><br><span class="line">    course_id <span class="type">varchar</span> (<span class="number">8</span>),</span><br><span class="line">    sec_id <span class="type">varchar</span> (<span class="number">8</span>),</span><br><span class="line">    semester <span class="type">varchar</span> (<span class="number">6</span>),</span><br><span class="line">    <span class="keyword">year</span> <span class="type">numeric</span> (<span class="number">4</span>,<span class="number">0</span>),</span><br><span class="line">    building <span class="type">varchar</span> (<span class="number">15</span>),</span><br><span class="line">    room_number <span class="type">varchar</span> (<span class="number">7</span>),</span><br><span class="line">    <span class="type">time</span> slot id <span class="type">varchar</span> (<span class="number">4</span>), </span><br><span class="line">    <span class="keyword">primary</span> key (course_id, sec_id, semester, <span class="keyword">year</span>),</span><br><span class="line">    <span class="keyword">check</span> (semester <span class="keyword">in</span> (<span class="string">&#x27;Fall&#x27;</span>, <span class="string">&#x27;Winter&#x27;</span>, <span class="string">&#x27;Spring&#x27;</span>, <span class="string">&#x27;Summer&#x27;</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>引用完整性</strong></p><blockquote><ul><li><strong>保证引用关系中的给定属性集合的取值也在被引用关系的特定属性集的取值中出现</strong></li><li><strong>外码是引用完整性约束的一种形式，其中被引用的属性构成被引用关系的主码</strong></li><li>至少要保证被引用关系的唯一性，要么主码约束要么唯一性约束</li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> course (</span><br><span class="line">course_id   <span class="type">char</span>(<span class="number">5</span>) <span class="keyword">primary</span> key,</span><br><span class="line">title <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">dept_name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">references</span> department#dept_name是department的主码</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>引用完整性上的级联操作</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> course (</span><br><span class="line">…</span><br><span class="line">dept_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line"><span class="keyword">foreign</span> key (dept_name) <span class="keyword">references</span> department</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">delete</span> cascade#如果被引用关系上的删除，更新操作违反了约束，那么就进行级联删除或者更新</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">update</span> cascade,</span><br><span class="line">. . . </span><br><span class="line">)</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">update</span> cascade</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">delete</span> cascade</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">set</span> <span class="keyword">null</span>#置空值</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">set</span> defualt#置缺省置</span><br></pre></td></tr></table></figure><p><strong>复杂check语句</strong></p><blockquote><p><strong>复杂的check语句在我们希望保证数据的完整性是有用的，但开销十分巨大</strong></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">check</span> (time_slot_id <span class="keyword">in</span> (<span class="keyword">select</span> time_slot_id <span class="keyword">from</span> time_slot))</span><br><span class="line">#section关系上定义约束</span><br><span class="line">#why <span class="keyword">not</span> use a <span class="keyword">foreign</span> key here?   因为不是超码</span><br></pre></td></tr></table></figure><p>上述语句不仅要在section更新时候进行计算，也要在time_slot发生更新的时候计算</p><h2 id="断言"><strong>断言</strong></h2><blockquote><p>谓词，表达了希望数据库总满足的一个条件</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> assertion <span class="operator">&lt;</span>assertion<span class="operator">-</span>name<span class="operator">&gt;</span> <span class="keyword">check</span> <span class="operator">&lt;</span>predicate<span class="operator">&gt;</span>;</span><br><span class="line">#不被任何数据库支持</span><br></pre></td></tr></table></figure><p><strong>创建断言的时候系统会检测其有效性，检测和维护有效性的开销很大，但触发器可以实现等价功能</strong></p><h2 id="数据类型">数据类型</h2><p><img src="image-20240520195105693.png" alt="image-20240520195105693"></p><h2 id="创建索引">创建索引</h2><blockquote><p><strong>索引：一种数据结构，允许数据库系统高效地找到关系中具有该属性指定值的元组，而不扫描关系的所有元组</strong></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student</span><br><span class="line">( ID <span class="type">varchar</span> (<span class="number">5</span>),</span><br><span class="line">name <span class="type">varchar</span> (<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">dept_name <span class="type">varchar</span> (<span class="number">20</span>),</span><br><span class="line">tot_cred <span class="type">numeric</span> (<span class="number">3</span>,<span class="number">0</span>) <span class="keyword">default</span> <span class="number">0</span>,</span><br><span class="line"><span class="keyword">primary</span> key (ID) )</span><br><span class="line"><span class="keyword">create</span> index studentID_index <span class="keyword">on</span> student(ID)</span><br><span class="line"><span class="comment">---------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span>  student</span><br><span class="line"><span class="keyword">where</span>  ID <span class="operator">=</span> ‘<span class="number">12345</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">#can be executed by using the index to find the required record, without looking at all records of student</span></span><br></pre></td></tr></table></figure><h2 id="用户自定义类型">用户自定义类型</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> type Dollars <span class="keyword">as</span> <span class="type">numeric</span> (<span class="number">12</span>,<span class="number">2</span>) <span class="keyword">final</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> department</span><br><span class="line">( dept_name <span class="type">varchar</span> (<span class="number">20</span>),</span><br><span class="line"> building <span class="type">varchar</span> (<span class="number">15</span>),</span><br><span class="line"> budget Dollars );</span><br><span class="line"><span class="keyword">create</span> type Pounds <span class="keyword">as</span> <span class="type">numeric</span> (<span class="number">12</span>,<span class="number">2</span>) <span class="keyword">final</span> </span><br><span class="line"># Pounds和Dollars不是一种类型</span><br></pre></td></tr></table></figure><h2 id="域">域</h2><p><img src="image-20240520195647678.png" alt="image-20240520195647678"></p><h2 id="大对象类型">大对象类型</h2><p><img src="image-20240520195728022.png" alt="image-20240520195728022"></p><h2 id="授权">授权</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="operator">&lt;</span>privilege list<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">on</span> <span class="operator">&lt;</span>relation name <span class="keyword">or</span> <span class="keyword">view</span> name<span class="operator">&gt;</span> <span class="keyword">to</span> <span class="operator">&lt;</span><span class="keyword">user</span> list<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>sql中的权限：</p><ul><li><strong>select：allows read access to</strong> <strong>relation,or</strong> <strong>the ability to query using the view</strong></li><li><strong>insert:the ability to insert tuples</strong></li><li><strong>update:</strong> <strong>the ability to update using the SQL update statement</strong></li><li><strong>delete：the ability to delete tuples.</strong></li><li><strong>all</strong> <strong>privileges：used as a short form for all the allowable privileges</strong></li></ul><h3 id="移除权限">移除权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> <span class="operator">&lt;</span>privilege list<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">on</span> <span class="operator">&lt;</span>relation name <span class="keyword">or</span> <span class="keyword">view</span> name<span class="operator">&gt;</span> <span class="keyword">from</span> <span class="operator">&lt;</span><span class="keyword">user</span> list<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><ul><li>如果 **<revokee-list>**包含public那么全部的用户会失去权限，除了授权用户</li><li>如果相同的权限被不同的人授予给相同的用户两次，那么在被一次撤权后会保留权限。</li><li>所有依赖被撤除权限的权限也会被撤除</li></ul><h3 id="角色">角色</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> role instructor</span><br><span class="line"><span class="keyword">grant</span> instructor <span class="keyword">to</span> Amit</span><br><span class="line"># Privileges can be granted <span class="keyword">to</span> roles:</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> takes <span class="keyword">to</span> instructor</span><br><span class="line"># Roles can be granted <span class="keyword">to</span> users, <span class="keyword">as</span> well <span class="keyword">as</span> <span class="keyword">to</span> other roles</span><br><span class="line"><span class="keyword">create</span> role teaching_assistant</span><br><span class="line"><span class="keyword">grant</span> teaching_assistant <span class="keyword">to</span> instructor # Instructor inherits <span class="keyword">all</span> privileges <span class="keyword">of</span> teaching_assistant</span><br></pre></td></tr></table></figure><h3 id="视图的授权">视图的授权</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> geo_instructor <span class="keyword">as</span></span><br><span class="line">( <span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"> <span class="keyword">from</span> instructor</span><br><span class="line"> <span class="keyword">where</span> dept_name <span class="operator">=</span> ’Geology’);</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> geo_instructor <span class="keyword">to</span>  geo_staff</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="授权的转移">授权的转移</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#允许被授权用户进行授权</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> department <span class="keyword">to</span> Amit <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br><span class="line">#级联收权，缺省</span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">select</span> <span class="keyword">on</span> department <span class="keyword">from</span> Amit, Satoshi cascade;</span><br><span class="line">#显示限定不级联收权</span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">select</span> <span class="keyword">on</span> department <span class="keyword">from</span> Amit, Satoshi restrict;</span><br><span class="line">#仅收回授权选项</span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">grant</span> option <span class="keyword">for</span> <span class="keyword">select</span> <span class="keyword">on</span> department <span class="keyword">from</span> Amit, Satoshi restrict;</span><br></pre></td></tr></table></figure><p><strong>一个用户具有权限等价于授权图中存在由根到用户节点的路径</strong></p><h1 id="高级sql">高级SQL</h1><h2 id="函数与过程">函数与过程</h2><h3 id="函数">函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">Define</span> a <span class="keyword">function</span> that, given the name <span class="keyword">of</span> a department, <span class="keyword">returns</span> the count <span class="keyword">of</span> the number <span class="keyword">of</span> instructors <span class="keyword">in</span> that department.</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> dept_count (dept_name <span class="type">varchar</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">returns</span> <span class="type">integer</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> d_count  <span class="type">integer</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span> (<span class="operator">*</span> ) <span class="keyword">into</span> d_count</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> instructor.dept_name <span class="operator">=</span> dept_name</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> d_count;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--------</span></span><br><span class="line"><span class="keyword">select</span> dept_name, budget</span><br><span class="line"><span class="keyword">from</span> department</span><br><span class="line"><span class="keyword">where</span> dept_count (dept_name ) <span class="operator">&gt;</span> <span class="number">12</span></span><br></pre></td></tr></table></figure><p><img src="image-20240522090152312.png" alt="image-20240522090152312"></p><h3 id="存储过程">存储过程</h3><p><img src="image-20240522085957034.png" alt="image-20240522085957034"></p><p><img src="image-20240522090006465.png" alt="image-20240522090006465"></p><p><img src="image-20240522090059620.png" alt="image-20240522090059620"></p><p>区别</p><ul><li><strong>存储过程和函数是事先经过编译并存储在数据库中的一段SQL语句的集合</strong></li><li><strong>存储过程和函数可以对一段代码进行封装，以便日后调用</strong></li><li><strong>数据库中创建存储过程的语句为CREATE PROCEDURE，并通过CALL语句加存储过程名来调用存储过程</strong></li><li><strong>数据库中创建函数的语句为CREATE FUNCTION，并通过函数名来调用函数</strong></li><li><strong>存储过程和函数都用于提高数据库性能，减少频繁访问数据库和减少网络延迟等方式加速执行效率。</strong></li><li><strong>函数：简单的计算型任务，例如字符串或日期拼接、返回单个值等。</strong></li><li><strong>存储过程：复杂的业务逻辑、更新和删除相关操作。</strong></li><li><strong>存储过程需要显式地被调用，并且可以包含各种复杂的控制结构和代码块。</strong></li></ul><p><img src="image-20240522090240468.png" alt="image-20240522090240468"></p><h2 id="触发器">触发器</h2><blockquote><p>可以被系统自动执行、作为数据库修改的side effect 的语句</p></blockquote><ul><li><p><strong>我们要指定触发器执行的条件和动作</strong></p></li><li><p><strong>触发器事件可以是插入、删除、更新，其中更新可以限定到一个属性上 更新前后可以被引用</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">referencing</span> <span class="keyword">old</span> <span class="type">row</span> <span class="keyword">as</span>  :<span class="keyword">for</span> deletes <span class="keyword">and</span> updates</span><br><span class="line"><span class="keyword">referencing</span> <span class="keyword">new</span> <span class="type">row</span> <span class="keyword">as</span>  : <span class="keyword">for</span> inserts <span class="keyword">and</span> updates</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> setnull_trigger before <span class="keyword">update</span> <span class="keyword">of</span> takes</span><br><span class="line"><span class="keyword">referencing</span> <span class="keyword">new</span> <span class="type">row</span> <span class="keyword">as</span> nrow</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">when</span> (nrow.grade <span class="operator">=</span> ‘ ‘)</span><br><span class="line"><span class="keyword">begin</span> <span class="keyword">atomic</span></span><br><span class="line"><span class="keyword">set</span> nrow.grade <span class="operator">=</span> <span class="keyword">null</span>;   </span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> credits_earned after <span class="keyword">update</span> <span class="keyword">of</span> takes <span class="keyword">on</span> (grade)</span><br><span class="line"><span class="keyword">referencing</span> <span class="keyword">new</span> <span class="type">row</span> <span class="keyword">as</span> nrow</span><br><span class="line"><span class="keyword">referencing</span> <span class="keyword">old</span> <span class="type">row</span> <span class="keyword">as</span> orow</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">when</span> nrow.grade <span class="operator">&lt;&gt;</span> ’F’ <span class="keyword">and</span> nrow.grade <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line"><span class="keyword">and</span> (orow.grade <span class="operator">=</span> ’F’ <span class="keyword">or</span> orow.grade <span class="keyword">is</span> <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">begin</span> <span class="keyword">atomic</span></span><br><span class="line"><span class="keyword">update</span> student</span><br><span class="line"><span class="keyword">set</span> tot_cred<span class="operator">=</span> tot_cred <span class="operator">+</span> </span><br><span class="line">(<span class="keyword">select</span> credits</span><br><span class="line"><span class="keyword">from</span> course</span><br><span class="line"><span class="keyword">where</span> course.course_id<span class="operator">=</span> nrow.course_id)</span><br><span class="line"><span class="keyword">where</span> student.id <span class="operator">=</span> nrow.id;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p><img src="image-20240522091147745.png" alt="image-20240522091147745"></p><p><img src="image-20240522090959333.png" alt="image-20240522090959333"></p><p><img src="image-20240522091258072.png" alt="image-20240522091258072"></p><p><img src="image-20240522091316867.png" alt="image-20240522091316867"></p><h2 id="闭包查询">闭包查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="keyword">recursive</span> rec_prereq(course_id, prereq_id) <span class="keyword">as</span> (</span><br><span class="line"><span class="keyword">select</span> course_id, prereq_id</span><br><span class="line"><span class="keyword">from</span> prereq</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> rec_prereq.course_id, prereq.prereq_id,</span><br><span class="line"><span class="keyword">from</span> rec_rereq, prereq</span><br><span class="line"><span class="keyword">where</span> rec_prereq.prereq_id <span class="operator">=</span> prereq.course_id</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> ∗ </span><br><span class="line"><span class="keyword">from</span> rec_prereq;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;肯定有错，PPT来源于学校，如果侵权请通过邮箱告知&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;sql初步&quot;&gt;SQL初步&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Structed Query Language 结构化查询语言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img </summary>
      
    
    
    
    
    <category term="sql" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>约数定理</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2024/04/05/%E7%BA%A6%E6%95%B0%E5%AE%9A%E7%90%86/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2024/04/05/%E7%BA%A6%E6%95%B0%E5%AE%9A%E7%90%86/</id>
    <published>2024-04-05T09:45:40.000Z</published>
    <updated>2024-04-05T09:45:40.349Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>线性筛详解</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2024/04/05/%E7%BA%BF%E6%80%A7%E7%AD%9B%E8%AF%A6%E8%A7%A3/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2024/04/05/%E7%BA%BF%E6%80%A7%E7%AD%9B%E8%AF%A6%E8%A7%A3/</id>
    <published>2024-04-05T09:26:22.000Z</published>
    <updated>2024-04-05T09:26:59.307Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>stl之手撕sort函数</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2024/03/20/stl-sort/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2024/03/20/stl-sort/</id>
    <published>2024-03-20T11:45:01.000Z</published>
    <updated>2024-03-20T13:25:00.161Z</updated>
    
    <content type="html"><![CDATA[<p>​写在前面的话：大二下学期时，有一门课叫数据结构实践，在最后一次上机的时候，老师限时让我们做一道oj题，题目是关于stl中sort函数的实现问题，很不幸，我一个点都没过得了0分。因此，在课后想再试试，故有此篇文章。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​	写在前面的话：大二下学期时，有一门课叫数据结构实践，在最后一次上机的时候，老师限时让我们做一道oj题，题目是关于stl中sort函数的实现问题，很不幸，我一个点都没过得了0分。因此，在课后想再试试，故有此篇文章。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="c++" scheme="https://klklkl10086.github.io/klklkl10086.github.io/categories/c/"/>
    
    
    <category term="STL" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2024/02/22/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2024/02/22/%E8%93%9D%E6%A1%A5%E6%9D%AF/</id>
    <published>2024-02-22T02:50:11.000Z</published>
    <updated>2024-04-12T14:13:26.814Z</updated>
    
    <content type="html"><![CDATA[<p>放在前面的话：</p><p>​这份笔记是在大二下刚开学的时候进行书写的，主要参考的是Acwing的<a href="https://www.acwing.com/activity/content/19/">蓝桥杯辅导课</a>，笔者在成体系的学习算法之前已经学习过基本的<a href="https://comeupklklkl.gitee.io/jluloser.github.io/2023/10/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>，以及离散数学。（PS:y总讲课很好，如果可以建议报一下试试）</p><h1 id="基础概念">基础概念</h1><p>1s内c++可以运算一亿次即1e8次，因此我们的最大次数小于1e7到1e8之间便可以</p><p>int的范围约为[-2e9,+2e9]，最大值可以通过 0x7fffffff 来表示，long long的范围是 [- 1e18，+1e18]</p><p>由数据范围反推算法复杂度以及算法内容：</p><p><img src="image-20240412192522712.png" alt="image-20240412192522712"></p><p>下取整 （int）直接除</p><p>上取整：转化成下取整</p><p><img src="image-20240314212814712.png" alt="image-20240314212814712"></p><p><img src="image-20240314213050728.png" alt="image-20240314213050728"></p><h1 id="输入技巧">输入技巧</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="built_in">getline</span>(cin,str);</span><br><span class="line"><span class="keyword">while</span>(cnt--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">getline</span>(cin,str);</span><br><span class="line">        <span class="function">stringstream <span class="title">ssin</span><span class="params">(str)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(ssin&gt;&gt;a[n]) n++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="递归与递推">递归与递推</h1><p>递归：把问题分成若干个相同子问题</p><p>递推：由子问题推出最终问题</p><h1 id="二分">二分</h1><h2 id="整数二分">整数二分</h2><ul><li><p>确定一个区间使得答案一定在一个区间里</p></li><li><p>找一个性质，满足两点：</p><p>性质具有二段性</p><p>答案是二段性的分段点（有两种情况，一种是前段的终点a，一种是后段的起点b，a与b不重合）</p></li></ul><p><img src="image-20240307215445608.png" alt="image-20240307215445608"></p><p><img src="image-20240307215206733.png" alt="image-20240307215206733"></p><p><a href="https://www.acwing.com/file_system/file/content/whole/index/content/3073/">y总模板</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;<span class="comment">//一定要加一</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;<span class="comment">//</span></span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记忆技巧：</p><p>如果我们想要的点x是左部分的<strong>右端点</strong>，则区间分为 [l,mid-1] ,[<strong>mid</strong>,r]</p><p>如果我们想要的点x是右部分的<strong>左端点</strong>，则区间分为 [l,<strong>mid</strong>] ,[mid+1,r]</p><p>即我们想要的x是什么方向的端点，mid就在哪个部分，<strong>只要l=mid出现计算mid的时候一定要加一</strong></p><h1 id="前缀和">前缀和</h1><p><strong>一定要将下标加一，不然遇见s[i-1]会出问题</strong></p><h2 id="一维前缀和">一维前缀和</h2><p>利用数列的思想：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>r</mi></msub><mo>−</mo><msub><mi>S</mi><mi>l</mi></msub><mo>=</mo><msub><mi>a</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>a</mi><mrow><mi>l</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>a</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">S_r-S_l=a_{l+1}+a_{l+2}+...+a_{r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.791661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.791661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><h2 id="二维前缀和">二维前缀和</h2><p>与一维前缀和思想类似:</p><blockquote><p><strong>容斥原理</strong>:</p><p>在计数时，必须注意没有重复，没有遗漏。为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目<a href="https://baike.baidu.com/item/%E6%8E%92%E6%96%A5/10717656?fromModule=lemma_inlink">排斥</a>出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理</p></blockquote><p><strong>1.计算前缀和矩阵</strong></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></msub><mo>=</mo><msub><mi>S</mi><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></msub><mo>+</mo><msub><mi>S</mi><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msub><mo>−</mo><msub><mi>S</mi><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msub><mo>+</mo><msub><mi>a</mi><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">S_{(x,y)} = S_{(x-1,y)}+S_{(x,y-1)}-S_{(x-1,y-1)}+a_{(x,y)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7857599999999999em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span></span></p><p><strong>2.利用前缀和矩阵计算子矩阵的和</strong></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></msub><mo>=</mo><msub><mi>S</mi><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></msub><mo>−</mo><msub><mi>S</mi><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msub><mo>−</mo><msub><mi>S</mi><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>−</mo><mn>1</mn><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></msub><mo>+</mo><msub><mi>S</mi><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>−</mo><mn>1</mn><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">S_{(x_1,y_1),(x_2,y_2)} = S_{(x_2,y_2)}-S_{(x_2,y_1-1)}-S_{(x_1-1,y_2)}+S_{(x_1-1,y_1-1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mpunct mtight">,</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span></span></p><h1 id="差分">差分</h1><p>前缀和的逆应用</p><p><strong>在指定的区间内统一加上或者减去一个数字</strong></p><p><img src="image-20240412195444573.png" alt="image-20240412195444573"></p><p>输入一个 n 行 m列的整数矩阵，再输入 q 个操作，每个操作包含五个整数 x1,y1,x2,y2,c1,1,2,2,，其中 (x1,y1)和 (x2,y2)表示一个子矩阵的左上角坐标和右下角坐标。</p><p>每个操作都要将选中的子矩阵中的每个元素的值加上 c。</p><p>请你将进行完所有操作后的矩阵输出。</p><h4 id="输入格式">输入格式</h4><p>第一行包含整数 n,m,q,。</p><p>接下来 n 行，每行包含 m 个整数，表示整数矩阵。</p><p>接下来 q 行，每行包含 55个整数 x1,y1,x2,y2，c表示一个操作。</p><h4 id="输出格式">输出格式</h4><p>共 n 行，每行 m 个整数，表示所有操作进行完毕后的最终矩阵。</p><h4 id="输入样例：">输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3 4 3</span><br><span class="line">1 2 2 1</span><br><span class="line">3 2 2 1</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 2 2 1</span><br><span class="line">1 3 2 3 2</span><br><span class="line">3 1 3 4 1</span><br></pre></td></tr></table></figure><h4 id="输出样例：">输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 3 4 1</span><br><span class="line">4 3 4 1</span><br><span class="line">2 2 2 2</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> a[N][N],n,m,q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">a[i][j]+=x;</span><br><span class="line">a[i+<span class="number">1</span>][j]-=x;</span><br><span class="line">a[i][j+<span class="number">1</span>]-=x;</span><br><span class="line">a[i+<span class="number">1</span>][j+<span class="number">1</span>]+=x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> x1,y1,x2,y2,c;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;c);</span><br><span class="line">a[x1][y1]+=c;</span><br><span class="line">a[x2+<span class="number">1</span>][y1]-=c;</span><br><span class="line">a[x1][y2+<span class="number">1</span>]-=c;</span><br><span class="line">a[x2+<span class="number">1</span>][y2+<span class="number">1</span>]+=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">a[i][j]+=a[i<span class="number">-1</span>][j]+a[i][j<span class="number">-1</span>]-a[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i][j]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一维差分">一维差分</h2><h2 id="二维差分">二维差分</h2><h1 id="数学知识">数学知识</h1><p>尽力分析</p><p>打表找规律</p><h3 id="裴蜀定理">裴蜀定理</h3><p><img src="image-20240412201207067.png" alt="image-20240412201207067"></p><p><img src="image-20240412201220057.png" alt="image-20240412201220057"></p><p><img src="image-20240314210202079.png" alt="image-20240314210202079"></p><h3 id="最大公因数">最大公因数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="朴素筛质数"><strong>朴素筛质数</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[i]) <span class="keyword">continue</span>;</span><br><span class="line">        primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + i; j &lt;= n; j += i)</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="枚举-模拟-排序">枚举 模拟 排序</h1><p><strong>归并排序模板</strong></p><p>计算逆序对</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    cnt+=<span class="built_in">merge_sort</span>(q,l,mid)+<span class="built_in">merge_sort</span>(q,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="type">int</span> i=l,j=mid+<span class="number">1</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i]&lt;=q[j]) tmp[k++]=q[i++];</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            cnt+=mid-i+<span class="number">1</span>;<span class="comment">////key</span></span><br><span class="line">            tmp[k++]=q[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) tmp[k++]=q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) tmp[k++]=q[j++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l,j=<span class="number">0</span>;i&lt;=r;i++,j++) q[i]=tmp[j];</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="树状数组与线段树">树状数组与线段树</h1><p>前者精密  后者处理范围广</p><p><img src="image-20240324104634741.png" alt="image-20240324104634741"></p><p><img src="image-20240324105942645.png" alt="image-20240324105942645"></p><p><img src="image-20240324110501255.png" alt="image-20240324110501255"></p><p><img src="image-20240324194807646.png" alt="image-20240324194807646"></p><p><img src="image-20240324195124747.png" alt="image-20240324195124747"></p><p>线段树节点的个数最多是4n，存储方式和堆的存储方式一样，使用一维数组存储，下标为x的节点的父节点是x/2（x&gt;&gt;1） 左儿子是2x 右儿子是2x+1</p><h1 id="位运算">位运算</h1><p>求n的第k位数字: n &gt;&gt; k &amp; 1<br>返回n的最后一位1：lowbit(n) = n &amp; -n</p><h1 id="快速幂">快速幂</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对p做二进制拆分， 对n做平方倍增 -- O(log n)</span></span><br><span class="line"> <span class="function">ll <span class="title">quick_power</span><span class="params">(ll n, ll p)</span></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;  <span class="comment">//如果指数不为0</span></span><br><span class="line">        <span class="keyword">if</span>(p &amp; <span class="number">1</span>) res *= n;  <span class="comment">// 如果对应二进制数的当前位为1, 则res 乘以当前位的值</span></span><br><span class="line">        n *= n;              <span class="comment">//对n进行倍增</span></span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>;             <span class="comment">//指数右移1位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="高精度计算">高精度计算</h1><h2 id="大数加法">大数加法</h2><h3 id="课程">课程</h3><p><strong>没有考虑负数的情况</strong></p><p><a href="https://www.bilibili.com/video/BV1Ne411v78Z/?spm_id_from=333.788&amp;vd_source=9a4fe569cfdfb26138828e9c87e1512d">b站大数加法</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">vector2string</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; x, <span class="type">int</span> s, <span class="type">bool</span> flag = <span class="number">1</span>)</span><span class="comment">//flag为1则x为正数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">string <span class="title">ans</span><span class="params">(s, <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s; i++)</span><br><span class="line">&#123;</span><br><span class="line">ans[i] = <span class="string">&#x27;0&#x27;</span> + x[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());<span class="comment">//倒置</span></span><br><span class="line"> <span class="keyword">if</span>(!flag)    ans.<span class="built_in">insert</span>(<span class="number">0</span>,<span class="string">&quot;-&quot;</span>);<span class="comment">//如果为负数在数字前面添加负号</span></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">add</span><span class="params">(string&amp; num1, string&amp; num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(num1.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(num2.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num1.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">a[num1.<span class="built_in">size</span>() - i - <span class="number">1</span>] = num1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num2.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">b[num2.<span class="built_in">size</span>() - i - <span class="number">1</span>] = num2[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(num1.size() + num2.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> len = num2.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (num2.<span class="built_in">size</span>() &gt; num1.<span class="built_in">size</span>()) len = num1.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">c[i]+= a[i] + b[i];</span><br><span class="line">c[i + <span class="number">1</span>] += c[i] / <span class="number">10</span>;</span><br><span class="line">c[i] %= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//位数较长的数平移加上对应位置的c[i]</span></span><br><span class="line"><span class="keyword">if</span> (num1.<span class="built_in">size</span>() &gt; num2.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; num1.<span class="built_in">size</span>(); i++)</span><br><span class="line">c[i] += a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (num1.<span class="built_in">size</span>() &lt; num2.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; num2.<span class="built_in">size</span>(); i++)</span><br><span class="line">c[i] += b[i];</span><br><span class="line">&#125;</span><br><span class="line">    len = num1.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (num2.<span class="built_in">size</span>() &gt; num1.<span class="built_in">size</span>()) len = num2.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span> (c[len] == <span class="number">0</span>)<span class="comment">//去除前导0</span></span><br><span class="line">&#123;</span><br><span class="line">len--;</span><br><span class="line">&#125;</span><br><span class="line">string ans = <span class="built_in">vector2string</span>(c, len + <span class="number">1</span>);<span class="comment">//转换为string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习">练习</h3><p><a href="https://leetcode.cn/problems/add-strings/submissions/504061261/">力扣 字符串加法</a></p><h2 id="大数减法">大数减法</h2><h3 id="课程">课程</h3><p><a href="https://www.bilibili.com/video/BV1kb4y1A7Wf/?spm_id_from=333.788&amp;vd_source=9a4fe569cfdfb26138828e9c87e1512d">b站</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">divide</span><span class="params">(string&amp; num1, string&amp; num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> flag = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (num1.<span class="built_in">size</span>() &lt; num2.<span class="built_in">size</span>() || (num1.<span class="built_in">size</span>() == num2.<span class="built_in">size</span>() &amp;&amp; num1 &lt; num2))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(num1, num2);</span><br><span class="line">flag = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(num1.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(num2.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num1.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">a[num1.<span class="built_in">size</span>() - i - <span class="number">1</span>] = num1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num2.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">b[num2.<span class="built_in">size</span>() - i - <span class="number">1</span>] = num2[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(num1.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> len = num2.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt; b[i])</span><br><span class="line">&#123;</span><br><span class="line">a[i] += <span class="number">10</span>;</span><br><span class="line">a[i + <span class="number">1</span>]--;</span><br><span class="line">&#125;</span><br><span class="line">c[i] += a[i] - b[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; num1.<span class="built_in">size</span>(); i++)</span><br><span class="line">c[i] += a[i];</span><br><span class="line">len=c.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (c[len] == <span class="number">0</span>)</span><br><span class="line">len--;</span><br><span class="line"></span><br><span class="line">string ans;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans = <span class="built_in">vector2string</span>(c, len + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ans = <span class="built_in">vector2string</span>(c, len + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大数乘法">大数乘法</h2><p><a href="https://www.bilibili.com/video/BV1LA411v7mt?p=3&amp;vd_source=9a4fe569cfdfb26138828e9c87e1512d">b站 高精度算法</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">mulity</span><span class="params">(string&amp; num1, string&amp; num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(num1.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(num2.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(num1.size() + num2.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= num1.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">a[num1.<span class="built_in">size</span>() - i] = num1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= num2.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">b[num2.<span class="built_in">size</span>() - i] = num2[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= num2.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= num1.<span class="built_in">size</span>(); j++)</span><br><span class="line">&#123;</span><br><span class="line">c[i + j - <span class="number">1</span>] += b[i] * a[j];</span><br><span class="line">c[i + j] += c[i + j - <span class="number">1</span>] / <span class="number">10</span>;</span><br><span class="line">c[i + j - <span class="number">1</span>] %= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> len = c.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (c[len] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">len--;</span><br><span class="line">&#125;</span><br><span class="line">string ans = <span class="built_in">vector2string</span>(c, len + <span class="number">1</span>);</span><br><span class="line">ans = ans.<span class="built_in">substr</span>(<span class="number">0</span>, ans.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态规划-dp">动态规划（dp）</h1><p>暴力dfs-&gt;记忆化搜索–&gt;递推（dp）</p><p>记忆化搜索 = 暴力dfs+记录答案</p><p>递推的公式  = dfs向下递归的公式</p><p>dp的重点在于状态转移方程，即从树的最下层向上归的过程</p><p><a href="https://www.acwing.com/file_system/file/content/whole/index/content/10768518/">跳楼梯</a></p><p><a href="https://acm.cjlu.edu.cn/problem/3641">大盗阿福</a></p><h2 id="背包问题">背包问题</h2><ul><li><p>状态表示</p></li><li><p>状态计算</p><p><img src="image-20240315092802200.png" alt="image-20240315092802200"></p><p><img src="/image-20240315093548155.png" alt="image-20240315093548155"></p></li></ul><p>注意：右边的子集不一定存在只有 当 j  &gt;= v[i]的时候才存在</p><p>之后转化为一维</p><h3 id="0-1背包问题">0-1背包问题</h3><blockquote><p>已知一个背包容积为V，现在有N个物品，每个物品有一个价值Wi，一个体积Vi，每件物品最多用一次，求可以选择的总价值最大。</p></blockquote><h3 id="完全背包问题">完全背包问题</h3><p>每件物品有无限个</p><h3 id="多重背包问题">多重背包问题</h3><p>每个物品有有限个</p><h3 id="分组背包问题">分组背包问题</h3><p>每一组最多选择一个物品</p><p>[mid+1, r]:</p>]]></content>
    
    
    <summary type="html">蓝桥杯学习记录</summary>
    
    
    
    <category term="算法" scheme="https://klklkl10086.github.io/klklkl10086.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="蓝桥杯" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>Pandas</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2024/02/04/pandas/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2024/02/04/pandas/</id>
    <published>2024-02-04T14:31:41.000Z</published>
    <updated>2024-03-18T09:14:40.964Z</updated>
    
    
    
    
    <category term="Python" scheme="https://klklkl10086.github.io/klklkl10086.github.io/categories/Python/"/>
    
    
    <category term="Pandas" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>Python</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2024/01/14/Python/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2024/01/14/Python/</id>
    <published>2024-01-14T07:15:19.000Z</published>
    <updated>2024-03-18T09:14:52.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本知识">基本知识</h1><h2 id="字面量">字面量</h2><blockquote><p>在代码中，被写下来的固定的值</p></blockquote><p><strong>常见的字面量数据类型</strong></p><ul><li>数字        整数  浮点数  复数 布尔</li><li>字符串      双引号包围 “字符串”</li><li>列表</li><li>元组</li><li>集合</li><li>字典</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字面量（有空格）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)<span class="comment">#字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">12</span>) <span class="comment">#整数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1.0</span>) <span class="comment">#浮点数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;钱包还有:&quot;</span>, money, <span class="string">&quot;收了一块钱还剩:&quot;</span>, money+<span class="number">1</span>) <span class="comment"># 输出多个变量</span></span><br></pre></td></tr></table></figure><p>写在print语句中的是字面量</p><h2 id="注释">注释</h2><p><strong>单行注释</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我是单行注释（建议有空格）</span></span><br></pre></td></tr></table></figure><p><strong>多行注释</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;我是多行注释一般用于开头解释类和程序</span></span><br><span class="line"><span class="string">三个引号开头，三个引号结尾，可以换行</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="变量">变量</h2><blockquote><p>记录数据的盒子,值可以改变</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变量名 = 变量值</span></span><br><span class="line">money = <span class="number">52</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;钱包还有:&quot;</span>, money, <span class="string">&quot;\n收了一块钱还剩:&quot;</span>, money+<span class="number">1</span>)</span><br><span class="line">money = money-<span class="number">10</span> <span class="comment">#  + -  *  /</span></span><br></pre></td></tr></table></figure><h2 id="数据类型">数据类型</h2><blockquote><p>变量没有类型，<strong>变量中存储的数据</strong>有类型</p></blockquote><p><strong>type()语句</strong></p><blockquote><p>用于查看<strong>数据</strong>的类型的函数</p></blockquote><p><strong>使用print直接输出</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="string">&quot;str&quot;</span>))</span><br><span class="line">money = <span class="number">52</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(money))</span><br></pre></td></tr></table></figure><p><strong>用变量存储返回的结果</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str_type = (<span class="built_in">type</span>(<span class="string">&quot;123456&quot;</span>))</span><br><span class="line">money = <span class="number">52</span></span><br><span class="line">money_type = (<span class="built_in">type</span>(money))</span><br></pre></td></tr></table></figure><p><strong>数据类型的转换</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转为整数</span></span><br><span class="line"><span class="built_in">int</span>(x) </span><br><span class="line">num = <span class="built_in">int</span>(<span class="string">&quot;11&quot;</span>)<span class="comment"># 保字符串里都是数字</span></span><br><span class="line">int_float = <span class="built_in">int</span>(<span class="number">11.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转为浮点</span></span><br><span class="line"><span class="built_in">float</span>(x)</span><br><span class="line">float_int = <span class="built_in">float</span>(<span class="number">11</span>)</span><br><span class="line"><span class="comment"># 转为字符串</span></span><br><span class="line"><span class="built_in">str</span>(x)</span><br><span class="line">float_str = <span class="built_in">str</span>(<span class="number">111.34</span>)</span><br></pre></td></tr></table></figure><blockquote><p>任何语句都可转换成字符串</p></blockquote><h2 id="标识符">标识符</h2><blockquote><p><strong>名字</strong></p></blockquote><p><strong>命名规则</strong></p><ul><li>英文  大小写敏感</li><li>中文  不推荐使用</li><li>数字  不可以作为开头</li><li>下划线 _</li><li>不可以使用关键字</li></ul><h2 id="运算符">运算符</h2><p><strong>数学运算符</strong></p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">操作</th></tr></thead><tbody><tr><td style="text-align:center">+</td><td style="text-align:center">加法</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">减法</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">乘法</td></tr><tr><td style="text-align:center">/</td><td style="text-align:center">除法</td></tr><tr><td style="text-align:center">//</td><td style="text-align:center">取整除</td></tr><tr><td style="text-align:center">%</td><td style="text-align:center">取余数</td></tr><tr><td style="text-align:center">**</td><td style="text-align:center">指数</td></tr></tbody></table><p><strong>赋值运算符</strong></p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">操作</th></tr></thead><tbody><tr><td style="text-align:center">=</td><td style="text-align:center">赋值</td></tr></tbody></table><p><strong>复合赋值运算符</strong></p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">操作</th></tr></thead><tbody><tr><td style="text-align:center">+=</td><td style="text-align:center">c+=a  等价于 c=c+a</td></tr><tr><td style="text-align:center">-=</td><td style="text-align:center">c-=a  等价于 c=c-a</td></tr><tr><td style="text-align:center">*=</td><td style="text-align:center">c*=a  等价于 c=c*a</td></tr><tr><td style="text-align:center">/=</td><td style="text-align:center">c/=a  等价于 c=c/a</td></tr><tr><td style="text-align:center">%=</td><td style="text-align:center">c%=a  等价于 c=c%a</td></tr><tr><td style="text-align:center">**=</td><td style="text-align:center">c**=a  等价于 c=c **a</td></tr><tr><td style="text-align:center">//=</td><td style="text-align:center">c//=a  等价于 c=c//a</td></tr></tbody></table><h2 id="字符串">字符串</h2><p><strong>定义</strong></p><ul><li><p>单引号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="string">&#x27;hhhh&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>可以内含双引号</strong></p></li><li><p>双引号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name2 = <span class="string">&quot;hhhhhh2&quot;</span></span><br></pre></td></tr></table></figure><p><strong>可以内含单引号</strong></p></li><li><p>三引号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和多行注释一样</span></span><br><span class="line">name3 = <span class="string">&quot;&quot;&quot;hhhhh</span></span><br><span class="line"><span class="string">hhh3&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>可以用 \ 解除效用 变成普通字符串</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;&quot;123456&#x27;</span></span><br><span class="line">name = <span class="string">&quot;&#x27;12345&#x27;&quot;</span></span><br><span class="line">name = <span class="string">&quot;\&quot;123456&quot;</span></span><br></pre></td></tr></table></figure><p><strong>字符串拼接</strong></p><blockquote><p>使用+号</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>+<span class="string">&quot;456&quot;</span>)</span><br><span class="line">name = <span class="string">&quot;987&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;12345&quot;</span> + name + <span class="string">&quot;564&quot;</span>)</span><br><span class="line">tel = <span class="number">132456</span></span><br><span class="line"><span class="comment"># print(&quot;111111&quot; + tel +&quot;454&quot;) error</span></span><br></pre></td></tr></table></figure><p><strong>字符串没有办法和其他类型拼接</strong></p><p><strong>字符串格式化</strong></p><p><strong>方法一：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;kjkjk&quot;</span></span><br><span class="line">where = <span class="string">&quot;at kl&quot;</span></span><br><span class="line">message = <span class="string">&quot;abced %s %s&quot;</span> % (name, where)</span><br><span class="line"><span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出： abced kjkjk at kl</span></span><br></pre></td></tr></table></figure><p><strong>通过占位的形式完成拼接，%表示占位，s表示将变量变成字符串放入占位的地方</strong></p><table><thead><tr><th>格式符号</th><th>转化</th></tr></thead><tbody><tr><td>%s</td><td>转化为<strong>字符串</strong>放入占位位置</td></tr><tr><td>%d</td><td>转化为<strong>整数</strong>放入占位位置</td></tr><tr><td>%f</td><td>转化为<strong>浮点</strong>放入占位位置</td></tr></tbody></table><p><strong>方法二:</strong></p><p><strong>不限数据类型，不做精度控制，适合对精度没有要求时快速使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">f&quot;...<span class="subst">&#123;变量&#125;</span> &quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num1=<span class="number">11</span></span><br><span class="line">name = <span class="string">&quot;klklklk&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;my name is <span class="subst">&#123;name&#125;</span> ,and age is <span class="subst">&#123;num1&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">my name is klklklk ,and age is 11</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>格式化的精度控制</strong></p><blockquote><p>m.n 控制数度的宽度和精度，m控制宽度，<strong>但当宽度小于自身时不生效</strong>，n控制精度会进行<strong>四舍五入</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">num1=<span class="number">11</span></span><br><span class="line">num2=<span class="number">11.345</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数字11宽度5：%5d\n&quot;</span> % num1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数字11宽度1：%1d\n&quot;</span> % num1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数字11.345宽度7，精度2：%7.2f\n&quot;</span> % num2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数字11.345宽度不限，精度2: %.2f&quot;</span> % num2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数字11.345精度不限，宽度2: %2f&quot;</span> % num2)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">数字11宽度5：   11</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">数字11宽度1：11</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">数字11.345宽度7，精度2：  11.35</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">数字11.345宽度不限，精度2: 11.35</span></span><br><span class="line"><span class="string">数字11.345精度不限，宽度2: 11.345000</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>表达式格式化</strong></p><blockquote><p>表达式：一条具有明确执行结果的代码语句</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1 * 1 = %d&quot;</span> % (<span class="number">1</span>*<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;1 * 2 = <span class="subst">&#123;<span class="number">1</span>*<span class="number">2</span>&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;字符串在python的类型名是：%s&quot;</span> % <span class="built_in">type</span>(<span class="string">&quot;字符串&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出:</span></span><br><span class="line"><span class="string">1 * 1 = 1</span></span><br><span class="line"><span class="string">1 * 2 = 2</span></span><br><span class="line"><span class="string">字符串在python的类型名是：&lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="数据输入">数据输入</h2><p><strong>input语句</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;what is your name?&quot;</span>)</span><br><span class="line">name = <span class="built_in">input</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;you name is <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;what is your name?\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;you name is <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>input语句不管输入什么都统统当作字符串看待，可自行进行数据转换</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="built_in">input</span>(<span class="string">&quot;what is your age?\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;age is&quot;</span>, <span class="built_in">type</span>(age))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">what is your age?</span></span><br><span class="line"><span class="string"> 输入： 18</span></span><br><span class="line"><span class="string">age is &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="判断语句">判断语句</h1><h2 id="布尔类型和比较运算符">布尔类型和比较运算符</h2><p>布尔类型的字面量：</p><p>True ：表示真</p><p>False：表示假</p><p>比较运算符：</p><blockquote><p>== , &gt; , &lt; , &gt;= ,&lt;= ,!=</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool_1 = <span class="literal">True</span></span><br><span class="line">bool_2 = <span class="literal">False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;bool1 is<span class="subst">&#123;<span class="built_in">type</span>(bool_1)&#125;</span>,bool2 is <span class="subst">&#123;<span class="built_in">type</span>(bool_2)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">bool1 is&lt;class &#x27;bool&#x27;&gt;,bool2 is &lt;class &#x27;bool&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">num1 = <span class="number">10</span></span><br><span class="line">num2 = <span class="number">10</span></span><br><span class="line">num3 = <span class="number">15</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;num1 == num2 is <span class="subst">&#123;num1 == num2&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;num1 != num3 is <span class="subst">&#123;num1 != num3&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">num1 == num2 is True</span></span><br><span class="line"><span class="string">num1 != num3 is True</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>字符串也可以进行 == ，! = 比较</strong></p><h2 id="if语句">if语句</h2><p>if [条件] ：</p><p>​条件成立时执行的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">18</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;my age is <span class="subst">&#123;age&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i am a adult&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i will go to university&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;time fly quickly!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">my age is 18</span></span><br><span class="line"><span class="string">i am a adult</span></span><br><span class="line"><span class="string">i will go to university</span></span><br><span class="line"><span class="string">time fly quickly!</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>缩进！！！</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;my age is <span class="subst">&#123;age&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i am a adult&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i will go to university&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;time fly quickly!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">my age is 10</span></span><br><span class="line"><span class="string">time fly quickly!</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="if-else语句">if else语句</h2><blockquote><p>if 条件：</p><p>​条件成立时执行的内容</p><p>else：</p><p>​条件不满足时执行的内容</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;my age is <span class="subst">&#123;age&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i am a adult.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i will go to university.&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i am a child.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i am going to senior high school.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;time fly quickly!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">my age is 10</span></span><br><span class="line"><span class="string">i am a child.</span></span><br><span class="line"><span class="string">i am going to senior high school.</span></span><br><span class="line"><span class="string">time fly quickly!</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="if-elif-else语句">if elif else语句</h2><blockquote><p>if 条件：</p><p>​ 条件1成立时执行的内容</p><p>elif 条件2:</p><p>条件2成立时执行的内容</p><p>elif 条件n：<br>    条件 n成立时执行的内容</p><p>else：</p><p>​ 上述条件都不满足时执行的内容</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">height = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你的身高（cm）：&quot;</span>))</span><br><span class="line">vip_level = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;您的vip等级是：&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> height&lt;<span class="number">120</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;小于120cm 可以免费&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> vip_level&gt;<span class="number">3</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;vip&gt;3 可以免费&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;收费10元&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>多条件判断下，条件互斥，只要有一个条件满足，则其他条件不成立，语句不执行</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你的身高（cm）：&quot;</span>))&lt;<span class="number">120</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;小于120cm 可以免费&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;您的vip等级是：&quot;</span>))&gt;<span class="number">3</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;vip&gt;3 可以免费&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;收费10元&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="判断语句的嵌套">判断语句的嵌套</h2><blockquote><p>if  条件1:</p><p>​ 条件1成立时执行的内容</p><p>​ 条件1成立时执行的内容</p><p>​if 条件2:</p><p>​ 条件2成立时执行的内容</p><p>​ 条件2成立时执行的内容</p></blockquote><p>not表示取反</p><h1 id="循环语句">循环语句</h1><h2 id="while循环">while循环</h2><blockquote><p>while 条件:<br>条件满足要做的事情1</p><p>​条件满足要做的事情2</p><p>​条件满足要做的事情3</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i&lt;<span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;this is %d&quot;</span>% i)</span><br><span class="line">    i= i+<span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="built_in">sum</span>=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i&lt;=<span class="number">100</span>:</span><br><span class="line">    <span class="built_in">sum</span>+=i</span><br><span class="line">    i= i+<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sum=%d&quot;</span>%<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure><p>小脚本：</p><p>猜数字，猜错判断大于小于，猜对输出猜的次数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">num = random.randint(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">flag = <span class="literal">True</span></span><br><span class="line"><span class="keyword">while</span> flag:</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">    guess_num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;what is it?&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> guess_num == num:</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;you are right&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> guess_num &gt; num:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;you are bigger&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;you are smaller&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;the times is <span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>嵌套</strong></p><blockquote><p>while 条件1:<br>条件1满足要做的事情1</p><p>​条件1满足要做的事情2</p><p>​条件1满足要做的事情3</p><p>​…</p><p>​while 条件2:<br>​条件2满足要做的事情1</p><p>​条件2满足要做的事情2</p><p>​条件2满足要做的事情3</p><p>​…</p></blockquote><p>小脚本：</p><p>打印九九乘法表</p><p>前置知识：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#print输出如何不换行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lh = <span class="number">1</span></span><br><span class="line">rh = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> rh&lt;=<span class="number">9</span>:</span><br><span class="line">    lh=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> lh&lt;=rh:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%d * %d = %d &quot;</span>%(lh,rh,lh*rh), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        lh+=<span class="number">1</span></span><br><span class="line">    rh+=<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>()<span class="comment">#输出空内容 换行</span></span><br></pre></td></tr></table></figure><h2 id="for循环">for循环</h2><blockquote><p>for <strong>临时变量</strong> in 待处理的数据集:</p><p>​循环条件满足时候执行的代码</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;abcdefg&quot;</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> name:</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">b</span></span><br><span class="line"><span class="string">c</span></span><br><span class="line"><span class="string">d</span></span><br><span class="line"><span class="string">e</span></span><br><span class="line"><span class="string">f</span></span><br><span class="line"><span class="string">g</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>无法自定义无限循环，数据集不可能无限大</strong></p><p>小脚本：<br>统计字符串中有多少个字母a</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>(<span class="string">&quot;please input your str&quot;</span>)</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">if</span> x == <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure><p><strong>tips:</strong></p><blockquote><p>关于临时变量的作用范围，规范上，临时变量是不能在<strong>for循环外部</strong>进行访问，但是实际上，是可以访问到的</p></blockquote><p><strong>range语句</strong></p><p>获得一个数字序列，搭配for循环食用</p><blockquote><p>range(num)</p><p>获取一个从0 开始到num结束的数字序列（不包含num本身）</p></blockquote><blockquote><p>range(num1，num2)</p><p>获取一个从num1开始到num2结束的数字序列（不包含num2本身）</p></blockquote><blockquote><p>range(num1，num2，step)</p><p>获取一个从num1开始到num2结束的数字序列（不包含num2本身）,数字间的步长以step为标准，step默认为1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">8</span>):</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">5</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">7</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">8</span>,<span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>for循环嵌套</strong></p><blockquote><p>控制空格缩进</p><p>for <strong>临时变量1</strong> in 待处理的数据集:</p><p>​循环条件1满足时候执行的代码</p><p>​for <strong>临时变量2</strong> in 待处理的数据集:</p><p>​  循环条件2满足时候执行的代码</p></blockquote><p><strong>for循环和while循环可以互向嵌套</strong></p><p>小脚本：<br>使用for循环打印九九乘法表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> rh <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> lh <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,rh+<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;lh&#125;</span>*<span class="subst">&#123;rh&#125;</span>=<span class="subst">&#123;lh*rh&#125;</span>\t&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><h2 id="循环中断">循环中断</h2><p><strong>continue</strong></p><blockquote><p>中断所在本层循环，直接进入下一次循环</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">100</span>):</span><br><span class="line">语句<span class="number">1</span></span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">    语句<span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>跳过语句2，不执行</p><p><strong>break</strong></p><blockquote><p>直接结束所在本层循环</p></blockquote><h1 id="函数">函数</h1><p>封装特定功能，实现接口，避免重复性劳动，可以重复使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 内置函数 统计字符串长度</span></span><br><span class="line"><span class="built_in">len</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义函数 实现统计字符串长度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my</span> _<span class="built_in">len</span>(data):</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">        dount+=<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;字符串<span class="subst">&#123;data&#125;</span>的长度是:<span class="subst">&#123;count&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="定义">定义</h2><blockquote><p>def 函数名字(传入参数)<strong>:</strong></p><p>​函数体</p><p>​return 返回值</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say_hi</span>():<span class="comment"># 可以没有传入参数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hi i am klklkl&quot;</span>)</span><br><span class="line">    <span class="comment">#可以没有返回值</span></span><br></pre></td></tr></table></figure><p>先定义，再使用，在程序中调用函数才可以进行工作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say_hi</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hi i am klklkl&quot;</span>)</span><br><span class="line">    </span><br><span class="line">say_hi()</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">hi i am klklkl</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x,y</span>):</span><br><span class="line"><span class="keyword">return</span> x+y</span><br><span class="line">add(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">9</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>上述例子中，x和y是形式参数，4和5是实际参数</p><p>没有返回值，则返回值类型为NoneType，表示空，无意义，false</p><p><strong>None的应用</strong></p><ul><li><p>函数的返回值</p></li><li><p>if判断语句</p></li><li><p>声明无初始内容的变量</p></li></ul><p>函数可以嵌套调用，过程类似于栈</p><h2 id="多个返回值">多个返回值</h2><p>python的函数可以实现一次性返回多个值</p><blockquote><p>return 返回值1，返回值2</p><p>变量1，变量2 = 函数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x-<span class="number">1</span>,y+<span class="number">1</span></span><br><span class="line">res1,res2 = test1(<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(res1)</span><br><span class="line"><span class="built_in">print</span>(res2)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">-1</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="传入参数">传入参数</h2><h3 id="位置参数">位置参数</h3><p><img src="image-20240124000603415.png" alt="image-20240124000603415"></p><h3 id="关键字参数">关键字参数</h3><p><img src="image-20240124000631318.png" alt="image-20240124000631318"></p><h3 id="缺省参数">缺省参数</h3><p><img src="image-20240124000828120.png" alt="image-20240124000828120"></p><h3 id="不定长参数">不定长参数</h3><p><strong>位置传递的不定长</strong></p><p><img src="image-20240124001036657.png" alt="image-20240124001036657"></p><p><strong>关键字传递</strong></p><p><img src="image-20240124001119731.png" alt="image-20240124001119731"></p><h3 id="函数作为参数传递">函数作为参数传递</h3><p><img src="image-20240124001429469.png" alt="image-20240124001429469"></p><p>传递的是计算逻辑</p><h2 id="匿名函数">匿名函数</h2><p><img src="image-20240124001931614.png" alt="image-20240124001931614"></p><blockquote><p>lambda 传入参数: 函数体（只能有一行代码）</p></blockquote><p><img src="image-20240124002113484.png" alt="image-20240124002113484"></p><p><img src="image-20240124002424908.png" alt="image-20240124002424908"></p><h1 id="数据容器">数据容器</h1><blockquote><p>一种可以容纳多份数据的数据类型</p></blockquote><p>根据特点的不同可以划分为</p><ul><li>列表</li><li>元组</li><li>字符串</li><li>集合</li><li>字典</li></ul><h2 id="列表-list">列表（list）</h2><h3 id="定义">定义</h3><blockquote><p>变量名 = [元素1,元素2,…]</p></blockquote><p><strong>空列表：</strong></p><blockquote><p>变量名 = []</p><p>变量名 = list()</p></blockquote><p><strong>列表中的每个数据叫作元素</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">name_list = [<span class="string">&quot;name1&quot;</span>, <span class="string">&quot;name2&quot;</span>, <span class="string">&quot;name3&quot;</span>]</span><br><span class="line">com_list = [<span class="string">&quot;name1&quot;</span>, <span class="number">14</span>, <span class="number">2004</span>]</span><br><span class="line">none_list = []</span><br><span class="line"><span class="built_in">print</span>(name_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(name_list))</span><br><span class="line"><span class="built_in">print</span>(com_list)</span><br><span class="line"><span class="built_in">print</span>(none_list)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[&#x27;name1&#x27;, &#x27;name2&#x27;, &#x27;name3&#x27;]</span></span><br><span class="line"><span class="string">&lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line"><span class="string">[&#x27;name1&#x27;, 14, 2004]</span></span><br><span class="line"><span class="string">[]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>也可以嵌套列表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_list = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(my_list))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[[1, 2, 3], [4, 5, 6], [7, 8, 9]]</span></span><br><span class="line"><span class="string">&lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="元素索引">元素索引</h3><blockquote><p>利用下标索引进行取用</p><p>正向：从左到右，从前向后，从0开始，依次递增</p><p>负向：从右向左，从后向前，从-1开始，依次递减</p><p>不可以超出范围</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">0</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">zhangsan</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(my_list[-<span class="number">1</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">wangwu</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>嵌套列表</strong></p><blockquote><p>多层下标索引即可遍历,不可以超出范围</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">my_list = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">0</span>][<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(my_list[-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(my_list[-<span class="number">2</span>][-<span class="number">1</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">8</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="常用方法">常用方法</h3><blockquote><p>class中的内置函数</p></blockquote><h4 id="查询">查询</h4><blockquote><p>查询指定元素在列表中的下标(正向索引)，如果找不到就报错</p><p>列表.index(元素)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_list = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">index = my_list.index([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(index)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="修改">修改</h4><blockquote><p>修改指定下标位置的值</p><p>列表[下标] = 值</p><p>可以正向，也可以反向</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">0</span>])</span><br><span class="line">my_list[<span class="number">0</span>] = <span class="string">&quot;zhangsi&quot;</span></span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">0</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">zhangsan</span></span><br><span class="line"><span class="string">zhangsi</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="插入">插入</h4><blockquote><p>在指定下标索引位置插入指定元素</p><p>列表.insert(下标,元素)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>]</span><br><span class="line">my_list.insert(<span class="number">2</span>, <span class="string">&quot;zhaoliu&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[&#x27;zhangsan&#x27;, &#x27;lisi&#x27;, &#x27;zhaoliu&#x27;, &#x27;wangwu&#x27;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="追加">追加</h4><blockquote><p>在列表尾部添加元素</p></blockquote><p><strong>追加一个元素：</strong></p><blockquote><p>列表.append(元素)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>]</span><br><span class="line">my_list.append(<span class="number">1234</span>)</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[&#x27;zhangsan&#x27;, &#x27;lisi&#x27;, &#x27;wangwu&#x27;, 1234]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>]</span><br><span class="line">new_list = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">my_list.append(new_list)</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[&#x27;zhangsan&#x27;, &#x27;lisi&#x27;, &#x27;wangwu&#x27;, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>追加一批元素（新的列表）：</strong></p><blockquote><p>列表1.extend(列表2)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>]</span><br><span class="line">new_list = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">my_list.extend(new_list)</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[&#x27;zhangsan&#x27;, &#x27;lisi&#x27;, &#x27;wangwu&#x27;, [1, 2, 3], [4, 5, 6], [7, 8, 9]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="删除">删除</h4><blockquote><p>del列表[下标]</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>]</span><br><span class="line"><span class="keyword">del</span> my_list[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[&#x27;zhangsan&#x27;, &#x27;wangwu&#x27;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>列表.pop(下标)</p><p>会返回对应下标的元素内容</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(my_list.pop(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">wangwu</span></span><br><span class="line"><span class="string">[&#x27;zhangsan&#x27;, &#x27;lisi&#x27;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>删除某元素在列表中的第一个匹配项</strong></p><blockquote><p>列表.remove(元素)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>]</span><br><span class="line">my_list.remove(<span class="string">&quot;zhangsan&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[&#x27;lisi&#x27;, &#x27;wangwu&#x27;, &#x27;zhangsan&#x27;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>清空</strong></p><blockquote><p>列表.clear()</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>]</span><br><span class="line">my_list.clear()</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>统计元素个数</strong></p><blockquote><p>统计指定元素在列表中的个数</p><p>列表.count(元素)</p><p>返回值即为数量</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(my_list.count(<span class="string">&quot;zhangsan&quot;</span>))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>列表元素的数量</strong></p><blockquote><p>len(列表)</p><p>返回值即为数量</p><p>不是list内部的函数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(my_list))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="特点">特点</h3><ol><li><strong>列表有上限，但上限很大</strong></li><li><strong>可以容纳不同类型的元素</strong></li><li><strong>数据有序存储</strong></li><li><strong>允许重复数据存在</strong></li><li><strong>可以修改</strong></li></ol><h3 id="循环遍历">循环遍历</h3><p><strong>while循环遍历</strong></p><p><strong>下标索引</strong>的方式进行取用元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>]</span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> index&lt;<span class="built_in">len</span>(my_list):</span><br><span class="line">    x = my_list[index]</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">zhangsan</span></span><br><span class="line"><span class="string">lisi</span></span><br><span class="line"><span class="string">wangwu</span></span><br><span class="line"><span class="string">zhangsan</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>for循环遍历</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> my_list:</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">zhangsan</span></span><br><span class="line"><span class="string">lisi</span></span><br><span class="line"><span class="string">wangwu</span></span><br><span class="line"><span class="string">zhangsan</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="元组">元组</h2><blockquote><p>可以存储多个不同类型的元素，但是<strong>不可以修改</strong></p></blockquote><h3 id="定义">定义</h3><blockquote><p>变量 =   (元素,元素,元素, …)</p></blockquote><p>空元组：</p><blockquote><p>变量 =   ()</p><p>变量 =   tuple()</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">t1 = (<span class="number">1</span>,<span class="string">&quot;hello&quot;</span>,<span class="literal">True</span>)</span><br><span class="line">t2 = ()</span><br><span class="line">t3 = <span class="built_in">tuple</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t1=<span class="subst">&#123;t1&#125;</span>,type= <span class="subst">&#123;<span class="built_in">type</span>(t1)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t2=<span class="subst">&#123;t2&#125;</span>,type= <span class="subst">&#123;<span class="built_in">type</span>(t2)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t3=<span class="subst">&#123;t3&#125;</span>,type= <span class="subst">&#123;<span class="built_in">type</span>(t3)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">t1=(1, &#x27;hello&#x27;, True),type= &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="string">t2=(),type= &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="string">t3=&lt;class &#x27;tuple&#x27;&gt;,type= &lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t4= (<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t4=<span class="subst">&#123;t4&#125;</span>,type= <span class="subst">&#123;<span class="built_in">type</span>(t4)&#125;</span>&quot;</span>)</span><br><span class="line">t5= (<span class="string">&quot;hello,&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t5=<span class="subst">&#123;t5&#125;</span>,type= <span class="subst">&#123;<span class="built_in">type</span>(t5)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">t4=hello,type= &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="string">t5=(&#x27;hello&#x27;,),type= &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>当元组中<strong>只有一个元素</strong>的时候要求在其后<strong>写上一个逗号</strong>否则不是元组</p><h3 id="嵌套元组">嵌套元组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t6= ((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t5=<span class="subst">&#123;t6&#125;</span>,type= <span class="subst">&#123;<span class="built_in">type</span>(t6)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">t5=((1, 2, 3), (4, 5, 6), (7, 8)),type= &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="下标索引">下标索引</h3><p>和list一样，元组也可以通过下标索引进行取用元素，写法相同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t6= ((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(t6[<span class="number">1</span>][<span class="number">2</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="相关操作">相关操作</h3><h4 id="查找指定元素">查找指定元素</h4><p>查找并返回指定元素的下标</p><blockquote><p>元组. index(x)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t6= ((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(t6.index((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="统计元素个数">统计元素个数</h4><p>1.统计并返回元组中<strong>指定元素</strong>的个数</p><blockquote><p>元组.count()</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t6= ((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">7</span>,<span class="number">8</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(t6.count((<span class="number">7</span>,<span class="number">8</span>)))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>2.统计并返回<strong>元组中的元素</strong>个数</p><blockquote><p>len(元组)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t6= ((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">7</span>,<span class="number">8</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(t6))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="遍历">遍历</h4><p><strong>for循环</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t6= ((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">7</span>,<span class="number">8</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> t6:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">(1, 2, 3)</span></span><br><span class="line"><span class="string">(7, 8)</span></span><br><span class="line"><span class="string">(4, 5, 6)</span></span><br><span class="line"><span class="string">(7, 8)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>while循环</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">t6= ((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">7</span>,<span class="number">8</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> index&lt;<span class="built_in">len</span>(t6):</span><br><span class="line">    <span class="built_in">print</span>(t6[index])</span><br><span class="line">    index+=<span class="number">1</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">(1, 2, 3)</span></span><br><span class="line"><span class="string">(7, 8)</span></span><br><span class="line"><span class="string">(4, 5, 6)</span></span><br><span class="line"><span class="string">(7, 8)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>元组里的元素不可以修改，但是在元组里嵌套的list的元素是可以修改的</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t6= ((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">7</span>,<span class="number">8</span>),[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&quot;hello&quot;</span>],(<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(t6[-<span class="number">2</span>])</span><br><span class="line">t6[-<span class="number">2</span>][-<span class="number">1</span>]=<span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(t6[-<span class="number">2</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[1, 2, 3, 4, &#x27;hello&#x27;]</span></span><br><span class="line"><span class="string">[1, 2, 3, 4, &#x27;world&#x27;]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="特点">特点</h3><ol><li><strong>可以容纳不同类型的元素</strong></li><li><strong>数据有序存储</strong></li><li><strong>允许重复数据存在</strong></li><li><strong>不可以修改</strong></li></ol><h2 id="字符串">字符串</h2><blockquote><p>字符的容器，一个字符串可以存放任意数量的字符</p></blockquote><p><strong>下标索引在字符串中也可以使用，正向从0开始，负向从-1开始</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;abcdefg&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">g</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>字符串是不可修改的数据容器</strong>，<strong>只读</strong></p><h3 id="常用方法">常用方法</h3><h4 id="查找指定元素的下标">查找指定元素的下标</h4><blockquote><p>查找并返回指定元素的下标：字符串.index(x)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;abcdefg&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.index(<span class="string">&quot;bcd&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.index(<span class="string">&quot;g&quot;</span>))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="字符串替换">字符串替换</h4><blockquote><p>将字符串中指定的内容替换成指定内容，并返回替换后新的字符串</p><p><strong>字符串.replace(字符串1,字符串2)</strong>  将字符串1换成2形成新的字符串</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;abcdefg&quot;</span></span><br><span class="line">newstr = <span class="built_in">str</span>.replace(<span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;dcba&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(newstr)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">abcdefg</span></span><br><span class="line"><span class="string">dcbaefg</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="字符串分割">字符串分割</h4><blockquote><p><strong>字符串.split(分隔符字符串)</strong></p></blockquote><blockquote><p>按照指定的分隔符字符串，将字符串划分为多个字符串，并存到列表对象中</p></blockquote><p><strong>字符串本身不变而是得到一个列表对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;hello world i am klklkl&quot;</span></span><br><span class="line">newstr = <span class="built_in">str</span>.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;newstr = <span class="subst">&#123;newstr&#125;</span>,type = <span class="subst">&#123;<span class="built_in">type</span>(newstr)&#125;</span> &quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">hello world i am klklkl</span></span><br><span class="line"><span class="string">newstr = [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;i&#x27;, &#x27;am&#x27;, &#x27;klklkl&#x27;],type = &lt;class &#x27;list&#x27;&gt; </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="规整操作">规整操作</h4><p><strong>去除前后空格</strong></p><blockquote><p>字符串.strip()</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;   hello world i am klklkl  &quot;</span></span><br><span class="line">newstr = <span class="built_in">str</span>.strip()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;newstr = <span class="subst">&#123;newstr&#125;</span> &quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   hello world i am klklkl  </span></span><br><span class="line"><span class="string">newstr = hello world i am klklkl </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>去除前后指定字符串</strong></p><blockquote><p>字符串.strip(字符串)    将传入的字符串划分成小串，只要<strong>头尾</strong>含有就去除</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;12 hello world i am klklkl 21&quot;</span></span><br><span class="line">newstr = <span class="built_in">str</span>.strip(<span class="string">&quot;12&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;newstr = <span class="subst">&#123;newstr&#125;</span> &quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">12 hello world i am klklkl 21</span></span><br><span class="line"><span class="string">newstr =  hello world i am klklkl  </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="统计指定字符串出现的次数">统计指定字符串出现的次数</h4><blockquote><p>字符串.count(字符串)</p></blockquote><h4 id="统计字符串的长度">统计字符串的长度</h4><blockquote><p>len(字符串)</p></blockquote><h4 id="遍历">遍历</h4><p><strong>for循环</strong></p><p>同上</p><p><strong>while循环</strong></p><p>同上</p><h3 id="特点">特点</h3><ol><li><strong>只可以存储字符串</strong></li><li><strong>长度有上限，取决于内存大小</strong></li><li><strong>数据有序存储</strong></li><li><strong>允许重复数据存在</strong></li><li><strong>不可以修改</strong></li></ol><h2 id="序列">序列</h2><blockquote><p>内容<strong>连续，有序</strong>，可以<strong>使用下标索引</strong>的一类<strong>数据容器</strong></p></blockquote><blockquote><p>列表、元组、字符串均可以视为序列</p></blockquote><h3 id="切片">切片</h3><blockquote><p>从一个序列中取出一个子序列，形成一个新的序列，不修改原来的序列</p></blockquote><p><strong>语法：</strong></p><blockquote><p><strong>序列[起始下标: 结束下标:步长]</strong></p><p>起始下标：从何处开始，可以留空表示从头</p><p>结束下标：到那里结束，不包含结束下标位置，可以留空表示截去到尾部</p><p>步长：取元素的间隔，默认为1，可以省略不写</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">my_list1 = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">r1 = my_list1[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;r1 = <span class="subst">&#123;r1&#125;</span>&quot;</span>)</span><br><span class="line">my_tuple = (<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">r2 = my_tuple[:]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;r2 = <span class="subst">&#123;r2&#125;</span>&quot;</span>)</span><br><span class="line">my_str = <span class="string">&quot;0123456&quot;</span></span><br><span class="line">r3 = my_str[::<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;r3 = <span class="subst">&#123;r3&#125;</span>&quot;</span>)</span><br><span class="line">r4 = my_str[::-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;r4 = <span class="subst">&#123;r4&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">r1 = [1, 2, 3]</span></span><br><span class="line"><span class="string">r2 = (0, 1, 2, 3, 4, 5, 6)</span></span><br><span class="line"><span class="string">r3 = 0246</span></span><br><span class="line"><span class="string">r4 = 6543210</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="集合">集合</h2><blockquote><p>上述介绍的数据容器：列表、元组、字符串都支持重复元素，而集合<strong>不支持重复元素，顺序无法保证</strong>，自带<strong>去重</strong>功能</p></blockquote><h3 id="定义">定义</h3><blockquote><p>变量 = {元素1,元素2,元素3 ,…}</p></blockquote><p>空集合</p><blockquote><p>变量 = set()</p><p>{}是空字典</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_set = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;my_set=<span class="subst">&#123;my_set&#125;</span>&quot;</span>)</span><br><span class="line">none_set= <span class="built_in">set</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;none_set = <span class="subst">&#123;none_set&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">my_set=&#123;1, 2, 3, 4, 5, 6&#125;</span></span><br><span class="line"><span class="string">none_set = set()</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="常用操作">常用操作</h3><p><strong>不支持下标索引访问，可修改</strong></p><h4 id="添加">添加</h4><blockquote><p>集合.add(元素)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">my_set = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="string">&quot;klklkl&quot;</span>&#125;</span><br><span class="line">my_set.add(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(my_set)</span><br><span class="line">my_set.add(<span class="string">&quot;klklkl&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_set)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;1, 2, 3, 4, 5, 6, 10, &#x27;klklkl&#x27;&#125;</span></span><br><span class="line"><span class="string">&#123;1, 2, 3, 4, 5, 6, 10, &#x27;klklkl&#x27;&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="移除">移除</h4><p><strong>从集合中移除指定元素，同时集合被修改</strong></p><blockquote><p>集合.remove(元素)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my_set = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="string">&quot;klklkl&quot;</span>&#125;</span><br><span class="line">my_set.remove(<span class="string">&quot;klklkl&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_set)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;1, 2, 3, 4, 5, 6&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>从集合中<u>随机取出</u>一个元素，同时集合被修改，返回移除的元素，元素被移除</strong></p><blockquote><p>集合.pop()</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_set = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="string">&quot;klklkl&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(my_set.pop())</span><br><span class="line"><span class="built_in">print</span>(my_set)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">&#123;2, 3, 4, 5, 6, &#x27;klklkl&#x27;&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="清空">清空</h4><blockquote><p>集合.clear()</p></blockquote><h4 id="取差集">取差集</h4><blockquote><p>集合1.differrence(集合2)</p><p>取出集合1和集合2的差集（<strong>集合1有集合2没有的</strong>），返回一个新集合</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">1</span> ,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(set1.difference(set2))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;2, 4&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="去差集">去差集</h4><blockquote><p>集合1.difference_update(集合2)</p><p>消除集合1和集合2内相同的元素，集合1被修改集合2不变</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">1</span> ,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;</span><br><span class="line">set1.difference_update(set2)</span><br><span class="line"><span class="built_in">print</span>(set1)</span><br><span class="line"><span class="built_in">print</span>(set2)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;2, 4&#125;</span></span><br><span class="line"><span class="string">&#123;1, 3, 5, 7&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="集合合并">集合合并</h4><blockquote><p>集合1.union(集合2)</p><p>集合1和2合并成一个新的集合，集合1和2不变</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">1</span> ,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line">set3 = set1.union(set2)</span><br><span class="line"><span class="built_in">print</span>(set1)</span><br><span class="line"><span class="built_in">print</span>(set2)</span><br><span class="line"><span class="built_in">print</span>(set3)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line"><span class="string">&#123;1, 3, 5, 7, 8, 9&#125;</span></span><br><span class="line"><span class="string">&#123;1, 2, 3, 4, 5, 7, 8, 9&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="统计元素数量">统计元素数量</h4><blockquote><p>len(集合)</p></blockquote><h4 id="遍历">遍历</h4><p><strong>不支持下标索引，因此不可以用while循环</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set2 = &#123;<span class="number">1</span> ,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> set2:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;集合的元素有 :<span class="subst">&#123;element&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">集合的元素有 :1</span></span><br><span class="line"><span class="string">集合的元素有 :3</span></span><br><span class="line"><span class="string">集合的元素有 :5</span></span><br><span class="line"><span class="string">集合的元素有 :7</span></span><br><span class="line"><span class="string">集合的元素有 :8</span></span><br><span class="line"><span class="string">集合的元素有 :9</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="字典">字典</h2><p>含有两个数据，一个名为key，另一个为Value，字典可以通过key找到与其对应的value</p><p><strong>不允许元素重复，不可以使用下标索引，只可以通过key值取得对应的Value</strong></p><h3 id="定义">定义</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">变量 = &#123;key:value , key:value ,....&#125;</span><br><span class="line"><span class="comment">#空字典</span></span><br><span class="line">变量 = &#123;&#125;</span><br><span class="line">变量 = <span class="built_in">dict</span>()</span><br></pre></td></tr></table></figure><p><strong>获取value</strong></p><p>通过key值取得对应的Value</p><blockquote><p>字典.[key]</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dict_1 = &#123;<span class="string">&quot;liming&quot;</span>: <span class="number">56</span>, <span class="string">&quot;wanglikong&quot;</span>: <span class="number">99</span>, <span class="string">&quot;zhoujielin&quot;</span>: <span class="number">88</span>, <span class="string">&quot;lindaju&quot;</span>: <span class="number">77</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(dict_1[<span class="string">&quot;lindaju&quot;</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">77</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>字典的嵌套</strong></p><p><strong>key不能为字典，value可以是任意数据</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">stu_score_date = &#123;</span><br><span class="line">    <span class="string">&quot;wanglihong&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;yuwen&quot;</span>: <span class="number">77</span>,</span><br><span class="line">        <span class="string">&quot;shuxue&quot;</span>:<span class="number">66</span>,</span><br><span class="line">        <span class="string">&quot;yingyu&quot;</span>:<span class="number">99</span></span><br><span class="line">    &#125;,<span class="string">&quot;zhoujielun&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;yuwen&quot;</span>: <span class="number">87</span>,</span><br><span class="line">        <span class="string">&quot;shuxue&quot;</span>:<span class="number">65</span>,</span><br><span class="line">        <span class="string">&quot;yingyu&quot;</span>:<span class="number">89</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(stu_score_date)</span><br><span class="line"><span class="built_in">print</span>(stu_score_date[<span class="string">&quot;zhoujielun&quot;</span>][<span class="string">&quot;shuxue&quot;</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;&#x27;wanglihong&#x27;: &#123;&#x27;yuwen&#x27;: 77, &#x27;shuxue&#x27;: 66, &#x27;yingyu&#x27;: 99&#125;, &#x27;zhoujielun&#x27;: &#123;&#x27;yuwen&#x27;: 87, &#x27;shuxue&#x27;: 65, &#x27;yingyu&#x27;: 89&#125;&#125;</span></span><br><span class="line"><span class="string">65</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="常用操作">常用操作</h3><h4 id="增加元素">增加元素</h4><blockquote><p>字典[key] = value</p><p>字典被修改，增加了新元素</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dict_1 = &#123;<span class="string">&quot;liming&quot;</span>: <span class="number">56</span>, <span class="string">&quot;wanglikong&quot;</span>: <span class="number">99</span>, <span class="string">&quot;zhoujielin&quot;</span>: <span class="number">88</span>, <span class="string">&quot;lindaju&quot;</span>: <span class="number">77</span>&#125;</span><br><span class="line">dict_1[<span class="string">&quot;zhangsan&quot;</span>] = <span class="number">88</span></span><br><span class="line"><span class="built_in">print</span>(dict_1)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;&#x27;liming&#x27;: 56, &#x27;wanglikong&#x27;: 99, &#x27;zhoujielin&#x27;: 88, &#x27;lindaju&#x27;: 77, &#x27;zhangsan&#x27;: 88&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="更新元素">更新元素</h4><blockquote><p>字典[key] = value</p><p>字典被修改</p></blockquote><p><strong>如果key存在则为更新，不存在即为修改</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dict_1 = &#123;<span class="string">&quot;liming&quot;</span>: <span class="number">56</span>, <span class="string">&quot;wanglikong&quot;</span>: <span class="number">99</span>, <span class="string">&quot;zhoujielin&quot;</span>: <span class="number">88</span>, <span class="string">&quot;lindaju&quot;</span>: <span class="number">77</span>&#125;</span><br><span class="line">dict_1[<span class="string">&quot;liming&quot;</span>] = <span class="number">88</span></span><br><span class="line"><span class="built_in">print</span>(dict_1)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;&#x27;liming&#x27;: 88, &#x27;wanglikong&#x27;: 99, &#x27;zhoujielin&#x27;: 88, &#x27;lindaju&#x27;: 77&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="删除元素">删除元素</h4><blockquote><p>字典.pop(key)</p><p>删除字典中key的内容，并返回key对应的value</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dict_1 = &#123;<span class="string">&quot;liming&quot;</span>: <span class="number">56</span>, <span class="string">&quot;wanglikong&quot;</span>: <span class="number">99</span>, <span class="string">&quot;zhoujielin&quot;</span>: <span class="number">88</span>, <span class="string">&quot;lindaju&quot;</span>: <span class="number">77</span>&#125;</span><br><span class="line">dict_1.pop(<span class="string">&quot;wanglikong&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(dict_1)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;&#x27;liming&#x27;: 56, &#x27;zhoujielin&#x27;: 88, &#x27;lindaju&#x27;: 77&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="清空元素">清空元素</h4><blockquote><p>字典.clear()</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dict_1 = &#123;<span class="string">&quot;liming&quot;</span>: <span class="number">56</span>, <span class="string">&quot;wanglikong&quot;</span>: <span class="number">99</span>, <span class="string">&quot;zhoujielin&quot;</span>: <span class="number">88</span>, <span class="string">&quot;lindaju&quot;</span>: <span class="number">77</span>&#125;</span><br><span class="line">dict_1.clear()</span><br><span class="line"><span class="built_in">print</span>(dict_1)</span><br></pre></td></tr></table></figure><h4 id="获取全部key">获取全部key</h4><blockquote><p>字典.keys()</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dict_1 = &#123;<span class="string">&quot;liming&quot;</span>: <span class="number">56</span>, <span class="string">&quot;wanglikong&quot;</span>: <span class="number">99</span>, <span class="string">&quot;zhoujielin&quot;</span>: <span class="number">88</span>, <span class="string">&quot;lindaju&quot;</span>: <span class="number">77</span>&#125;</span><br><span class="line">keys=dict_1.keys()</span><br><span class="line"><span class="built_in">print</span>(keys)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">dict_keys([&#x27;liming&#x27;, &#x27;wanglikong&#x27;, &#x27;zhoujielin&#x27;, &#x27;lindaju&#x27;])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="遍历字典">遍历字典</h4><p><strong>方法1:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dict_1 = &#123;<span class="string">&quot;liming&quot;</span>: <span class="number">56</span>, <span class="string">&quot;wanglikong&quot;</span>: <span class="number">99</span>, <span class="string">&quot;zhoujielin&quot;</span>: <span class="number">88</span>, <span class="string">&quot;lindaju&quot;</span>: <span class="number">77</span>&#125;</span><br><span class="line">keys=dict_1.keys()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> keys:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span>对应的键值是<span class="subst">&#123;dict_1[i]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">liming对应的键值是56</span></span><br><span class="line"><span class="string">wanglikong对应的键值是99</span></span><br><span class="line"><span class="string">zhoujielin对应的键值是88</span></span><br><span class="line"><span class="string">lindaju对应的键值是77</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>方法2:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dict_1 = &#123;<span class="string">&quot;liming&quot;</span>: <span class="number">56</span>, <span class="string">&quot;wanglikong&quot;</span>: <span class="number">99</span>, <span class="string">&quot;zhoujielin&quot;</span>: <span class="number">88</span>, <span class="string">&quot;lindaju&quot;</span>: <span class="number">77</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dict_1:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span>对应的键值是<span class="subst">&#123;dict_1[i]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">liming对应的键值是56</span></span><br><span class="line"><span class="string">wanglikong对应的键值是99</span></span><br><span class="line"><span class="string">zhoujielin对应的键值是88</span></span><br><span class="line"><span class="string">lindaju对应的键值是77</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>不支持下标索引，不适用于while循环</strong></p><h4 id="统计元素数量">统计元素数量</h4><blockquote><p>len(字典)</p></blockquote><h3 id="特点">特点</h3><ol><li><strong>可以容纳多个数据，容纳不同类型的数据。</strong></li><li><strong>每一份数据是keyvalue键值对</strong></li><li><strong>可以通过key获取value</strong></li><li><strong>不允许重复key存在</strong></li><li><strong>不支持下标索引</strong></li><li><strong>可以修改</strong></li><li><strong>支持for循环不支持while循环</strong></li></ol><h2 id="总结">总结</h2><p><img src="image-20240123161337038.png" alt="image-20240123161337038"></p><p><img src="image-20240123161352170.png" alt="image-20240123161352170"></p><p><img src="image-20240123161442232.png" alt="image-20240123161442232"></p><h2 id="通用操作">通用操作</h2><p>下面对于字典的操作基本是对于key值的操作</p><h3 id="len">len</h3><blockquote><p>统计元素个数</p></blockquote><h3 id="max-和min">max 和min</h3><blockquote><p>获取最大元素，获取最小元素</p></blockquote><p>对于字典，获取的是最大或最小的key</p><h3 id="类型转换">类型转换</h3><ul><li><p>list(容器)</p><p>转列表</p></li><li><p>str(容器)</p><p>转字符串</p></li><li><p>tuple(容器)</p><p>转元组</p></li><li><p>set(容器)</p><p>转集合</p></li></ul><h3 id="sorted">sorted</h3><p>排序，并返回列表对象的结果，字典会丢失value</p><blockquote><p>sorted(容器)    正向排序，从小到大</p><p>sorted(容器，reverse = True)    反向排序</p></blockquote><p><img src="image-20240123162933181.png" alt="image-20240123162933181"></p><h1 id="文件">文件</h1><blockquote><p>文件编码：编码的技术，记录了如何将内容翻译成二进制以及如何解密二进制，不同的编码对同一文本的翻译不同</p></blockquote><p>常见文件编码：</p><ul><li>UTF-8  全球通用 默认编码</li><li>GBK</li><li>Big5</li></ul><h2 id="读取文件">读取文件</h2><ol><li>打开文件</li><li>读写文件</li><li>关闭文件</li></ol><h2 id="打开文件">打开文件</h2><blockquote><p>open(name,mode,encoding)</p><p>name：文件的名字可以包含路径，字符串表示</p><p>mode：设置打开文件的模式，只读，写入，追加等</p><p>encoding：编码格式（推荐使用UFT-8）</p></blockquote><p><img src="image-20240124003300313.png" alt="image-20240124003300313"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;D:/桌面/test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding = <span class="string">&quot;UTF-8&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>encoding不是第三个参数，因此要使用关键字参数</strong></p><h2 id="读取文件">读取文件</h2><blockquote><p>文件对象.read(num)</p><p>num:表示要读取的数据的长度，单位是字节，如果没有传入num，那么就表示读取文件中所有数据</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;D:/桌面/test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding = <span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(f.read(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(f.read())<span class="comment">#全部内容</span></span><br></pre></td></tr></table></figure><p><strong>连续读取会从上一次读取的末尾开始读取</strong></p><blockquote><p>文件对象.readlines()</p><p>按照行的方法把文件中的内容进行一次性读取，并返回一个列表，其中每一行的数据为一个元素</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;D:/桌面/test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding = <span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">list1 = f.readlines()</span><br></pre></td></tr></table></figure><p><strong>可以使用for循环读取行</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;D:/桌面/test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding = <span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;每一行为<span class="subst">&#123;line&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>连续读取会从上一次读取的末尾开始读取</strong></p><blockquote><p>文件对象.readline()</p><p>一次读取一行内容</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;D:/桌面/test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding = <span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">list1 = f.readline()</span><br></pre></td></tr></table></figure><h2 id="写入文件">写入文件</h2><blockquote><p>文件对象.write()</p><p>把内容写入缓冲区</p></blockquote><blockquote><p>文件对象.flush()</p><p>内容刷新，写入硬盘中的文件</p></blockquote><p><strong>close方法内置了flush功能</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;D:/桌面/test.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,encoding = <span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">f.write(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">f.flush()</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><h2 id="关闭文件">关闭文件</h2><blockquote><p>文件对象.close()</p></blockquote><p>解除文件占用</p><blockquote><p>with open(name,mode,encoding) as 文件对象:</p><p>​            操作</p></blockquote><p>完成操作后自动关闭文件，避免遗忘close方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;D:/桌面/test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding = <span class="string">&quot;UTF-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    res = f.read()</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h1 id="类">类</h1><h2 id="定义">定义</h2><blockquote><p>class 类名:</p><p>​satement1</p><p>​satement2</p><p>​    …</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    school = <span class="string">&quot;null&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, tmp_name, tmp_school, tmp_gener, tmp_id</span>):</span><br><span class="line">        self.school = tmp_school</span><br><span class="line">        self.<span class="built_in">id</span> = tmp_id</span><br><span class="line">        self.name = tmp_name</span><br><span class="line">        self.gener = tmp_gener</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">return_school</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.school</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">&quot;xiaoming&quot;</span>, <span class="string">&quot;guangmingzhongxue&quot;</span>, <span class="string">&quot;girl&quot;</span>, <span class="string">&quot;1992&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s.return_school())</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">guangmingzhongxue</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="初始化函数">初始化函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, tmp_name, tmp_school, tmp_gener, tmp_id</span>):</span><br><span class="line">       self.school = tmp_school</span><br><span class="line">       self.<span class="built_in">id</span> = tmp_id</span><br><span class="line">       self.name = tmp_name</span><br><span class="line">       self.gener = tmp_gener</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">python基础语法记录</summary>
    
    
    
    <category term="Python" scheme="https://klklkl10086.github.io/klklkl10086.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>微积分A3</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2023/11/20/%E5%BE%AE%E7%A7%AF%E5%88%86A3/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2023/11/20/%E5%BE%AE%E7%A7%AF%E5%88%86A3/</id>
    <published>2023-11-20T12:01:38.000Z</published>
    <updated>2024-03-18T09:15:19.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="无穷级数">无穷级数</h1><p><img src="638408206233530013_snap.png" alt="638408206233530013_snap"></p><p><img src="638408206234802681_snap.png" alt="638408206234802681_snap"></p><p><img src="638408206235719021_snap.png" alt="638408206235719021_snap"></p><p><img src="638408206236580000_snap.png" alt="638408206236580000_snap"></p><p><img src="638408206237869452_snap.png" alt="638408206237869452_snap"></p><p><img src="638408206238913676_snap.png" alt="638408206238913676_snap"></p><p><img src="638408206239800296_snap.png" alt="638408206239800296_snap"></p><p><img src="638408206241720242_snap.png" alt="638408206241720242_snap"></p><p><img src="638408206242522972_snap.png" alt="638408206242522972_snap"></p><p><img src="638408206243413316_snap.png" alt="638408206243413316_snap"></p><p><img src="638408206245168132_snap.png" alt="638408206245168132_snap"></p><p><img src="638408206246069990_snap.png" alt="638408206246069990_snap"></p><p><img src="638408206246872655_snap.png" alt="638408206246872655_snap"></p><p><img src="638408206248020433_snap.png" alt="638408206248020433_snap"></p><p><img src="638408206249321765_snap.png" alt="638408206249321765_snap"></p><h1 id="常微分方程">常微分方程</h1><p>课程：<a href="https://www.bilibili.com/video/BV1a24y1a7Sg">3小时讲不完《常微分方程》</a></p><p><img src="0001.jpg" alt=""></p><p><img src="0002.jpg" alt="0002"></p><p><img src="0003.jpg" alt="0003"></p><p><img src="0004.jpg" alt="0004"></p><p><img src="0005.jpg" alt="0005"></p><p><img src="0006.jpg" alt="0006"></p><p><img src="0007.jpg" alt="0007"></p><p><img src="0008.jpg" alt="0008"></p><p><img src="0009.jpg" alt="0009"></p><p><img src="0010.jpg" alt="0010"></p><p><img src="0011.jpg" alt="0011"></p><p><img src="Inkodo-20231219_141437.png" alt="Inkodo-20231219_141437"></p><p><img src="638385913390558932_snap.png" alt="638385913390558932_snap"></p><p><img src="638385913394669519_snap.png" alt="638385913394669519_snap"></p><p><img src="638385913398852815_snap.png" alt="638385913398852815_snap"></p><p><img src="638385913403913144_snap.png" alt="638385913403913144_snap"></p><p><img src="638385913408000479_snap.png" alt="638385913408000479_snap"></p><p><img src="638385522251274427_snap.png" alt="638385522251274427_snap"></p><p><img src="638385536354837256_snap.png" alt="638385536354837256_snap"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;无穷级数&quot;&gt;无穷级数&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;638408206233530013_snap.png&quot; alt=&quot;638408206233530013_snap&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;638408206234802681_snap.pn</summary>
      
    
    
    
    <category term="class record" scheme="https://klklkl10086.github.io/klklkl10086.github.io/categories/class-record/"/>
    
    
    <category term="微积分" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>learning library windows.h</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2023/11/14/learning-library-windows-h/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2023/11/14/learning-library-windows-h/</id>
    <published>2023-11-14T11:56:18.000Z</published>
    <updated>2024-03-18T09:13:41.126Z</updated>
    
    
    
    
    <category term="windows" scheme="https://klklkl10086.github.io/klklkl10086.github.io/categories/windows/"/>
    
    
    <category term="windows" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>Learning from Effective C++</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2023/10/29/Learning-from-Effictive-C/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2023/10/29/Learning-from-Effictive-C/</id>
    <published>2023-10-29T13:49:13.000Z</published>
    <updated>2024-03-20T11:50:41.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="effective-c-读书笔记">《Effective C++》读书笔记</h1><h2 id="00-导读">00.导读</h2><h3 id="1-理解下列术语">1.理解下列术语</h3><h4 id="declaration-声明式">declaration（声明式）</h4><p>告诉编译器某个东西的名称和type，但<strong>略去细节</strong>。</p><h4 id="definition-定义式">definition（定义式）</h4><p>提供编译器一些声明式所遗漏的细节。</p><ul><li><p>对 对象而言，定义式是编译器为此对象<strong>拨内存</strong>的地点。</p></li><li><p>对于function或function template而言定义式提供了<strong>代码本体</strong>。</p></li><li><p>对class和class template而言，定义式<strong>列出他们的成员</strong></p></li></ul><h4 id="initialization-u-初始化-u">Initialization（<u>初始化</u>）</h4><p>给对象赋<strong>初值</strong>的过程</p><p>对于<strong>用户自定义类型</strong>的对象而言，初始化由构造函数执行</p><p><strong>default构造函数</strong>（缺省构造函数）：可被调用但不带任何实参者，要不没有参数要不每个参数都有缺省值。</p><p><strong>copy构造函数</strong>（拷贝构造函数）：用来“<em><em>以同型对象</em><u>初始化</u><em>自我对象</em></em>”</p><p><strong>copy assignment</strong>（拷贝复制）操作符：用来“<strong>从另一个同型对象中<u><em>拷贝</em></u>其值到自我对象</strong>”</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>();                                     <span class="comment">//default构造函数</span></span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp; rhs);                    <span class="comment">//copy构造函数</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs);         <span class="comment">//copy assignment操作符</span></span><br><span class="line">&#125;;</span><br><span class="line">Widget w1;                                   <span class="comment">//调用default构造函数</span></span><br><span class="line"><span class="function">Widget <span class="title">w2</span><span class="params">(w1)</span></span>;                               <span class="comment">//调用copy构造函数</span></span><br><span class="line">w1=w2;                                       <span class="comment">//调用copy assignment操作符</span></span><br><span class="line"><span class="comment">/////////////当看到 = 时要小心，有可能是copy assignment操作符，也有可能是copy构造函数</span></span><br><span class="line">Widget w3 = w2;                              <span class="comment">//copy构造函数</span></span><br></pre></td></tr></table></figure><p><strong>copy构造函数与passed by value</strong></p><p>copy构造函数定义了一个对象如何 passed by value（以值传递）</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasAcceptableQuality</span><span class="params">(Widget w)</span></span>;</span><br><span class="line">.</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">Widget aWidget;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">hasAcceptableQuality</span>(aWidget)) .....<span class="comment">//值传递，调用了copy构造函数将awidget的值复制到Widget内</span></span><br></pre></td></tr></table></figure><h2 id="01-让自己习惯c">01.让自己习惯C++</h2><h3 id="条款01-视c-为一个语言联邦">条款01: 视C++为一个语言联邦</h3><p>即我们可以将c++看成一个由<strong>四种次语言组成的语言联邦</strong>，四种次语言分别是</p><ul><li>C</li><li>Object-Oriented C++</li><li>Template C++</li><li>STL</li></ul><p>每个次语言都有自己的规约，C++高效编程守则视状况而变化，取决于你用C++的哪一个部分</p><p>例如：<br><img src="image-20231029225351042.png" alt="image-20231029225351042"></p><h2 id="条款02：尽量以const-enum-inline替换-define">条款02：尽量以const，enum，inline替换 #define</h2>]]></content>
    
    
    <summary type="html">读书记录</summary>
    
    
    
    <category term="c++" scheme="https://klklkl10086.github.io/klklkl10086.github.io/categories/c/"/>
    
    
    <category term="专业书籍" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/%E4%B8%93%E4%B8%9A%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2023/10/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2023/10/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2023-10-29T10:47:25.000Z</published>
    <updated>2024-04-10T11:51:21.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性表">线性表</h1><p>同种数据类型的集合，静态列表例如：数组（array），动态列表例如：链表（linked list）</p><h3 id="链表">链表</h3><p>与数组</p><p><strong>区别</strong>：数组更强调于整块大小固定的、连续的内存空间，并且不可以随意的插入数据，<strong>而链表则可以分段并且可以随意改变大小，随意插入数据，更好地利用了内存空间。</strong></p><p>对于链表来讲，我们只需要知道第一个节点的地址，便可以<strong>环环相扣</strong>得到链表上所有的数据。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">数组</th><th style="text-align:center">链表</th></tr></thead><tbody><tr><td style="text-align:center">内存空间</td><td style="text-align:center">连续且大小固定</td><td style="text-align:center">不连续且大小不固定</td></tr><tr><td style="text-align:center">访问方式（时间复杂度）</td><td style="text-align:center">直接（低）</td><td style="text-align:center">遍历链表（高）</td></tr><tr><td style="text-align:center">内存空间利用</td><td style="text-align:center">不充分</td><td style="text-align:center">充分</td></tr><tr><td style="text-align:center">总结</td><td style="text-align:center">更容易实现</td><td style="text-align:center">易出错</td></tr></tbody></table><h4 id="单链表">单链表</h4><p>定义节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">link</span>;</span><span class="comment">//c++中直接写Node *</span></span><br><span class="line">&#125;;<span class="comment">// 定义节点</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="创建">创建</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Node * A;<span class="comment">//头指针 永远</span></span><br><span class="line">A = <span class="literal">NULL</span>;</span><br><span class="line">Node* temp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));    <span class="comment">//创建节点  对于c++首选new</span></span><br><span class="line">(*temp).data = <span class="number">2</span>;    <span class="comment">//temp-&gt;data=2;</span></span><br><span class="line">(*temp).link = <span class="literal">NULL</span>;    <span class="comment">//temp-&gt;link=NULL;</span></span><br><span class="line">A = temp;</span><br><span class="line">temp = new Node();</span><br><span class="line">temp-&gt;data=<span class="number">4</span>;</span><br><span class="line">temp-&gt;link=<span class="literal">NULL</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="遍历">遍历</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//用循环遍历链表</span></span><br><span class="line">    Node* temp1=A;</span><br><span class="line">    <span class="keyword">while</span>(temp1-&gt;link!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    temp1=temp1-&gt;link;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//末尾添加节点</span></span><br><span class="line">  temp = new Node();</span><br><span class="line">  temp-&gt;data=<span class="number">4</span>;</span><br><span class="line">  temp-&gt;link=<span class="literal">NULL</span>;</span><br><span class="line">  temp1-&gt;link = temp;</span><br></pre></td></tr></table></figure><h5 id="增加节点">增加节点</h5><p>头部</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span>;</span></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">Insert</span><span class="params">(<span class="keyword">struct</span> Node* head,<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* temp = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    temp-&gt;data = x;</span><br><span class="line">    temp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(head!=<span class="literal">NULL</span>) temp-&gt;next = head;</span><br><span class="line">    head = temp;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    head=Insert(head,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任意节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//head=NULL or head!=NULL</span></span><br><span class="line"><span class="comment">//假定链表目前为 2——&gt;4——&gt;6</span></span><br><span class="line"><span class="comment">//要将其变成    2——&gt;4——&gt;8——&gt;6</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">()</span>&#123;...&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(<span class="type">int</span> data,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* temp1 = new Node();</span><br><span class="line">    temp1-&gt;data = data;</span><br><span class="line">    temp1-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)<span class="comment">//如果插入头部</span></span><br><span class="line">&#123;</span><br><span class="line">    temp1-&gt;next = head;</span><br><span class="line">    head = temp1;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">    Node* temp2 = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-2</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    temp2 = temp2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">    temp1-&gt;next=temp2-&gt;next;</span><br><span class="line">    temp2-&gt;next = temp1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    Insert(<span class="number">2</span>,<span class="number">1</span>);<span class="comment">// 2</span></span><br><span class="line">    Insert(<span class="number">3</span>,<span class="number">2</span>);<span class="comment">// 2 3</span></span><br><span class="line">    Insert(<span class="number">4</span>,<span class="number">1</span>);<span class="comment">// 4 2 3</span></span><br><span class="line">    Insert(<span class="number">5</span>,<span class="number">2</span>);<span class="comment">// 4 5 2 3</span></span><br><span class="line">    Print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除节点">删除节点</h5><p>任意节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(<span class="type">int</span> data)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Delete</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp1</span> =</span> head;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        head = temp1-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//（前面有节点后面也有 OR 前面有节点后面没有）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp1 = temp1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp2</span> =</span> temp1-&gt;next;</span><br><span class="line">        temp1-&gt;next = temp2-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp2);<span class="comment">//delete temp2;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    Insert(<span class="number">2</span>);</span><br><span class="line">    Insert(<span class="number">4</span>);</span><br><span class="line">    Insert(<span class="number">6</span>);</span><br><span class="line">    Insert(<span class="number">5</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a position \n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    Delete(n);</span><br><span class="line">    Print();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="反转链表">反转链表</h5><p>方法一：</p><p><strong>遍历，一个节点一个节点的反转</strong></p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(<span class="keyword">struct</span> Node* head)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span> =</span> head;</span><br><span class="line"><span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, temp-&gt;data);</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, temp-&gt;data);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">Insert</span><span class="params">(<span class="keyword">struct</span> Node* head, <span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">temp-&gt;data = x;</span><br><span class="line">temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (head != <span class="literal">NULL</span>) temp-&gt;next = head;</span><br><span class="line">head = temp;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">Reverse</span><span class="params">(<span class="keyword">struct</span> Node* head)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">current</span>,*<span class="title">prev</span>,*<span class="title">next</span>;</span></span><br><span class="line">current = head;</span><br><span class="line">prev = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (current != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">next = current-&gt;next;</span><br><span class="line">current-&gt;next = prev;</span><br><span class="line">prev = current;</span><br><span class="line">current = next;</span><br><span class="line">&#125;</span><br><span class="line">head = prev;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">head=Insert(head, <span class="number">2</span>);</span><br><span class="line">head=Insert(head, <span class="number">4</span>);</span><br><span class="line">head=Insert(head, <span class="number">6</span>);</span><br><span class="line">head=Insert(head, <span class="number">8</span>);</span><br><span class="line">Print(head);</span><br><span class="line">head = Reverse(head);</span><br><span class="line">Print(head);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：</p><p><strong>递归</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Reverse</span><span class="params">(<span class="keyword">struct</span> Node* p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    head = p;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Reverse(p-&gt;next);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">q</span>=</span>p-&gt;next;</span><br><span class="line">q-&gt;next = p;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>利用嵌套关系来代替前指针的作用</u></p><h4 id="双向链表">双向链表</h4><p>特点</p><p>节点有两个指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span> <span class="comment">//指向</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">prev</span>;</span><span class="comment">//指向前节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>优点：可以反向查询</p><p>缺点：增加了额外内存，对于一样的操作相对于单项链表需要更多的步骤</p><p>实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">GetNewNode</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">temp-&gt;data = x;</span><br><span class="line">temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">temp-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertAtHead</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//在链首添加</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newnode</span> =</span> GetNewNode(x);</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">head = newnode;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">head-&gt;prev = newnode;</span><br><span class="line">newnode-&gt;next = head;</span><br><span class="line">newnode-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">head = newnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertAtTail</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//在末尾添加</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newnode</span> =</span> GetNewNode(x);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span> =</span> head;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">head = newnode;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">temp-&gt;next = newnode;</span><br><span class="line">newnode-&gt;prev = temp;</span><br><span class="line">newnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//打印链表</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span> =</span> head;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, temp-&gt;data);</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, temp-&gt;data);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ReversePrint</span><span class="params">()</span> <span class="comment">//逆转链表</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span> =</span> head;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Reverse:%d\n&quot;</span>, temp-&gt;data);</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//当链表只有一个或没有节点时</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Reverse: &quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (temp-&gt;prev != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, temp-&gt;data);</span><br><span class="line">temp = temp-&gt;prev;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,temp-&gt;data);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">head = <span class="literal">NULL</span>; </span><br><span class="line">InsertAtTail(<span class="number">2</span>); Print(); ReversePrint();</span><br><span class="line">InsertAtTail(<span class="number">4</span>); Print(); ReversePrint();</span><br><span class="line">InsertAtHead(<span class="number">6</span>); Print(); ReversePrint();</span><br><span class="line">InsertAtTail(<span class="number">8</span>); Print(); ReversePrint();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环链表">循环链表</h4><h3 id="栈-stack">栈（stack）</h3><p><strong>特点 ：封闭性好，使用方便</strong></p><h4 id="顺序存储">顺序存储</h4><p>以存储数字为例，利用数组实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sstack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> top;</span><br><span class="line"><span class="type">char</span>* array;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">sstack</span>(<span class="type">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">top = <span class="number">-1</span>;</span><br><span class="line">size = k;</span><br><span class="line">array = <span class="keyword">new</span> <span class="type">char</span>[k]();</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">sstack</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[]array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">(<span class="type">char</span>&amp; item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">item = array[top];</span><br><span class="line">top--;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">push</span><span class="params">(<span class="type">const</span> <span class="type">char</span> item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (top == size - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">top++;</span><br><span class="line">array[top] = item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">(<span class="type">char</span>&amp; item)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">item = array[top];</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isempty</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isfull</span><span class="params">(<span class="type">void</span>)</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (top == size - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="链式存储">链式存储</h4><p>使用单链表实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SLNode</span><span class="comment">// 节点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T date;</span><br><span class="line">SLNode&lt;T&gt;* next;</span><br><span class="line"><span class="built_in">SLNode</span>() &#123; next = <span class="literal">NULL</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sstack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SLNode</span> &lt;T&gt;* top; <span class="comment">// 栈顶指针指向表头</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">sstack</span>() &#123; top = <span class="literal">NULL</span>; &#125; <span class="comment">// 构造函数</span></span><br><span class="line"></span><br><span class="line">~<span class="built_in">sstack</span>() &#123; <span class="built_in">clear</span>(); &#125; <span class="comment">// 析构函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SLNode</span>&lt;T&gt;* tmp = <span class="keyword">new</span> <span class="built_in">SLNode</span>&lt;T&gt;();</span><br><span class="line">tmp-&gt;date = item;</span><br><span class="line">tmp-&gt;next = top;</span><br><span class="line">top = tmp;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">(T&amp; item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (top == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">item = top-&gt;date;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SLNode</span>&lt;T&gt;* tmp = top;</span><br><span class="line">top = top-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">(T&amp; item)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (top == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">item = top-&gt;date;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isempty</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (top == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SLNode</span>&lt;T&gt;* p;</span><br><span class="line"><span class="keyword">while</span> (top != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">p = top-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> top;</span><br><span class="line">top = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="比较">比较</h4><ol><li>在空间复杂性上，顺序栈必须初始就申请固定的空间，当栈不满时，必然造成空间的浪费；链式栈所需空间是根据需要随时申请的，其代价是为每个元素提供空间以存储其next指针域。</li><li>在时间复杂性上，对于针对栈顶的基本操作（压入、弹出和栈顶元素存取），顺序栈和链式栈的时间复杂性均为O(1) .</li></ol><h4 id="双栈">*双栈</h4><p><img src="image-20231023173710839.png" alt="image-20231023173710839"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sstack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* left;</span><br><span class="line">T* right;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line"><span class="type">int</span> lefttop;</span><br><span class="line"><span class="type">int</span> righttop;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">sstack</span>(<span class="type">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">size = k;</span><br><span class="line">left = <span class="keyword">new</span> T[k]();</span><br><span class="line">right = left;</span><br><span class="line">lefttop = <span class="number">-1</span>;</span><br><span class="line">righttop = size;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">sstack</span>() &#123; <span class="keyword">delete</span>[]left; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; item, <span class="type">int</span> num)</span><span class="comment">//num选择的栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (righttop == lefttop + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;full&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//栈已经满</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">lefttop++;</span><br><span class="line">left[lefttop] = item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">righttop--;</span><br><span class="line">right[righttop] = item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">(T&amp; item, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (righttop == size &amp;&amp; lefttop == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;双栈为空无法出栈&quot;</span> &lt;&lt; endl;</span><br><span class="line">item = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (lefttop == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;左栈为空无法出栈&quot;</span> &lt;&lt; endl;</span><br><span class="line">item = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">item = left[lefttop];</span><br><span class="line">lefttop--;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (righttop == size)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;右栈为空无法出栈&quot;</span> &lt;&lt; endl;</span><br><span class="line">item = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">item = right[righttop];</span><br><span class="line">righttop++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">(T&amp; item, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (lefttop == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">item = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">item = left[lefttop];</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (righttop == size) &#123; item = <span class="number">-1</span>; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">item = right[righttop];</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">0</span>) lefttop = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">righttop = size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isempty</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">0</span> &amp;&amp; lefttop == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">1</span> &amp;&amp; righttop == size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isfull</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lefttop + <span class="number">1</span> == righttop)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">int</span> x, chose;</span><br><span class="line"><span class="function">sstack&lt;<span class="type">int</span>&gt; <span class="title">stac</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;选项：push pop peek clear isempty isfull&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; num;</span><br><span class="line"><span class="keyword">switch</span> (num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">case</span>(<span class="number">1</span>): cout &lt;&lt; <span class="string">&quot;push item  chose:&quot;</span> &lt;&lt; endl; cin &gt;&gt; x; cin &gt;&gt; chose; stac.<span class="built_in">push</span>(x, chose); <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">case</span>(<span class="number">2</span>):cout &lt;&lt; <span class="string">&quot;pop chose:&quot;</span> &lt;&lt; endl;  cin &gt;&gt; chose; stac.<span class="built_in">pop</span>(x, chose); cout &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; endl; <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">case</span>(<span class="number">3</span>):cout &lt;&lt; <span class="string">&quot;peek chose:&quot;</span> &lt;&lt; endl; cin &gt;&gt; chose; stac.<span class="built_in">peek</span>(x, chose); cout &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; endl; <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">case</span>(<span class="number">4</span>):cout &lt;&lt; <span class="string">&quot;clear chose:&quot;</span> &lt;&lt; endl; cin &gt;&gt; chose; stac.<span class="built_in">clear</span>(chose); <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">case</span>(<span class="number">5</span>):cout &lt;&lt; <span class="string">&quot;empty chose:&quot;</span> &lt;&lt; endl; cin &gt;&gt; chose; cout &lt;&lt; stac.<span class="built_in">isempty</span>(chose) &lt;&lt; endl; <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">case</span>(<span class="number">6</span>):cout &lt;&lt; <span class="string">&quot;full:&quot;</span> &lt;&lt; endl; cout &lt;&lt; stac.<span class="built_in">isfull</span>() &lt;&lt; endl; <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">case</span>(<span class="number">7</span>):<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="应用">应用</h4><p><strong>括号匹配</strong></p><p><strong>题目一：</strong></p><p><a href="https://leetcode.cn/problems/valid-parentheses/description/">有效的括号</a></p><p><strong>存在三种情况：</strong></p><p>左括号多于右括号</p><p>右括号多于左括号</p><p>括号不匹配（左右括号对不上）。</p><p><strong>题目二：</strong></p><p><a href="https://leetcode.cn/problems/minimum-remove-to-make-valid-parentheses/description/">移除括号使其有效</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">stack&lt;<span class="type">char</span>*&gt; p1;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Solution</span>() &#123;&#125;</span><br><span class="line"><span class="function">string <span class="title">minRemoveToMakeValid</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span>* x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">p1.<span class="built_in">push</span>(&amp;s[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!p1.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">p1.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">s[i] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p1.<span class="built_in">empty</span>() == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">x = p1.<span class="built_in">top</span>();</span><br><span class="line">*x = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">p1.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">string ss;</span><br><span class="line"><span class="keyword">for</span> (string::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*it != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">ss.<span class="built_in">push_back</span>(*it);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ss;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>数制转换</strong></p><p>数制转换</p><p><strong>中缀表达式求值</strong></p><p>已知中缀表达式，求值</p><p><strong>方法一：中后缀转换，后缀表达式求值</strong></p><p>​对于高于1位的数字无法处理。</p><p><strong>中后缀转换：</strong></p><blockquote><p>如果检测到<strong>数字</strong>，则直接加入到后缀表达式中</p><p>如果检测到运算符时：</p><ol><li>若为‘（’，入栈</li><li>若为‘）’，则依次将栈中的运算符加入后缀表达式，直到出现‘（’，并从栈中删除‘（’</li><li>若为‘+’，‘-’，‘*’，‘/’</li></ol><ul><li>栈空，入栈</li><li>栈顶元素为‘（’,入栈</li><li><strong>高于</strong>栈顶元素优先级，入栈</li><li>否则，依次弹出栈顶运算符，直到一个优先级比它低的运算符或‘（’为止</li></ul><p>遍历完成，若栈非空，依次弹出栈中所有元素</p></blockquote><p><strong>方法二：利用两个栈进行计算</strong></p><blockquote><ol><li>初始化一个操作数栈和一个运算符栈。</li><li>从左到右读入中缀表达式，若读到的是操作数，则将其压入操作数栈中。</li><li>若读到的是运算符，则和运算符栈栈顶的操作符进行比较：如果优先级比栈顶运算符<strong>高</strong>，则入栈；如果优先级比栈顶运算符低或者等于，则弹出栈顶运算符，再从操作数栈中弹出 2 个操作数，对其进行运算，将结果压入操作数栈中,重复，直到当前读到的运算符优先级<strong>高于</strong>运算符栈的栈顶运算符。</li><li>若读到的是左括号，则直接入栈；若读到的是右括号，则弹出栈中第一个左括号前所有的运算符，每次同时弹出 2 个操作数进行运算，并将结果压入操作数栈中，最后将左括号弹出。</li><li>重复以上过程直到遇到结束符，若此时操作数栈不为空，则将所有操作符弹出，进行和上面相同的运算操作，最终栈顶元素即为计算结果。</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">qpow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)        <span class="comment">//如果n的当前末位为1</span></span><br><span class="line">            ans *= a;  <span class="comment">//ans乘上当前的a</span></span><br><span class="line">        a *= a;        <span class="comment">//a自乘</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;       <span class="comment">//n往右移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">midop</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">char</span>&gt; ssop;</span><br><span class="line">stack&lt;<span class="type">long</span> <span class="type">long</span>&gt; ssnum;</span><br><span class="line"><span class="type">bool</span> tag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">littlecalu</span><span class="params">(<span class="type">long</span> <span class="type">long</span> lh, <span class="type">long</span> <span class="type">long</span> rh, <span class="type">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (ch)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">case</span>(<span class="string">&#x27;+&#x27;</span>):</span><br><span class="line">&#123;</span><br><span class="line">ssnum.<span class="built_in">push</span>(lh + rh);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">case</span>(<span class="string">&#x27;-&#x27;</span>):</span><br><span class="line">&#123;</span><br><span class="line">ssnum.<span class="built_in">push</span>(lh - rh);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">case</span>(<span class="string">&#x27;*&#x27;</span>):</span><br><span class="line">&#123;</span><br><span class="line">ssnum.<span class="built_in">push</span>(lh * rh);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">case</span>(<span class="string">&#x27;/&#x27;</span>):</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (rh != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ssnum.<span class="built_in">push</span>(lh / rh);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;INVALID&quot;</span>;</span><br><span class="line">tag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">case</span>(<span class="string">&#x27;^&#x27;</span>):</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res = <span class="built_in">qpow</span>(lh, rh);</span><br><span class="line">ssnum.<span class="built_in">push</span>(res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">op_compare</span><span class="params">(<span class="type">char</span> a, <span class="type">char</span> b)</span><span class="comment">//优先级计算</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> aa = <span class="number">0</span>, bb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="string">&#x27;+&#x27;</span> || a == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">aa = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="string">&#x27;+&#x27;</span> || b == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">bb = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="string">&#x27;*&#x27;</span> || a == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">aa = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="string">&#x27;*&#x27;</span> || b == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">bb = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="string">&#x27;^&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">aa = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="string">&#x27;^&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">bb = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> aa &gt; bb ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="built_in">caclulate</span>(string str)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>;</span><br><span class="line">tag = <span class="number">1</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> len = str.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch = str[i];</span><br><span class="line"><span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">ssnum.<span class="built_in">push</span>(ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">while</span> (str[i] &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; str[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; i &lt;= len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> tmp = ssnum.<span class="built_in">top</span>();</span><br><span class="line">ssnum.<span class="built_in">pop</span>();</span><br><span class="line">tmp = tmp * <span class="number">10</span> + (str[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">ssnum.<span class="built_in">push</span>(tmp);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">ssop.<span class="built_in">push</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (ssop.<span class="built_in">empty</span>() != <span class="literal">true</span> &amp;&amp; ssop.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch1 = ssop.<span class="built_in">top</span>();</span><br><span class="line">ssop.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> lh, rh;</span><br><span class="line">rh = ssnum.<span class="built_in">top</span>();</span><br><span class="line">ssnum.<span class="built_in">pop</span>();</span><br><span class="line">lh = ssnum.<span class="built_in">top</span>();</span><br><span class="line">ssnum.<span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">littlecalu</span>(lh, rh, ch1);</span><br><span class="line"><span class="keyword">if</span> (!tag) <span class="keyword">return</span>;<span class="comment">//无效则结束计算</span></span><br><span class="line">&#125;</span><br><span class="line">ssop.<span class="built_in">pop</span>();</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ssop.<span class="built_in">empty</span>() != <span class="literal">true</span> &amp;&amp; ssop.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span> &amp;&amp; ssop.<span class="built_in">top</span>() != <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">op_compare</span>(ch, ssop.<span class="built_in">top</span>())) <span class="comment">//ch&gt;top</span></span><br><span class="line">&#123;</span><br><span class="line">ssop.<span class="built_in">push</span>(ch);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (ssop.<span class="built_in">empty</span>() != <span class="literal">true</span> &amp;&amp; !<span class="built_in">op_compare</span>(ch, ssop.<span class="built_in">top</span>()))</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch1 = ssop.<span class="built_in">top</span>();</span><br><span class="line">ssop.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> rh = ssnum.<span class="built_in">top</span>();</span><br><span class="line">ssnum.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> lh = ssnum.<span class="built_in">top</span>();</span><br><span class="line">ssnum.<span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">littlecalu</span>(lh, rh, ch1);</span><br><span class="line"><span class="keyword">if</span> (!tag) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ssop.<span class="built_in">push</span>(ch);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!ssop.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch1 = ssop.<span class="built_in">top</span>();</span><br><span class="line">ssop.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> rh = ssnum.<span class="built_in">top</span>();</span><br><span class="line">ssnum.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> lh = ssnum.<span class="built_in">top</span>();</span><br><span class="line">ssnum.<span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">littlecalu</span>(lh, rh, ch1);</span><br><span class="line"><span class="keyword">if</span> (!tag) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ssnum.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>递归</strong></p><blockquote><p><strong>有些情况下，若采用迭代算法或递归算法的非递归实现，将大大提高效率</strong></p></blockquote><p>八皇后</p><p>汉诺塔</p><p>BS找最大最小元素</p><h3 id="队列-queue">队列（queue）</h3><p><strong>特点：先进先出，队首删除，队尾插入,与栈类似，队列的封闭性也非常好，使用起来很安全</strong></p><h4 id="顺序存储">顺序存储</h4><p><strong>实现: 使用数组实现队列</strong></p><p><strong>初始状态，rear和front均为0</strong></p><p><strong>1.删除队首元素</strong></p><p>**方法一：**front=front +1</p><p>​<strong>问题：会存在无法利用的空间</strong></p><p><strong>方法二：元素向前移动，front始终不变在数组的头部。</strong></p><p>​<strong>问题：效率低下</strong></p><p><strong>方法三：循环队列</strong></p><p><strong>很好地解决了方法一二的问题。</strong></p><p>​但要设置参数count计数器判断队列是否满和空</p><ul><li>front指向队首位置，<strong>删除一个元素</strong>就将front顺时针移动一位；<strong>front初识化为0</strong></li><li>rear指向元素<strong>要插入</strong>的位置，插入一个元素就将rear顺时针移动一位； <strong>rear初始化为0</strong>，<strong>若指向队尾的元素初始化为-1</strong></li><li>count存放队列中元素的个数，当count等于Size时，不可再向队列中插入元素。当count=0时队列为空</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCircularQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> count;<span class="comment">//计数器</span></span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;<span class="comment">//指向队尾的元素初始化为-1</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span>* array;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyCircularQueue</span>(<span class="type">int</span> k) </span><br><span class="line">    &#123;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="type">int</span>[k]();</span><br><span class="line">        size = k;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        front = <span class="number">0</span>; <span class="comment">////</span></span><br><span class="line">        rear = <span class="number">-1</span>;<span class="comment">////</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">enQueue</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == size) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        count++;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % size;</span><br><span class="line">        array[rear] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">deQueue</span><span class="params">()</span><span class="comment">//删除队首元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">front = (front + <span class="number">1</span>) % size;</span><br><span class="line">count--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Front</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> array[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Rear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> array[rear];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == size) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="链式存储">链式存储</h4><p><strong>实现：使用链表实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> date;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myqueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>* front;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>* rear;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Myqueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">front = <span class="literal">NULL</span>;</span><br><span class="line">rear = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Node</span>* tmp = <span class="keyword">new</span> <span class="keyword">struct</span> Node;</span><br><span class="line">        tmp-&gt;date = item;</span><br><span class="line"><span class="keyword">if</span> (rear != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">rear-&gt;next = tmp;</span><br><span class="line">rear = rear-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">            front=tmp；</span><br><span class="line">&#125;</span><br><span class="line">        rear=tmp;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (front == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> x = front-&gt;date;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Node</span>* tmp;</span><br><span class="line">tmp = front;</span><br><span class="line">front = front-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line">        <span class="keyword">if</span>(front==<span class="literal">NULL</span>) rear=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (front == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> front-&gt;date;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (front == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="顺序存储和链式存储">顺序存储和链式存储</h4><p><img src="image-20231025180959906.png" alt="image-20231025180959906"></p><h3 id="扩展">扩展</h3><p><img src="image-20231025181037056.png" alt="image-20231025181037056"></p><h4 id="优先队列">优先队列</h4><p><strong>定义与声明</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;template &lt;class T, class Container = vector&lt;T&gt;,  class Compare = less&lt;typename Container::value_type&gt; &gt; class priority_queue;</span><br></pre></td></tr></table></figure><p>第一个模板参数为为class T，代表每个元素的类型.</p><p>第二个模板参数为class Container，缺省值为vector<T>,代表存储这些数据的容器，可以是vector，deque等，<strong>但不能是list</strong>，因为它的内部空间不连续.</p><p>第三个模板参数为class Compare，缺省值为less<T>,其中less是个仿函数，是降序排序，既<strong>优先级最大的是容器中最大的元素</strong>.又叫比较函数.</p><p>当然<strong>可以升序排序，把less改为greater即可.</strong></p><p><strong>less 和 greater使用的前提是建立在这些数据类型是C++基本的数据类型.</strong></p><p>来源：<a href="https://blog.csdn.net/weixin_47257473/article/details/129262572">C++——优先级队列(priority_queue)的使用及实现_c++ 优先级队列-CSDN博客</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不写后面两个参数默认为vector，less</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq1;</span><br><span class="line"><span class="comment">//建立一个优先级队列(大堆)，数据类型是int，利用vector容器实现，less（降序）实现</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; pq2;</span><br><span class="line"><span class="comment">//建立一个优先级队列(小堆)，数据类型是int，利用vector容器实现，greater（降序）实现</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pq3;</span><br></pre></td></tr></table></figure><p><strong>常用接口：</strong></p><blockquote><p>它的操作与基本队列操作一样，主要有以下接口：</p><p><strong>top()</strong> ：返回元素中<strong>第一个元素的引用</strong>（优先级最高的元素都会被放到顶部，既第一个元素）.</p><p><strong>push()</strong>：插入一个元素，并重新维护堆，无返回值.</p><p><strong>pop()</strong> ：<strong>删除优先级最高的元素</strong>，并重新维护堆无返回值</p><p><strong>size()</strong> ：返回容器中<strong>有效元素的数量，返回队列的大小</strong></p><p><strong>empty()</strong> ：检测容器**是否为空.**返回“true”或者“false”.</p></blockquote><h2 id="字符串">字符串</h2><h4 id="模式匹配问题">模式匹配问题</h4><p><strong>「朴素模式匹配法 」</strong></p><p><img src="image-20231207212644104.png" alt="image-20231207212644104"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFstringMatching</span><span class="params">(<span class="type">const</span> string str,<span class="type">const</span> string pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=str.<span class="built_in">size</span>()-pattern.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[i]==pattern[j]&amp;&amp;j&lt;pattern.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">if</span>(j==pattern.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i-pattern.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法分析</strong></p><p><img src="image-20231207213113063.png" alt="image-20231207213113063"></p><p><img src="image-20231207213142891.png" alt="image-20231207213142891"></p><p><strong>「快速模式匹配算法」</strong></p><p><a href="https://www.bilibili.com/video/BV1Px411z7Yo/?spm_id_from=333.337.search-card.all.click&amp;vd_source=9a4fe569cfdfb26138828e9c87e1512d">b站 课程kmp1</a></p><p><a href="https://www.bilibili.com/video/BV1hW411a7ys/?spm_id_from=333.999.0.0&amp;vd_source=9a4fe569cfdfb26138828e9c87e1512d">b站 课程kmp2</a></p><p>对于BF算法的改进，BF算法的效率不高是因为进行了重复的字符比较</p><p><strong>算法思想：</strong></p><p>是指针i 只前进不后退，避免重复比较，让模式串向后滑动的距离最大化。</p><p>失败函数的确定：<br>求模式串的子串的最大相等子串,即计算前缀后缀相等表——next，next数组只和模式串有关系</p><p>next数组表示，当匹配失败的时候应该将j移动到哪个坐标。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">nextfun</span><span class="params">(string pattern, vector&lt;<span class="type">int</span>&gt;&amp; next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//生成前缀表</span></span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>, size = pattern.<span class="built_in">size</span>(), i = <span class="number">1</span>;</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pattern[i] == pattern[len])</span><br><span class="line">&#123;</span><br><span class="line">len++;</span><br><span class="line">next[i] = len;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">len = next[len - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">next[i] = <span class="number">0</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前缀表向右移一位，生成next数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">next[i] = next[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmp_search</span><span class="params">(string text, string pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> pat_size = pattern.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> text_size = text.<span class="built_in">size</span>();</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(pat_size)</span></span>;</span><br><span class="line"><span class="built_in">nextfun</span>(pattern, next);</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;<span class="comment">//text[i],pattern[j]</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; text_size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j == pat_size - <span class="number">1</span> &amp;&amp; text[i] == pattern[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i - j);</span><br><span class="line"><span class="comment">//return (i - j);//只找一个匹配的话</span></span><br><span class="line">j = next[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (text[i] == pattern[j])</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">j = next[j];</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于next数组的求值，仍存在<strong>改进</strong>之处：当匹配失败的时候，当前 j 指向的字符和 next[ j ] 指向的字符相等时，会重复比较</p><p>因此，可以基于next生成一个nextval数组：</p><p>​如果位置k的元素与位置next[k]元素<strong>相同</strong>时，nextval[k]=nextval[next[k]]</p><p>​如果位置k的元素与位置next[k]元素<strong>不同</strong>时，nextval[k]= next[k]</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">nextfun</span><span class="params">(<span class="built_in">string</span> pattern, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nextval)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//生成前缀表</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;next(nextval.size());</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>, size = pattern.size(), i = <span class="number">1</span>;</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pattern[i] == pattern[len])</span><br><span class="line">&#123;</span><br><span class="line">len++;</span><br><span class="line">next[i] = len;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">len = next[len - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">next[i] = <span class="number">0</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前缀表向右移一位</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">next[i] = next[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">       <span class="comment">//基于next生成nextval数组</span></span><br><span class="line">nextval[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pattern[i] == pattern[next[i]])</span><br><span class="line">nextval[i] = next[next[i]];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">nextval[i] = next[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习</strong>：</p><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">力扣——找出字符串中第一个匹配项的下标</a></p><h1 id="树">树</h1><h2 id="基本操作">基本操作</h2><p><strong>1、判树空：TREEEMPTY(T)</strong></p><p><strong>2、求根结点：ROOT(T)</strong></p><p><strong>3、求树的深度：TREEDEPTH(T)</strong></p><p><strong>4、求结点的兄弟节点：同一双亲的孩子互称</strong></p><p><strong>5、求结点的双亲：PARENT(T, e)</strong></p><p><strong>6、求结点的孩子：CHILD(T, e, i)</strong></p><p><strong>7、建立树：CREATE_TREE(T, T1 , T2 , … , Tm )</strong></p><p><strong>8、遍历树：TRAVERSAL(T)</strong></p><h2 id="二叉树">二叉树</h2><p><strong>树与二叉树</strong></p><ul><li>二叉树每个结点最多有 2 个子结点，树则无此限制；</li><li>二叉树中结点的子树分成左子树和右子树，即使某结点只 有一棵子树，也要指明该子树是左子树，还是右子树，<strong>就是说 二叉树是有序的。</strong></li></ul><h3 id="基本性质">基本性质</h3><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>二叉树中层数为</mtext><mi>i</mi><mtext>的结点至多有</mtext><msup><mn>2</mn><mi>i</mi></msup><mtext>个，</mtext><mi>i</mi><mo>≥</mo><mn>0</mn><mtext>。</mtext></mrow><annotation encoding="application/x-tex">二叉树中层数为 i 的结点至多有2^i个，i≥0。</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0106339999999998em;vertical-align:-0.13597em;"></span><span class="mord cjk_fallback">二</span><span class="mord cjk_fallback">叉</span><span class="mord cjk_fallback">树</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">层</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">为</span><span class="mord mathdefault">i</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">结</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">至</span><span class="mord cjk_fallback">多</span><span class="mord cjk_fallback">有</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8746639999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord cjk_fallback">。</span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>高度为</mtext><mi>k</mi><mtext>的二叉树中至多有</mtext><msup><mn>2</mn><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn><mo stretchy="false">(</mo><mi>k</mi><mo>≥</mo><mn>0</mn><mo stretchy="false">)</mo><mtext>个结点。</mtext></mrow><annotation encoding="application/x-tex">高度为k的二叉树中至多有2^{k+1}-1 (k≥0)个结点。</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9824379999999999em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">高</span><span class="mord cjk_fallback">度</span><span class="mord cjk_fallback">为</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">二</span><span class="mord cjk_fallback">叉</span><span class="mord cjk_fallback">树</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">至</span><span class="mord cjk_fallback">多</span><span class="mord cjk_fallback">有</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">结</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">。</span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>设</mtext><mi>T</mi><mtext>是由</mtext><mi>n</mi><mtext>个结点构成的二叉树，其中，叶结点个数为</mtext><msub><mi>n</mi><mn>0</mn></msub><mtext>，度为</mtext><mn>2</mn><mtext>的结点个数为</mtext><msub><mi>n</mi><mn>2</mn></msub><mtext>，则有</mtext><mo>:</mo><msub><mi>n</mi><mn>0</mn></msub><mtext>＝</mtext><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">设T是由n个结点构成的二叉树，其中，叶结点个数为n_0，度为2的结点个数为n_2，则有:n_0＝n_2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">设</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">由</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">结</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">构</span><span class="mord cjk_fallback">成</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">二</span><span class="mord cjk_fallback">叉</span><span class="mord cjk_fallback">树</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">叶</span><span class="mord cjk_fallback">结</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">为</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">度</span><span class="mord cjk_fallback">为</span><span class="mord">2</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">结</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">为</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">则</span><span class="mord cjk_fallback">有</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">＝</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>满二叉树</mtext><mo>:</mo><mtext>一棵非空高度为</mtext><mi>k</mi><mo stretchy="false">(</mo><mi>k</mi><mo>&gt;</mo><mo>=</mo><mn>0</mn><mo stretchy="false">)</mo><mtext>的满二叉树，是有</mtext><msup><mn>2</mn><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup><mtext>–</mtext><mn>1</mn><mtext>个结点的二叉树</mtext></mrow><annotation encoding="application/x-tex">满二叉树:一棵非空高度为k ( k &gt;= 0 )的满二叉树，是有2^{k+1} – 1个结点的二叉树</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">满</span><span class="mord cjk_fallback">二</span><span class="mord cjk_fallback">叉</span><span class="mord cjk_fallback">树</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">棵</span><span class="mord cjk_fallback">非</span><span class="mord cjk_fallback">空</span><span class="mord cjk_fallback">高</span><span class="mord cjk_fallback">度</span><span class="mord cjk_fallback">为</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">满</span><span class="mord cjk_fallback">二</span><span class="mord cjk_fallback">叉</span><span class="mord cjk_fallback">树</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">有</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord">–</span><span class="mord">1</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">结</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">二</span><span class="mord cjk_fallback">叉</span><span class="mord cjk_fallback">树</span></span></span></span></span></p><p><img src="image-20231028203341830.png" alt="image-20231028203341830"></p><p><strong>满二叉树的特点是：</strong><br><strong>① 叶结点都在第k层上；</strong><br><strong>② 每个分支结点都有两个子结点；</strong><br><strong>③ 叶结点的个数等于非叶结点个数加1。</strong></p><blockquote><p>一棵有 n 个结点、高为 k 的二叉树 T，一棵高为 k 的满二叉树 T* ， 用正整数按层次顺序分别编号 T 和 T* 的所有结点，如果T 之所有结 点恰好对应于T*的前 n 个结点，则称 T 为<strong>完全二叉树。</strong></p></blockquote><p><img src="image-20231028203822677.png" alt="image-20231028203822677"></p><h3 id="存储结构">存储结构</h3><p><strong>顺序存储</strong></p><p><img src="image-20231029140215064.png" alt="image-20231029140215064"></p><p><img src="image-20231029140236742.png" alt="image-20231029140236742"></p><p><strong>链式存储</strong></p><p><img src="image-20231029140316009.png" alt="image-20231029140316009"></p><p><img src="image-20231029140327999.png" alt="image-20231029140327999"></p><p><img src="image-20231029140412615.png" alt="image-20231029140412615"></p><h3 id="基本操作">基本操作</h3><h4 id="中根遍历">中根遍历</h4><p>力扣： <a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/?envType=study-plan-v2&amp;envId=top-100-liked">https://leetcode.cn/problems/binary-tree-inorder-traversal/description/?envType=study-plan-v2&amp;envId=top-100-liked</a></p><p><strong>递归算法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">       cout&lt;&lt;root-&gt;val; </span><br><span class="line">       <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>迭代算法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">     TreeNode *left;</span><br><span class="line">     TreeNode *right;</span><br><span class="line">     <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line">stack&lt;TreeNode*&gt; sstack;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span>||(!sstack.<span class="built_in">empty</span>()))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sstack.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* p = sstack.<span class="built_in">top</span>();</span><br><span class="line">        cout&lt;&lt;p-&gt;val;</span><br><span class="line">        sstack.<span class="built_in">pop</span>();</span><br><span class="line">        root = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="先根遍历">先根遍历</h4><p>力扣：<a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/submissions/478115880/">https://leetcode.cn/problems/binary-tree-preorder-traversal/submissions/478115880/</a></p><p><strong>算法基本等同于中根遍历，只是改了输出顺序，先输出根节点再遍历左右子树。</strong></p><p><strong>递归：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       cout&lt;&lt;root-&gt;val; </span><br><span class="line">       <span class="built_in">preorder</span>(root-&gt;left);</span><br><span class="line">       <span class="built_in">preorder</span>(root-&gt;right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>非递归算法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">     TreeNode *left;</span><br><span class="line">     TreeNode *right;</span><br><span class="line">     <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span>||(!sstack.<span class="built_in">empty</span>()))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;root-&gt;val;</span><br><span class="line">            sstack.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* p = sstack.<span class="built_in">top</span>();</span><br><span class="line">        sstack.<span class="built_in">pop</span>();</span><br><span class="line">        root = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="后根遍历">后根遍历</h4><p>力扣：<a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/submissions/478118154/">https://leetcode.cn/problems/binary-tree-postorder-traversal/submissions/478118154/</a></p><p>递归：与先根中根类似</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">       <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">       cout&lt;&lt;root-&gt;val; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>非递归：</strong></p><ul><li><strong>先/中根的非递归算法，一个结点只进出栈一次。结点进栈，表示遍历开始； 结点出栈，表示左子树遍历完毕；输出语句的位置为进/出栈时。</strong></li><li><strong>后根遍历，输出结点需在遍历完右子树之后；若每个结点还是进出栈一次， 无法完成，需多次进出栈。</strong></li></ul><p><strong>准备工作栈：</strong></p><p>​                                <img src="image-20231029145156512.png" alt=" "></p><p><img src="image-20231029145238195.png" alt="image-20231029145238195"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line">TreeNode* left;</span><br><span class="line">TreeNode* right;</span><br><span class="line"><span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"><span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"><span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode* left, TreeNode* right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">TreeNode* p;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="built_in">node</span>(TreeNode* root, <span class="type">int</span> num) :<span class="built_in">p</span>(root), <span class="built_in">num</span>(num) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;node&gt; sstack;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">sstack.<span class="built_in">push</span>(<span class="built_in">node</span>(root, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">while</span> (!sstack.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>* tmp;</span><br><span class="line">tmp = &amp;(sstack.<span class="built_in">top</span>());</span><br><span class="line">sstack.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">switch</span> (tmp-&gt;num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">case</span> (<span class="number">0</span>):</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">tmp-&gt;num = <span class="number">1</span>;</span><br><span class="line">sstack.<span class="built_in">push</span>(*tmp);</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;p-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">sstack.<span class="built_in">push</span>(<span class="built_in">node</span>(tmp-&gt;p-&gt;left, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">case</span>(<span class="number">1</span>):</span><br><span class="line">&#123;</span><br><span class="line">tmp-&gt;num = <span class="number">2</span>;</span><br><span class="line">sstack.<span class="built_in">push</span>(*tmp);</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;p-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">sstack.<span class="built_in">push</span>(<span class="built_in">node</span>(tmp-&gt;p-&gt;right, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">case</span> (<span class="number">2</span>):</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; tmp-&gt;p-&gt;val;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><p><strong>力扣官方题解</strong></p><p>​没有用标识区别是哪一个状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode *&gt; stk;</span><br><span class="line">        TreeNode *prev = <span class="literal">nullptr</span>;              <span class="comment">///用来记录前一个访问的节点</span></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">///////////////////////////////////////////////////</span></span><br><span class="line">            <span class="comment">//到此为止完全和中序遍历完全相同</span></span><br><span class="line">            <span class="comment">///////////////////////////////////////////////////</span></span><br><span class="line">           <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span> || root-&gt;right == prev)<span class="comment">////判断右子树是否访问过或存不存在</span></span><br><span class="line">           &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(root);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/binary-tree-postorder-traversal/submissions/478118154/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="层次遍历">层次遍历</h4><p>力扣：</p><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/submissions/480155496/">https://leetcode.cn/problems/binary-tree-level-order-traversal/submissions/480155496/</a></p><p>用队列辅助实现，和广度优先算法有点像，但经过优化，<strong>一次性移除一层的节点</strong></p><blockquote><p>我们可以用一种巧妙的方法修改广度优先搜索：</p><pre><code>首先根元素入队当队列不为空的时候    求当前队列的长度 sis_isi    依次从队列中取 sis_isi 个元素进行拓展，然后进入下一次迭代</code></pre><p>它和普通广度优先搜索的区别在于，普通广度优先搜索每次只取一个元素拓展，而这里每次取 sis_isi 个元素。在上述过程中的第 iii 次迭代就得到了二叉树的第 iii 层的 sis_isi 个元素。</p><p>为什么这么做是对的呢？我们观察这个算法，可以归纳出这样的循环不变式：第 iii 次迭代前，队列中的所有元素就是第 iii 层的所有元素，并且按照从左向右的顺序排列。证明它的三条性质（你也可以把它理解成数学归纳法）：</p><pre><code>初始化：i=1i = 1i=1 的时候，队列里面只有 root，是唯一的层数为 111 的元素，因为只有一个元素，所以也显然满足「从左向右排列」；保持：如果 i=ki = ki=k 时性质成立，即第 kkk 轮中出队 sks_ksk 的元素是第 kkk 层的所有元素，并且顺序从左到右。因为对树进行广度优先搜索的时候由低 kkk 层的点拓展出的点一定也只能是 k+1k + 1k+1 层的点，并且 k+1k + 1k+1 层的点只能由第 kkk 层的点拓展到，所以由这 sks_ksk 个点能拓展到下一层所有的 sk+1s_&#123;k+1&#125;sk+1 个点。又因为队列的先进先出（FIFO）特性，既然第 kkk 层的点的出队顺序是从左向右，那么第 k+1k + 1k+1 层也一定是从左向右。至此，我们已经可以通过数学归纳法证明循环不变式的正确性。终止：因为该循环不变式是正确的，所以按照这个方法迭代之后每次迭代得到的也就是当前层的层次遍历结果。至此，我们证明了算法是正确的。</code></pre><p>作者：力扣官方题解</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector &lt;vector &lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue &lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> currentLevelSize = q.<span class="built_in">size</span>();</span><br><span class="line">            ret.<span class="built_in">push_back</span>(vector &lt;<span class="type">int</span>&gt; ());</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= currentLevelSize; ++i)  &#123;<span class="comment">//移除处理本层所有节点</span></span><br><span class="line">                <span class="keyword">auto</span> node = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                ret.<span class="built_in">back</span>().<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/binary-tree-level-order-traversal/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="创建二叉树">创建二叉树</h4><ul><li><p><strong>先根序列和中根序列可以确定</strong></p><p><img src="image-20231106185651324.png" alt="image-20231106185651324"></p></li><li><p><strong>后根序列和中根序列可以确定</strong></p><p><img src="image-20231106185722158.png" alt="image-20231106185722158"></p></li><li><p><strong>先根序列和后根序列不能确定</strong></p></li></ul><p><strong>已知含空指针的先根序列</strong></p><p><strong>递归实现，规定所给的先序序列如果有空指针则用 ”#“ 标识</strong></p><p><img src="image-20231106192625787.png" alt="image-20231106192625787"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* root;</span><br><span class="line"><span class="type">char</span>* arry;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line"><span class="type">int</span> point;<span class="comment">//读到字符串的第几个了</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">solution</span>(<span class="type">char</span>* arr, <span class="type">int</span> si) :<span class="built_in">arry</span>(arr), <span class="built_in">size</span>(si)</span><br><span class="line">&#123;</span><br><span class="line">root = <span class="literal">NULL</span>;</span><br><span class="line">point = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* <span class="built_in">creatBinTree</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arry[point] == <span class="string">&#x27;#&#x27;</span> || point &gt; size - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">point++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> TreeNode* tmp = <span class="keyword">new</span> <span class="keyword">struct</span> TreeNode;</span><br><span class="line">tmp-&gt;val = arry[point];</span><br><span class="line"><span class="keyword">if</span> (point == <span class="number">0</span>) root = tmp;</span><br><span class="line">point++;</span><br><span class="line">tmp-&gt;left = <span class="built_in">creatBinTree</span>();</span><br><span class="line">tmp-&gt;right = <span class="built_in">creatBinTree</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>已知中根和后根序列</strong></p><p><strong>pta：</strong></p><p>给定非空二叉树的中根序列和后根序列，请编写程序创建该二叉树，计算其高度和先根序列；如给定的中根和后根序列不合法，则亦能识别。</p><p><strong>合法性</strong></p><blockquote><ul><li>长度要相同，可以都为0</li><li>任一字母的中序序列和后序序列<strong>左右元素相同</strong>，顺序可以不一致，通过递归实现</li></ul></blockquote><p><strong>已知先根和中根序列</strong></p><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/?envType=list&amp;envId=YAlgtJ0f">105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）</a></p><h4 id="复制二叉树">复制二叉树</h4><p>用<strong>遍历</strong>的方式进行复制</p><p>以后序遍历为例子</p><p>**复制过程：**先复制子结点，再复制父结点，然后将父结 点与子结点链接起来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* <span class="built_in">copy</span>(<span class="keyword">struct</span> TreeNode* tmp, <span class="keyword">struct</span> TreeNode* tmp1)</span><br><span class="line">&#123;</span><br><span class="line">tmp1 = <span class="keyword">new</span> <span class="keyword">struct</span> TreeNode;</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;left != <span class="literal">NULL</span>) tmp1-&gt;left = <span class="built_in">copy</span>(tmp-&gt;left, tmp1-&gt;left);</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;right != <span class="literal">NULL</span>)    tmp1-&gt;right = <span class="built_in">copy</span>(tmp-&gt;right, tmp1-&gt;right);</span><br><span class="line"></span><br><span class="line">tmp1-&gt;val = tmp-&gt;val;</span><br><span class="line"><span class="keyword">return</span> tmp1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计算树的高度">计算树的高度</h4><p><strong>注意根节点是第0层还是第1层</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">high</span><span class="params">(<span class="keyword">struct</span> Node* root)</span><span class="comment">//根所在的是第一层</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> h1, h2;</span><br><span class="line"><span class="keyword">if</span> (root)</span><br><span class="line">&#123;</span><br><span class="line">h1 = <span class="built_in">high</span>(root-&gt;left);</span><br><span class="line">h2 = <span class="built_in">high</span>(root-&gt;right);</span><br><span class="line"><span class="keyword">return</span> h1 &gt; h2 ? h1 + <span class="number">1</span> : h2 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计算树的路径">计算树的路径</h4><p><strong>练习</strong></p><p><a href="https://leetcode.cn/problems/path-sum/?utm_source=LCUS&amp;utm_medium=ip_redirect&amp;utm_campaign=transfer2china">112. 路径总和 - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode *root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum == root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left, sum - root-&gt;val) || <span class="built_in">hasPathSum</span>(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/path-sum/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归  广度优先搜索</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode *root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode *&gt; que_node;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que_val;</span><br><span class="line">        que_node.<span class="built_in">push</span>(root);</span><br><span class="line">        que_val.<span class="built_in">push</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">while</span> (!que_node.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode *now = que_node.<span class="built_in">front</span>();</span><br><span class="line">            <span class="type">int</span> temp = que_val.<span class="built_in">front</span>();</span><br><span class="line">            que_node.<span class="built_in">pop</span>();</span><br><span class="line">            que_val.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (now-&gt;left == <span class="literal">nullptr</span> &amp;&amp; now-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp == sum) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (now-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                que_node.<span class="built_in">push</span>(now-&gt;left);</span><br><span class="line">                que_val.<span class="built_in">push</span>(now-&gt;left-&gt;val + temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (now-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                que_node.<span class="built_in">push</span>(now-&gt;right);</span><br><span class="line">                que_val.<span class="built_in">push</span>(now-&gt;right-&gt;val + temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/path-sum/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/path-sum-ii/description/">113. 路径总和 II - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">        targetSum -= root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; targetSum == <span class="number">0</span>) &#123;</span><br><span class="line">            ret.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, targetSum);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, targetSum);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> targetSum) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, targetSum);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/path-sum-ii/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/path-sum-iii/description/?utm_source=LCUS&amp;utm_medium=ip_redirect&amp;utm_campaign=transfer2china">437. 路径总和 III - 力扣（LeetCode）</a></p><p>我的思路：暴利破解，遍历每个节点  之后递归搜索有无路径满足</p><p>改进算法：</p><p>前缀和，</p><p><strong>PTA：</strong></p><p>编写程序找出二叉树中和最大的路径，二叉树结点为不等于0的整数。本题的“路径”限定为<strong>以根结点为起点，以叶结点为终点</strong>的路径。路径的和，即该路径所包含的所有结点的数据值之和。</p><p><strong>输入格式:</strong></p><p>输入为一组用空格间隔的整数，个数不超过100个，表示带空指针信息的二叉树先根序列。</p><p><strong>输出格式:</strong></p><p>输出为两行，第一行为该二叉树路径和的最大值，第二行为一组整数，每个整数后一个空格，即该最大路径包含的结点值（按从根的叶的顺序），如果存在多条满足条件路径，则输出最左边一条。</p><p><strong>输入样例1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 0 0 3 0 0</span><br></pre></td></tr></table></figure><p><strong>输出样例1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 3 </span><br></pre></td></tr></table></figure><p><strong>输入样例2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1 2 0 0 3 0 0</span><br></pre></td></tr></table></figure><p><strong>输出样例2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">-1 3 </span><br></pre></td></tr></table></figure><h4 id="查找给定结点的父结点">查找给定结点的父结点</h4><p>遍历的同时进行比较</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* <span class="built_in">Father</span>(<span class="keyword">struct</span> TreeNode* root,<span class="type">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root || (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == root-&gt;left-&gt;val) <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == root-&gt;right-&gt;val) <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* res = <span class="built_in">Father</span>(root-&gt;left, value);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* res1 = <span class="built_in">Father</span>(root-&gt;right, value);</span><br><span class="line">    <span class="keyword">if</span> (res != <span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> res1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找符合数据域条件的结点">查找符合数据域条件的结点</h4><p>遍历的同时进行比较</p><p>例如：采用递归前序遍历进行查找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* <span class="built_in">Find</span>(<span class="keyword">struct</span> TreeNode*root,<span class="type">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)&#123;<span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line"><span class="keyword">if</span> (value == root-&gt;val) <span class="keyword">return</span> root;</span><br><span class="line"><span class="built_in">findpreorder</span>(root-&gt;left, value);</span><br><span class="line"><span class="built_in">findpreorder</span>(root-&gt;right, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="释放二叉树">释放二叉树</h4><p>遍历的同时进行释放</p><p>如：采用层次遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteTree</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">struct</span> TreeNode*&gt; list;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    list.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* tmp;</span><br><span class="line">    <span class="keyword">while</span> (!list.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = list.<span class="built_in">front</span>();</span><br><span class="line">        list.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;left != <span class="literal">NULL</span>) list.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;right != <span class="literal">NULL</span>) list.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入结点">插入结点</h4><ul><li>在二叉树中插入结点，要<strong>确定待插入结点与插入位置结点的父子关系</strong>。</li><li>设p为指向待插入结点的指针，简称结点 p；s为指向插入位置结点 的指针，简称结点s. 即要确定 p 作为 s 的左儿子还是右儿子，以 及如何维护 s 原来的父子关系。</li></ul><p>指定为左儿子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">struct</span> TreeNode* s,<span class="keyword">struct</span> TreeNode* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>||p==<span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    p-&gt;left=s-&gt;left;</span><br><span class="line">    p-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">    s-&gt;left=p;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除给定结点及其左右子树">删除给定结点及其左右子树</h4><p>相较于释放二叉树，我们还需要改变父节点的内容。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(<span class="keyword">struct</span> TreeNode* root,<span class="keyword">struct</span> TreeNode* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>||p==<span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(root==p) &#123;<span class="built_in">deleteTree</span>(root); <span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* father=<span class="built_in">Father</span>(p);<span class="comment">//查找p的父节点</span></span><br><span class="line">    <span class="keyword">if</span>(father-&gt;left==q) father-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> father-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">deleteTree</span>(p);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="表达式树">表达式树</h4><p><strong>概念</strong></p><p>表达式有一个内在二叉树结构，即表达式(a+b) * (c−d)−e对应的二叉树，二叉树中叶结点是表达式中的变量或常数（如：a，b），非叶结点是操作符。</p><p><img src="image-20231106213745029.png" alt="image-20231106213745029"></p><p><strong>后缀表达式构造对应的表达式树</strong></p><p><img src="image-20231106214008659.png" alt="image-20231106214008659"></p><p>实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* <span class="built_in">creatBinTree</span>(<span class="type">char</span>* array, <span class="type">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* tmp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> point = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (point &lt;= size - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (array[point] == <span class="string">&#x27;+&#x27;</span> || array[point] == <span class="string">&#x27;-&#x27;</span> || array[point] == <span class="string">&#x27;*&#x27;</span> || array[point] == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">tmp = <span class="keyword">new</span> <span class="keyword">struct</span> <span class="built_in">TreeNode</span>(array[point]);</span><br><span class="line">tmp-&gt;left = ss.<span class="built_in">top</span>();</span><br><span class="line">ss.<span class="built_in">pop</span>();</span><br><span class="line">tmp-&gt;right = ss.<span class="built_in">top</span>();</span><br><span class="line">ss.<span class="built_in">pop</span>();</span><br><span class="line">ss.<span class="built_in">push</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tmp = <span class="keyword">new</span> <span class="keyword">struct</span> <span class="built_in">TreeNode</span>(array[point]);</span><br><span class="line">ss.<span class="built_in">push</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line">point++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ss.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>已知表达式树，计算其对应的值</strong></p><p>将表达式树转换为后缀表达式，再利用栈计算后缀表达式的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">double</span>&gt; cacu;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* root;</span><br><span class="line">vector&lt;<span class="type">char</span>&gt; v;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tree2array</span><span class="params">(<span class="keyword">struct</span> TreeNode* tmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (tmp-&gt;left != <span class="literal">NULL</span>) <span class="built_in">Tree2array</span>(tmp-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (tmp-&gt;right != <span class="literal">NULL</span>) <span class="built_in">Tree2array</span>(tmp-&gt;right);</span><br><span class="line">    v.<span class="built_in">push_back</span>(tmp-&gt;val);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Treecaculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> lh = <span class="number">0</span>, rh = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Tree2array</span>(root);</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">char</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it &lt; v.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*it == <span class="string">&#x27;+&#x27;</span> || *it == <span class="string">&#x27;-&#x27;</span> || *it == <span class="string">&#x27;*&#x27;</span> || *it == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (*it)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">case</span>(<span class="string">&#x27;+&#x27;</span>):</span><br><span class="line">                    &#123;rh = cacu.<span class="built_in">top</span>();</span><br><span class="line">                     cacu.<span class="built_in">pop</span>();</span><br><span class="line">                     lh = cacu.<span class="built_in">top</span>();</span><br><span class="line">                     cacu.<span class="built_in">pop</span>();</span><br><span class="line">                     cacu.<span class="built_in">push</span>(lh + rh);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="built_in">case</span>(<span class="string">&#x27;-&#x27;</span>):</span><br><span class="line">                    &#123;rh = cacu.<span class="built_in">top</span>();</span><br><span class="line">                     cacu.<span class="built_in">pop</span>(); </span><br><span class="line">                     lh = cacu.<span class="built_in">top</span>(); </span><br><span class="line">                     cacu.<span class="built_in">pop</span>(); </span><br><span class="line">                     cacu.<span class="built_in">push</span>(lh - rh); </span><br><span class="line">                     <span class="keyword">break</span>; &#125;</span><br><span class="line">                <span class="built_in">case</span>(<span class="string">&#x27;*&#x27;</span>): </span><br><span class="line">                    &#123;rh = cacu.<span class="built_in">top</span>(); </span><br><span class="line">                     cacu.<span class="built_in">pop</span>(); </span><br><span class="line">                     lh = cacu.<span class="built_in">top</span>();</span><br><span class="line">                     cacu.<span class="built_in">pop</span>(); </span><br><span class="line">                     cacu.<span class="built_in">push</span>(lh * rh);</span><br><span class="line">                     <span class="keyword">break</span>; &#125;</span><br><span class="line">                <span class="built_in">case</span>(<span class="string">&#x27;/&#x27;</span>): </span><br><span class="line">                    &#123;rh = cacu.<span class="built_in">top</span>();</span><br><span class="line">                     cacu.<span class="built_in">pop</span>(); </span><br><span class="line">                     lh = cacu.<span class="built_in">top</span>();</span><br><span class="line">                     cacu.<span class="built_in">pop</span>();</span><br><span class="line">                     cacu.<span class="built_in">push</span>(lh / rh);</span><br><span class="line">                     <span class="keyword">break</span>; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cacu.<span class="built_in">push</span>(*it - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (cacu.<span class="built_in">top</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线索化二叉树">*线索化二叉树</h2><p><strong>概念</strong></p><blockquote><p>通过遍历二叉树可得到结点的一个线性序列，在<strong>线性序列</strong>中，除第一个结点外，每个结点有且仅有一个前驱， 除最后一个结点外，每个结点有且仅有一个后继。 但在二叉树中只能找到结点的左孩子、右孩子，结点在<strong>线性序列中的前驱和后继</strong>只有在遍历过程中才能得到</p></blockquote><p>为了与结点在二叉树中所具有的前驱（即父结点）和后继即子结 点）区别开来，通常把某种序列中结点的前驱或后继冠以某种遍历 的名称，如把中根序列中结点的前驱称作中根前驱，结点的后继称 作中根后继。</p><p><strong>节点变化：</strong></p><p><img src="image-20231107190809887.png" alt="image-20231107190809887"></p><p><img src="image-20231107190947535.png" alt="image-20231107190947535"></p><p><img src="image-20231107191653826.png" alt="image-20231107191653826"></p><p><strong>[目的]</strong></p><p>​在<strong>中序线索二叉树</strong>中不需要对二叉树进行遍历就可以方便地找到给定结点的<strong>中序前驱和中序后继结点</strong>，并且不需要太多额外的空间。</p><p><strong><u>线索二叉树中一个结点是叶结点的充要条件为：左、 右标识(LThread、RThread)均为1。</u></strong></p><h4 id="相关操作">相关操作</h4><p><strong>搜索以t为根的线索二叉树的中根序列的第一个结点</strong></p><p><strong>【算法思想】：</strong></p><ol><li>若t有左子树，则第一个节点是左子树最左下的节点。</li><li>若t无左子树，则第一个节点是t。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> Lthread;</span><br><span class="line">    <span class="type">bool</span> Rthread;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* left;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">returnfirst</span>(<span class="keyword">struct</span> ThreadBinTree* root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* p=root;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;Lthread==<span class="number">0</span>) p=p-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>搜索以t为根的线索二叉树的中根序列的最后一个结点</strong></p><p><strong>『算法思想』</strong></p><ol><li>若t有右子树则最后一个为最右下方的节点</li><li>若没有，则t即为最后一个</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">returnlast</span>(<span class="keyword">struct</span> ThreadBinTree* root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* p=root;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;Rthread==<span class="number">0</span>) p=p-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在中序线索二叉树中,查找结点p的<u>中根前驱</u>结点</strong></p><p><strong>『算法思想』</strong></p><ol><li>若p节点的Lthread=1，则left指向的即为中序前驱节点</li><li>若为Lthread=0，则p的左子树的中根序列最后一个结点即为p的中根前驱节点</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">returnlast</span>(<span class="keyword">struct</span> ThreadBinTree* root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">returnpre</span>(<span class="keyword">struct</span> ThreadBinTree* p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;Lthread) <span class="keyword">return</span> p-&gt;left;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span>(<span class="built_in">returnlast</span>(p-&gt;left));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在中序线索二叉树中,查找结点p的<u>中根后继</u>结点</strong></p><p><strong>『算法思想』</strong></p><ol><li>若p节点的Rthread=1，则right指向的即为中序前驱节点</li><li>若为Rthread=0，则p的右子树的中根序列第一个结点即为p的中根前驱节点</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">returnfirst</span>(<span class="keyword">struct</span> ThreadBinTree* root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">returnafter</span>(<span class="keyword">struct</span> ThreadBinTree* p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;Rthread) <span class="keyword">return</span> p-&gt;right;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span>(<span class="built_in">returnlast</span>(p-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>中序遍历线索二叉树</strong></p><p>正向遍历</p><p><strong>『算法思想』</strong></p><p>只要先找到中序序列中的<strong>第一个结点</strong>，然后依次找结点的<strong>中序后继</strong>直至其为 空时止</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">returnfirst</span>(<span class="keyword">struct</span> ThreadBinTree* root);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">returnafter</span>(<span class="keyword">struct</span> ThreadBinTree* p);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(<span class="keyword">struct</span> ThreadBinTree* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* first=<span class="built_in">returnfirst</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(first!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;first-&gt;val;</span><br><span class="line">        first=<span class="built_in">returnafter</span>(first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>反向遍历</strong></p><p><strong>『算法思想』</strong></p><p>只要先找到中序序列中的<strong>最后一个结点</strong>，然后依次找结点的<strong>中序前驱</strong>直至其为空时止</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">returnlast</span>(<span class="keyword">struct</span> ThreadBinTree* root);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">returnpre</span>(<span class="keyword">struct</span> ThreadBinTree* p);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deinorder</span><span class="params">(<span class="keyword">struct</span> ThreadBinTree* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* last=<span class="built_in">returnpre</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(last!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;last-&gt;val;</span><br><span class="line">        last=<span class="built_in">returnpre</span>(last);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>中根序列线索二叉树插入节点</strong></p><p>**例如：**在线索二叉树中插入结点p作为结点s的右子结点，</p><p><strong>『算法思想』</strong></p><ol><li><p><strong>s没有右子节点</strong></p><p>​<img src="image-20231109190718789.png" alt="image-20231109190718789"></p></li></ol><p>此时对于结点s我们需要改变以下内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;Rthread=s-&gt;Rthread;</span><br><span class="line">p-&gt;right=s-&gt;right;</span><br><span class="line">s-&gt;right=p;</span><br><span class="line">s-&gt;Rthread=<span class="number">0</span>;</span><br><span class="line">p-&gt;Lthread=<span class="number">1</span>;</span><br><span class="line">p-&gt;left=s;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>s有右子节点</strong></li></ol><p><img src="image-20231109191109896.png" alt="image-20231109191109896"></p><p>此时对于结点s我们需要改变以下内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;Rthread=s-&gt;Rthread;</span><br><span class="line">p-&gt;right=s-&gt;right;</span><br><span class="line">p-&gt;Lthread=<span class="number">1</span>;</span><br><span class="line">p-&gt;left=s;</span><br><span class="line">s-&gt;right=p;</span><br><span class="line">q=p-&gt;right;</span><br><span class="line">q=<span class="built_in">returnfirst</span>(q);</span><br><span class="line">q-&gt;left=p;</span><br></pre></td></tr></table></figure><p>综上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">struct</span> ThreadBinTree* s,<span class="keyword">struct</span> ThreadBinTree* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;right=s-&gt;right;</span><br><span class="line">    p-&gt;Rthread=s-&gt;Rthread;</span><br><span class="line">    p-&gt;left=s;</span><br><span class="line">    p-&gt;Lthread=<span class="number">1</span>;</span><br><span class="line">    s-&gt;right=p;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(s-&gt;Rthread==<span class="number">1</span>)<span class="comment">//s没有右子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;Rthread=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有右子树</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* tmp=p-&gt;right;</span><br><span class="line">    tmp=<span class="built_in">returnfirst</span>(tmp);</span><br><span class="line">    tmp-&gt;left=p;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线索二叉树删除节点</strong></p><p><strong>以删除右孩子为例讨论删除算法：</strong></p><p>即：在一棵中序线索二叉树中，结点 s 的右子结点 p 存在，删除 p</p><p><strong>『算法思想』</strong></p><p><strong>分类：</strong></p><ol><li><p>p为叶子节点，没有左右子树</p><p><img src="image-20231109193435838.png" alt="image-20231109193435838"></p></li><li><p>p没有左子树，但有右子树</p><p><img src="image-20231109193507445.png" alt="image-20231109193507445"></p></li><li><p>p没有右子树，但有左子树</p><p><img src="image-20231109193631495.png" alt="image-20231109193631495"></p></li><li><p>p既有左子树，又有右子树</p></li></ol><p>​<img src="image-20231109193648175.png" alt="image-20231109193648175"></p><p><strong>线索化二叉树</strong></p><p>遍历的同时复制并修改结点域</p><p>例如：中序线索化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">BinTree2ThreadTree</span>(<span class="keyword">struct</span> TreeNode* root,)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">BinTree2ThreadTree</span>(root-&gt;left);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哈夫曼树">哈夫曼树</h2><p><img src="image-20231109200421248.png" alt="image-20231109200421248"></p><p><img src="image-20231109200432792.png" alt="image-20231109200432792"></p><p><strong>预备知识</strong></p><p><img src="image-20231109200554739.png" alt="image-20231109200554739"></p><blockquote><p><strong>「定义5.6」</strong> 扩充二叉树的外通路长度定义为<strong>从根到每个外结点的路径长度之 和</strong>，内通路长度定义为从根到<strong>每个内结点的路径长度之和</strong>。</p></blockquote><p><img src="image-20231109200749078.png" alt="image-20231109200749078"></p><blockquote><p><strong>「定义5.7」</strong></p><p>给扩充二叉树的 n 个外结点分别赋上一个实数权。扩充二叉树 的加权外通路长度定义为:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mi>P</mi><mi>L</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>w</mi><mi>i</mi></msub><msub><mi>L</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">WPL=\sum\limits_{i=1}^{n}w_iL_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>其中 n 表示外结点的个数，wi 和 Li 分别 表示外结点 ki的权值和根到 ki的路径长度。</p></blockquote><p><img src="image-20231109201819723.png" alt="image-20231109201819723"></p><blockquote><p><strong>「定义5.8」</strong></p><p>在外结点权值分别为 w1 , w2 , … , wn的所有扩充二叉树中，加权外通路长度最小的扩充二叉树称为最优二叉树</p></blockquote><p><img src="image-20231109201854960.png" alt="image-20231109201854960"></p><p><strong>构造哈夫曼树</strong></p><p><strong>「算法思想」</strong></p><p><img src="image-20231109202023891.png" alt="image-20231109202023891"></p><p><img src="image-20231109202220497.png" alt="image-20231109202220497"></p><p><img src="image-20231109202410225.png" alt="image-20231109202410225"></p><blockquote><p>在外结点权值分别为w1 ,w2 ,…,wn的扩充二叉树中，由哈 夫曼算法构造出的哈夫曼树的带权路径长度最小，因此哈夫曼树为<strong>最优二叉树</strong>。</p></blockquote><blockquote><p>由观察可知，字符集中的字符所在的结点均是哈夫曼树中的外结点。哈夫曼树中<strong>没有度为 1 的结点</strong></p></blockquote><blockquote><p>在构造哈夫曼树的过程中，没有一片树叶是其他树叶的 祖先，所以**每个叶结点对应的编码不可能是其他叶结点 对应的编码的前缀，**由此可知哈夫曼编码是二进制的前缀码。</p></blockquote><p><strong>「代码实现」</strong></p><p><img src="image-20231109203436647.png" alt="image-20231109203436647"></p><p>假设给定m个实数（代表权值）对应结点的地址存于一维数组H[1:  m+1]中，该数组已按结点的Weight域排序，即：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">(</mo><mi>H</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>≤</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>≤</mo><mi>W</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">(</mo><mi>H</mi><mo stretchy="false">[</mo><mi>m</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>≤</mo><mi>W</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>l</mi><mi>e</mi><mi>q</mi><mo>≤</mo><mo>+</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">Weight(H[1])\leq..\leq  Weight(H[m])\leq  Weightleq\leq +\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">∞</span></span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HuffmanTreeNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HuffmanTreeNode</span>* Llink;</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line"><span class="comment">//也可以加一个info字段代表是什么字符</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HuffmanTreeNode</span>* Rlink;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HuffmanTreeNode</span>* <span class="built_in">createHuffmanTree</span>(<span class="type">int</span>* arr, <span class="type">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> root;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HuffmanTreeNode</span>* H = <span class="keyword">new</span> <span class="keyword">struct</span> HuffmanTreeNode[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= size - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">H[i].Llink = <span class="literal">NULL</span>;</span><br><span class="line">H[i].Rlink = <span class="literal">NULL</span>;</span><br><span class="line">H[i].weight = arr[i];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= size - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HuffmanTreeNode</span> tmp;</span><br><span class="line">tmp.weight = H[i].weight + H[i + <span class="number">1</span>].weight;</span><br><span class="line">tmp.Llink = &amp;H[i];</span><br><span class="line">tmp.Rlink = &amp;H[i + <span class="number">1</span>];</span><br><span class="line"><span class="comment">//插入排序，将tmp插入原来的序列并保持有序</span></span><br><span class="line">root = i + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (tmp.weight &gt; H[root].weight)</span><br><span class="line">&#123;</span><br><span class="line">H[root - <span class="number">1</span>] = H[root];</span><br><span class="line">root++;</span><br><span class="line">&#125;</span><br><span class="line">H[root - <span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;H[root];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20231109211156143.png" alt="image-20231109211156143"></p><p><img src="image-20231109211225493.png" alt="image-20231109211225493"></p><p><strong>PTA</strong></p><blockquote><p>编写一个哈夫曼编码译码程序。针对一段文本，根据文本中字符出现频率构造哈夫曼树，给出每个字符的哈夫曼编码，并进行译码，计算编码前后文本大小。<br>为确保构建的哈夫曼树唯一，本题做如下限定：</p><ol><li>选择根结点权值最小的两棵二叉树时，选取<strong>权值较小者作为左子树</strong>。</li><li>若多棵二叉树根结点权值相等，则<strong>先生成的作为左子树</strong>，后生成的作为右子树，具体来说：i) 对于单结点二叉树，优先选择根结点对应字母在文本中最先出现者，如文本为cba，三个字母均出现1次，但c在文本中最先出现，b第二出现，故则选择c作为左子树，b作为右子树。ii) 对于非单结点二叉树，先生成的二叉树作为左子树，后生成的二叉树作为右子树。iii. 若单结点和非单结点二叉树根结点权值相等，优先选择单结点二叉树。</li><li>生成哈夫曼编码时，哈夫曼树<strong>左分支标记为0，右分支标记为1</strong>。</li></ol><p><strong>输入格式:</strong></p><p>输入为3行。第1行为一个字符串，包含不超过5000个字符，至少包含两个不同的字符，每个字符为a-z的小写字母。第2、3行为两个由0、1组成的字符串，表示待译码的哈夫曼编码。</p><p><strong>输出格式:</strong></p><p>输出第一行为用空格间隔的2个整数，分别为压缩前后文本大小，以字节为单位，一个字符占1字节，8个二进制位占1字节，若压缩后文本不足8位，则按1字节算。输出从第二行开始，每行为1个字符的哈夫曼编码，按各字符在文本中出现次数递增顺序输出，若多个字符出现次数相同，则按其在文本出现先后排列。每行格式为“字母:编码”。最后两行为两行字符串，表示译码结果，若译码失败，则输出INVALID。</p><p><strong>输入样例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cbaxyyzz</span><br><span class="line">0100</span><br><span class="line">011</span><br></pre></td></tr></table></figure><p><strong>输出样例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">8 3</span><br><span class="line">c:100</span><br><span class="line">b:101</span><br><span class="line">a:110</span><br><span class="line">x:111</span><br><span class="line">y:00</span><br><span class="line">z:01</span><br><span class="line">zy</span><br><span class="line">INVALID</span><br></pre></td></tr></table></figure></blockquote><h2 id="树的存储与操作">树的存储与操作</h2><p>略</p><p>待更新</p><h2 id="等价类与并查集">等价类与并查集</h2><p><img src="image-20231109211344638.png" alt="image-20231109211344638"></p><p>学习途径：<a href="https://zhuanlan.zhihu.com/p/93647900">并查集——Pecco    知乎详解</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>* left;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>* right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DSU</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; parent;<span class="comment">//一开始，我们先将它们的父节点设为自己</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; rank; <span class="comment">//每个节点对应的树的高度，初值为1</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">DSU</span>(<span class="type">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">parent.<span class="built_in">resize</span>(size + <span class="number">1</span>);</span><br><span class="line">rank.<span class="built_in">resize</span>(size + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size + <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">parent[i] = i;</span><br><span class="line">rank[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">// 寻找x所在的树的根节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (parent[x] == x)<span class="comment">//自己就是父节点即找到了根节点则返回</span></span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">parent[x] = <span class="built_in">find</span>(parent[x]);<span class="comment">//找父亲的父节点</span></span><br><span class="line"><span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">find</span>(i), y = <span class="built_in">find</span>(j);</span><br><span class="line"><span class="keyword">if</span> (rank[x] &lt;= rank[y]) <span class="comment">//x高度低于y或相等时，把i挂在j的树上</span></span><br><span class="line">&#123;</span><br><span class="line">parent[x] = y;<span class="comment">//i所在树的根节点x 的父节点是j所在树的根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">parent[y] = x;<span class="comment">//j所在树的根节点的父节点是i所在树的根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rank[x] == rank[y] &amp;&amp; x != y) <span class="comment">//如果高度相等并且 i和j所在的树不相同 则j的树高度要加一</span></span><br><span class="line">&#123;</span><br><span class="line">rank[y]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="图">图</h1><h2 id="存储结构">存储结构</h2><h3 id="邻接矩阵">邻接矩阵</h3><p><img src="image-20231112090728805.png" alt="image-20231112090728805"></p><p><img src="image-20231112090748991.png" alt="image-20231112090748991"></p><p><img src="image-20231112090816704.png" alt="image-20231112090816704"></p><blockquote><p>无向图的邻接矩阵对称，可压缩存储；有n个顶点的无向图所需存储空间为n(n+1)/2；</p><p>有向图的邻接矩阵不一定对称；有n个顶点的有向图所需存储空间为n²</p></blockquote><h3 id="邻接表">邻接表</h3><p><img src="image-20231112091633952.png" alt="image-20231112091633952"></p><blockquote><p>边链表里VerAdj是与顶点相连的节点编号，cost是权值，link指向下一个与顶点相连的节点</p></blockquote><blockquote><p>VerName是顶点名字，adjacent指向与其相连的节点链表</p></blockquote><p><img src="image-20231112091849162.png" alt="image-20231112091849162"></p><p><img src="image-20231112091952212.png" alt="image-20231112091952212"></p><blockquote><p>对于边很多的图（也称稠密图），适于用邻接矩阵存储，因为占用的空间少。</p><p>而对于顶点多而边少的图（也称稀疏图），若用邻接矩阵存储， 对应的邻接矩阵将是一个稀疏矩阵，存储利用率很低。因此，顶点多而边少的图适于用邻接表存储</p></blockquote><h3 id="其他存储结构">其他存储结构</h3><p><img src="image-20231112092304534.png" alt="image-20231112092304534"></p><p><img src="image-20231112092317950.png" alt="image-20231112092317950"></p><h2 id="图的遍历">图的遍历</h2><p><a href="https://www.luogu.com.cn/problem/P3916">图的遍历 洛谷</a></p><h3 id="深度优先遍历">深度优先遍历</h3><p><strong>递归算法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> VerAdj;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>* link;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> name;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>* adjacent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DepthFirstSearch</span><span class="params">(<span class="keyword">struct</span> Node* head,<span class="type">int</span> v,<span class="type">int</span>* visit,<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; head[v].name&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">visit[v] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>* p = head[v].adjacent;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (visit[p-&gt;VerAdj] != <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DepthFirstSearch</span>(head, p-&gt;VerAdj, visit, size);</span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;link;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">struct</span> Node* head,<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* visited=<span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= size<span class="number">-1</span>; i++) visited[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= size<span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (visited[i] != <span class="number">0</span>)</span><br><span class="line"><span class="built_in">DepthFirstSearch</span>(head, i, visited, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20231112165358070.png" alt="image-20231112165358070"></p><p><strong>迭代算法</strong></p><p>利用栈进行访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> VerAdj;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span>* link;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> name;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span>* adjacent;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">struct</span> Node* head, <span class="type">int</span> size,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* visited = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; ss;</span><br><span class="line">    ss.<span class="built_in">push</span>(v);</span><br><span class="line">    <span class="keyword">while</span> (!ss.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Node</span> p = head[ss.<span class="built_in">top</span>()];</span><br><span class="line">        <span class="keyword">if</span> (visited[p.name] != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; p.name &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            visited[p.name] = <span class="number">1</span>;</span><br><span class="line">            ss.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">edge</span>* q = p.adjacent;</span><br><span class="line">            <span class="keyword">while</span> (q != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited[q-&gt;VerAdj] != <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ss.<span class="built_in">push</span>(q-&gt;VerAdj);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                q = q-&gt;link;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20231112175225401.png" alt="image-20231112175225401"></p><h3 id="广度优先遍历">广度优先遍历</h3><p>使用<strong>队列</strong>实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> VerAdj;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span>* link;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> name;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span>* adjacent;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">struct</span> Node* head, <span class="type">int</span> size, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* visited = <span class="keyword">new</span> <span class="type">int</span>[size + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= size; i++)  visited[i] = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">    cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    list.<span class="built_in">push</span>(v);</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!list.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">edge</span>* p = head[list.<span class="built_in">front</span>()].adjacent;</span><br><span class="line">        list.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[p-&gt;VerAdj] != <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; p-&gt;VerAdj &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                visited[p-&gt;VerAdj] = <span class="number">1</span>;</span><br><span class="line">                list.<span class="built_in">push</span>(p-&gt;VerAdj);</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20231112181329874.png" alt="image-20231112181329874"></p><p><img src="image-20231112181406328.png" alt="image-20231112181406328"></p><p><img src="image-20231112181546799.png" alt="image-20231112181546799"></p><h2 id="拓扑排序">拓扑排序</h2><blockquote><p><strong>AOV</strong>网：<strong>在有向图中</strong>，用顶点表示活动，用有向边表示活动之间的<strong>先后关系</strong>，称这样的有向图为AOV网(Activity On Vertex Network)。重点在于研究结点Verterx</p></blockquote><blockquote><p>在AOV网络中，如果活动Vi 必须在活动Vj 之前进行，则存在有向边，**AOV网络中不能出现有向回路，**即有向环。 在AOV网络中如果出现了有向环，则意味着某项活动应以自己作为先决条件。 因此，对给定的AOV网络，应判断它是否存在有向环</p></blockquote><p><img src="image-20231112182247852.png" alt="image-20231112182247852"></p><blockquote><p>如果通过拓扑排序能将AOV网络的所有顶点都排入一个拓扑有序的序列中，则该AOV网络中必定不会出现有向环；<strong>相反，如果得不到满足要求的拓扑有序序列，则说明AOV网络中存在有向环</strong>， 此AOV网络所代表的工程是不可行的</p></blockquote><p><strong>「算法思想」</strong></p><ol><li>从网中选择一个入度为0的顶点并将其输出。</li><li>从网中删除该顶点及其所有出边。</li><li>执行1 、2 ，直至所有顶点都已输出，或者网中剩余顶点的度均不为0（说明网中存在回路，无法继续拓扑排序）。</li></ol><p><strong>注意：对于任何无回路的AOV网，其顶点均可排成拓扑序列，但其拓扑序列未必唯一</strong></p><p><img src="image-20231114200441806.png" alt="image-20231114200441806"></p><p><img src="image-20231114200505007.png" alt="image-20231114200505007"></p><p><img src="image-20231114200610199.png" alt="image-20231114200610199"></p><p><strong>入栈时：count[i]记录当前的栈顶，top赋值为新的栈顶</strong></p><p><strong>出栈时：top即为栈顶的编号，count[top]为栈顶下面的元素编号</strong></p><p><strong>实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TopoOrder</span><span class="params">(<span class="keyword">struct</span> Node* Head,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* count = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n<span class="number">-1</span>; i++)<span class="comment">//初始化count数组</span></span><br><span class="line">&#123;</span><br><span class="line">count[n] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i++)<span class="comment">//初始化count数组</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>* p = Head[i].adjacent;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">count[p-&gt;VerAdj]++;</span><br><span class="line">p = p-&gt;link;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> top = <span class="number">-1</span>; <span class="comment">// 将数组变成虚拟栈</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (count[i] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">count[i] = top;</span><br><span class="line">top=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i++)<span class="comment">//已经无 有向环 的前提下</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (top == <span class="number">-1</span>) <span class="keyword">return</span> ;<span class="comment">//无度为0的结点</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp = <span class="number">-1</span>;</span><br><span class="line">temp = top;</span><br><span class="line">top = count[top];</span><br><span class="line">std::cout &lt;&lt; temp&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>* p = Head[temp].adjacent;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)<span class="comment">//更新count数组和虚拟栈</span></span><br><span class="line">&#123;</span><br><span class="line">count[p-&gt;VerAdj]--;</span><br><span class="line"><span class="keyword">if</span> (count[p-&gt;VerAdj] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">count[p-&gt;VerAdj] = top;</span><br><span class="line">top = p-&gt;VerAdj;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">                p = p-&gt;link;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习一：</strong></p><p><a href="https://leetcode.cn/problems/course-schedule/description/">课程表</a></p><p><strong>要注意判断是否有有向环</strong></p><p>官方题解：</p><p>一：深度优先搜索</p><p>深度优先搜索，将拓扑排序与深度优先搜索联系在一起，二者都是先完成前一个结点再完成后一个结点</p><blockquote><p>对于图中的任意一个节点，它在搜索的过程中有三种状态，即：</p><ul><li><p>「未搜索」：我们还没有搜索到这个节点；</p></li><li><p>「搜索中」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成；</p></li><li><p>「已完成」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的<strong>更底部的位置</strong>，满足拓扑排序的要求。</p></li></ul><p>通过上述的三种状态，我们就可以给出使用深度优先搜索得到拓扑排序的算法流程，在每一轮的搜索搜索开始时，我们任取一个「未搜索」的节点开始进行深度优先搜索。</p><ul><li><p>我们将当前搜索的节点 u 标记为「搜索中」，遍历该节点的每一个相邻节点 v：</p></li><li><p>​    如果 v为「未搜索」，那么我们开始搜索 v，待搜索完成回溯到 u；</p></li><li><p>​    如果 v为「搜索中」，那么我们就找到了图中的一个环，因此是不存在拓扑排序的；</p></li><li><p>​    如果 v为「已完成」，那么说明 v已经在栈中了，而 u还不在栈中，因此 u 无论何时入栈都不会影响到 (u,v) 之前的拓扑关系，以及不用进行任何操作。</p></li><li><p>当 u 的所有相邻节点都为「已完成」时，我们将 u 放入栈中，并将其标记为「已完成」。</p></li></ul><p>在整个深度优先搜索的过程结束后，如果我们没有找到图中的环，那么栈中存储这所有的 n个节点，从栈顶到栈底的顺序即为一种拓扑排序。</p></blockquote><blockquote><p><strong>优化</strong></p><p>由于我们只需要判断是否存在一种拓扑排序，而栈的作用仅仅是存放最终的拓扑排序结果，因此我们可以只记录每个节点的状态，而省去对应的栈。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; visited;</span><br><span class="line">    <span class="type">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        visited[u] = <span class="number">1</span>;<span class="comment">//将本结点标记为搜索中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v: edges[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>)</span><br><span class="line">            &#123;<span class="comment">//如果邻接结点未搜索，则开始搜索</span></span><br><span class="line">                <span class="built_in">dfs</span>(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;<span class="comment">//搜索完V发现有环，结束,上面几层均是结束</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;<span class="comment">//如果结点在搜索中存在环，记录并返回</span></span><br><span class="line">                valid = <span class="literal">false</span>;<span class="comment">//记录</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//不存在环则邻接结点完全搜索完，将本结点标记</span></span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">resize</span>(numCourses);<span class="comment">//初始化边结点的数目</span></span><br><span class="line">        visited.<span class="built_in">resize</span>(numCourses);<span class="comment">//初始化访问标记的数目</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;<span class="comment">//结点状态为0则开始搜索</span></span><br><span class="line">                <span class="built_in">dfs</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/course-schedule/description/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>二：广度优先搜索</p><p>这个方法类似与课本上的解法，只不过是用队列进行实现。</p><p><strong>重点是判断能否产生拓扑序列</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; indeg;<span class="comment">//入度记录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        indeg.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]);</span><br><span class="line">            ++indeg[info[<span class="number">0</span>]];<span class="comment">//更新入度表</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;<span class="comment">//建立度为0的队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> visited = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;<span class="comment">//计算可以去掉的结点有多少个</span></span><br><span class="line">            ++visited;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v: edges[u]) &#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> visited == numCourses;<span class="comment">//如果全可以去掉则不存在有向环则可以产生拓扑序列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/course-schedule/description/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>练习二：</p><p><a href="https://leetcode.cn/problems/course-schedule-ii/description/">课程表二</a></p><h2 id="关键路径">关键路径</h2><blockquote><p>如果在<strong>有向无环</strong>的<strong>带权</strong>图中 ：</p><ul><li>用有向边表示一个工程中的各项活动(Activity) •</li><li>用边上的权值表示活动的持续时间(Duration)</li><li>用顶点表示事件(Event)</li></ul><p>则这样的有向图叫做用边表示活动的网络，简称AOE (Activity  On <strong>Edges</strong>)网络。</p></blockquote><blockquote><p>● 源点：表示整个工程的开始（入度为零）。</p><p>● 汇点：表示整个工程的结束（出度为零）</p></blockquote><p><img src="image-20231115170037611.png" alt="image-20231115170037611"></p><blockquote><p>在AOE网络中, 有些活动必须顺序进行，有些活动可以并行进行。</p><p>从源点到各个顶点，以至从源点到汇点的有向路径可能不止一条。 这些路径的长度也可能不同。完成不同路径的活动所需的时间虽 然不同，但<strong>只有各条路径上的所有活动都完成了，整个工程才算完成</strong>。</p><p>因此，<strong>完成整个工程所需的时间</strong>取决于从源点到汇点的最长路径长度，<strong>即路径上所有活动的持续时间之和</strong>。路径长度最长的路径被称为<strong>关键路径</strong>(Critical Path)。</p></blockquote><p><img src="image-20231115170628128.png" alt="image-20231115170628128"></p><p><img src="image-20231115172253166.png" alt="image-20231115172253166"></p><p><img src="image-20231115172306261.png" alt="image-20231115172306261"></p><p><strong>事件——结点</strong></p><p>最早事件<strong>发生</strong>时间 ve(i) 源点到i点的最长路径长度，即前一个邻接结点的ve加上路径权值最大的那一个</p><p>最晚事件<strong>发生</strong>时间 vl(i)  即后一个邻接结点的vl减去路径权值取最小的那一个，即减去了<strong>时间最长的活动</strong>（“关键活动”）的时长</p><p><strong>活动——边</strong></p><p>最早活动<strong>开始</strong>时间 e(i)</p><p>最晚活动<strong>开始</strong>时间 e(i)</p><p><strong>「算法」</strong></p><ol><li><strong>判断是否存在有向环</strong>，通过拓扑排序进行判断，如果有有向环则中止算法，如果没有，则<strong>按照拓扑排序的顺序</strong>求出各个事件的最早发生时间ve</li><li>按照拓扑排序的<strong>逆序列</strong>求出每个事件的最晚发生事件vl</li><li>根据ve和vl确定活动的最早开始时间e(i)和最晚开始时间l(i)，如果<strong>二者相等则为关键活动</strong></li></ol><p><strong>「实现」</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> name;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span>* link;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> Veradj;</span><br><span class="line">    <span class="type">int</span> cost;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span>* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AOE</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>* Head;<span class="comment">//经过拓扑排序后的结点序列</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    vector&lt;<span class="keyword">struct</span> edge&gt; critical;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">criticalPath</span><span class="params">(<span class="keyword">struct</span> Node* Head, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//求关键路径之前先判断是否存在有向环，不存在则将结点按拓扑排序排好送入Head</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ve</span><span class="params">(num)</span>, <span class="title">vl</span><span class="params">(num)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= num - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ve[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num - <span class="number">1</span>; i++)<span class="comment">//汇点不在范围内,因为没有出边</span></span><br><span class="line">        &#123;<span class="comment">//按拓扑序列进行计算</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">edge</span>* p = Head[i].link;</span><br><span class="line">            <span class="type">int</span> k = Head[i].name;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">NULL</span>)<span class="comment">//求事件最早happen时间</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;cost + ve[k] &gt; ve[p-&gt;Veradj])</span><br><span class="line">                &#123;</span><br><span class="line">                    ve[p-&gt;Veradj] = p-&gt;cost + ve[i];</span><br><span class="line">                &#125;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= num - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vl[i] = ve[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = num - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;<span class="comment">//求事件最晚发生时间</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">edge</span>* p = Head[i].link;</span><br><span class="line">            <span class="type">int</span> k = p-&gt;Veradj;</span><br><span class="line">            <span class="keyword">while</span> (p)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (vl[k] - p-&gt;cost &lt; vl[Head[i].name])</span><br><span class="line">                &#123;</span><br><span class="line">                    vl[Head[i].name] = vl[k] - p-&gt;cost;</span><br><span class="line">                &#125;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= num - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;<span class="comment">//求活动的最晚最早开始事件</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">edge</span>* p = Head[i].link;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>, e = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> k = p-&gt;Veradj;</span><br><span class="line">                e = ve[Head-&gt;name];</span><br><span class="line">                l = vl[k] - p-&gt;cost;</span><br><span class="line">                <span class="keyword">if</span> (e == l)<span class="comment">//相等即为关键活动</span></span><br><span class="line">                &#123;</span><br><span class="line">                    critical.<span class="built_in">push_back</span>(*p);</span><br><span class="line">                &#125;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>「时间复杂度」</strong></p><p><img src="image-20231115223943001.png" alt="image-20231115223943001"></p><blockquote><p>定理 6.3     任意的非空AOE网<strong>至少</strong>存在一条关键路径。</p></blockquote><blockquote><p>推论 6.1     假设&lt;Ti,Tj&gt;边属于AOE网，则有</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi>l</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>−</mo><mi>v</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>≥</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">(</mo><mo>&lt;</mo><mi>T</mi><mi>i</mi><mo separator="true">,</mo><mi>T</mi><mi>j</mi><mo>&gt;</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">vl[j]-ve[i]\geq weight(&lt;Ti,Tj&gt;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span></span></span></span></span></p><p>如果属于关键路径则：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi>l</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>−</mo><mi>v</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">(</mo><mo>&lt;</mo><mi>T</mi><mi>i</mi><mo separator="true">,</mo><mi>T</mi><mi>j</mi><mo>&gt;</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">vl[j]-ve[i]= weight(&lt;Ti,Tj&gt;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span></span></span></span></span></p></blockquote><h2 id="最短路径问题">最短路径问题</h2><p><a href="https://www.luogu.com.cn/training/5312#problems">洛谷最短路径问题题单</a></p><h3 id="单源最短路径">单源最短路径</h3><p><strong>单源：即只有一个出发点</strong></p><p><strong>1.无权最短路径</strong></p><blockquote><p>无权：即每条边的权值都为1</p></blockquote><blockquote><p>源点到各顶点的路径<strong>所经历的边的数目</strong>就是路径的长度</p><p>相对于源点<strong>由近及远</strong>依次求各顶点的最短路径</p></blockquote><p><strong>「算法思想」</strong></p><blockquote><p>Di 为源点S到顶点 i 的最短路径长度;初始：Ds =0 ∀i ≠ S，Di = -1</p><ol><li>访问初始顶点S，对S的所有邻接顶点w, 若Dw = -1，则Dw =Ds+1</li><li>v是当前被访问的顶点，对于v的所有邻接顶点w, 若Dw = -1，则 Dw =Dv +1</li><li>处理完v的所有邻接顶点后，访问另一个满足Du =Dv的顶点u，若不存 在这样的顶点，则访问满足Du =Dv +1的顶点u，若仍不存在，算法结束.</li></ol></blockquote><p><strong>图的广度优先遍历。</strong></p><p><img src="image-20231116163259067.png" alt="image-20231116163259067"></p><p><img src="image-20231116163444506.png" alt="image-20231116163444506"></p><p><strong>「实现」</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">noValueMap</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;<span class="keyword">struct</span> Node&gt;Head;<span class="comment">//邻接表的首节点</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; list;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShortestPath</span><span class="params">(<span class="type">int</span> v)</span><span class="comment">//v是起点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">path</span><span class="params">(Head.size())</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(Head.size())</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= Head.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">path[i] = <span class="number">-1</span>;</span><br><span class="line">dist[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">dist[v] = <span class="number">0</span>;</span><br><span class="line">list.<span class="built_in">push</span>(v);</span><br><span class="line"><span class="keyword">while</span> (!list.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tmp = list.<span class="built_in">front</span>();</span><br><span class="line">list.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>* p = Head[tmp].adjacent;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> k = p-&gt;VerAdj;</span><br><span class="line"><span class="keyword">if</span> (dist[k] == <span class="number">-1</span>)<span class="comment">//没被访问过</span></span><br><span class="line">&#123;</span><br><span class="line">dist[k] = dist[tmp]+<span class="number">1</span>;</span><br><span class="line">list.<span class="built_in">push</span>(k);</span><br><span class="line">path[k] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;link;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>「复杂度」</strong></p><p><img src="image-20231116165054100.png" alt="image-20231116165054100"></p><p><strong>2.正权最短路径</strong></p><p><strong>「前提」</strong></p><p><strong>每条边的权值为正数</strong></p><p><img src="image-20231116165552262.png" alt="image-20231116165552262"></p><p><strong>迪杰斯特拉算法</strong></p><p><strong>「算法思想」</strong></p><blockquote><p>把图中所有顶点分成两个集合，</p><p>​第一个集合 包含已确定最短路径的顶点，</p><p>​第二个集合 包含尚未确定最短路径的顶点。</p><p>按照<strong>最短路径长度递增</strong>的顺序逐 个把第二个集合的顶点加到第一个集合中去，直至从源点出发可以到达的所有顶点都包含到第一个集合中</p></blockquote><blockquote><p>步骤：</p><ol><li>初始时( S为初始顶点） D[s] =0 (<strong>起点的距离</strong>为0)且∀ i ≠ S 有D[ i ] =MAX(无穷，根据题目换成权值的最大值+1)。</li><li>在未访问的顶点中选择<strong>D值最小</strong>的顶点v，访问v，令 S[v]=1（表示已被访问）。</li><li>依次考察v的<strong>邻接顶点</strong>w，若 D[ v ]+weight(&lt;v，w&gt;) &lt; Dw ， 则改变Dw的值，使Dw = Dv + weight(&lt;v，w&gt;) 。</li><li>重复 2、3，直至所有顶点皆被访问（找到源点到该顶点的最短路径）</li></ol></blockquote><p><img src="image-20231119105737954.png" alt="image-20231119105737954"></p><p><strong>「实现」</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> VerAdj;</span><br><span class="line"><span class="type">int</span> cost;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>* link;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> name;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>* adjacent;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PositiveValuePath</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;<span class="keyword">struct</span> Node&gt; Head;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dist;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> Max = <span class="number">1000</span>;<span class="comment">//取决于题目权值的约束条件，一定要比最大值大</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DshortsPath</span><span class="params">(<span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dist.<span class="built_in">resize</span>(Head.<span class="built_in">size</span>());</span><br><span class="line">path.<span class="built_in">resize</span>(Head.<span class="built_in">size</span>());</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(Head.size())</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= Head.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">dist[i] = Max;</span><br><span class="line">path[i] = <span class="number">-1</span>;</span><br><span class="line">visited[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">dist[start] = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> next = start;</span><br><span class="line">visited[next] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= Head.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>* p = Head[next].adjacent;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> k = p-&gt;VerAdj;</span><br><span class="line"><span class="keyword">if</span> (visited[k] == <span class="number">0</span> &amp;&amp; dist[next] + p-&gt;cost &lt; dist[k])</span><br><span class="line">&#123;</span><br><span class="line">dist[k] = dist[next] + p-&gt;cost;</span><br><span class="line">path[k] = next;<span class="comment">//在源点到k点的最短路中，k的上一个节点是next</span></span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;link;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> min = Max;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= Head.<span class="built_in">size</span>() - <span class="number">1</span>; i++)<span class="comment">//更新next，在未访问节点中选取距离最近的节点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dist[i] &lt; min &amp;&amp; visited[i] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">next = i;</span><br><span class="line">min = dist[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">visited[next] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="image-20231119111932519.png" alt="image-20231119111932519"></p><p><strong><u>算法结束时</u>，dist[x]将包括所有最短路径的长度。</strong></p><p><strong>「练习」</strong></p><p><a href="https://leetcode.cn/problems/network-delay-time/description/">网络延迟时间</a></p><p><img src="image-20231119122232538.png" alt="image-20231119122232538"></p><p>对于<strong>稀疏图</strong>，即边的个数远小于点的个数时，<strong>时间效率不高</strong>，可以采用<strong>优先队列</strong>进行改进。</p><p>优先队列相关内容见线性表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DshortsPath</span><span class="params">(<span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; plist;</span><br><span class="line">       <span class="comment">//优先队列，按照piar的第一个数据升序排列</span></span><br><span class="line">dist[start] = <span class="number">0</span>;</span><br><span class="line">plist.<span class="built_in">push</span>(&#123; <span class="number">0</span>,start &#125;);<span class="comment">//&lt;距离，节点号&gt;</span></span><br><span class="line"><span class="type">int</span> node_size = date.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span> (plist.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> t = plist.<span class="built_in">top</span>();</span><br><span class="line">plist.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">int</span> tindex = t.second, distance = t.first;</span><br><span class="line"><span class="keyword">if</span> (visited[tindex])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">visited[tindex] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EDGE</span>* p = date[tindex].next;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> index = p-&gt;adj_index;</span><br><span class="line"><span class="keyword">if</span> (!visited[index] &amp;&amp; dist[tindex] + p-&gt;val &lt; dist[index])</span><br><span class="line">&#123;</span><br><span class="line">dist[index] = dist[tindex] + p-&gt;val;</span><br><span class="line">plist.<span class="built_in">push</span>(&#123; dist[index],index &#125;);<span class="comment">//将求过距离的节点放入优先队列中排序，以便生成下次访问的节点</span></span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; node_size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dist[i] != Max)<span class="comment">//可以到达</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, dist[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="每对顶点之间的最短路径">每对顶点之间的最短路径</h3><p><strong>Floyd算法</strong></p><p><strong>「基本思想」</strong></p><p><img src="image-20231121215600271.png" alt="image-20231121215600271"></p><p><img src="image-20231121220114159.png" alt="image-20231121220114159"></p><p><img src="image-20231121220247584.png" alt="image-20231121220247584"></p><p><strong>「实现」</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myMap</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edge;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dist;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> MAX ;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AllLength</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">A</span>(edge.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;=edge.<span class="built_in">size</span>()<span class="number">-1</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= edge.<span class="built_in">size</span>() - <span class="number">1</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                A[i][j] = edge[i][j];</span><br><span class="line">                <span class="keyword">if</span> (edge[i][j] &lt; MAX &amp;&amp; i != j) path[i][j] = i;<span class="comment">//i到j的路上前一个节点是i</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    path[i][j] = <span class="number">-1</span>;<span class="comment">//无路可走</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= edge.<span class="built_in">size</span>() - <span class="number">1</span>; k++)<span class="comment">//不断添加经过的范围</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= edge.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j&lt;= edge.<span class="built_in">size</span>() - <span class="number">1</span>; j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (j != k &amp;&amp; j != i &amp;&amp; A[i][k] &lt; MAX &amp;&amp; A[k][j] &lt; MAX &amp;&amp; A[i][k] + A[k][j] &lt; A[i][j])</span><br><span class="line">                            <span class="comment">//i到k可及，k到j可及</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            A[i][j] = A[i][k] + A[k][j];</span><br><span class="line">                            path[i][j] = path[k][j];<span class="comment">//i经由k到j的路上前一个节点是 k到j上的前一个节点</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> myMap::MAX = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p><strong>「复杂度」</strong></p><p><img src="image-20231121222347936.png" alt="image-20231121222347936"></p><p><strong>「练习」</strong></p><p><a href="https://leetcode.cn/problems/evaluate-division/description/?utm_source=LCUS&amp;utm_medium=ip_redirect&amp;utm_campaign=transfer2china">力扣 除法求值</a></p><h3 id="满足约束的最短路径">*满足约束的最短路径</h3><p><img src="image-20231125110927125.png" alt="image-20231125110927125"></p><p><strong>「算法思路」</strong></p><p><img src="image-20231125111316497.png" alt="image-20231125111316497"></p><p><img src="image-20231125112146476.png" alt="image-20231125112146476"></p><p><img src="image-20231125112206584.png" alt="image-20231125112206584"></p><h2 id="最小支撑树">最小支撑树</h2><blockquote><p>对于一个无向网络——无向加权连通图N=(V, E, C)（C表示该图为 权图），其顶点个数为|V|=n，图中边的个数为|E|，可以从它的|E|条边 中选出n-1条边，使之满足：</p><p>(1) 这n-1条边和图的n个顶点构成一个连通图。</p><p>(2) 该连通图的代价（n-1条边上的权值之和）是所有满足条件(1)的 连通图的代价的最小值。</p><p>这样的连通图被称为网络的最小支撑树</p></blockquote><p><img src="image-20231125112342879.png" alt="image-20231125112342879"></p><h3 id="prim算法">Prim算法</h3><p><strong>「算法思路」</strong></p><p><img src="image-20231125112558260.png" alt="image-20231125112558260"></p><p>​<img src="image-20231125144316659.png" alt="image-20231125144316659"></p><p><strong>「实现」</strong></p><p>假定编号从1开始</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">EDGE</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> head;</span><br><span class="line"><span class="type">int</span> tail;</span><br><span class="line"><span class="type">int</span> cost;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myMap</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> MAX;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adjcent;<span class="comment">//邻接矩阵</span></span><br><span class="line">vector&lt;<span class="keyword">struct</span> EDGE&gt; TE;<span class="comment">//最小支撑树边的集合</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prim</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TE.<span class="built_in">resize</span>(adjcent.<span class="built_in">size</span>());</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">closedge</span>(adjcent.<span class="built_in">size</span>());<span class="comment">//lowcost vex 权值和U中的顶点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= adjcent.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">closedge[i].first = adjcent[<span class="number">1</span>][i];<span class="comment">// 初始状态U中只有起点1</span></span><br><span class="line">closedge[i].second = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">closedge[<span class="number">1</span>].second = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= adjcent.<span class="built_in">size</span>(); j++)<span class="comment">//有n个点，n-1条边加入TE</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> v = <span class="number">0</span>, min = MAX;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= adjcent.<span class="built_in">size</span>(); i++)<span class="comment">//找最短的</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (closedge[i].second != <span class="number">-1</span> &amp;&amp; closedge[i].first &lt; min)</span><br><span class="line">&#123;</span><br><span class="line">v = i;</span><br><span class="line">min = closedge[i].first;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (v != <span class="number">0</span>)<span class="comment">//找到了</span></span><br><span class="line">&#123;</span><br><span class="line">TE[count].head = closedge[v].second;</span><br><span class="line">TE[count].tail = v;</span><br><span class="line">TE[count].cost = closedge[v].first;</span><br><span class="line">count++;</span><br><span class="line">closedge[v].first = <span class="number">0</span>;<span class="comment">//v is putted in group U</span></span><br><span class="line">closedge[v].second = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= adjcent.<span class="built_in">size</span>(); k++)<span class="comment">//更新closedge数组</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (closedge[k].second != <span class="number">-1</span> &amp;&amp; adjcent[v][k] &lt; closedge[k].first)</span><br><span class="line">&#123;</span><br><span class="line">closedge[k].first = adjcent[v][k];</span><br><span class="line">closedge[k].second = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//图不连通</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;NOT CONNECTED&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> myMap::MAX = <span class="number">100</span>;<span class="comment">/////</span></span><br></pre></td></tr></table></figure><p><strong>注意MAX的值一定要大于边界条件</strong></p><p><img src="image-20231125163221574.png" alt="image-20231125163221574"></p><p><strong>「练习」</strong></p><p><a href="https://leetcode.cn/problems/min-cost-to-connect-all-points/description/">力扣 连接所有点的最小费用</a></p><h3 id="kruskal算法">Kruskal算法</h3><p><strong>「算法思路」</strong></p><p><img src="image-20231125162612696.png" alt="image-20231125162612696"></p><p><s>Prim是重点在于已知一个点在U中找与其相邻的最小权值边，而Kruskal算法在于已知所有点在不同的连通分量里找权值最小的边</s></p><p><img src="image-20231125162944745.png" alt="image-20231125162944745"></p><p><img src="image-20231125163134781.png" alt="image-20231125163134781"></p><p><strong>「实现」</strong></p><p>依旧要借用辅助数组TE来记录支撑树的边,还要由数组E保存图中的边</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">EDGE</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> head;</span><br><span class="line"><span class="type">int</span> tail;</span><br><span class="line"><span class="type">int</span> cost;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myMap</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> T;<span class="comment">//连通分量，初识也是点的个数</span></span><br><span class="line">vector&lt;EDGE&gt; E;<span class="comment">//图中所有边集合</span></span><br><span class="line">vector&lt;<span class="keyword">struct</span> EDGE&gt; TE;<span class="comment">//最小支撑树边的集合</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(EDGE a, EDGE b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.cost &lt;= b.cost;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TE.<span class="built_in">resize</span>(E.<span class="built_in">size</span>());</span><br><span class="line">std::<span class="built_in">sort</span>(E.<span class="built_in">begin</span>(), E.<span class="built_in">end</span>(),cmp);</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (T &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> v1 = E[j].head;</span><br><span class="line"><span class="type">int</span> v2 = E[j].tail;</span><br><span class="line"><span class="type">int</span> cost = E[j].cost;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Find</span>(v1) != <span class="built_in">Find</span>(v2))<span class="comment">//不在一个连通分支中</span></span><br><span class="line">&#123;</span><br><span class="line">TE[count].head = v1;</span><br><span class="line">TE[count].tail = v2;</span><br><span class="line">TE[count].cost = cost;</span><br><span class="line">count++;</span><br><span class="line"><span class="built_in">merge</span>(v1, v2);</span><br><span class="line">T--;</span><br><span class="line">&#125;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="图的应用">图的应用</h2><h3 id="可及性与传递闭包">可及性与传递闭包</h3><p><strong>warshall算法</strong></p><p><strong>「基本概念」</strong></p><p><img src="image-20231125170212022.png" alt="image-20231125170212022"></p><blockquote><p><strong>沃尔肖（Warshall）算法：</strong><br>求有向图G可及矩阵的算法，递推公式如下：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mi>S</mi><msup><mi>M</mi><mrow><mo stretchy="false">(</mo><mi>K</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>W</mi><mi>S</mi><msup><mi>M</mi><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mspace width="1em"/><mi>O</mi><mi>R</mi><mspace width="1em"/><mo stretchy="false">(</mo><mi>W</mi><mi>S</mi><msup><mi>M</mi><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mspace width="1em"/><mi>A</mi><mi>N</mi><mi>D</mi><mspace width="1em"/><mi>W</mi><mi>S</mi><msup><mi>M</mi><mrow><mo stretchy="false">(</mo><mi>K</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mspace width="2em"/><mspace width="2em"/><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">WSM^{(K)}[i][j]=WSM^{(k-1)}[i][j]\quad OR\quad(WSM^{(k-1)}[i][k]\quad AND\quad WSM^{(K-1)}[k][j])\\ \qquad \qquad 1\leq k \leq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.188em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.188em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mspace" style="margin-right:2em;"></span><span class="mspace" style="margin-right:2em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></span></p><p>其中</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mi>S</mi><msup><mi>M</mi><mn>0</mn></msup><mo>=</mo><mi>A</mi><mspace width="1em"/><mo stretchy="false">(</mo><mtext>加上主对角线元素</mtext><mn>1</mn><mo stretchy="false">)</mo><mspace width="1em"/><mi>A</mi><mtext>是有向图</mtext><mi>G</mi><mtext>的邻接矩阵</mtext><mspace linebreak="newline"></mspace><mi>W</mi><mi>S</mi><msup><mi>M</mi><mrow><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mtext>表示定点</mtext><mi>i</mi><mtext>只经过顶点</mtext><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>k</mi><mtext>到达</mtext><mi>j</mi><mtext>的可及性</mtext></mrow><annotation encoding="application/x-tex">WSM^0 = A\quad (加上主对角线元素1) \quad A是有向图G的邻接矩阵\\WSM^{(k)}[i][j]表示定点i只经过顶点1,2,...,k到达j的可及性</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">加</span><span class="mord cjk_fallback">上</span><span class="mord cjk_fallback">主</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">角</span><span class="mord cjk_fallback">线</span><span class="mord cjk_fallback">元</span><span class="mord cjk_fallback">素</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">A</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">向</span><span class="mord cjk_fallback">图</span><span class="mord mathdefault">G</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">邻</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">矩</span><span class="mord cjk_fallback">阵</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.188em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">点</span><span class="mord mathdefault">i</span><span class="mord cjk_fallback">只</span><span class="mord cjk_fallback">经</span><span class="mord cjk_fallback">过</span><span class="mord cjk_fallback">顶</span><span class="mord cjk_fallback">点</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">达</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">及</span><span class="mord cjk_fallback">性</span></span></span></span></span></p></blockquote><p><strong>「实现」</strong></p><p><img src="image-20231130191358878.png" alt="image-20231130191358878"></p><p><img src="image-20231130192912825.png" alt="image-20231130192912825"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myMAP</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">Warshall</span>()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; wsm = A;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= A.<span class="built_in">size</span>() - <span class="number">1</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= A.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (wsm[i][k] = <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= A.<span class="built_in">size</span>() - <span class="number">1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">wsm[i][j] = wsm[i][j] + wsm[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> wsm;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>拓扑逆序算法</strong></p><p><strong>「算法思想」</strong></p><p><img src="image-20231130193447217.png" alt="image-20231130193447217"></p><p><img src="image-20231130193415347.png" alt="image-20231130193415347"></p><p>「实现」</p><p><img src="image-20231130194254569.png" alt="image-20231130194254569"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myMAP</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;Node&gt; head;<span class="comment">//图的邻接表已经按照拓扑序列排列过</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tranclo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; REACH;</span><br><span class="line">vector&lt;<span class="type">int</span> &gt; Breach;</span><br><span class="line">Breach.<span class="built_in">resize</span>(head.<span class="built_in">size</span>());</span><br><span class="line">REACH.<span class="built_in">resize</span>(head.<span class="built_in">size</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= head.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">Breach[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = head.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">Breach[i] = <span class="number">1</span>;</span><br><span class="line">REACH[i].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EDGE</span>* p = head[i].link;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = p-&gt;num;</span><br><span class="line"><span class="keyword">if</span> (Breach[j] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= REACH[j].<span class="built_in">size</span>() - <span class="number">1</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Breach[k] ==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">REACH[i].<span class="built_in">push_back</span>(k);</span><br><span class="line">Breach[k] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= head.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">Breach[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="连通分量">连通分量</h3><p><strong>「算法思想」</strong></p><p><img src="image-20231130202654827.png" alt="image-20231130202654827"></p><p><strong>在求出可及性的基础上进行计算，wsm[ i ] [ j ] =1&amp;&amp;wsm[ j ] [ i ]=1  成立即i和j在一个连通分量里。</strong></p><h1 id="排序">排序</h1><h2 id="基本概念和指标">基本概念和指标</h2><blockquote><p>关键字域（key）：排序依据</p><p>主关键词：如果在数据表中各个对象的关键词互不相同，这种关键词即主关键词。按照主关键词进行排序，排序的结果是唯一的。</p><p>次关键词：数据表中有些对象的关键词可能相同，这种关键词称为次关键词。按照次关键词进行排序，排序的结果不一定唯一</p></blockquote><blockquote><p>稳定性：对于一开始表中主关键词域相同的对象，排序前后相对顺序不变</p><p>排序的时间开销：即排序算法的时间复杂度，是衡量算法好坏的 最重要的标志，可用算法执行过程中关键词的比较次数与记录的 移动次数来衡量。</p></blockquote><blockquote><p>有些排序算法的时间复杂度受记录关键词序列初始排列及记录个数影响较大，此时，按最好情况、最坏情况及平均情况，分别估算比较次数和移动次数。</p><p>算法执行时所需的附加存储空间，是评价排序算法好坏的另外一 个指标</p></blockquote><p><img src="image-20231130203508041.png" alt="image-20231130203508041"></p><h2 id="插入排序">插入排序</h2><h3 id="直接插入排序">直接插入排序</h3><p><strong>「算法思想」</strong></p><p>将一个记录插入到已经排好序的有序表中，从而获得一个新的、记录数增加1的有序表。</p><p><strong>「实现」</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>「分析」</strong></p><p><img src="image-20231228185940386.png" alt="image-20231228185940386"></p><p><strong>「稳定性」</strong></p><p><strong>具有稳定性。</strong></p><p>「改进」</p><p>将<strong>顺序查找</strong>改为<strong>二分查找</strong>，构造二分/对半插入排序算法</p><p>也是个稳定的排序方法</p><h3 id="希尔排序">希尔排序</h3><p>对直接插入排序的改进</p><p><strong>「算法思想」</strong></p><p><img src="image-20231228190556468.png" alt="image-20231228190556468"></p><p><img src="image-20231228190623271.png" alt="image-20231228190623271"></p><p><img src="image-20231228190713082.png" alt="image-20231228190713082"></p><p><img src="image-20231228190809518.png" alt="image-20231228190809518"></p><p><strong>「实现」</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>「增量的取法」</strong></p><p><img src="image-20231228190906374.png" alt="image-20231228190906374"></p><p><strong>「复杂度」</strong></p><p><img src="image-20231228191037103.png" alt="image-20231228191037103"></p><p><img src="image-20231228191043450.png" alt="image-20231228191043450"></p><p><img src="image-20231228191246262.png" alt="image-20231228191246262"></p><p><strong>「稳定性」</strong></p><p><strong>不稳定</strong></p><h2 id="交换排序">交换排序</h2><h3 id="冒泡排序">冒泡排序</h3><p><strong>「算法思想」</strong></p><p>从左到右/从上到下 比较相邻记录的关键词，交换存在逆序的记录</p><blockquote><p>经过一次冒泡排序可以把最大关键词的记录移动到最后</p><p>经过n-1次，就可以对所有记录排序</p><p>发生一次记录交换，反序对少一个</p></blockquote><p><strong>「实现」</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>「改进」</strong></p><p>某趟扫描没有任何记录交换的时候就算法终止</p><p><strong>「复杂度」</strong></p><p><img src="image-20231228191947851.png" alt="image-20231228191947851"></p><p><img src="image-20231228192251995.png" alt="image-20231228192251995"></p><p><strong>「稳定性」</strong></p><p><strong>稳定</strong></p><h3 id="快速排序-分划交换排序">快速排序(分划交换排序)</h3><p><strong>「算法思想」</strong></p><p><img src="image-20231228192527737.png" alt="image-20231228192527737"></p><p><strong>「实现」</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>「复杂度」</strong></p><p><img src="image-20231228193524847.png" alt="image-20231228193524847"></p><p><strong>改进：</strong><br><img src="image-20231228194055159.png" alt="image-20231228194055159"></p><p><img src="image-20231228194133557.png" alt="image-20231228194133557"></p><p><strong>「稳定性」</strong></p><p><strong>不稳定</strong></p><h2 id="选择排序">选择排序</h2><h3 id="直接选择排序">直接选择排序</h3><p><strong>「算法思想」</strong></p><p><img src="image-20231228200101145.png" alt="image-20231228200101145"></p><p><strong>「实现」</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>「复杂度」</strong></p><p><img src="image-20231228200243718.png" alt="image-20231228200243718"></p><p><img src="image-20231228200411426.png" alt="image-20231228200411426"></p><p><strong>改进：</strong></p><blockquote><p>选择排序的关键是找最大或者最小记录，利用树形保存前面的比较结果，下一次选择时直接利用，可以大大减少比较次数</p><p><img src="image-20231228200859044.png" alt="image-20231228200859044"></p><p><strong>相关概念</strong></p><p>比赛树：每次两两比较的结果把关键词大者作为优胜者上升到父结点，，称 这种树为比赛树<br>外结点：位于最底层的叶结点      内结点：非叶结点</p><p><img src="image-20231228201249293.png" alt="image-20231228201249293"></p><p><img src="image-20231228201415248.png" alt="image-20231228201415248"></p></blockquote><p><strong>「稳定性」</strong></p><p><strong>不稳定</strong></p><h3 id="堆排序">堆排序</h3><blockquote><p>堆：：<strong>完全二叉树</strong>中的任意结点的关键词大于等于它的两个子结点的关键词，把这样的数据结构称为堆（<strong>大根堆</strong> ）</p><p>大根堆中根结点的关键词最大，小根堆中根结点的关键词最小。</p></blockquote><p><img src="image-20231228201723577.png" alt="image-20231228201723577"></p><p><strong>「算法思想」</strong></p><p><img src="image-20231228201835198.png" alt="image-20231228201835198"></p><p><strong>过程：</strong></p><ol><li><p>建堆</p></li><li><p>交换再重建堆</p><p><img src="image-20231228202751553.png" alt="image-20231228202751553"></p></li></ol><p><img src="image-20231228202716431.png" alt="image-20231228202716431"></p><p>​<img src="image-20231228203139519.png" alt="image-20231228203139519"></p><p><strong>「实现」</strong></p><p><strong>堆存储于顺序线性表（数组）中</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>「复杂度」</strong></p><p><img src="image-20231228204228279.png" alt="image-20231228204228279"></p><p><strong>「稳定性」</strong></p><p><strong>不稳定</strong></p><h2 id="合并排序">合并排序</h2><blockquote><ol><li>合并/归并：把两个或多个有序文件组成一个单一的有序文件。</li><li>基于合并操作完成排序。</li></ol></blockquote><blockquote><p>当 i 和 j 分别在两个表内变化时，通过比较A[i]与B[j]的关键词大小，依次把 <strong>关键词小</strong>的对象放到新表X[k]中；</p><p>当 i与 j中有一个<strong>超出表长</strong>时，将另一个表中的<strong>剩余部分</strong>照抄到新表X中</p></blockquote><p><img src="image-20231228204800031.png" alt="image-20231228204800031"></p><p><strong>「实现」</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>改进：</strong></p><blockquote><p>分析合并排序算法，不难发现它的两个缺点：</p><ol><li>当数据集非常小 时，比如只有2个元素，仍然采用分治策略，影响效率。</li><li>Merge算法基于元素移动，当元素比较大时，移动操作比较费时</li></ol><p>➢针对这两个问题的解决办法：</p><ol><li>对于小数据集以及前几趟合并操作，调用直接插入排序算法 。</li><li>将数组存储改为链表存储，这样记录移动变为指针移动</li></ol></blockquote><p><strong>「复杂度」</strong></p><p><img src="image-20231228210738722.png" alt="image-20231228210738722"></p><p><strong>「稳定性」</strong></p><p><strong>稳定</strong></p><h2 id="基于关键词比较的排序算法分析">基于关键词比较的排序算法分析</h2><p><img src="image-20231228211003577.png" alt="image-20231228211003577"></p><h2 id="分治排序的一般方法">分治排序的一般方法</h2><blockquote><p>快速排序、合并排序，应用了分治策略</p></blockquote><p><img src="image-20231228211507430.png" alt="image-20231228211507430"></p><h2 id="分布排序">分布排序</h2><p><img src="image-20231228211613438.png" alt="image-20231228211613438"></p><p><strong>「复杂度」</strong></p><p>时间复杂度可以达到线性阶。</p><h3 id="基数分布排序">基数分布排序</h3><p><img src="image-20231228212050722.png" alt="image-20231228212050722"></p><blockquote><p><strong>基于基数分布的排序（基数排序）</strong></p><ol><li>最高次序位法 ：先按高位分桶，然后桶内进行排序  如：英文单词，扑克牌</li><li>最低次序位法 ：先按最低位排序，然后按下一个次低位排序，…， 最后按最高位排序。</li></ol></blockquote><p><img src="image-20231228212242265.png" alt="image-20231228212242265"></p><p><strong>「实现」</strong></p><p><img src="image-20240106192844493.png" alt="image-20240106192844493"></p><h3 id="值分布排序">值分布排序</h3><p><img src="image-20231228212717956.png" alt="image-20231228212717956"></p><p><strong>「实现」</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>例如：堆三元组表存储的稀疏矩阵，求转置矩阵，可以利用值排序</p><p><img src="image-20231228213101065.png" alt="image-20231228213101065"></p><p><img src="image-20231228213111411.png" alt="image-20231228213111411"></p><h1 id="查找">查找</h1><h2 id="线性表的查找">线性表的查找</h2><h3 id="顺序查找">顺序查找</h3><p><strong>「无序表顺序查找」</strong></p><p>查找失败的查找长度：n+1</p><p>分析：</p><p><img src="image-20240101220318755.png" alt="image-20240101220318755"></p><p>改进： 自组织表</p><p><img src="image-20240101220409170.png" alt="image-20240101220409170"></p><p><strong>「有序表的顺序查找」</strong></p><blockquote><p>但如果只对表查找一次，则顺序查找要比排序快； 如果要在同一个文件中不断查找，将表按序排列再查找是个很好的方法</p></blockquote><h3 id="对半查找">对半查找</h3><p><strong>算法思想</strong></p><p><img src="image-20240103223229203.png" alt="image-20240103223229203"></p><p><strong>算法分析</strong></p><p><img src="image-20240103223348132.png" alt="image-20240103223348132"></p><p><img src="image-20240103225607803.png" alt="image-20240103225607803"></p><h4 id="一致对半查找">一致对半查找</h4><p><img src="image-20240103230244102.png" alt="image-20240103230244102"></p><p><img src="image-20240103230341008.png" alt="image-20240103230341008"></p><p><img src="image-20240103230837327.png" alt="image-20240103230837327"></p><p><img src="image-20240103230908047.png" alt="image-20240103230908047"></p><h3 id="斐波那契查找">斐波那契查找</h3><p><img src="image-20240103231158412.png" alt="image-20240103231158412"></p><p><img src="image-20240103231110183.png" alt="image-20240103231110183"></p><p><img src="image-20240103231126829.png" alt="image-20240103231126829"></p><p><img src="image-20240103231302067.png" alt="image-20240103231302067"></p><p><img src="image-20240103231518508.png" alt="image-20240103231518508"></p><h3 id="插值查找">插值查找</h3><p><img src="image-20240105222143570.png" alt="image-20240105222143570"></p><p><strong>算法思想</strong></p><p><img src="image-20240105222226192.png" alt="image-20240105222226192"></p><p><img src="image-20240105222431296.png" alt="image-20240105222431296"></p><h2 id="树形结构的查找">树形结构的查找</h2><h3 id="字典树-trie树">字典树（trie树）</h3><p><strong>常用来解决根据前缀查询字符串的问题</strong></p><p><img src="image-20240310165419879.png" alt="image-20240310165419879"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TrieNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TrieNode</span>* next[<span class="number">36</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">     <span class="type">bool</span> end=<span class="literal">false</span>;</span><br><span class="line"><span class="type">char</span> word[<span class="number">30</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉查找树-bst">二叉查找树（BST）</h3><blockquote><p>一棵<strong>二叉查找树</strong>是一棵可能为空的二叉树形，并且关键词 各不相同。二叉查找树中的任一结点P，它的左子树中结点的关键 词都小于KEY§，而右子树中结点的关键词都大于KEY§</p></blockquote><blockquote><p>二叉查找树 （或称二叉搜索树、排序树）是一棵可能为空 的二叉树形，一棵非空的二叉查找树中的所有结点在<strong>中根次序</strong>下 按其关键词由<strong>小到大</strong>排序，并且<strong>关键词各不相同</strong></p></blockquote><p><img src="image-20240105222809843.png" alt="image-20240105222809843"></p><p><img src="image-20240105222820415.png" alt="image-20240105222820415"></p><p><strong>查找</strong></p><p>走过每层</p><p><img src="image-20240105223017035.png" alt="image-20240105223017035"></p><p>实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BSTNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BSTnode</span>* left;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BSTnode</span>* right;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="function">BSTnode* <span class="title">Search</span><span class="params">(BSTnode* root,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="literal">NULL</span>||root-&gt;key==k) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;root-&gt;key) <span class="keyword">return</span> <span class="built_in">Search</span>(root-&gt;left,k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Search</span>(root-&gt;right,k);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代版本****时间复杂度O(h)  h为树的高度******</span></span><br><span class="line"><span class="function">BSTnode* <span class="title">Search</span><span class="params">(BSTnode* root,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BSTnode* p =root;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;p-&gt;key) p=p-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k&gt;p-&gt;key) p=p-&gt;right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入</strong></p><p><img src="image-20240105223155417.png" alt="image-20240105223155417"></p><p><img src="image-20240105223457083.png" alt="image-20240105223457083"></p><p><img src="image-20240105223523711.png" alt="image-20240105223523711"></p><p><img src="image-20240310174139175.png" alt="image-20240310174139175"></p><p><img src="image-20240310174614936.png" alt="image-20240310174614936"></p><p><strong>实现</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(BSTnode* &amp;root,<span class="type">int</span> k )</span>    <span class="comment">//返回值为空，采用引用的方法进行修改根节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>) root = <span class="keyword">new</span> <span class="built_in">BSTnode</span>(k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&lt;root-&gt;key) <span class="built_in">Insert</span>(root-&gt;left,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&gt;root-&gt;key) <span class="built_in">Insert</span>(root-&gt;right,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BSTnode* <span class="title">Insert</span><span class="params">(BSTnode* root,<span class="type">int</span> k)</span>  <span class="comment">//返回值为指针，采用值传递的方法更改</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>) root = <span class="keyword">new</span> <span class="built_in">BSTnode</span>(k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&lt;root-&gt;key) root-&gt;left = <span class="built_in">Insert</span>(root-&gt;left,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&gt;root-&gt;key)root-&gt;right = <span class="built_in">Insert</span>(root-&gt;right,k);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除</strong></p><p><img src="image-20240105223607737.png" alt="image-20240105223607737"></p><p><img src="image-20240105223651585.png" alt="image-20240105223651585"></p><p><img src="image-20240105223731685.png" alt="image-20240105223731685"></p><p><img src="image-20240105223832556.png" alt="image-20240105223832556"></p><p><img src="image-20240105224144290.png" alt="image-20240105224144290"></p><p><img src="image-20240310185938404.png" alt="image-20240310185938404"></p><p>其实只用分成三类</p><p>没有孩子：不做操作</p><p>有一个孩子：子承父业</p><p>有两个孩子：右子树的中序顺序的第一个（即右子树的最小的一个或者说是k的中序后继）换到k的位置</p><p><strong>算法分析</strong></p><p><img src="image-20240105224222452.png" alt="image-20240105224222452"></p><h3 id="最优二叉查找树">最优二叉查找树</h3><p><img src="image-20240105224454142.png" alt="image-20240105224454142"></p><h3 id="高度平衡树-avl">高度平衡树（AVL）</h3><p>上述所介绍的二叉查找树各个操作的时间复杂度由树的高度决定的，因此我们希望树的高度越低越好，即树矮胖是好的，效率是高的，但达到完全二叉树或者是满二叉树条件较为苛刻，所以我们引入了高度平衡树：</p><p><img src="image-20240106094728254.png" alt="image-20240106094728254"></p><p><img src="image-20240106094807446.png" alt="image-20240106094807446"></p><p><strong>高度的粗略计算</strong></p><p><img src="image-20240310202636483.png" alt="image-20240310202636483"></p><p><img src="image-20240310202742527.png" alt="image-20240310202742527"></p><p><strong>实现</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AVLnode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    AVLnode* left,*right;</span><br><span class="line">    <span class="built_in">AVLnode</span>(<span class="type">int</span> k) &#123;key=k;height=<span class="number">0</span>;left=right=<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Height</span><span class="params">(AVLnode* t )</span></span>&#123;<span class="keyword">return</span> (t==<span class="literal">NULL</span>)? <span class="number">-1</span>:t-&gt;height;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;<span class="keyword">return</span> (a&gt;b)?  a:b;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpdateHeight</span><span class="params">(ALVnode* t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t-&gt;height = <span class="number">1</span>+<span class="built_in">max</span>(<span class="built_in">Height</span>(t-&gt;left),<span class="built_in">Height</span>(t-&gt;right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查找</strong></p><p><strong>与普通的二叉查找树一致</strong></p><p><strong>插入</strong></p><p>为了保持树仍是<strong>高度平衡树</strong>会有以下四种插入情况</p><blockquote><p>LL型(R旋转): 新结点P插到A的左子树的左子树上</p><p>RR型(L旋转): 新结点P插入到A的右子树的右子树上</p><p>LR型(LR旋转): 结点P 插入到A的左子树的右子树上</p><p>RL型(RL旋转): 结点P插入到A的右子树的左子树上</p></blockquote><p><img src="image-20240106095023563.png" alt="image-20240106095023563"></p><p>实现</p><p><img src="image-20240310204430867.png" alt="image-20240310204430867"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LL</span><span class="params">(AVLndoe* &amp;A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AVLnode*B = A-&gt;left;</span><br><span class="line">    A-&gt;left = B-&gt;right;</span><br><span class="line">    <span class="built_in">UpdateHeight</span>(A);</span><br><span class="line">    <span class="built_in">UpdateHright</span>(B);</span><br><span class="line">    A=B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20240106095039512.png" alt="image-20240106095039512"></p><p>实现：<br><img src="image-20240310204602220.png" alt="image-20240310204602220"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RR</span><span class="params">(AVLnode* &amp;A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ALVnode*B = A-&gt;right;</span><br><span class="line">    A-&gt;right=B-&gt;left;</span><br><span class="line">    B-&gt;left = A;</span><br><span class="line">    <span class="built_in">UpdateHeight</span>(A);</span><br><span class="line">    <span class="built_in">UpdateHeight</span>(B);</span><br><span class="line">    A=B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20240106095216226.png" alt="image-20240106095216226"></p><p>实现：</p><p><img src="image-20240310205153288.png" alt="image-20240310205153288"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="image-20240106095504100.png" alt="image-20240106095504100"></p><p><img src="image-20240310205424816.png" alt="image-20240310205424816"></p><p><strong>通过上述四种操作，在插入前后数的高度和平衡性不受影响</strong></p><p><img src="image-20240310210443974.png" alt="image-20240310210443974"></p><p><img src="image-20240310210827325.png" alt="image-20240310210827325"></p><p><strong>删除</strong></p><p><img src="image-20240106095744779.png" alt="image-20240106095744779"></p><p>先采用二叉查找树的删除算法删除，再调整平衡性</p><p><img src="image-20240310211117006.png" alt="image-20240310211117006"></p><p><img src="image-20240310211217942.png" alt="image-20240310211217942"></p><p><img src="image-20240106100430797.png" alt="image-20240106100430797"></p><p><img src="image-20240106100814938.png" alt="image-20240106100814938"></p><h3 id="红黑树">红黑树</h3><p><img src="image-20240310211647955.png" alt="image-20240310211647955"></p><p><img src="image-20240310212033556.png" alt="image-20240310212033556"></p><p><img src="image-20240310212238453.png" alt="image-20240310212238453"></p><p><img src="image-20240310212437504.png" alt="image-20240310212437504"></p><p><img src="image-20240310212659183.png" alt="image-20240310212659183"></p><p><strong>插入</strong></p><p>1.原本为空树，插入后将根涂成黑色，不用做其他操作</p><p>2.插入节点的<strong>父节点是黑色</strong>，插入节点染成红色，不影响红黑树的性质，不用做任何操作</p><p>3.当<strong>父节点为红色，插入节点也为红色</strong>，为满足性质2，在不同的前提条件下要做不同的修改：</p><ul><li>如果<strong>当前节点的叔叔节点是红色</strong>，则父节点和叔叔节点都变为黑色，祖父染成红色</li><li>如果<strong>当前节点的叔叔节点是黑色或者叔叔节点不存在</strong>：则按照路径进行RL LR LL RR 旋转，最后根染成黑色，子节点染成红色。</li></ul><p><img src="image-20240310213236445.png" alt="image-20240310213236445"></p><p><img src="image-20240310213215470.png" alt="image-20240310213215470"></p><p><img src="image-20240310213404065.png" alt="image-20240310213404065"></p><p><img src="image-20240310213524549.png" alt="image-20240310213524549"></p><p><img src="image-20240310213637500.png" alt="image-20240310213637500"></p><p><img src="image-20240310214037548.png" alt="image-20240310214037548"></p><p><img src="image-20240310214405411.png" alt="image-20240310214405411"></p><p><strong>删除：</strong></p><p><img src="image-20240312110640554.png" alt="image-20240312110640554"></p><p>1.<strong>删除含有两个孩子的节点</strong>，可以归结为删除一个孩子的节点或者删除叶子节点（用中根后继的值替换被删除的节点的值，再删除中根后继）。</p><p>2**.删除一个孩子的节点或者是叶子节点**：</p><ul><li><p>​<strong>x为红色</strong>，则一定是叶子节点，直接删除</p></li><li><p>​<strong>x为黑色</strong>，<strong>替换的节点为红色</strong>，用r替换x，并将r染成黑色</p></li><li><p>​x为黑色，r为黑色，即<strong>双黑缺陷</strong>，又可以分为三种情况</p></li></ul><p>​  <img src="image-20240312111328699.png" alt="image-20240312111328699"></p><p><img src="image-20240312111649302.png" alt="image-20240312111649302"></p><p><img src="image-20240312111836712.png" alt="image-20240312111836712"></p><p><img src="image-20240312112005940.png" alt="image-20240312112005940"></p><p><img src="image-20240312112241241.png" alt="image-20240312112241241"></p><p><img src="image-20240312112410625.png" alt="image-20240312112410625"></p><p><img src="image-20240312112539622.png" alt="image-20240312112539622"></p><p><img src="image-20240312112622044.png" alt="image-20240312112622044"></p><p><img src="image-20240312112829179.png" alt="image-20240312112829179"></p><p><img src="image-20240312113017077.png" alt="image-20240312113017077"></p><h3 id="b树及其变形树">B树及其变形树</h3><p><strong>外查找</strong></p><p><img src="image-20240106100852098.png" alt="image-20240106100852098"></p><p>B树</p><p><img src="image-20240106100930019.png" alt="image-20240106100930019"></p><p><img src="image-20240106101133799.png" alt="image-20240106101133799"></p><p><img src="image-20240106101153223.png" alt="image-20240106101153223"></p><p><img src="image-20240106101329481.png" alt="image-20240106101329481"></p><p><img src="image-20240106101651230.png" alt="image-20240106101651230"></p><p><strong>插入</strong></p><p><img src="image-20240106101936483.png" alt="image-20240106101936483"></p><p><strong>删除</strong></p><p><img src="image-20240106103136080.png" alt="image-20240106103136080"></p><p><img src="image-20240106103155393.png" alt="image-20240106103155393"></p><p><img src="image-20240106103307884.png" alt="image-20240106103307884"></p><p><strong>B+树</strong></p><p><img src="image-20240106103352250.png" alt="image-20240106103352250"></p><p><img src="image-20240106103453737.png" alt="image-20240106103453737"></p><p><img src="image-20240106103503815.png" alt="image-20240106103503815"></p><p><img src="image-20240106103529896.png" alt="image-20240106103529896"></p><h3 id="数字查找">数字查找</h3><p><img src="image-20240106104151508.png" alt="image-20240106104151508"></p><p><img src="image-20240106104418518.png" alt="image-20240106104418518"></p><p><img src="image-20240106104511300.png" alt="image-20240106104511300"></p><p><img src="image-20240106104549177.png" alt="image-20240106104549177"></p><h2 id="散列">散列</h2><blockquote><p>前面所介绍的查找方法有两种，一种是<strong>基于表中关键词</strong>与给定 变元K的比较, 另一种是进行<strong>数字的匹配</strong>。这两种方法，在找到以 给定K为关键词的记录之前都要检查若干数目的关键词。</p></blockquote><blockquote><p>但散列方法却几乎完全免去了对表的搜索。以给定变元K为自变 量，通过<strong>某种函数h(K)</strong> 直接计算出函数值，此值被解释为存放以 K为关键词的记录的地址。查找时，用相同方法计算出与给定变 元K对应之记录的存储地址A，进而到A所指的存储单元中取出要 查的记录</p></blockquote><p><img src="image-20240106104706595.png" alt="image-20240106104706595"></p><p><img src="image-20240106104923458.png" alt="image-20240106104923458"></p><p><img src="image-20240106104941486.png" alt="image-20240106104941486"></p><p><img src="image-20240106105012495.png" alt="image-20240106105012495"></p><h3 id="冲突调节">冲突调节</h3><p><strong>拉链法</strong></p><p><img src="image-20240106110042989.png" alt="image-20240106110042989"></p><p><img src="image-20240106110126481.png" alt="image-20240106110126481"></p><p><img src="image-20240106110229273.png" alt="image-20240106110229273"></p><p><img src="image-20240106110252632.png" alt="image-20240106110252632"></p><h3 id="删除"><strong>删除</strong></h3><p><img src="image-20240106111448484.png" alt="image-20240106111448484"></p><p><img src="image-20240106111742833.png" alt="image-20240106111742833"></p><p><img src="image-20240106112145372.png" alt="image-20240106112145372"></p>]]></content>
    
    
    <summary type="html">数据结构笔记</summary>
    
    
    
    <category term="class record" scheme="https://klklkl10086.github.io/klklkl10086.github.io/categories/class-record/"/>
    
    
    <category term="数据结构" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Linux课程复习笔记</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2023/09/26/Linux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2023/09/26/Linux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</id>
    <published>2023-09-26T14:30:07.000Z</published>
    <updated>2024-03-18T09:14:07.598Z</updated>
    
    <content type="html"><![CDATA[<p><strong>声明：本篇文章参考和引用了2023下半年吉林大学郭东老师的PPT，如有侵权，请联系我，我将会立马删除</strong></p><h1 id="一-unix操作系统">一、UNIX操作系统</h1><h2 id="1-历史简介">1.历史简介</h2><p>1969年诞生于AT&amp;T贝尔试验室</p><p>开发者是Ken Thompson  和  Dennis Ritchie</p><p>最初使用汇编语言开发，后用C语言重写UNIX源码，UNIX和C完美地结合成一个统一的整体</p><p>UNIX以源代码的形式发行，形成了两个重要的流派:<br>UNIX SYSTEM V （AT&amp;T）和  Berkeley UNIX(UCB)</p><h2 id="2-标准化">2.标准化</h2><p>即对每种实现必须定义的各种限制进行说明</p><p>有两个重要的UNXI标准：</p><ol><li>系统V接口定义 SVID         例如： at&amp;t</li><li>可移植操作系统接口 POSIX  例如：IEEE、 ISO</li></ol><h2 id="3-其他的unix系统">3.其他的UNIX系统</h2><h3 id="1-linux">1&gt; Linux</h3><p>目前应用最为广泛的<strong>类UNIX系统</strong></p><h4 id="背景">背景</h4><h5 id="两个人-：">「两个人」：</h5><p>Richard Stallman和 Linus Torvalds，前者启动GNU项目 创建FSF组织 提出copyleft理念 制订GPL协议 发起开源运动</p><h5 id="四个一-："><strong>「四个一」</strong>：</h5><ul><li>一个项目 GNU</li></ul><p>​        <strong>G</strong>NU’s NOT <strong>U</strong>NIX</p><p>​        <strong>目标</strong>：</p><p>​创建一个自有共享 可以被任何人修改的类UNIX操作系统</p><p>​与UNIX系统兼容</p><p>​不受UNIX名字和源代码私有权限制</p><p>​能运行UNIX程序</p><p>​GNU项目完成了许多UNIX系统上应用程序的仿制品</p><p>​        GNU项目开发的重要软件工具有：</p><p>​ GCC:GNU编译器套件，包括GNU c编译器</p><p>​ G++：C++编译器 是GCC的一部分</p><p>​GDB：源代码级的调试器，支持多种语言</p><p>​GNU make: UNUX make命令的免费版本</p><p>​ bash:  命令解释器（shell）</p><p>​ GNU Emacs :  文本编辑器及环境</p><p>​       <strong>未成功开发操纵系统内核</strong></p><ul><li><p>一个组织 FSF</p><p>自由软件基金会</p><p>目标：<br>执行GNU计划</p><p>​提供技术 法律以及财政支持</p><p>​开发更多的自有软件</p></li><li><p>一个理念 Copy<strong>left</strong></p></li><li><p>一个许可证 GPL</p><p><strong>背景：</strong><br>发行大型软件需要的合适许可协议</p><p>已经有的许可协议：</p><p><img src="image-20231125202333757.png" alt="image-20231125202333757"></p><blockquote><p>Copyright©：版权所有，即软件的一切权利归软件作者私有，用户只有使用权没有其他权利包括复制软件的权利</p></blockquote></li></ul><p>​Richard Stallman提出Copyleft的概念（著<strong>左</strong>权）</p><p><img src="image-20231125202957871.png" alt="image-20231125202957871"></p><blockquote><p>利用现有的著作体制来保护所有用户和二次开发者的自由授权方式</p><p>它赋予所有人运行程序，复制程序，修改程序和发行修改程序的权限，但是使用者不能在修改后的软件上添加限制</p></blockquote><p>​基于copyleft Stallman提出来了GPL许可证，GNU通用的公共许可证</p><blockquote><p>GPL授予程序接受人以下权利，或称“自由”：</p><ul><li>赋予所有人运行程序，复制程序，修改程序和发行修改程序的自有</li><li>重新发行软件的人不能在修改后的软件上添加限制</li></ul></blockquote><p>GNU开发的工具都在GPL下发行</p><p>意义：<br><img src="image-20231125203240445.png" alt="image-20231125203240445"></p><p><strong>其他开源许可证：</strong><br>Apache ,BSD,MIT,Mozilla</p><p><img src="image-20231125203426215.png" alt="image-20231125203426215"></p><h4 id="linux的诞生">Linux的诞生</h4><p>内核在GPL协议下发布，参与了开源运动，Linux内核更新速度极其快</p><p>吉祥物：tux</p><p><img src="image-20231125203724965.png" alt="image-20231125203724965"></p><p>Linux的含义：操作系统内核或者是基于linux内核的操作系统</p><p><strong>Linux操作系统版本：包括内核版本和发行版本</strong></p><p>[内核版本]：有Linux内核社区统一进行发布，包括主版本号 次版本号和修订次数，奇数表示开发版本，偶数表示稳定版本，修订次数标明内核被修改的次数</p><p><img src="image-20231125204046584.png" alt="image-20231125204046584"></p><p>「发行版本」 发行版的名称或版本号是由发行版的维护者决定</p><p><img src="image-20231125204139444.png" alt="image-20231125204139444"></p><p><img src="image-20231125204157090.png" alt="image-20231125204157090"></p><h3 id="2-unix操作系统概要">2&gt; UNIX操作系统概要</h3><p>计算机系统= 硬件+系统软件+应用软件</p><p>UNIX操作系统是包含了文本编辑器 编译器 和其他系统工具程序的程序集</p><p>UNIX操作系统是按照分层软件模型实现的</p><p><img src="image-20231125204400373.png" alt="image-20231125204400373"></p><p>内核：</p><p><img src="image-20231125204440090.png" alt="image-20231125204440090"></p><p><img src="image-20231125204501355.png" alt="image-20231125204501355"></p><p><img src="image-20231125204515488.png" alt="image-20231125204515488"></p><p><img src="image-20231125204551016.png" alt="image-20231125204551016"></p><h5 id="相关概念">「相关概念」</h5><p>虚拟计算机：UNIX向系统中每个用户指定一个执行环境，这个环境称为虚拟计算机，包括一个用户接口终端和共享的其他计算机资源，UNIX是多用户操作系统 虚拟计算机的集合，而从用户视角是独想计算机</p><p>进程：UNUX系统通过进程向用户分配资源</p><h5 id="特征">「特征」</h5><p>可移植性（c语言保证）</p><p>多用户性：多用户同时共同使用计算机，各个用户执行不同的程序，提供安全机制隔离用户</p><p>多任务性：启动一个任务后继续执行其他任务，允许用户在前台和后台多个任务之间进行切换</p><p>分级文件系统：对数据和程序文件进行分组管理，便于查找文件和程序</p><p>与设备独立的输入输出操作：</p><p>用户界面shell：</p><p>​命令解释器： 控制用户与系统的交互，实现用户命令输入与结果输出</p><p>​shell脚本： UNIX Shell是一种成熟的编程语言，Shell 脚本 包含一系列命令， 实现较为复杂 的功能</p><p>系统工具与服务：UNIX系统包括100多个系统工具程序（命令），标准的UNIX系统组成部分完成用户所需要的各种功能</p><h1 id="二-linux入门">二、Linux入门</h1><h2 id="1-登录系统">1.登录系统</h2><h3 id="登录作用">「登录作用」</h3><ol><li>UNIX是一个多用户操作系统。</li><li>用户在使用UNIX系统前必须进行登录</li></ol><h3 id="登录方式">「登录方式」</h3><ol><li>本地登录：在本地输入用户名和密码登录</li><li>远程登录：使用远程登录软件登录 eg: ssh</li></ol><h3 id="命令提示符">「命令提示符」</h3><p>最简单的命令提示符只有一个字符，一般root根用户是#，普通用户是$，用户可以设置提示符，显示丰富系统信息。</p><p><img src="image-20231128105235339.png" alt="image-20231128105235339"></p><p>普通用户</p><h3 id="修改口令">「修改口令」</h3><p><strong>passwd命令</strong>来修改或创建口令</p><p>1.可以修改自己的口令:</p><p><img src="image-20231128105425593.png" alt="image-20231128105425593"></p><p>2.修改别人的口令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd username</span><br></pre></td></tr></table></figure><p>只有root可以</p><p>3.创建口令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd username</span><br></pre></td></tr></table></figure><p>应用场景：root创建普通用户后，为其分配初始口令</p><h3 id="退出系统">「退出系统」</h3><p>用户完成工作后离开系统的过程，退出意味着和系统断开连接结束对话</p><p>三种方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br><span class="line">[Ctrl-d]</span><br><span class="line"><span class="built_in">logout</span></span><br></pre></td></tr></table></figure><p>logout需要在登录shell中</p><h2 id="2-命令">2.命令</h2><ul><li>UNIX系统有几百条命令/系统工具</li><li>绝大多数命令格式相同</li><li>大部分UNIX提供在线帮助 help man info</li><li>通过输入命令告诉系统要做什么事</li><li>命令行中回车键解释为命令行的结束符</li></ul><p>例子：<br><img src="image-20231128110218045.png" alt="image-20231128110218045"></p><h3 id="命令格式">「命令格式」</h3><h4 id="基本格式">基本格式</h4><p><img src="image-20231128110252691.png" alt="image-20231128110252691"></p><p><img src="image-20231128110324019.png" alt="image-20231128110324019"></p><p>命令本身  和   命令+选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#命令+选项</span></span><br><span class="line"><span class="built_in">ls</span> -a     <span class="comment">#显示目录中的隐藏文件</span></span><br><span class="line"><span class="built_in">ls</span> -a -l  <span class="comment">#将隐含的文件用长格式形式显示</span></span><br><span class="line"><span class="built_in">ls</span> -la    <span class="comment">#作用同上，写法不同</span></span><br><span class="line"><span class="comment">#命令+参数</span></span><br><span class="line"><span class="built_in">ls</span> /home  <span class="comment">#显示指定目录的文件 </span></span><br><span class="line"><span class="comment">#命令+选项+参数</span></span><br><span class="line"><span class="built_in">ls</span> -a /home  <span class="comment">#命令+选项+参数</span></span><br></pre></td></tr></table></figure><p><img src="image-20231128110819617.png" alt="image-20231128110819617"></p><p><img src="image-20231128111034774.png" alt="image-20231128111034774"></p><h4 id="不同流派">不同流派</h4><p><img src="image-20231128111303688.png" alt="image-20231128111303688"></p><p><img src="image-20231128111426160.png" alt="image-20231128111426160"></p><p><img src="image-20231128111413828.png" alt="image-20231128111413828"></p><p><img src="image-20231128111346324.png" alt="image-20231128111346324"></p><p><img src="image-20231128111534508.png" alt="image-20231128111534508"></p><h3 id="日期和时间的显示">「日期和时间的显示」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span></span><br></pre></td></tr></table></figure><p><img src="image-20231128111633306.png" alt="image-20231128111633306"></p><p><strong>UNIX使用24小时制</strong></p><h3 id="用户信息">「用户信息」</h3><p><strong>who命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">who</span></span><br></pre></td></tr></table></figure><p><img src="image-20231128111741085.png" alt="image-20231128111741085"></p><p>第一列：登录用户名，登录用户名</p><p>第二列：登录终端号，登录到哪里</p><p>第三列：登录时间</p><p>第四列：登录主机，从哪里登录的</p><h3 id="终端">「终端」</h3><p><strong>物理终端</strong>：一套输入输出设备，用于用户登录和使用计算机，如连接在计算机上的显示器，鼠标，键盘与名词主机对应</p><p><strong>虚拟终端</strong>（tty）</p><p><strong>本地</strong>的linux系统提供的，例如虚拟机或者是linux系统服务器之类的，</p><p><img src="image-20231128112152987.png" alt="image-20231128112152987"></p><p><img src="image-20231128112440981.png" alt="image-20231128112440981"></p><p><img src="image-20231128142651757.png" alt="虚拟机登录"></p><p>使用虚拟机登录终端为tty</p><p><img src="capture_20231128142808500.bmp" alt="capture_20231128142808500"></p><p>对于Ununtu图形化界面</p><p><img src="image-20231128151721044.png" alt="image-20231128151721044"></p><p><strong>伪终端</strong>（pty）</p><p>由<strong>远程登录软件或终端模拟软件</strong>模拟出的终端</p><p><img src="image-20231128141759139.png" alt="image-20231128141759139"></p><p><img src="image-20231128141823390.png" alt="image-20231128141823390"></p><p><img src="image-20231128142451870.png" alt="手机软件远程登录"></p><h3 id="常用其他命令">「常用其他命令」</h3><h4 id="who-am-i和whoami命令">who am i和whoami命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">who</span> am i</span><br><span class="line"><span class="built_in">who</span> am I</span><br></pre></td></tr></table></figure><p>显示终端上登录的用户信息</p><p><img src="image-20231128152126549.png" alt="image-20231128152126549"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">whoami</span></span><br></pre></td></tr></table></figure><p>显示用户名</p><p><img src="image-20231128153157246.png" alt="image-20231128153157246"></p><h4 id="显示日历-cal命令">显示日历 cal命令</h4><p>默认显示当月日历</p><p><img src="image-20231128152807363.png" alt="image-20231128152807363"></p><p>参数中可以指定年和月，显示指定年月的日历表</p><h4 id="help命令-man命令-info命令">help命令 man命令 info命令</h4><p>「内部命令」 shell代码中的一部分，shell启动后驻留内存，执行速度快</p><p>「外部命令」保存在文件系统中的程序，被调用时才载入内存执行</p><p><img src="image-20231128154054687.png" alt="image-20231128154054687"></p><p><img src="image-20231128154113516.png" alt="image-20231128154113516"></p><p><img src="image-20231128154124919.png" alt="image-20231128154124919"></p><p><img src="image-20231128154138497.png" alt="image-20231128154138497"></p><p><img src="image-20231128154231499.png" alt="image-20231128154231499"></p><h4 id="last命令">last命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">last</span><br></pre></td></tr></table></figure><p>它用来展示关于系统用户最后登录会话的信息</p><p><img src="capture_20231128153410861.bmp" alt="capture_20231128153410861"></p><blockquote><p>输出的每一行从左到右包含的列分别是：</p><ul><li>用户名。 当系统重启或者关闭时，<code>last</code>显示指定用户为<code>reboot</code>或者<code>shutdown</code>。</li><li>会话占用的 tty。<code>:0</code>通常意味着用户登录了一个桌面环境</li><li>IP 地址或者用户登录的主机名</li><li>会话开始时间和停止时间</li><li>会话时长。如果会话仍然是激活的，或者用户没有登出，last 将会显示信息，而不是时长</li></ul></blockquote><h4 id="history">history</h4><p>显示输入的所有命令记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span></span><br></pre></td></tr></table></figure><p><img src="image-20231128153900626.png" alt="image-20231128153900626"></p><h3 id="命令行快捷键与命令补齐">「命令行快捷键与命令补齐」</h3><p><img src="image-20231128154332308.png" alt="image-20231128154332308"></p><h2 id="3-shell">3.shell</h2><p><img src="image-20231128154719823.png" alt="image-20231128154719823"></p><p><img src="image-20231128154736510.png" alt="image-20231128154736510"></p><p><img src="image-20231129211049340.png" alt="image-20231129211049340"></p><p><img src="image-20231129211156849.png" alt="image-20231129211156849"></p><p><img src="image-20231129211302220.png" alt="image-20231129211302220"></p><h2 id="4-软件的安装与卸载">4.软件的安装与卸载</h2><h4 id="安装软件">「安装软件」</h4><p><strong>1.两种方法</strong></p><ul><li><p>下载软件源代码后编译安装</p></li><li><p>基于网络存储库安装/更新软件</p><p>两种基于网络存储库的软件安装方法：</p><p>1.yum后继为dnf     eg：Redhat OpenEluer</p><p>2.apt                       eg:Ubuntu  Debian</p></li></ul><p><strong>2.使用yum（dnf）安装软件包</strong></p><p><img src="image-20231129211838221.png" alt="image-20231129211838221"></p><blockquote><p>软件包集合：服务于一个共同的目的一组软件包，例如系统工具集等</p></blockquote><p><strong>使用dnf可以对软件包组进行安装和删除等操作，使相关操作更高效</strong></p><p><img src="image-20231129212018114.png" alt="image-20231129212018114"></p><h2 id="5-登录过程">5.登录过程</h2><h3 id="启动过程">启动过程</h3><p><strong>操作系统常驻部分载入内存</strong>其余部分保留在磁盘上，用户请求时候再载入内存，用户登录时 shell程序载入内存。</p><p><strong>[init进程]</strong>：UNIX系统所有进程的祖先进程，启动所有系统服务和后台进程，系统启动后init创建虚拟终端为用户登录做准备</p><h1 id="三-vi编辑器">三、vi编辑器</h1><blockquote><p>工具软件，文本编辑器，用于创建新文件或修改旧文本文件，编辑对象是文本文件，相对简化的字处理器</p></blockquote><p><img src="image-20231129213205077.png" alt="image-20231129213205077"></p><h3 id="1-工作模式">1.工作模式</h3><h4 id="命令模式">「命令模式」</h4><p>启动后默认进入，所有的输入都被看作命令，不显示，被执行，通过按键删除字 行 段落，移动光标或者执行其他操作</p><h4 id="末行模式">「末行模式」</h4><p>按下冒号，在最后一行输入命令，回车结束命令</p><h4 id="文本输入模式">「文本输入模式」</h4><p>键盘输入文本字符，屏幕显示用户输入</p><h4 id="模式切换">「模式切换」</h4><p><img src="image-20231129213525501.png" alt="image-20231129213525501"></p><p><strong>注意大小写和英文字符</strong></p><h3 id="2-基本操作">2.基本操作</h3><h3 id="打开或创建文件">「打开或创建文件」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi     <span class="comment">#在当前工作目录新建一个文件并打开</span></span><br><span class="line"></span><br><span class="line">vi myfirst <span class="comment">#存在myfirst文件则为打开文件，不存在则新建并打开</span></span><br></pre></td></tr></table></figure><p><img src="image-20231129213840486.png" alt="image-20231129213840486"></p><p><img src="image-20231129213850965.png" alt="image-20231129213850965"></p><h3 id="编辑文件">「编辑文件」</h3><ul><li>按下小写字母 i 进入文本输入模式</li><li>通过键盘进行输入文本</li><li>按下 BackSpace或者Ctrl+h删除字符</li><li>每行结束后按Enter进入下一行</li></ul><h3 id="保存文件与退出">「保存文件与退出」</h3><p>按下ESC退出文本编辑模式进入命令模式，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:wq</span><br><span class="line">:x</span><br><span class="line">ZZ</span><br></pre></td></tr></table></figure><p>上述三种的其中一种，按下回车即为保存并退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:q</span><br></pre></td></tr></table></figure><p>若文件没被修改即为退出，已经被修改未保存则无法退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:q!</span><br></pre></td></tr></table></figure><p>不保存文件直接退出</p><h3 id="存储缓冲区">「存储缓冲区」</h3><p><img src="image-20231129214521276.png" alt="image-20231129214521276"></p><h3 id="光标的移动">「光标的移动」</h3><p><strong>命令模式下</strong></p><p><img src="image-20231129214614398.png" alt="image-20231129214614398"></p><p><strong>命令模式进入文本输入模式不同的命令键有不同的效果：</strong></p><p><img src="image-20231129214707433.png" alt="image-20231129214707433"></p><p><strong>光标移动键(命令模式)</strong></p><p><img src="image-20231129215354489.png" alt="image-20231129215354489"></p><p><strong>精准定位</strong></p><p>命令模式：</p><p><img src="image-20231129215414056.png" alt="image-20231129215414056"></p><p>末行模式：</p><p><img src="image-20231129215526241.png" alt="image-20231129215526241"></p><p><strong>翻页：</strong></p><p><img src="image-20231129215624206.png" alt="image-20231129215624206"></p><p><strong>文件修改：</strong></p><p>命令模式下：</p><p><img src="image-20231130144409680.png" alt="image-20231130144409680"></p><p>删除字符：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除单个字符</span></span><br><span class="line">x</span><br><span class="line"><span class="comment">#数字n+x删除n个字符</span></span><br><span class="line">2x</span><br><span class="line"><span class="comment">#撤销当前行的修改</span></span><br><span class="line">U</span><br><span class="line"><span class="comment">#撤销最近的修改</span></span><br><span class="line">u</span><br></pre></td></tr></table></figure><p>删除行和单词</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除光标所在行</span></span><br><span class="line"><span class="built_in">dd</span></span><br><span class="line"><span class="comment">#数字n+dd删除n行</span></span><br><span class="line">2dd<span class="comment">#删除两行</span></span><br><span class="line"><span class="comment">#删除光标所在单词</span></span><br><span class="line">dw</span><br></pre></td></tr></table></figure><p>重复上一次操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.</span><br></pre></td></tr></table></figure><p>替换字符</p><p><img src="image-20231130145148593.png" alt="image-20231130145148593"></p><p>载入文本</p><p>从其他文件中载入文本内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:r 文件名</span><br><span class="line"><span class="comment">#指定文本副本插入当前文件光标的下一行</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:a,b w file</span><br><span class="line">#把文件的a到b行写到file中</span><br></pre></td></tr></table></figure><p><strong>文件重排：</strong></p><p><img src="image-20231130150229039.png" alt="image-20231130150229039"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#复制当前行</span></span><br><span class="line">yy</span><br><span class="line"><span class="comment">#删除当前行</span></span><br><span class="line"><span class="built_in">dd</span></span><br></pre></td></tr></table></figure><p>使用<strong>操作符和域控制键</strong>修改/重排文本</p><p><img src="image-20231130152354930.png" alt="image-20231130152354930"></p><h3 id="3-定制vi">3.定制vi</h3><p><img src="image-20231130152759807.png" alt="image-20231130152759807"></p><h3 id="选项格式">「选项格式」</h3><p><img src="image-20231130152856213.png" alt="image-20231130152856213"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#只显示修改过的选项</span></span><br><span class="line">:<span class="built_in">set</span></span><br><span class="line"><span class="comment">#显示X的值</span></span><br><span class="line">:<span class="built_in">set</span> X?</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#显示行号</span></span><br><span class="line">:<span class="built_in">set</span> nu</span><br><span class="line"><span class="comment">#取消显示行号</span></span><br><span class="line">:<span class="built_in">set</span> nonu</span><br></pre></td></tr></table></figure><h3 id="vim配置文件">「vim配置文件」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/.exrc</span><br><span class="line">~/.vimrc</span><br></pre></td></tr></table></figure><p>vi编辑器中使用命令设置的所有选项都是临时的，退出vi就会失效</p><p>在用户主目录创建 ~/.exrc 或 ~/.vimrc 配置文件，设置选项后，可使每次启动时选项保持不变</p><h3 id="4-搜索替换与命令执行">4.搜索替换与命令执行</h3><h4 id="搜索">「搜索」</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#命令模式下输入</span></span><br><span class="line">/+要搜索的字符即为从光标所在的位置查找字符</span><br><span class="line"><span class="comment">#例如：</span></span><br><span class="line">/A</span><br></pre></td></tr></table></figure><p><strong>按下N是下一个匹配与命令搜索方向相反，按下n为下一个匹配，与命令搜索方向相同</strong></p><h4 id="搜索并替换">「搜索并替换」</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:「行范围」 s/被替换单词/新单词/[g]</span><br><span class="line"><span class="comment">#g是全行替换，行范围默认为当前行</span></span><br></pre></td></tr></table></figure><p><img src="image-20231202185736902.png" alt="image-20231202185736902"></p><h4 id="运行shell命令">「运行shell命令」</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#: ! command</span></span><br><span class="line">: ! <span class="built_in">date</span></span><br><span class="line"><span class="comment">#将命令执行结果加到文本中：</span></span><br><span class="line">:r! <span class="built_in">command</span></span><br></pre></td></tr></table></figure><h1 id="四-linux文件系统">四、Linux文件系统</h1><h2 id="1-磁盘组织">1.磁盘组织</h2><blockquote><p>目录：Linux文件系统的组织单元</p></blockquote><p>Linux文件系统通过目录对文件进行组织管理，</p><h2 id="2-文件类型">2.文件类型</h2><p>UNIX文件视角：</p><ul><li>文件是字节序列，一切都是文件</li><li>文件可以分为，普通文件、目录文件、特殊文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看文件类型</span></span><br><span class="line">file 文件名</span><br></pre></td></tr></table></figure><p><img src="image-20231202191624635.png" alt="image-20231202191624635"></p><p><img src="image-20231202191641349.png" alt="image-20231202191641349"></p><h2 id="3-目录详述">3.目录详述</h2><p><strong>目录结构以层次结构进行组织</strong></p><p><img src="image-20231202191741582.png" alt="image-20231202191741582"></p><blockquote><p>父子关系：相邻两层目录间的关系</p><p>上层目录是下层目录的父目录，下层目录是上层目录的子目录</p></blockquote><p><img src="image-20231202191842230.png" alt="image-20231202191842230"></p><blockquote><p>重要目录：Linux系统的标准目录</p></blockquote><p><img src="image-20231202192035623.png" alt="image-20231202192035623"></p><h3 id="重要目录作用"><strong>「重要目录作用」</strong></h3><p><img src="image-20231202192347215.png" alt="image-20231202192347215"></p><p><img src="image-20231202192539500.png" alt="image-20231202192539500"></p><p><img src="image-20231202192558821.png" alt="image-20231202192558821"></p><p><img src="image-20231202192723221.png" alt="image-20231202192723221"></p><h3 id="主目录"><strong>「主目录」</strong></h3><blockquote><p>主目录：管理员在创建用户的时候为其分配的特定目录</p></blockquote><ul><li>用户登录时，自动进入主目录</li><li>用户在其主目录拥有读、写和执行权限</li><li>用户在其主目录可以创建任意多的子目录</li><li>主目录名字通常和用户名相同</li></ul><h3 id="工作目录">「工作目录」</h3><blockquote><p>工作目录：用户先在在文件系统中的目录</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br><span class="line"><span class="comment">#查看目前的工作目录</span></span><br></pre></td></tr></table></figure><h3 id="路径">「路径」</h3><blockquote><p>路径：文件在文件系统中的位置描述方式</p></blockquote><p><strong>路径名用来定义文件。</strong></p><blockquote><p>绝对路径：从根目录开始到文件的路径</p></blockquote><p><img src="image-20231202193349892.png" alt="image-20231202193349892"></p><blockquote><p>相对路径：从当前目录开始到达文件的路径</p></blockquote><p><img src="image-20231202193359114.png" alt="image-20231202193359114"></p><h3 id="特殊符号"><strong>「特殊符号」</strong></h3><p><strong>点（.）：表示当前目录</strong></p><p><strong>点点（…）：表示当前目录的父目录</strong></p><h3 id="命名约束">「命名约束」</h3><p>文件和目录如何命名。</p><p><img src="image-20231202193529448.png" alt="image-20231202193529448"></p><h2 id="4-目录操作命令">4.目录操作命令</h2><h3 id="cd命令">「cd命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> [目录名]</span><br><span class="line"><span class="comment">#改变工作目录</span></span><br></pre></td></tr></table></figure><p><img src="image-20231202193744996.png" alt="image-20231202193744996"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span></span><br><span class="line"><span class="comment">#返回用户主目录</span></span><br><span class="line"><span class="built_in">cd</span> .</span><br><span class="line"><span class="comment">#进入当前目录</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="comment">#进入上一级目录</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="comment">#进入当前用户的主目录</span></span><br><span class="line"><span class="built_in">cd</span> ~tux</span><br><span class="line"><span class="comment">#进入tux主目录，前提是你有权限进入</span></span><br></pre></td></tr></table></figure><h3 id="mkdir命令">「mkdir命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> 目录名</span><br><span class="line"><span class="comment">#创建目录</span></span><br><span class="line"><span class="built_in">mkdir</span> 目录名1 目录名2 目录名3</span><br><span class="line"><span class="comment">#创建多个目录</span></span><br></pre></td></tr></table></figure><p><img src="image-20231202194116992.png" alt="image-20231202194116992"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一次创建多层目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p xx/yy/zz</span><br></pre></td></tr></table></figure><h3 id="rmdir命令">「rmdir命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除目录，只能删除空目录，即目录中只含有.和..</span></span><br><span class="line"><span class="built_in">rmdir</span> 「目录名」</span><br></pre></td></tr></table></figure><h3 id="ls命令">「ls命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#显示指定目录内容</span></span><br><span class="line"><span class="built_in">ls</span> 「目录名」</span><br></pre></td></tr></table></figure><p><img src="image-20231202194341628.png" alt="image-20231202194341628"></p><p><strong>选项 -l：</strong></p><p><img src="image-20231202194434138.png" alt="image-20231202194434138"></p><p><img src="image-20231202194520579.png" alt="image-20231202194520579"></p><p>第二列：文件的链接数</p><p>第三列：文件的所有者，通常与文件创建者用户名相同，文件的所有者发生转移，则两者不同</p><p>第四列：文件所属的组，管理员创建用户时，指定用户隶属于某个组，用户创建文件时，文件属于用户默认隶属的组</p><p>第五列：文件大小，单位字节</p><p>第六列：文件上一次修改的日期和时间</p><p>第七列：文件的名称</p><p><strong>选项 -a：</strong><br>查看隐藏文件</p><p><img src="image-20231202194822252.png" alt="image-20231202194822252"></p><h3 id="cat命令">「cat命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#显示一个或多个文件的内容</span></span><br><span class="line"><span class="built_in">cat</span> 文件名1 文件名2 </span><br></pre></td></tr></table></figure><p><img src="image-20231202194922602.png" alt="image-20231202194922602"></p><h3 id="rm命令">「rm命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除文件</span></span><br><span class="line"><span class="built_in">rm</span> 文件名</span><br></pre></td></tr></table></figure><p><img src="image-20231202194955122.png" alt="image-20231202194955122"></p><p><img src="image-20231202195022506.png" alt="image-20231202195022506"></p><h1 id="五-unix文件系统高级操作">五、UNIX文件系统高级操作</h1><h2 id="1-shell重定向">1.shell重定向</h2><p><img src="image-20231202195437195.png" alt="image-20231202195437195"></p><h3 id="输出重定向">「输出重定向」</h3><p>输出重定向允许用户将命令（进程）的输出保存到文件中</p><p>shell使用&gt;和&gt;&gt;作为输出重定向操作符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> &gt; filename <span class="comment">#覆盖重定向</span></span><br><span class="line"><span class="built_in">command</span> &gt;&gt; filename  <span class="comment">#追加重定向</span></span><br></pre></td></tr></table></figure><p><img src="image-20231202200457240.png" alt="image-20231202200457240"></p><h3 id="输入重定向">「输入重定向」</h3><p>输入重定向允许用户从指定文件得到输入来运行命令</p><p><img src="image-20231202200542587.png" alt="image-20231202200542587"></p><p><strong>shell使用&lt;和 &lt;&lt;作为输出重定向操作符</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">comand &lt; filename <span class="comment">#命令行中使用</span></span><br><span class="line"><span class="built_in">command</span> &lt;&lt; 分界符<span class="comment">#脚本编程中使用</span></span><br></pre></td></tr></table></figure><h2 id="2-文件操作命令">2.文件操作命令</h2><h3 id="cat命令">「cat命令」</h3><p><img src="image-20231202200855618.png" alt="image-20231202200855618"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> filename <span class="comment">#命令参数</span></span><br><span class="line"><span class="built_in">cat</span> &lt; filename <span class="comment">#输入重定向</span></span><br></pre></td></tr></table></figure><p><img src="image-20231202200950422.png" alt="image-20231202200950422"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; filename <span class="comment">#使用cat和输出重定向可以创建文件</span></span><br></pre></td></tr></table></figure><p><img src="image-20231202201039530.png" alt="image-20231202201039530"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt;&gt; filename <span class="comment"># 若文件不存在则会创建文件并将键盘输入内容输入到文件中，如存在则追加输入</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> filename &gt; filename.copy <span class="comment">#复制文件</span></span><br><span class="line"><span class="built_in">cat</span> filename1 filename2 &gt; filename.copy <span class="comment">#复制多个到一个</span></span><br></pre></td></tr></table></figure><p><img src="image-20231202201447583.png" alt="image-20231202201447583"></p><h3 id="cp命令">「cp命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> 文件名1 文件名2 <span class="comment">#创建文件副本</span></span><br><span class="line"><span class="built_in">cp</span>  filename1 filename2 目录名 <span class="comment">#将一个或多个文件复制到指定目录</span></span><br></pre></td></tr></table></figure><p><img src="image-20231202201742015.png" alt="image-20231202201742015"></p><p><img src="image-20231202201803414.png" alt="image-20231202201803414"></p><p><img src="image-20231202201823928.png" alt="image-20231202201823928"></p><p><strong>命令选项：</strong></p><blockquote><p><strong>-i</strong>：如果目标文件已经存在要求确认</p></blockquote><p><img src="image-20231202201932935.png" alt="image-20231202201932935"></p><blockquote><p><strong>-r</strong>：将目录复制到新的目录</p></blockquote><p><img src="image-20231202202013511.png" alt="image-20231202202013511"></p><h3 id="mv命令">「mv命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> 文件名（s） 目录 <span class="comment">#将文件移到其他目录（非文件所在目录）</span></span><br><span class="line"><span class="built_in">mv</span> 文件名1 文件名2 <span class="comment">#移动并改变文件名 </span></span><br></pre></td></tr></table></figure><p><img src="image-20231202204134259.png" alt="image-20231202204134259"></p><p><img src="image-20231202204154232.png" alt="image-20231202204154232"></p><p><img src="image-20231202204205615.png" alt="image-20231202204205615"></p><p><strong>命令选项：</strong></p><blockquote><p><strong>-i</strong> ：如果目标文件已经存在要求确认</p></blockquote><p><img src="image-20231202204258626.png" alt="image-20231202204258626"></p><h3 id="ln-命令">「ln 命令」</h3><p><strong>在已存在和新文件名之间创建链接，为已存在的文件起新名字，使用不同的名字引用同一文件</strong></p><ul><li>在不同目录中频繁操作同一文件</li><li>在每个目录中建立该文件的链接文件，通过链接文件对原文件进行操作</li><li>链接文件不占用过多的磁盘空间</li></ul><p>涉及文件存储的三个部分</p><p><img src="image-20231202204606759.png" alt="image-20231202204606759"></p><p><img src="image-20231203102033260.png" alt="image-20231203102033260"></p><p><img src="image-20231203102140610.png" alt="image-20231203102140610"></p><p>「wc命令」</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#计算一个或者多个文件的行数、字数和字符数</span></span><br><span class="line"><span class="built_in">wc</span> [文件名]</span><br><span class="line"><span class="comment">#无参数默认键盘输入</span></span><br><span class="line"><span class="built_in">wc</span></span><br><span class="line"><span class="comment">#统计多个文件</span></span><br><span class="line"><span class="built_in">wc</span> [文件名] [文件名]</span><br></pre></td></tr></table></figure><p><img src="image-20231203102458849.png" alt="image-20231203102458849"></p><p>选项：</p><blockquote><p>-l  ：统计行数</p><p>-c：统计字符数</p><p>-w：统计字数</p></blockquote><p><img src="image-20231203102721023.png" alt="image-20231203102721023"></p><p><img src="image-20231203102735066.png" alt="image-20231203102735066"></p><h2 id="3-文件名替换">3.文件名替换</h2><p><img src="image-20231203103037503.png" alt="image-20231203103037503"></p><p>「?通配符」</p><blockquote><p>代表单个字符,不可为空</p></blockquote><p><img src="image-20231203103420980.png" alt="image-20231203103420980"></p><p>「*通配符」</p><blockquote><p>文件名中的任意个字符（包括0个）</p></blockquote><p><img src="image-20231203103547461.png" alt="image-20231203103547461"></p><p><img src="image-20231203103559206.png" alt="image-20231203103559206"></p><p>「[] 通配符」</p><blockquote><p>包含括号中指定的任一<strong>字符</strong></p></blockquote><p><img src="image-20231203103837817.png" alt="image-20231203103837817"></p><p><img src="image-20231203103924092.png" alt="image-20231203103924092"></p><h2 id="4-其它文件操作命令">4.其它文件操作命令</h2><h3 id="find命令">「find命令」</h3><blockquote><p>在多层目录中搜索指定文件，快速查看文件指定部分</p></blockquote><p><img src="image-20231203104202314.png" alt="image-20231203104202314"></p><p><img src="image-20231203104329792.png" alt="image-20231203104329792"></p><p>搜索选项：</p><p><img src="image-20231203104352656.png" alt="image-20231203104352656"></p><blockquote><p>-name  :  通过文件名查找文件</p></blockquote><p><img src="image-20231203104459455.png" alt="image-20231203104459455"></p><blockquote><p>-type: 通过文件类型查找文件</p></blockquote><p><img src="image-20231203104629325.png" alt="image-20231203104629325"></p><p>动作选项：</p><p><img src="image-20231203104715277.png" alt="image-20231203104715277"></p><blockquote><p>-exec:用户给出命令，对找到的文件进行操作</p></blockquote><p><img src="image-20231203104903043.png" alt="image-20231203104903043"></p><blockquote><p>-ok:用户执行命令前需要确认</p></blockquote><p><img src="image-20231203105155036.png" alt="image-20231203105155036"></p><h3 id="head命令">「head命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#显示文件头部若干行</span></span><br><span class="line"><span class="built_in">head</span> [filenames]  <span class="comment">#默认显示前10行</span></span><br></pre></td></tr></table></figure><blockquote><p>-n： 显示文件前n行</p></blockquote><p><img src="image-20231204090519119.png" alt="image-20231204090519119"></p><h3 id="tail命令">「tail命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#显示文件尾部若干行</span></span><br><span class="line"><span class="built_in">tail</span> [filenames] <span class="comment">#默认后10行</span></span><br></pre></td></tr></table></figure><blockquote><p>-n ： 显示文件后n行</p></blockquote><p><img src="image-20231204090715118.png" alt="image-20231204090715118"></p><h3 id="cut命令">「cut命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从文件中取出指定域或列</span></span><br><span class="line"><span class="built_in">cut</span> 选项 文件名</span><br></pre></td></tr></table></figure><blockquote><p>-f : 指定域位置 ，1，3，5       1-3，5</p></blockquote><p><img src="image-20231204091146132.png" alt="image-20231204091146132"></p><p><img src="image-20231204091217513.png" alt="image-20231204091217513"></p><blockquote><p>-c ：指定字符的位置</p></blockquote><p><img src="image-20231204091313084.png" alt="image-20231204091313084"></p><blockquote><p>-d  ：指定域分隔字符</p></blockquote><p><img src="image-20231204091403924.png" alt="image-20231204091403924"></p><h3 id="paste命令">「paste命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逐行连接两个或多个文件</span></span><br><span class="line"><span class="built_in">paste</span> file1 file2+（s）</span><br></pre></td></tr></table></figure><blockquote><p>-d：指定具体分隔符，默认为制表符</p></blockquote><p><img src="image-20231204091627160.png" alt="image-20231204091627160"></p><p><img src="image-20231204091647719.png" alt="image-20231204091647719"></p><h3 id="more命令">「more命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#另页查看工具</span></span><br><span class="line">more filename</span><br></pre></td></tr></table></figure><blockquote><p>-lines:每屏显示的行数</p><p>+line-number:从第line-number 行开始显示</p><p>+/pattern  : 从包含pattern的行的上两行开始显示</p><p>-c:在显示每页之前清屏</p><p>-d:显示提示[Press space to continue, ‘q’ to quit]</p></blockquote><p><img src="image-20231204091933287.png" alt="image-20231204091933287"></p><h3 id="less命令">「less命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#分页查看工具，允许在文件中向后和向前移动</span></span><br><span class="line">less filename</span><br></pre></td></tr></table></figure><p>基于more 和 vi 更高级的工具</p><h2 id="5-unix-内部：文件系统">5.UNIX 内部：文件系统</h2><p><img src="image-20231204092210032.png" alt="image-20231204092210032"></p><p><img src="image-20231204092224326.png" alt="image-20231204092224326"></p><p><img src="image-20231204092310347.png" alt="image-20231204092310347"></p><h1 id="六-探索shell">六、探索shell</h1><h2 id="1-启动shell">1.启动shell</h2><p>用户成功登录系统，shell启动，用户退出，shell进程结束</p><p>系统中每个用户都有一个默认的shell，在系统口令文件/etc/passwd指定</p><p><img src="image-20231204093910980.png" alt="image-20231204093910980"></p><p><img src="image-20231204093928448.png" alt="image-20231204093928448"></p><p><img src="image-20231204094005033.png" alt="image-20231204094005033"></p><h2 id="2-shell的主要功能">2.shell的主要功能</h2><p><img src="image-20231204094146647.png" alt="image-20231204094146647"></p><p><img src="image-20231204094215586.png" alt="image-20231204094215586"></p><h3 id="正则表达式">「正则表达式」</h3><p><img src="image-20231204133415834.png" alt="image-20231204133415834"></p><p><img src="image-20231204133446879.png" alt="image-20231204133446879"></p><p><img src="image-20231204133543972.png" alt="image-20231204133543972"></p><p>例子：</p><p><img src="image-20231204133732850.png" alt="image-20231204133732850"></p><p><strong>POSIX标准正则表达式：</strong></p><p><img src="image-20231204133904964.png" alt="image-20231204133904964"></p><p><strong>扩展正则表达式：仅在部分程序中支持，例如 egrep、awk 等</strong></p><p><img src="image-20231204134201536.png" alt="image-20231204134201536"></p><p>例子：</p><p><img src="image-20231204134254841.png" alt="image-20231204134254841"></p><p><strong>正则表达式与通配符区别：</strong><br><img src="image-20231204134330146.png" alt="image-20231204134330146"></p><h3 id="echo命令">「echo命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将消息参数显示在用户终端上，没有参数输出空行</span></span><br><span class="line"><span class="built_in">echo</span> message</span><br></pre></td></tr></table></figure><p><img src="image-20231204094319850.png" alt="image-20231204094319850"></p><blockquote><p>-n ：禁止换行，输出后不换行</p></blockquote><p><img src="image-20231204135140526.png" alt="image-20231204135140526"></p><blockquote><p>-e ：解释反斜杠引导的转义字符（用于控制消息格式的字符，字符串的一部分，以\开始由shell解释为用户想要得到的输出）</p></blockquote><p><img src="image-20231204094459579.png" alt="image-20231204094459579"></p><p><img src="image-20231204133102241.png" alt="image-20231204133102241"></p><p><img src="image-20231204133128633.png" alt="image-20231204133128633"></p><p><img src="image-20231204135012223.png" alt="image-20231204135012223"></p><p><img src="image-20231204133213407.png" alt="image-20231204133213407"></p><h3 id="消除元字符的特殊含义">「消除元字符的特殊含义」</h3><blockquote><p>元字符：shell中具有特殊含义和用途的字符，在shell中出现时不代表字面含义</p></blockquote><p>如：<br><img src="image-20231204135653676.png" alt="image-20231204135653676"></p><p>消除元字符特殊含义的<strong>元字符</strong>：</p><p><img src="image-20231204135735214.png" alt="image-20231204135735214"></p><blockquote><p>\ :后面的元字符按照字符的字面量解释</p></blockquote><blockquote><p>&quot;  &quot; ： 取消除$、`、\外元字符的特殊含义。双引号中保留空白字符（空格、制表和换行符等）</p></blockquote><p><img src="image-20231204140215379.png" alt="image-20231204140215379"></p><blockquote><p>’ ’ ： 单引号中任何字符都失去特殊含义，单引号中保留空白字符（空格、制表和换行符等）</p></blockquote><p><img src="image-20231204140531736.png" alt="image-20231204140531736"></p><h2 id="3-shell变量">3.shell变量</h2><blockquote><ul><li>shell为响应用户请求，保存一些信息到shell变量中</li><li>变量有名称，可以通过赋值来控制或定制系统环境</li></ul></blockquote><p><img src="image-20231204140700159.png" alt="image-20231204140700159"></p><h3 id="显示和清除变量：set和unset">「显示和清除变量：set和unset」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看当前使用的shell变量（环境变量和局部变量）</span></span><br><span class="line"><span class="built_in">set</span></span><br></pre></td></tr></table></figure><p><img src="image-20231204140851846.png" alt="image-20231204140851846"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除不需要的变量</span></span><br><span class="line"><span class="built_in">unset</span></span><br></pre></td></tr></table></figure><p><img src="image-20231204141227863.png" alt="image-20231204141227863"></p><p><strong>赋值时，等号左右无空格</strong></p><h3 id="给变量赋值">「给变量赋值」</h3><p><img src="image-20231204141317503.png" alt="image-20231204141317503"></p><h3 id="显示shell变量的值">「显示shell变量的值」</h3><p><img src="image-20231204141350586.png" alt="image-20231204141350586"></p><blockquote><p>shell变量可用于在命令行中帮助保存复杂选项或参数</p></blockquote><p><img src="image-20231204142142961.png" alt="image-20231204142142961"></p><h3 id="shell的标准变量">「shell的标准变量」</h3><p><img src="image-20231204142211346.png" alt="image-20231204142211346"></p><p><strong>标准变量：</strong></p><blockquote><p>HOME:保存用户主目录；用于其他命令定位主目录</p></blockquote><p><img src="image-20231204142314306.png" alt="image-20231204142314306"></p><blockquote><p>PATH : 设置shell载入外部命令（程序）时所要查找的目录</p></blockquote><p><img src="image-20231204142634082.png" alt="image-20231204142634082"></p><p><strong>路径间的分隔符是 ：</strong></p><p><img src="image-20231204143119671.png" alt="image-20231204143119671"></p><blockquote><p>PS1 : 设置作为命令提示符的字符串</p></blockquote><p><img src="image-20231204143511681.png" alt="image-20231204143511681"></p><p><img src="image-20231204143529264.png" alt="image-20231204143529264"></p><p><img src="image-20231204143619476.png" alt="image-20231204143619476"></p><p><img src="image-20231204143657006.png" alt="image-20231204143657006"></p><blockquote><p>PS2 : 多行输入一条命令时，设置第二行及以后行的提示符，默认为&gt;</p></blockquote><p><img src="image-20231204144200378.png" alt="image-20231204144200378"></p><p><img src="image-20231204144144616.png" alt="image-20231204144144616"></p><p><img src="image-20231204144216316.png" alt="image-20231204144216316"></p><blockquote><p>SHELL：设置登录的shell的完整路径</p></blockquote><p><img src="image-20231204144325814.png" alt="image-20231204144325814"></p><blockquote><p>TERM ： 设置终端类型</p></blockquote><p><img src="image-20231204144401392.png" alt="image-20231204144401392"></p><h2 id="4-其他元字符">4.其他元字符</h2><h3 id="执行命令：使用重音符号">「执行命令：使用重音符号  ` 」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># `告诉shell先执行重音符号扩起来的命令，结果替换命令行中原来扩起来的命令，也称命令替换符</span></span><br></pre></td></tr></table></figure><p><img src="image-20231204150134375.png" alt="image-20231204150134375"></p><p><img src="image-20231204150428115.png" alt="image-20231204150428115"></p><h3 id="命令序列：使用分号">「命令序列：使用分号  ; 」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在一个命令行中分隔多个命令，shell从左到右执行</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p><img src="image-20231204150612587.png" alt="image-20231204150612587"></p><h3 id="命令编组：使用括号">「命令编组：使用括号 ( )」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#几个命令放在一对括号中，编为一组执行，编组命令可以被重定向</span></span><br><span class="line">()</span><br></pre></td></tr></table></figure><p><img src="image-20231204150730847.png" alt="image-20231204150730847"></p><h3 id="后台处理：使用-符号">「后台处理：使用 &amp; 符号」</h3><blockquote><p>UNIX 是多任务系统，允许同时执行多个程序</p></blockquote><p><img src="image-20231204151039451.png" alt="image-20231204151039451"></p><p><img src="image-20231204151240267.png" alt="image-20231204151240267"></p><h3 id="链接命令：使用管道操作符">「链接命令：使用管道操作符  | 」</h3><blockquote><p>| ： 将一个命令的标准输出作为另一个命令的标准输入</p></blockquote><p><img src="image-20231204151409765.png" alt="image-20231204151409765"></p><h2 id="5-其他unix系统工具">5.其他UNIX系统工具</h2><h3 id="sleep命令">「sleep命令」</h3><blockquote><p>sleep：使执行该命令的进程延时指定的秒数</p></blockquote><h3 id="ps-命令">「ps 命令」</h3><blockquote><p>ps：查看进程详细信息</p></blockquote><p><img src="image-20231204151807585.png" alt="image-20231204151807585"></p><p>选项：</p><blockquote><p>-e：显示所有进程<br>-f： 显示信息的完整列表（包括完整的命令行）</p></blockquote><h3 id="kill命令">「kill命令」</h3><blockquote><p>kill ：发信号给指定进程，进行进程间的通信</p></blockquote><p><img src="image-20231204152126562.png" alt="image-20231204152126562"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> [-signal] PID</span><br></pre></td></tr></table></figure><p><img src="image-20231204152231320.png" alt="image-20231204152231320"></p><p><img src="image-20231204152509331.png" alt="image-20231204152509331"></p><h3 id="tee命令">「tee命令」</h3><p><img src="image-20231204152538886.png" alt="image-20231204152538886"></p><p><img src="image-20231204152651165.png" alt="image-20231204152651165"></p><p><img src="image-20231204152757094.png" alt="image-20231204152757094"></p><p><strong>注意：覆盖式输出。</strong></p><p><strong>选项：</strong></p><blockquote><p>-a ： 追加而非覆盖</p></blockquote><h3 id="grep命令">「grep命令」</h3><blockquote><p>在一个或多个文件中查找满足特定格式的行</p></blockquote><p><img src="image-20231204152855243.png" alt="image-20231204152855243"></p><p><img src="image-20231204152908288.png" alt="image-20231204152908288"></p><p><img src="image-20231204152945454.png" alt="image-20231204152945454"></p><h3 id="sort命令">「sort命令」</h3><blockquote><p>对文件内容按照字母或者数字顺序排序</p></blockquote><p><img src="image-20231204153040406.png" alt="image-20231204153040406"></p><p><img src="image-20231204153056280.png" alt="image-20231204153056280"></p><h2 id="6-启动文件">6.启动文件</h2><h3 id="shell环境配置文件">「shell环境配置文件」</h3><p><img src="image-20231204153205012.png" alt="image-20231204153205012"></p><h3 id="登录shell与非登录shell">「登录shell与非登录shell」</h3><p><img src="image-20231204153352222.png" alt="image-20231204153352222"></p><h3 id="配置文件功能">「配置文件功能」</h3><p><img src="image-20231204153421749.png" alt="image-20231204153421749"></p><p><img src="image-20231204153515457.png" alt="image-20231204153515457"></p><p><img src="image-20231204153646249.png" alt="image-20231204153646249"></p><p><img src="image-20231204153736701.png" alt="image-20231204153736701"></p><p><img src="image-20231204153748650.png" alt="image-20231204153748650"></p><h3 id="alias命令">「alias命令」</h3><p><img src="image-20231204153904462.png" alt="image-20231204153904462"></p><p><img src="image-20231204153958644.png" alt="image-20231204153958644"></p><h2 id="7-unix进程管理">7.UNIX进程管理</h2><p><img src="image-20231204154021259.png" alt="image-20231204154021259"></p><p><img src="image-20231204154035124.png" alt="image-20231204154035124"></p><p><img src="image-20231204154101766.png" alt="image-20231204154101766"></p><p><img src="image-20231204154119984.png" alt="image-20231204154119984"></p><p><img src="image-20231204154131717.png" alt="image-20231204154131717"></p><h1 id="七-程序开发">七、程序开发</h1><h2 id="1-程序的编辑-翻译与执行">1.程序的编辑、翻译与执行</h2><h3 id="建立可执行程序的步骤">「建立可执行程序的步骤」</h3><ol><li>编写源文件（源代码）</li><li>建立目标文件（目标代码/目标模块）</li><li>建立可执行文件（可执行代码/载入模块）</li></ol><p><img src="image-20231204160927261.png" alt="image-20231204160927261"></p><h3 id="编译-解释程序">「编译/解释程序」</h3><p><img src="image-20231204161014316.png" alt="image-20231204161014316"></p><h2 id="2-编译-链接c-c-程序">2.编译、链接C/C++程序</h2><blockquote><p>gcc ： GNU C 编译器，Linux通用 C 语言编译器</p><p>g++：GNU C++ 语言编译器</p></blockquote><h3 id="gcc-g-执行编译的步骤">「gcc / g++ 执行编译的步骤」</h3><ol><li><p>预处理：把头文件展开，去掉注释，宏替换，条件编译等；</p><p>​         生成 <strong>.i</strong> 文件</p></li><li><p>编  译：将预处理后的文件转换成<strong>汇编语言</strong></p><p>​         生成 <strong>.s</strong> 文件</p></li><li><p>汇  编：由汇编语言变为<strong>目标代码（机器代码）</strong></p><p>​         生成 <strong>.o</strong> 文件</p></li><li><p>链 接：链接目标代码，生成<strong>可执行程序</strong></p></li></ol><p><img src="image-20231204161322195.png" alt="image-20231204161322195"></p><h3 id="gcc-g-编译程序">「gcc  /  g++编译程序」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc [选项] 源文件名</span><br></pre></td></tr></table></figure><p>选项：</p><blockquote><p>-c ：只进行<strong>预处理、编译和汇编</strong>，只生成程序的目标代码文件</p><p>-o ： 指定<strong>生成的可执行程序名</strong>，缺省时候生成的可执行程序名是 a.out ；语法: -o 文件名</p></blockquote><p><img src="image-20231204161547150.png" alt="image-20231204161547150"></p><p><img src="image-20231204161612641.png" alt="image-20231204161612641"></p><h2 id="3-重定向程序输出与出错信息">3.重定向程序输出与出错信息</h2><p><img src="image-20231204161657044.png" alt="image-20231204161657044"></p><p><img src="image-20231204161829042.png" alt="image-20231204161829042"></p><h2 id="4-make工具-u-看不懂原理-u">4.make工具（<u>看不懂原理</u>）</h2><blockquote><p>make工具 ： GNU工程化编译工具，用于编译众多相互关联的源代码文件</p></blockquote><p><img src="image-20231204161934418.png" alt="image-20231204161934418"></p><p><img src="image-20231204161949121.png" alt="image-20231204161949121"></p><p><img src="image-20231204162001606.png" alt="image-20231204162001606"></p><p><img src="image-20231204162333300.png" alt="image-20231204162333300"></p><h1 id="八-shell编程">八、shell编程</h1><h2 id="1-unix-shell编程语言简介">1.UNIX shell编程语言简介</h2><p><img src="image-20231204163613672.png" alt="image-20231204163613672"></p><p><img src="image-20231204163747359.png" alt="image-20231204163747359"></p><p><img src="image-20231204163848400.png" alt="image-20231204163848400"></p><p><strong>前提条件：</strong></p><ol><li><strong>对于使用sh命令的方法：脚本中的命令要与使用的shell兼容</strong></li><li><strong>对于第二种方法：要先使文件对于用户或所有者具有可执行权限</strong></li></ol><p><img src="image-20231204164023952.png" alt="image-20231204164023952"></p><p><img src="image-20231204164102844.png" alt="image-20231204164102844"></p><p><img src="image-20231204164242380.png" alt="image-20231204164242380"></p><p><img src="image-20231204164437159.png" alt="image-20231204164437159"></p><h3 id="退出shell的方法">「退出shell的方法」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br><span class="line">Ctrl -d</span><br></pre></td></tr></table></figure><h3 id="执行脚本">「执行脚本」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh program  <span class="comment">#不需要执行权限，在子shell中进行，脚本文件需要与所用shell兼容</span></span><br><span class="line">./program   <span class="comment">#要具有可执行的权限，在子shell中进行</span></span><br><span class="line">. program   <span class="comment">#不需要可执行权限，在当前shell中执行</span></span><br></pre></td></tr></table></figure><p><img src="image-20231205100059587.png" alt="image-20231205100059587"></p><h2 id="2-编程基础">2.编程基础</h2><h3 id="命令置换-命令">「命令置换 ``命令」</h3><blockquote><p>将一个命令的输出作为另一个命令的参数(重音符号)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="built_in">command</span>`</span><br></pre></td></tr></table></figure><p><img src="image-20231205100259221.png" alt="image-20231205100259221"></p><h3 id="读取输入-read命令">「读取输入 read命令」</h3><blockquote><p>从标准输入设备读入字符串存入变量中</p></blockquote><p><strong>多变量输入</strong>：输入中第1个字符串存入第1个变量，第2个字符串存入第2个变量，…，字符串数多于变量数，所有剩余字符存入最后一个变量</p><p><img src="image-20231205100411909.png" alt="image-20231205100411909"></p><h3 id="自定义变量">「自定义变量」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名=变量值</span><br></pre></td></tr></table></figure><ul><li><p><strong>shell不支持数据类型，赋给变量的值解释成字符串</strong></p></li><li><p><strong>变量名遵守与文件命名同样的语法规则</strong></p></li><li><p><strong>变量可以在shell提示符下定义并使用</strong></p></li></ul><p>生存周期：变量保存在内存中，直到脚本结束或终止</p><h3 id="清除变量-："><strong>「清除变量」：</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> 变量名</span><br></pre></td></tr></table></figure><h3 id="显示变量值-：">「显示变量值」：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $变量名</span><br></pre></td></tr></table></figure><h3 id="命令行参数-：">「命令行参数」：</h3><blockquote><p>又称位置变量，用户输入命令时后面跟的数据项，空格分隔</p></blockquote><ol><li><strong>参数传递给程序，可以改变程序行为或执行顺序</strong></li><li><strong>按顺序命令行参数被命名为$0、$1、…$9</strong></li><li>*<em>命令行参数多于9个，第9个之后的被忽略，但可通过$<em>获得</em></em></li></ol><p><img src="image-20231205100834762.png" alt="image-20231205100834762"></p><h3 id="set-命令">「set 命令」</h3><blockquote><p>给位置变量赋值，set参数依次赋值给位置变量</p></blockquote><p><img src="image-20231205100950854.png" alt="image-20231205100950854"></p><h3 id="exit">「exit」</h3><blockquote><p>shell内部命令，立即终止程序运行</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span> n</span><br></pre></td></tr></table></figure><ul><li><strong>n是退出状态，也称返回码</strong></li><li><strong>没有提供返回码，使用shell执行最后一条命令的退出值</strong></li><li><strong>为与其他UNIX程序/命令完成时返回一个退出状态，保持一致，编写shell脚本，返回给父进程一个退出状态</strong></li></ul><h2 id="3-条件与测试语句">3.条件与测试语句</h2><h3 id="if-then">「if-then」</h3><p><img src="image-20231205101350833.png" alt="image-20231205101350833"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><img src="image-20231205101431498.png" alt="image-20231205101431498"></p><h3 id="if-then-else">「if-then-else」</h3><p><img src="image-20231205101530279.png" alt="image-20231205101530279"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><img src="image-20231205101603297.png" alt="image-20231205101603297"></p><p>「if -then-eif」</p><p><img src="image-20231205101637201.png" alt="image-20231205101603297"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition1 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> [ condition2 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> [condition3 ]</span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="test">「test」</h3><blockquote><p>内部命令，它计算作为其参数的表达式的真假</p></blockquote><ul><li>**<em>真返回0，<em>假返回非0值</em></em></li><li><strong>[ condition ]是test命令的一种特殊写法</strong></li></ul><p><img src="image-20231205103608624.png" alt="image-20231205103608624"></p><p><img src="image-20231205103641272.png" alt="image-20231205103641272"></p><p><strong>判断数值：</strong></p><p><img src="image-20231205103654191.png" alt="image-20231205103654191"></p><p><strong>判断字符串：</strong></p><p><img src="image-20231205103707192.png" alt="image-20231205103707192"></p><p><img src="image-20231205103733801.png" alt="image-20231205103733801"></p><p><img src="image-20231205103751538.png" alt="image-20231205103751538"></p><p><strong>文件检测：</strong></p><p><img src="image-20231205103934119.png" alt="image-20231205103934119"></p><p><img src="image-20231205104022879.png" alt="image-20231205104022879"></p><h2 id="4-算术运算">4.算术运算</h2><h3 id="expr">「expr 」</h3><p><img src="image-20231205104139324.png" alt="image-20231205104139324"></p><p><img src="image-20231205104225736.png" alt="image-20231205104225736"></p><p><img src="image-20231205104242409.png" alt="image-20231205104242409"></p><h3 id="let">「let」</h3><p><img src="image-20231205104313227.png" alt="image-20231205104313227"></p><h2 id="5-循环">5.循环</h2><h3 id="for">「for」</h3><p><img src="image-20231205104412482.png" alt="image-20231205104412482"></p><p><img src="image-20231205104428159.png" alt="image-20231205104428159"></p><h3 id="while循环">「while循环」</h3><h1 id="九-系统管理">九、系统管理</h1><h2 id="1-文件系统管理">1.文件系统管理</h2><p><img src="image-20231205104731672.png" alt="image-20231205104731672"></p><h3 id="fdisk-命令">「fdisk 命令」</h3><p><img src="image-20231205104812741.png" alt="image-20231205104812741"></p><h3 id="mkfs">「mkfs」</h3><p><img src="image-20231205104853625.png" alt="image-20231205104853625"></p><h3 id="mount">「mount」</h3><p><img src="image-20231205104922676.png" alt="image-20231205104922676"></p><p><img src="image-20231205104945923.png" alt="image-20231205104945923"></p><h3 id="df">「df」</h3><p><img src="image-20231205105013868.png" alt="image-20231205105013868"></p><h3 id="du">「du」</h3><p><img src="image-20231205105036834.png" alt="image-20231205105036834"></p><h2 id="2-存档和压缩文件">2.存档和压缩文件</h2><h3 id="tar">「tar」</h3><p><img src="image-20231205105131143.png" alt="image-20231205105131143"></p><p><img src="image-20231205105225215.png" alt="image-20231205105225215"></p><p><img src="image-20231205105302202.png" alt="image-20231205105302202"></p><p><img src="image-20231205105317906.png" alt="image-20231205105317906"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;声明：本篇文章参考和引用了2023下半年吉林大学郭东老师的PPT，如有侵权，请联系我，我将会立马删除&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;一-unix操作系统&quot;&gt;一、UNIX操作系统&lt;/h1&gt;
&lt;h2 id=&quot;1-历史简介&quot;&gt;1.历史简介&lt;/h2&gt;
&lt;</summary>
      
    
    
    
    <category term="class record" scheme="https://klklkl10086.github.io/klklkl10086.github.io/categories/class-record/"/>
    
    
    <category term="Linux" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>学习生活随记</title>
    <link href="https://klklkl10086.github.io/klklkl10086.github.io/2023/07/28/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    <id>https://klklkl10086.github.io/klklkl10086.github.io/2023/07/28/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</id>
    <published>2023-07-28T07:43:29.000Z</published>
    <updated>2024-07-05T14:54:58.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大一上学期">大一上学期</h2><p>c语言</p><p>蓝桥杯省三</p><h2 id="大一下学期">大一下学期</h2><p>c++面向对象程序设计</p><p>初识CTF REVERSE</p><h2 id="大一暑假">大一暑假</h2><p>CTF REVERSE</p><p>数据结构</p><p>matlab</p><p>python</p><p>hexo搭建博客</p><p>微积分</p><p>暑假过得稀碎，啥也不是，好像学了又好像没学。</p><h2 id="大二上学期">大二上学期</h2><p>课程： 计算机组成原理  数据结构 离散2  微积分3  c++设计</p><p>参加数学建模比赛，真的很难绷，选c题做的稀烂。</p><p>加了百度菁英班，算法题全是数论相关，欧拉函数真的很迷，做完全都忘记了。</p><p>计组原理和数据结构全是硬菜，前者与数电紧密相联，并且内容很多，后者则是需要实践与学习相结合 。离散数学也不好过 ，概念很多，逻辑关系很强，老师讲课也很赶（虽然不是老师的错）——2023.9.26</p><p>今天中午尝试了中午提前到教室，在阶梯教室睡午觉然后继续学习，感觉梦回高三睡在合堂，不知道什么时候能轻松一点。上周六的CTF校赛没有参加，还是好好学习准备期末考试吧。</p><p>——2023/10/24</p><p>​离散数学和面向对象程序设计都是4/4，蛮开心的 ，继续前进吧。——2023/11/13</p><p>期末考试还可以，总算拯救了绩点，得了一千奖学金和数模省三等奖（水），以及六级没过（悲）——2024/2/28</p><h2 id="大二暑假">大二暑假</h2><p>美赛</p><p>python pandas</p><p>很摆烂</p><h2 id="大二下">大二下</h2><p>专业课很多的一个学期</p><p>完蛋啦，今天上午那个数据结构(1.5学分)上机《手撕sort进阶版》一个点都没答对，上周的红黑树也是,有一个点没过,又一次想死了，悲。下午上完毛概冲去蜜雪冰城买了一杯饮料喝了喝,好喝,但还是难受,≧ ﹏ ≦,自己是不是不适合这个专业呢?——2024/03/18</p><p>暑假来了已经彻底放弃保研了——2024/7/5</p>]]></content>
    
    
    <summary type="html">一些关于学习的简单记录</summary>
    
    
    
    <category term="life" scheme="https://klklkl10086.github.io/klklkl10086.github.io/categories/life/"/>
    
    
    <category term="随记" scheme="https://klklkl10086.github.io/klklkl10086.github.io/tags/%E9%9A%8F%E8%AE%B0/"/>
    
  </entry>
  
</feed>
