<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>klklkl&#39;s blogs</title>
  
  <subtitle>学习笔记和一些思考</subtitle>
  <link href="https://comeupklklkl.gitee.io/jluloser.github.io/atom.xml" rel="self"/>
  
  <link href="https://comeupklklkl.gitee.io/jluloser.github.io/"/>
  <updated>2024-03-19T13:43:52.786Z</updated>
  <id>https://comeupklklkl.gitee.io/jluloser.github.io/</id>
  
  <author>
    <name>klklkl</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>蓝桥杯</title>
    <link href="https://comeupklklkl.gitee.io/jluloser.github.io/2024/02/22/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    <id>https://comeupklklkl.gitee.io/jluloser.github.io/2024/02/22/%E8%93%9D%E6%A1%A5%E6%9D%AF/</id>
    <published>2024-02-22T02:50:11.000Z</published>
    <updated>2024-03-19T13:43:52.786Z</updated>
    
    <content type="html"><![CDATA[<p>放在前面的话：</p><p>​这份笔记是在大二下刚开学的时候进行书写的，主要参考的是Acwing的<a href="https://www.acwing.com/activity/content/19/">蓝桥杯辅导课</a>，也有部分内容参考了《算法竞赛入门经典》，笔者在成体系的学习算法之前已经学习过基本的<a href="https://comeupklklkl.gitee.io/jluloser.github.io/2023/10/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>，以及离散数学。（PS:y总讲课很好，如果可以建议报一下试试）</p><h1 id="基础概念">基础概念</h1><p><img src="image-20240303174545579.png" alt="image-20240303174545579"></p><p><img src="image-20240303174624177.png" alt="image-20240303174624177"></p><p>long long + - 1e18</p><p><img src="image-20240303171131695.png" alt="image-20240303171131695"></p><p><img src="image-20240303171619694.png" alt="image-20240303171619694"></p><p><img src="image-20240303215100441.png" alt="image-20240303215100441"></p><p>下取整 （int）直接除</p><p>上取整：转化成下取整</p><p><img src="image-20240314212814712.png" alt="image-20240314212814712"></p><p><img src="image-20240314213050728.png" alt="image-20240314213050728"></p><p><img src="image-20240319174400674.png" alt="image-20240319174400674"></p><h1 id="技巧">技巧</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="built_in">getline</span>(cin,str);</span><br><span class="line"><span class="keyword">while</span>(cnt--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">getline</span>(cin,str);</span><br><span class="line">        <span class="function">stringstream <span class="title">ssin</span><span class="params">(str)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(ssin&gt;&gt;a[n]) n++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="递归与递推">递归与递推</h1><p>递归：把问题分成若干个相同子问题</p><p>递推：由子问题推出最终问题</p><h1 id="二分">二分</h1><h2 id="整数二分">整数二分</h2><ul><li><p>确定一个区间使得答案一定在一个区间里</p></li><li><p>找一个性质，满足两点：</p><p>性质具有二段性</p><p>答案是二段性的分段点（有两种情况，一种是前段的终点a，一种是后段的起点b，a与b不重合）</p></li></ul><p><img src="image-20240307215445608.png" alt="image-20240307215445608"></p><p><img src="image-20240307215206733.png" alt="image-20240307215206733"></p><h1 id="前缀和">前缀和</h1><p>一定要将下标加一，不然遇见s[i-1]会出问题</p><h2 id="一维前缀和">一维前缀和</h2><p>利用数列的思想：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>r</mi></msub><mo>−</mo><msub><mi>S</mi><mi>l</mi></msub><mo>=</mo><msub><mi>a</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>a</mi><mrow><mi>l</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>a</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">S_r-S_l=a_{l+1}+a_{l+2}+...+a_{r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.791661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.791661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><h2 id="二维前缀和">二维前缀和</h2><p>与一维前缀和思想类似:</p><blockquote><p><strong>容斥原理</strong>:</p><p>在计数时，必须注意没有重复，没有遗漏。为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目<a href="https://baike.baidu.com/item/%E6%8E%92%E6%96%A5/10717656?fromModule=lemma_inlink">排斥</a>出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理</p></blockquote><p><strong>1.计算前缀和矩阵</strong></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></msub><mo>=</mo><msub><mi>S</mi><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></msub><mo>+</mo><msub><mi>S</mi><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msub><mo>−</mo><msub><mi>S</mi><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msub><mo>+</mo><msub><mi>a</mi><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">S_{(x,y)} = S_{(x-1,y)}+S_{(x,y-1)}-S_{(x-1,y-1)}+a_{(x,y)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7857599999999999em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span></span></p><p><strong>2.利用前缀和矩阵计算子矩阵的和</strong></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></msub><mo>=</mo><msub><mi>S</mi><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></msub><mo>−</mo><msub><mi>S</mi><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msub><mo>−</mo><msub><mi>S</mi><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>−</mo><mn>1</mn><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></msub><mo>+</mo><msub><mi>S</mi><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>−</mo><mn>1</mn><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">S_{(x_1,y_1),(x_2,y_2)} = S_{(x_2,y_2)}-S_{(x_2,y_1-1)}-S_{(x_1-1,y_2)}+S_{(x_1-1,y_1-1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mpunct mtight">,</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span></span></p><h1 id="数学知识">数学知识</h1><p>尽力分析</p><p>打表找规律</p><p><img src="image-20240314210202079.png" alt="image-20240314210202079"></p><h1 id="高精度计算">高精度计算</h1><h2 id="大数加法">大数加法</h2><h3 id="课程">课程</h3><p><strong>没有考虑负数的情况</strong></p><p><a href="https://www.bilibili.com/video/BV1Ne411v78Z/?spm_id_from=333.788&amp;vd_source=9a4fe569cfdfb26138828e9c87e1512d">b站大数加法</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">vector2string</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; x, <span class="type">int</span> s, <span class="type">bool</span> flag = <span class="number">1</span>)</span><span class="comment">//flag为1则x为正数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">string <span class="title">ans</span><span class="params">(s, <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s; i++)</span><br><span class="line">&#123;</span><br><span class="line">ans[i] = <span class="string">&#x27;0&#x27;</span> + x[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());<span class="comment">//倒置</span></span><br><span class="line"> <span class="keyword">if</span>(!flag)    ans.<span class="built_in">insert</span>(<span class="number">0</span>,<span class="string">&quot;-&quot;</span>);<span class="comment">//如果为负数在数字前面添加负号</span></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">add</span><span class="params">(string&amp; num1, string&amp; num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(num1.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(num2.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num1.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">a[num1.<span class="built_in">size</span>() - i - <span class="number">1</span>] = num1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num2.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">b[num2.<span class="built_in">size</span>() - i - <span class="number">1</span>] = num2[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(num1.size() + num2.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> len = num2.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (num2.<span class="built_in">size</span>() &gt; num1.<span class="built_in">size</span>()) len = num1.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">c[i]+= a[i] + b[i];</span><br><span class="line">c[i + <span class="number">1</span>] += c[i] / <span class="number">10</span>;</span><br><span class="line">c[i] %= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//位数较长的数平移加上对应位置的c[i]</span></span><br><span class="line"><span class="keyword">if</span> (num1.<span class="built_in">size</span>() &gt; num2.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; num1.<span class="built_in">size</span>(); i++)</span><br><span class="line">c[i] += a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (num1.<span class="built_in">size</span>() &lt; num2.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; num2.<span class="built_in">size</span>(); i++)</span><br><span class="line">c[i] += b[i];</span><br><span class="line">&#125;</span><br><span class="line">    len = num1.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (num2.<span class="built_in">size</span>() &gt; num1.<span class="built_in">size</span>()) len = num2.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span> (c[len] == <span class="number">0</span>)<span class="comment">//去除前导0</span></span><br><span class="line">&#123;</span><br><span class="line">len--;</span><br><span class="line">&#125;</span><br><span class="line">string ans = <span class="built_in">vector2string</span>(c, len + <span class="number">1</span>);<span class="comment">//转换为string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习">练习</h3><p><a href="https://leetcode.cn/problems/add-strings/submissions/504061261/">力扣 字符串加法</a></p><h2 id="大数减法">大数减法</h2><h3 id="课程">课程</h3><p><a href="https://www.bilibili.com/video/BV1kb4y1A7Wf/?spm_id_from=333.788&amp;vd_source=9a4fe569cfdfb26138828e9c87e1512d">b站</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">divide</span><span class="params">(string&amp; num1, string&amp; num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> flag = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (num1.<span class="built_in">size</span>() &lt; num2.<span class="built_in">size</span>() || (num1.<span class="built_in">size</span>() == num2.<span class="built_in">size</span>() &amp;&amp; num1 &lt; num2))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(num1, num2);</span><br><span class="line">flag = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(num1.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(num2.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num1.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">a[num1.<span class="built_in">size</span>() - i - <span class="number">1</span>] = num1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num2.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">b[num2.<span class="built_in">size</span>() - i - <span class="number">1</span>] = num2[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(num1.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> len = num2.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt; b[i])</span><br><span class="line">&#123;</span><br><span class="line">a[i] += <span class="number">10</span>;</span><br><span class="line">a[i + <span class="number">1</span>]--;</span><br><span class="line">&#125;</span><br><span class="line">c[i] += a[i] - b[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; num1.<span class="built_in">size</span>(); i++)</span><br><span class="line">c[i] += a[i];</span><br><span class="line">len=c.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (c[len] == <span class="number">0</span>)</span><br><span class="line">len--;</span><br><span class="line"></span><br><span class="line">string ans;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans = <span class="built_in">vector2string</span>(c, len + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ans = <span class="built_in">vector2string</span>(c, len + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大数乘法">大数乘法</h2><p><a href="https://www.bilibili.com/video/BV1LA411v7mt?p=3&amp;vd_source=9a4fe569cfdfb26138828e9c87e1512d">b站 高精度算法</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">mulity</span><span class="params">(string&amp; num1, string&amp; num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(num1.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(num2.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(num1.size() + num2.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= num1.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">a[num1.<span class="built_in">size</span>() - i] = num1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= num2.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">b[num2.<span class="built_in">size</span>() - i] = num2[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= num2.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= num1.<span class="built_in">size</span>(); j++)</span><br><span class="line">&#123;</span><br><span class="line">c[i + j - <span class="number">1</span>] += b[i] * a[j];</span><br><span class="line">c[i + j] += c[i + j - <span class="number">1</span>] / <span class="number">10</span>;</span><br><span class="line">c[i + j - <span class="number">1</span>] %= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> len = c.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (c[len] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">len--;</span><br><span class="line">&#125;</span><br><span class="line">string ans = <span class="built_in">vector2string</span>(c, len + <span class="number">1</span>);</span><br><span class="line">ans = ans.<span class="built_in">substr</span>(<span class="number">0</span>, ans.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态规划-dp">动态规划（dp）</h1><p>暴力dfs-&gt;记忆化搜索–&gt;递推（dp）</p><p>记忆化搜索 = 暴力dfs+记录答案</p><p>递推的公式  = dfs向下递归的公式</p><p>dp的重点在于状态转移方程，即从树的最下层向上归的过程</p><p><a href="https://www.acwing.com/file_system/file/content/whole/index/content/10768518/">跳楼梯</a></p><p><a href="https://acm.cjlu.edu.cn/problem/3641">大盗阿福</a></p><h2 id="背包问题">背包问题</h2><ul><li><p>状态表示</p></li><li><p>状态计算</p><p><img src="image-20240315092802200.png" alt="image-20240315092802200"></p><p><img src="/image-20240315093548155.png" alt="image-20240315093548155"></p></li></ul><p>注意：右边的子集不一定存在只有 当 j  &gt;= v[i]的时候才存在</p><p>之后转化为一维</p><h3 id="0-1背包问题">0-1背包问题</h3><blockquote><p>已知一个背包容积为V，现在有N个物品，每个物品有一个价值Wi，一个体积Vi，每件物品最多用一次，求可以选择的总价值最大。</p></blockquote><h3 id="完全背包问题">完全背包问题</h3><p>每件物品有无限个</p><h3 id="多重背包问题">多重背包问题</h3><p>每个物品有有限个</p><h3 id="分组背包问题">分组背包问题</h3><p>每一组最多选择一个物品</p>]]></content>
    
    
    <summary type="html">蓝桥杯学习记录</summary>
    
    
    
    <category term="算法" scheme="https://comeupklklkl.gitee.io/jluloser.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="蓝桥杯" scheme="https://comeupklklkl.gitee.io/jluloser.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>Pandas</title>
    <link href="https://comeupklklkl.gitee.io/jluloser.github.io/2024/02/04/pandas/"/>
    <id>https://comeupklklkl.gitee.io/jluloser.github.io/2024/02/04/pandas/</id>
    <published>2024-02-04T14:31:41.000Z</published>
    <updated>2024-03-18T09:14:40.964Z</updated>
    
    
    
    
    <category term="Python" scheme="https://comeupklklkl.gitee.io/jluloser.github.io/categories/Python/"/>
    
    
    <category term="Pandas" scheme="https://comeupklklkl.gitee.io/jluloser.github.io/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>Python</title>
    <link href="https://comeupklklkl.gitee.io/jluloser.github.io/2024/01/14/Python/"/>
    <id>https://comeupklklkl.gitee.io/jluloser.github.io/2024/01/14/Python/</id>
    <published>2024-01-14T07:15:19.000Z</published>
    <updated>2024-03-18T09:14:52.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本知识">基本知识</h1><h2 id="字面量">字面量</h2><blockquote><p>在代码中，被写下来的固定的值</p></blockquote><p><strong>常见的字面量数据类型</strong></p><ul><li>数字        整数  浮点数  复数 布尔</li><li>字符串      双引号包围 “字符串”</li><li>列表</li><li>元组</li><li>集合</li><li>字典</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字面量（有空格）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)<span class="comment">#字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">12</span>) <span class="comment">#整数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1.0</span>) <span class="comment">#浮点数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;钱包还有:&quot;</span>, money, <span class="string">&quot;收了一块钱还剩:&quot;</span>, money+<span class="number">1</span>) <span class="comment"># 输出多个变量</span></span><br></pre></td></tr></table></figure><p>写在print语句中的是字面量</p><h2 id="注释">注释</h2><p><strong>单行注释</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我是单行注释（建议有空格）</span></span><br></pre></td></tr></table></figure><p><strong>多行注释</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;我是多行注释一般用于开头解释类和程序</span></span><br><span class="line"><span class="string">三个引号开头，三个引号结尾，可以换行</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="变量">变量</h2><blockquote><p>记录数据的盒子,值可以改变</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变量名 = 变量值</span></span><br><span class="line">money = <span class="number">52</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;钱包还有:&quot;</span>, money, <span class="string">&quot;\n收了一块钱还剩:&quot;</span>, money+<span class="number">1</span>)</span><br><span class="line">money = money-<span class="number">10</span> <span class="comment">#  + -  *  /</span></span><br></pre></td></tr></table></figure><h2 id="数据类型">数据类型</h2><blockquote><p>变量没有类型，<strong>变量中存储的数据</strong>有类型</p></blockquote><p><strong>type()语句</strong></p><blockquote><p>用于查看<strong>数据</strong>的类型的函数</p></blockquote><p><strong>使用print直接输出</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="string">&quot;str&quot;</span>))</span><br><span class="line">money = <span class="number">52</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(money))</span><br></pre></td></tr></table></figure><p><strong>用变量存储返回的结果</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str_type = (<span class="built_in">type</span>(<span class="string">&quot;123456&quot;</span>))</span><br><span class="line">money = <span class="number">52</span></span><br><span class="line">money_type = (<span class="built_in">type</span>(money))</span><br></pre></td></tr></table></figure><p><strong>数据类型的转换</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转为整数</span></span><br><span class="line"><span class="built_in">int</span>(x) </span><br><span class="line">num = <span class="built_in">int</span>(<span class="string">&quot;11&quot;</span>)<span class="comment"># 保字符串里都是数字</span></span><br><span class="line">int_float = <span class="built_in">int</span>(<span class="number">11.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转为浮点</span></span><br><span class="line"><span class="built_in">float</span>(x)</span><br><span class="line">float_int = <span class="built_in">float</span>(<span class="number">11</span>)</span><br><span class="line"><span class="comment"># 转为字符串</span></span><br><span class="line"><span class="built_in">str</span>(x)</span><br><span class="line">float_str = <span class="built_in">str</span>(<span class="number">111.34</span>)</span><br></pre></td></tr></table></figure><blockquote><p>任何语句都可转换成字符串</p></blockquote><h2 id="标识符">标识符</h2><blockquote><p><strong>名字</strong></p></blockquote><p><strong>命名规则</strong></p><ul><li>英文  大小写敏感</li><li>中文  不推荐使用</li><li>数字  不可以作为开头</li><li>下划线 _</li><li>不可以使用关键字</li></ul><h2 id="运算符">运算符</h2><p><strong>数学运算符</strong></p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">操作</th></tr></thead><tbody><tr><td style="text-align:center">+</td><td style="text-align:center">加法</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">减法</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">乘法</td></tr><tr><td style="text-align:center">/</td><td style="text-align:center">除法</td></tr><tr><td style="text-align:center">//</td><td style="text-align:center">取整除</td></tr><tr><td style="text-align:center">%</td><td style="text-align:center">取余数</td></tr><tr><td style="text-align:center">**</td><td style="text-align:center">指数</td></tr></tbody></table><p><strong>赋值运算符</strong></p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">操作</th></tr></thead><tbody><tr><td style="text-align:center">=</td><td style="text-align:center">赋值</td></tr></tbody></table><p><strong>复合赋值运算符</strong></p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">操作</th></tr></thead><tbody><tr><td style="text-align:center">+=</td><td style="text-align:center">c+=a  等价于 c=c+a</td></tr><tr><td style="text-align:center">-=</td><td style="text-align:center">c-=a  等价于 c=c-a</td></tr><tr><td style="text-align:center">*=</td><td style="text-align:center">c*=a  等价于 c=c*a</td></tr><tr><td style="text-align:center">/=</td><td style="text-align:center">c/=a  等价于 c=c/a</td></tr><tr><td style="text-align:center">%=</td><td style="text-align:center">c%=a  等价于 c=c%a</td></tr><tr><td style="text-align:center">**=</td><td style="text-align:center">c**=a  等价于 c=c **a</td></tr><tr><td style="text-align:center">//=</td><td style="text-align:center">c//=a  等价于 c=c//a</td></tr></tbody></table><h2 id="字符串">字符串</h2><p><strong>定义</strong></p><ul><li><p>单引号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="string">&#x27;hhhh&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>可以内含双引号</strong></p></li><li><p>双引号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name2 = <span class="string">&quot;hhhhhh2&quot;</span></span><br></pre></td></tr></table></figure><p><strong>可以内含单引号</strong></p></li><li><p>三引号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和多行注释一样</span></span><br><span class="line">name3 = <span class="string">&quot;&quot;&quot;hhhhh</span></span><br><span class="line"><span class="string">hhh3&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>可以用 \ 解除效用 变成普通字符串</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;&quot;123456&#x27;</span></span><br><span class="line">name = <span class="string">&quot;&#x27;12345&#x27;&quot;</span></span><br><span class="line">name = <span class="string">&quot;\&quot;123456&quot;</span></span><br></pre></td></tr></table></figure><p><strong>字符串拼接</strong></p><blockquote><p>使用+号</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>+<span class="string">&quot;456&quot;</span>)</span><br><span class="line">name = <span class="string">&quot;987&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;12345&quot;</span> + name + <span class="string">&quot;564&quot;</span>)</span><br><span class="line">tel = <span class="number">132456</span></span><br><span class="line"><span class="comment"># print(&quot;111111&quot; + tel +&quot;454&quot;) error</span></span><br></pre></td></tr></table></figure><p><strong>字符串没有办法和其他类型拼接</strong></p><p><strong>字符串格式化</strong></p><p><strong>方法一：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;kjkjk&quot;</span></span><br><span class="line">where = <span class="string">&quot;at kl&quot;</span></span><br><span class="line">message = <span class="string">&quot;abced %s %s&quot;</span> % (name, where)</span><br><span class="line"><span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出： abced kjkjk at kl</span></span><br></pre></td></tr></table></figure><p><strong>通过占位的形式完成拼接，%表示占位，s表示将变量变成字符串放入占位的地方</strong></p><table><thead><tr><th>格式符号</th><th>转化</th></tr></thead><tbody><tr><td>%s</td><td>转化为<strong>字符串</strong>放入占位位置</td></tr><tr><td>%d</td><td>转化为<strong>整数</strong>放入占位位置</td></tr><tr><td>%f</td><td>转化为<strong>浮点</strong>放入占位位置</td></tr></tbody></table><p><strong>方法二:</strong></p><p><strong>不限数据类型，不做精度控制，适合对精度没有要求时快速使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">f&quot;...<span class="subst">&#123;变量&#125;</span> &quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num1=<span class="number">11</span></span><br><span class="line">name = <span class="string">&quot;klklklk&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;my name is <span class="subst">&#123;name&#125;</span> ,and age is <span class="subst">&#123;num1&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">my name is klklklk ,and age is 11</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>格式化的精度控制</strong></p><blockquote><p>m.n 控制数度的宽度和精度，m控制宽度，<strong>但当宽度小于自身时不生效</strong>，n控制精度会进行<strong>四舍五入</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">num1=<span class="number">11</span></span><br><span class="line">num2=<span class="number">11.345</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数字11宽度5：%5d\n&quot;</span> % num1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数字11宽度1：%1d\n&quot;</span> % num1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数字11.345宽度7，精度2：%7.2f\n&quot;</span> % num2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数字11.345宽度不限，精度2: %.2f&quot;</span> % num2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数字11.345精度不限，宽度2: %2f&quot;</span> % num2)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">数字11宽度5：   11</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">数字11宽度1：11</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">数字11.345宽度7，精度2：  11.35</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">数字11.345宽度不限，精度2: 11.35</span></span><br><span class="line"><span class="string">数字11.345精度不限，宽度2: 11.345000</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>表达式格式化</strong></p><blockquote><p>表达式：一条具有明确执行结果的代码语句</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1 * 1 = %d&quot;</span> % (<span class="number">1</span>*<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;1 * 2 = <span class="subst">&#123;<span class="number">1</span>*<span class="number">2</span>&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;字符串在python的类型名是：%s&quot;</span> % <span class="built_in">type</span>(<span class="string">&quot;字符串&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出:</span></span><br><span class="line"><span class="string">1 * 1 = 1</span></span><br><span class="line"><span class="string">1 * 2 = 2</span></span><br><span class="line"><span class="string">字符串在python的类型名是：&lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="数据输入">数据输入</h2><p><strong>input语句</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;what is your name?&quot;</span>)</span><br><span class="line">name = <span class="built_in">input</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;you name is <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;what is your name?\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;you name is <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>input语句不管输入什么都统统当作字符串看待，可自行进行数据转换</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="built_in">input</span>(<span class="string">&quot;what is your age?\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;age is&quot;</span>, <span class="built_in">type</span>(age))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">what is your age?</span></span><br><span class="line"><span class="string"> 输入： 18</span></span><br><span class="line"><span class="string">age is &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="判断语句">判断语句</h1><h2 id="布尔类型和比较运算符">布尔类型和比较运算符</h2><p>布尔类型的字面量：</p><p>True ：表示真</p><p>False：表示假</p><p>比较运算符：</p><blockquote><p>== , &gt; , &lt; , &gt;= ,&lt;= ,!=</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool_1 = <span class="literal">True</span></span><br><span class="line">bool_2 = <span class="literal">False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;bool1 is<span class="subst">&#123;<span class="built_in">type</span>(bool_1)&#125;</span>,bool2 is <span class="subst">&#123;<span class="built_in">type</span>(bool_2)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">bool1 is&lt;class &#x27;bool&#x27;&gt;,bool2 is &lt;class &#x27;bool&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">num1 = <span class="number">10</span></span><br><span class="line">num2 = <span class="number">10</span></span><br><span class="line">num3 = <span class="number">15</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;num1 == num2 is <span class="subst">&#123;num1 == num2&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;num1 != num3 is <span class="subst">&#123;num1 != num3&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">num1 == num2 is True</span></span><br><span class="line"><span class="string">num1 != num3 is True</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>字符串也可以进行 == ，! = 比较</strong></p><h2 id="if语句">if语句</h2><p>if [条件] ：</p><p>​条件成立时执行的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">18</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;my age is <span class="subst">&#123;age&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i am a adult&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i will go to university&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;time fly quickly!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">my age is 18</span></span><br><span class="line"><span class="string">i am a adult</span></span><br><span class="line"><span class="string">i will go to university</span></span><br><span class="line"><span class="string">time fly quickly!</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>缩进！！！</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;my age is <span class="subst">&#123;age&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i am a adult&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i will go to university&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;time fly quickly!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">my age is 10</span></span><br><span class="line"><span class="string">time fly quickly!</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="if-else语句">if else语句</h2><blockquote><p>if 条件：</p><p>​条件成立时执行的内容</p><p>else：</p><p>​条件不满足时执行的内容</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;my age is <span class="subst">&#123;age&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i am a adult.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i will go to university.&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i am a child.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i am going to senior high school.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;time fly quickly!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">my age is 10</span></span><br><span class="line"><span class="string">i am a child.</span></span><br><span class="line"><span class="string">i am going to senior high school.</span></span><br><span class="line"><span class="string">time fly quickly!</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="if-elif-else语句">if elif else语句</h2><blockquote><p>if 条件：</p><p>​ 条件1成立时执行的内容</p><p>elif 条件2:</p><p>条件2成立时执行的内容</p><p>elif 条件n：<br>    条件 n成立时执行的内容</p><p>else：</p><p>​ 上述条件都不满足时执行的内容</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">height = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你的身高（cm）：&quot;</span>))</span><br><span class="line">vip_level = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;您的vip等级是：&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> height&lt;<span class="number">120</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;小于120cm 可以免费&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> vip_level&gt;<span class="number">3</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;vip&gt;3 可以免费&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;收费10元&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>多条件判断下，条件互斥，只要有一个条件满足，则其他条件不成立，语句不执行</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你的身高（cm）：&quot;</span>))&lt;<span class="number">120</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;小于120cm 可以免费&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;您的vip等级是：&quot;</span>))&gt;<span class="number">3</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;vip&gt;3 可以免费&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;收费10元&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="判断语句的嵌套">判断语句的嵌套</h2><blockquote><p>if  条件1:</p><p>​ 条件1成立时执行的内容</p><p>​ 条件1成立时执行的内容</p><p>​if 条件2:</p><p>​ 条件2成立时执行的内容</p><p>​ 条件2成立时执行的内容</p></blockquote><p>not表示取反</p><h1 id="循环语句">循环语句</h1><h2 id="while循环">while循环</h2><blockquote><p>while 条件:<br>条件满足要做的事情1</p><p>​条件满足要做的事情2</p><p>​条件满足要做的事情3</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i&lt;<span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;this is %d&quot;</span>% i)</span><br><span class="line">    i= i+<span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="built_in">sum</span>=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i&lt;=<span class="number">100</span>:</span><br><span class="line">    <span class="built_in">sum</span>+=i</span><br><span class="line">    i= i+<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sum=%d&quot;</span>%<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure><p>小脚本：</p><p>猜数字，猜错判断大于小于，猜对输出猜的次数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">num = random.randint(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">flag = <span class="literal">True</span></span><br><span class="line"><span class="keyword">while</span> flag:</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">    guess_num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;what is it?&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> guess_num == num:</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;you are right&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> guess_num &gt; num:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;you are bigger&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;you are smaller&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;the times is <span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>嵌套</strong></p><blockquote><p>while 条件1:<br>条件1满足要做的事情1</p><p>​条件1满足要做的事情2</p><p>​条件1满足要做的事情3</p><p>​…</p><p>​while 条件2:<br>​条件2满足要做的事情1</p><p>​条件2满足要做的事情2</p><p>​条件2满足要做的事情3</p><p>​…</p></blockquote><p>小脚本：</p><p>打印九九乘法表</p><p>前置知识：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#print输出如何不换行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lh = <span class="number">1</span></span><br><span class="line">rh = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> rh&lt;=<span class="number">9</span>:</span><br><span class="line">    lh=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> lh&lt;=rh:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%d * %d = %d &quot;</span>%(lh,rh,lh*rh), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        lh+=<span class="number">1</span></span><br><span class="line">    rh+=<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>()<span class="comment">#输出空内容 换行</span></span><br></pre></td></tr></table></figure><h2 id="for循环">for循环</h2><blockquote><p>for <strong>临时变量</strong> in 待处理的数据集:</p><p>​循环条件满足时候执行的代码</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;abcdefg&quot;</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> name:</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">b</span></span><br><span class="line"><span class="string">c</span></span><br><span class="line"><span class="string">d</span></span><br><span class="line"><span class="string">e</span></span><br><span class="line"><span class="string">f</span></span><br><span class="line"><span class="string">g</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>无法自定义无限循环，数据集不可能无限大</strong></p><p>小脚本：<br>统计字符串中有多少个字母a</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>(<span class="string">&quot;please input your str&quot;</span>)</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">if</span> x == <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure><p><strong>tips:</strong></p><blockquote><p>关于临时变量的作用范围，规范上，临时变量是不能在<strong>for循环外部</strong>进行访问，但是实际上，是可以访问到的</p></blockquote><p><strong>range语句</strong></p><p>获得一个数字序列，搭配for循环食用</p><blockquote><p>range(num)</p><p>获取一个从0 开始到num结束的数字序列（不包含num本身）</p></blockquote><blockquote><p>range(num1，num2)</p><p>获取一个从num1开始到num2结束的数字序列（不包含num2本身）</p></blockquote><blockquote><p>range(num1，num2，step)</p><p>获取一个从num1开始到num2结束的数字序列（不包含num2本身）,数字间的步长以step为标准，step默认为1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">8</span>):</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">5</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">7</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">8</span>,<span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>for循环嵌套</strong></p><blockquote><p>控制空格缩进</p><p>for <strong>临时变量1</strong> in 待处理的数据集:</p><p>​循环条件1满足时候执行的代码</p><p>​for <strong>临时变量2</strong> in 待处理的数据集:</p><p>​  循环条件2满足时候执行的代码</p></blockquote><p><strong>for循环和while循环可以互向嵌套</strong></p><p>小脚本：<br>使用for循环打印九九乘法表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> rh <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> lh <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,rh+<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;lh&#125;</span>*<span class="subst">&#123;rh&#125;</span>=<span class="subst">&#123;lh*rh&#125;</span>\t&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><h2 id="循环中断">循环中断</h2><p><strong>continue</strong></p><blockquote><p>中断所在本层循环，直接进入下一次循环</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">100</span>):</span><br><span class="line">语句<span class="number">1</span></span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">    语句<span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>跳过语句2，不执行</p><p><strong>break</strong></p><blockquote><p>直接结束所在本层循环</p></blockquote><h1 id="函数">函数</h1><p>封装特定功能，实现接口，避免重复性劳动，可以重复使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 内置函数 统计字符串长度</span></span><br><span class="line"><span class="built_in">len</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义函数 实现统计字符串长度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my</span> _<span class="built_in">len</span>(data):</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">        dount+=<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;字符串<span class="subst">&#123;data&#125;</span>的长度是:<span class="subst">&#123;count&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="定义">定义</h2><blockquote><p>def 函数名字(传入参数)<strong>:</strong></p><p>​函数体</p><p>​return 返回值</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say_hi</span>():<span class="comment"># 可以没有传入参数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hi i am klklkl&quot;</span>)</span><br><span class="line">    <span class="comment">#可以没有返回值</span></span><br></pre></td></tr></table></figure><p>先定义，再使用，在程序中调用函数才可以进行工作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say_hi</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hi i am klklkl&quot;</span>)</span><br><span class="line">    </span><br><span class="line">say_hi()</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">hi i am klklkl</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x,y</span>):</span><br><span class="line"><span class="keyword">return</span> x+y</span><br><span class="line">add(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">9</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>上述例子中，x和y是形式参数，4和5是实际参数</p><p>没有返回值，则返回值类型为NoneType，表示空，无意义，false</p><p><strong>None的应用</strong></p><ul><li><p>函数的返回值</p></li><li><p>if判断语句</p></li><li><p>声明无初始内容的变量</p></li></ul><p>函数可以嵌套调用，过程类似于栈</p><h2 id="多个返回值">多个返回值</h2><p>python的函数可以实现一次性返回多个值</p><blockquote><p>return 返回值1，返回值2</p><p>变量1，变量2 = 函数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x-<span class="number">1</span>,y+<span class="number">1</span></span><br><span class="line">res1,res2 = test1(<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(res1)</span><br><span class="line"><span class="built_in">print</span>(res2)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">-1</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="传入参数">传入参数</h2><h3 id="位置参数">位置参数</h3><p><img src="image-20240124000603415.png" alt="image-20240124000603415"></p><h3 id="关键字参数">关键字参数</h3><p><img src="image-20240124000631318.png" alt="image-20240124000631318"></p><h3 id="缺省参数">缺省参数</h3><p><img src="image-20240124000828120.png" alt="image-20240124000828120"></p><h3 id="不定长参数">不定长参数</h3><p><strong>位置传递的不定长</strong></p><p><img src="image-20240124001036657.png" alt="image-20240124001036657"></p><p><strong>关键字传递</strong></p><p><img src="image-20240124001119731.png" alt="image-20240124001119731"></p><h3 id="函数作为参数传递">函数作为参数传递</h3><p><img src="image-20240124001429469.png" alt="image-20240124001429469"></p><p>传递的是计算逻辑</p><h2 id="匿名函数">匿名函数</h2><p><img src="image-20240124001931614.png" alt="image-20240124001931614"></p><blockquote><p>lambda 传入参数: 函数体（只能有一行代码）</p></blockquote><p><img src="image-20240124002113484.png" alt="image-20240124002113484"></p><p><img src="image-20240124002424908.png" alt="image-20240124002424908"></p><h1 id="数据容器">数据容器</h1><blockquote><p>一种可以容纳多份数据的数据类型</p></blockquote><p>根据特点的不同可以划分为</p><ul><li>列表</li><li>元组</li><li>字符串</li><li>集合</li><li>字典</li></ul><h2 id="列表-list">列表（list）</h2><h3 id="定义">定义</h3><blockquote><p>变量名 = [元素1,元素2,…]</p></blockquote><p><strong>空列表：</strong></p><blockquote><p>变量名 = []</p><p>变量名 = list()</p></blockquote><p><strong>列表中的每个数据叫作元素</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">name_list = [<span class="string">&quot;name1&quot;</span>, <span class="string">&quot;name2&quot;</span>, <span class="string">&quot;name3&quot;</span>]</span><br><span class="line">com_list = [<span class="string">&quot;name1&quot;</span>, <span class="number">14</span>, <span class="number">2004</span>]</span><br><span class="line">none_list = []</span><br><span class="line"><span class="built_in">print</span>(name_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(name_list))</span><br><span class="line"><span class="built_in">print</span>(com_list)</span><br><span class="line"><span class="built_in">print</span>(none_list)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[&#x27;name1&#x27;, &#x27;name2&#x27;, &#x27;name3&#x27;]</span></span><br><span class="line"><span class="string">&lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line"><span class="string">[&#x27;name1&#x27;, 14, 2004]</span></span><br><span class="line"><span class="string">[]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>也可以嵌套列表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_list = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(my_list))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[[1, 2, 3], [4, 5, 6], [7, 8, 9]]</span></span><br><span class="line"><span class="string">&lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="元素索引">元素索引</h3><blockquote><p>利用下标索引进行取用</p><p>正向：从左到右，从前向后，从0开始，依次递增</p><p>负向：从右向左，从后向前，从-1开始，依次递减</p><p>不可以超出范围</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">0</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">zhangsan</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(my_list[-<span class="number">1</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">wangwu</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>嵌套列表</strong></p><blockquote><p>多层下标索引即可遍历,不可以超出范围</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">my_list = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">0</span>][<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(my_list[-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(my_list[-<span class="number">2</span>][-<span class="number">1</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">8</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="常用方法">常用方法</h3><blockquote><p>class中的内置函数</p></blockquote><h4 id="查询">查询</h4><blockquote><p>查询指定元素在列表中的下标(正向索引)，如果找不到就报错</p><p>列表.index(元素)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_list = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">index = my_list.index([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(index)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="修改">修改</h4><blockquote><p>修改指定下标位置的值</p><p>列表[下标] = 值</p><p>可以正向，也可以反向</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">0</span>])</span><br><span class="line">my_list[<span class="number">0</span>] = <span class="string">&quot;zhangsi&quot;</span></span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">0</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">zhangsan</span></span><br><span class="line"><span class="string">zhangsi</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="插入">插入</h4><blockquote><p>在指定下标索引位置插入指定元素</p><p>列表.insert(下标,元素)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>]</span><br><span class="line">my_list.insert(<span class="number">2</span>, <span class="string">&quot;zhaoliu&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[&#x27;zhangsan&#x27;, &#x27;lisi&#x27;, &#x27;zhaoliu&#x27;, &#x27;wangwu&#x27;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="追加">追加</h4><blockquote><p>在列表尾部添加元素</p></blockquote><p><strong>追加一个元素：</strong></p><blockquote><p>列表.append(元素)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>]</span><br><span class="line">my_list.append(<span class="number">1234</span>)</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[&#x27;zhangsan&#x27;, &#x27;lisi&#x27;, &#x27;wangwu&#x27;, 1234]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>]</span><br><span class="line">new_list = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">my_list.append(new_list)</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[&#x27;zhangsan&#x27;, &#x27;lisi&#x27;, &#x27;wangwu&#x27;, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>追加一批元素（新的列表）：</strong></p><blockquote><p>列表1.extend(列表2)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>]</span><br><span class="line">new_list = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">my_list.extend(new_list)</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[&#x27;zhangsan&#x27;, &#x27;lisi&#x27;, &#x27;wangwu&#x27;, [1, 2, 3], [4, 5, 6], [7, 8, 9]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="删除">删除</h4><blockquote><p>del列表[下标]</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>]</span><br><span class="line"><span class="keyword">del</span> my_list[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[&#x27;zhangsan&#x27;, &#x27;wangwu&#x27;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>列表.pop(下标)</p><p>会返回对应下标的元素内容</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(my_list.pop(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">wangwu</span></span><br><span class="line"><span class="string">[&#x27;zhangsan&#x27;, &#x27;lisi&#x27;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>删除某元素在列表中的第一个匹配项</strong></p><blockquote><p>列表.remove(元素)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>]</span><br><span class="line">my_list.remove(<span class="string">&quot;zhangsan&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[&#x27;lisi&#x27;, &#x27;wangwu&#x27;, &#x27;zhangsan&#x27;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>清空</strong></p><blockquote><p>列表.clear()</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>]</span><br><span class="line">my_list.clear()</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>统计元素个数</strong></p><blockquote><p>统计指定元素在列表中的个数</p><p>列表.count(元素)</p><p>返回值即为数量</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(my_list.count(<span class="string">&quot;zhangsan&quot;</span>))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>列表元素的数量</strong></p><blockquote><p>len(列表)</p><p>返回值即为数量</p><p>不是list内部的函数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(my_list))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="特点">特点</h3><ol><li><strong>列表有上限，但上限很大</strong></li><li><strong>可以容纳不同类型的元素</strong></li><li><strong>数据有序存储</strong></li><li><strong>允许重复数据存在</strong></li><li><strong>可以修改</strong></li></ol><h3 id="循环遍历">循环遍历</h3><p><strong>while循环遍历</strong></p><p><strong>下标索引</strong>的方式进行取用元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>]</span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> index&lt;<span class="built_in">len</span>(my_list):</span><br><span class="line">    x = my_list[index]</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">zhangsan</span></span><br><span class="line"><span class="string">lisi</span></span><br><span class="line"><span class="string">wangwu</span></span><br><span class="line"><span class="string">zhangsan</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>for循环遍历</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> my_list:</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">zhangsan</span></span><br><span class="line"><span class="string">lisi</span></span><br><span class="line"><span class="string">wangwu</span></span><br><span class="line"><span class="string">zhangsan</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="元组">元组</h2><blockquote><p>可以存储多个不同类型的元素，但是<strong>不可以修改</strong></p></blockquote><h3 id="定义">定义</h3><blockquote><p>变量 =   (元素,元素,元素, …)</p></blockquote><p>空元组：</p><blockquote><p>变量 =   ()</p><p>变量 =   tuple()</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">t1 = (<span class="number">1</span>,<span class="string">&quot;hello&quot;</span>,<span class="literal">True</span>)</span><br><span class="line">t2 = ()</span><br><span class="line">t3 = <span class="built_in">tuple</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t1=<span class="subst">&#123;t1&#125;</span>,type= <span class="subst">&#123;<span class="built_in">type</span>(t1)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t2=<span class="subst">&#123;t2&#125;</span>,type= <span class="subst">&#123;<span class="built_in">type</span>(t2)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t3=<span class="subst">&#123;t3&#125;</span>,type= <span class="subst">&#123;<span class="built_in">type</span>(t3)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">t1=(1, &#x27;hello&#x27;, True),type= &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="string">t2=(),type= &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="string">t3=&lt;class &#x27;tuple&#x27;&gt;,type= &lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t4= (<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t4=<span class="subst">&#123;t4&#125;</span>,type= <span class="subst">&#123;<span class="built_in">type</span>(t4)&#125;</span>&quot;</span>)</span><br><span class="line">t5= (<span class="string">&quot;hello,&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t5=<span class="subst">&#123;t5&#125;</span>,type= <span class="subst">&#123;<span class="built_in">type</span>(t5)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">t4=hello,type= &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="string">t5=(&#x27;hello&#x27;,),type= &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>当元组中<strong>只有一个元素</strong>的时候要求在其后<strong>写上一个逗号</strong>否则不是元组</p><h3 id="嵌套元组">嵌套元组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t6= ((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t5=<span class="subst">&#123;t6&#125;</span>,type= <span class="subst">&#123;<span class="built_in">type</span>(t6)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">t5=((1, 2, 3), (4, 5, 6), (7, 8)),type= &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="下标索引">下标索引</h3><p>和list一样，元组也可以通过下标索引进行取用元素，写法相同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t6= ((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(t6[<span class="number">1</span>][<span class="number">2</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="相关操作">相关操作</h3><h4 id="查找指定元素">查找指定元素</h4><p>查找并返回指定元素的下标</p><blockquote><p>元组. index(x)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t6= ((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(t6.index((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="统计元素个数">统计元素个数</h4><p>1.统计并返回元组中<strong>指定元素</strong>的个数</p><blockquote><p>元组.count()</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t6= ((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">7</span>,<span class="number">8</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(t6.count((<span class="number">7</span>,<span class="number">8</span>)))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>2.统计并返回<strong>元组中的元素</strong>个数</p><blockquote><p>len(元组)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t6= ((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">7</span>,<span class="number">8</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(t6))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="遍历">遍历</h4><p><strong>for循环</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t6= ((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">7</span>,<span class="number">8</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> t6:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">(1, 2, 3)</span></span><br><span class="line"><span class="string">(7, 8)</span></span><br><span class="line"><span class="string">(4, 5, 6)</span></span><br><span class="line"><span class="string">(7, 8)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>while循环</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">t6= ((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">7</span>,<span class="number">8</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> index&lt;<span class="built_in">len</span>(t6):</span><br><span class="line">    <span class="built_in">print</span>(t6[index])</span><br><span class="line">    index+=<span class="number">1</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">(1, 2, 3)</span></span><br><span class="line"><span class="string">(7, 8)</span></span><br><span class="line"><span class="string">(4, 5, 6)</span></span><br><span class="line"><span class="string">(7, 8)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>元组里的元素不可以修改，但是在元组里嵌套的list的元素是可以修改的</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t6= ((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">7</span>,<span class="number">8</span>),[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&quot;hello&quot;</span>],(<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(t6[-<span class="number">2</span>])</span><br><span class="line">t6[-<span class="number">2</span>][-<span class="number">1</span>]=<span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(t6[-<span class="number">2</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[1, 2, 3, 4, &#x27;hello&#x27;]</span></span><br><span class="line"><span class="string">[1, 2, 3, 4, &#x27;world&#x27;]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="特点">特点</h3><ol><li><strong>可以容纳不同类型的元素</strong></li><li><strong>数据有序存储</strong></li><li><strong>允许重复数据存在</strong></li><li><strong>不可以修改</strong></li></ol><h2 id="字符串">字符串</h2><blockquote><p>字符的容器，一个字符串可以存放任意数量的字符</p></blockquote><p><strong>下标索引在字符串中也可以使用，正向从0开始，负向从-1开始</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;abcdefg&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">g</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>字符串是不可修改的数据容器</strong>，<strong>只读</strong></p><h3 id="常用方法">常用方法</h3><h4 id="查找指定元素的下标">查找指定元素的下标</h4><blockquote><p>查找并返回指定元素的下标：字符串.index(x)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;abcdefg&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.index(<span class="string">&quot;bcd&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.index(<span class="string">&quot;g&quot;</span>))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="字符串替换">字符串替换</h4><blockquote><p>将字符串中指定的内容替换成指定内容，并返回替换后新的字符串</p><p><strong>字符串.replace(字符串1,字符串2)</strong>  将字符串1换成2形成新的字符串</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;abcdefg&quot;</span></span><br><span class="line">newstr = <span class="built_in">str</span>.replace(<span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;dcba&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(newstr)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">abcdefg</span></span><br><span class="line"><span class="string">dcbaefg</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="字符串分割">字符串分割</h4><blockquote><p><strong>字符串.split(分隔符字符串)</strong></p></blockquote><blockquote><p>按照指定的分隔符字符串，将字符串划分为多个字符串，并存到列表对象中</p></blockquote><p><strong>字符串本身不变而是得到一个列表对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;hello world i am klklkl&quot;</span></span><br><span class="line">newstr = <span class="built_in">str</span>.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;newstr = <span class="subst">&#123;newstr&#125;</span>,type = <span class="subst">&#123;<span class="built_in">type</span>(newstr)&#125;</span> &quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">hello world i am klklkl</span></span><br><span class="line"><span class="string">newstr = [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;i&#x27;, &#x27;am&#x27;, &#x27;klklkl&#x27;],type = &lt;class &#x27;list&#x27;&gt; </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="规整操作">规整操作</h4><p><strong>去除前后空格</strong></p><blockquote><p>字符串.strip()</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;   hello world i am klklkl  &quot;</span></span><br><span class="line">newstr = <span class="built_in">str</span>.strip()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;newstr = <span class="subst">&#123;newstr&#125;</span> &quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   hello world i am klklkl  </span></span><br><span class="line"><span class="string">newstr = hello world i am klklkl </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>去除前后指定字符串</strong></p><blockquote><p>字符串.strip(字符串)    将传入的字符串划分成小串，只要<strong>头尾</strong>含有就去除</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;12 hello world i am klklkl 21&quot;</span></span><br><span class="line">newstr = <span class="built_in">str</span>.strip(<span class="string">&quot;12&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;newstr = <span class="subst">&#123;newstr&#125;</span> &quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">12 hello world i am klklkl 21</span></span><br><span class="line"><span class="string">newstr =  hello world i am klklkl  </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="统计指定字符串出现的次数">统计指定字符串出现的次数</h4><blockquote><p>字符串.count(字符串)</p></blockquote><h4 id="统计字符串的长度">统计字符串的长度</h4><blockquote><p>len(字符串)</p></blockquote><h4 id="遍历">遍历</h4><p><strong>for循环</strong></p><p>同上</p><p><strong>while循环</strong></p><p>同上</p><h3 id="特点">特点</h3><ol><li><strong>只可以存储字符串</strong></li><li><strong>长度有上限，取决于内存大小</strong></li><li><strong>数据有序存储</strong></li><li><strong>允许重复数据存在</strong></li><li><strong>不可以修改</strong></li></ol><h2 id="序列">序列</h2><blockquote><p>内容<strong>连续，有序</strong>，可以<strong>使用下标索引</strong>的一类<strong>数据容器</strong></p></blockquote><blockquote><p>列表、元组、字符串均可以视为序列</p></blockquote><h3 id="切片">切片</h3><blockquote><p>从一个序列中取出一个子序列，形成一个新的序列，不修改原来的序列</p></blockquote><p><strong>语法：</strong></p><blockquote><p><strong>序列[起始下标: 结束下标:步长]</strong></p><p>起始下标：从何处开始，可以留空表示从头</p><p>结束下标：到那里结束，不包含结束下标位置，可以留空表示截去到尾部</p><p>步长：取元素的间隔，默认为1，可以省略不写</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">my_list1 = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">r1 = my_list1[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;r1 = <span class="subst">&#123;r1&#125;</span>&quot;</span>)</span><br><span class="line">my_tuple = (<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">r2 = my_tuple[:]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;r2 = <span class="subst">&#123;r2&#125;</span>&quot;</span>)</span><br><span class="line">my_str = <span class="string">&quot;0123456&quot;</span></span><br><span class="line">r3 = my_str[::<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;r3 = <span class="subst">&#123;r3&#125;</span>&quot;</span>)</span><br><span class="line">r4 = my_str[::-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;r4 = <span class="subst">&#123;r4&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">r1 = [1, 2, 3]</span></span><br><span class="line"><span class="string">r2 = (0, 1, 2, 3, 4, 5, 6)</span></span><br><span class="line"><span class="string">r3 = 0246</span></span><br><span class="line"><span class="string">r4 = 6543210</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="集合">集合</h2><blockquote><p>上述介绍的数据容器：列表、元组、字符串都支持重复元素，而集合<strong>不支持重复元素，顺序无法保证</strong>，自带<strong>去重</strong>功能</p></blockquote><h3 id="定义">定义</h3><blockquote><p>变量 = {元素1,元素2,元素3 ,…}</p></blockquote><p>空集合</p><blockquote><p>变量 = set()</p><p>{}是空字典</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_set = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;my_set=<span class="subst">&#123;my_set&#125;</span>&quot;</span>)</span><br><span class="line">none_set= <span class="built_in">set</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;none_set = <span class="subst">&#123;none_set&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">my_set=&#123;1, 2, 3, 4, 5, 6&#125;</span></span><br><span class="line"><span class="string">none_set = set()</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="常用操作">常用操作</h3><p><strong>不支持下标索引访问，可修改</strong></p><h4 id="添加">添加</h4><blockquote><p>集合.add(元素)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">my_set = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="string">&quot;klklkl&quot;</span>&#125;</span><br><span class="line">my_set.add(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(my_set)</span><br><span class="line">my_set.add(<span class="string">&quot;klklkl&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_set)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;1, 2, 3, 4, 5, 6, 10, &#x27;klklkl&#x27;&#125;</span></span><br><span class="line"><span class="string">&#123;1, 2, 3, 4, 5, 6, 10, &#x27;klklkl&#x27;&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="移除">移除</h4><p><strong>从集合中移除指定元素，同时集合被修改</strong></p><blockquote><p>集合.remove(元素)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my_set = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="string">&quot;klklkl&quot;</span>&#125;</span><br><span class="line">my_set.remove(<span class="string">&quot;klklkl&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_set)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;1, 2, 3, 4, 5, 6&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>从集合中<u>随机取出</u>一个元素，同时集合被修改，返回移除的元素，元素被移除</strong></p><blockquote><p>集合.pop()</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_set = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="string">&quot;klklkl&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(my_set.pop())</span><br><span class="line"><span class="built_in">print</span>(my_set)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">&#123;2, 3, 4, 5, 6, &#x27;klklkl&#x27;&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="清空">清空</h4><blockquote><p>集合.clear()</p></blockquote><h4 id="取差集">取差集</h4><blockquote><p>集合1.differrence(集合2)</p><p>取出集合1和集合2的差集（<strong>集合1有集合2没有的</strong>），返回一个新集合</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">1</span> ,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(set1.difference(set2))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;2, 4&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="去差集">去差集</h4><blockquote><p>集合1.difference_update(集合2)</p><p>消除集合1和集合2内相同的元素，集合1被修改集合2不变</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">1</span> ,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;</span><br><span class="line">set1.difference_update(set2)</span><br><span class="line"><span class="built_in">print</span>(set1)</span><br><span class="line"><span class="built_in">print</span>(set2)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;2, 4&#125;</span></span><br><span class="line"><span class="string">&#123;1, 3, 5, 7&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="集合合并">集合合并</h4><blockquote><p>集合1.union(集合2)</p><p>集合1和2合并成一个新的集合，集合1和2不变</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">1</span> ,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line">set3 = set1.union(set2)</span><br><span class="line"><span class="built_in">print</span>(set1)</span><br><span class="line"><span class="built_in">print</span>(set2)</span><br><span class="line"><span class="built_in">print</span>(set3)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line"><span class="string">&#123;1, 3, 5, 7, 8, 9&#125;</span></span><br><span class="line"><span class="string">&#123;1, 2, 3, 4, 5, 7, 8, 9&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="统计元素数量">统计元素数量</h4><blockquote><p>len(集合)</p></blockquote><h4 id="遍历">遍历</h4><p><strong>不支持下标索引，因此不可以用while循环</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set2 = &#123;<span class="number">1</span> ,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> set2:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;集合的元素有 :<span class="subst">&#123;element&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">集合的元素有 :1</span></span><br><span class="line"><span class="string">集合的元素有 :3</span></span><br><span class="line"><span class="string">集合的元素有 :5</span></span><br><span class="line"><span class="string">集合的元素有 :7</span></span><br><span class="line"><span class="string">集合的元素有 :8</span></span><br><span class="line"><span class="string">集合的元素有 :9</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="字典">字典</h2><p>含有两个数据，一个名为key，另一个为Value，字典可以通过key找到与其对应的value</p><p><strong>不允许元素重复，不可以使用下标索引，只可以通过key值取得对应的Value</strong></p><h3 id="定义">定义</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">变量 = &#123;key:value , key:value ,....&#125;</span><br><span class="line"><span class="comment">#空字典</span></span><br><span class="line">变量 = &#123;&#125;</span><br><span class="line">变量 = <span class="built_in">dict</span>()</span><br></pre></td></tr></table></figure><p><strong>获取value</strong></p><p>通过key值取得对应的Value</p><blockquote><p>字典.[key]</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dict_1 = &#123;<span class="string">&quot;liming&quot;</span>: <span class="number">56</span>, <span class="string">&quot;wanglikong&quot;</span>: <span class="number">99</span>, <span class="string">&quot;zhoujielin&quot;</span>: <span class="number">88</span>, <span class="string">&quot;lindaju&quot;</span>: <span class="number">77</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(dict_1[<span class="string">&quot;lindaju&quot;</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">77</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>字典的嵌套</strong></p><p><strong>key不能为字典，value可以是任意数据</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">stu_score_date = &#123;</span><br><span class="line">    <span class="string">&quot;wanglihong&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;yuwen&quot;</span>: <span class="number">77</span>,</span><br><span class="line">        <span class="string">&quot;shuxue&quot;</span>:<span class="number">66</span>,</span><br><span class="line">        <span class="string">&quot;yingyu&quot;</span>:<span class="number">99</span></span><br><span class="line">    &#125;,<span class="string">&quot;zhoujielun&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;yuwen&quot;</span>: <span class="number">87</span>,</span><br><span class="line">        <span class="string">&quot;shuxue&quot;</span>:<span class="number">65</span>,</span><br><span class="line">        <span class="string">&quot;yingyu&quot;</span>:<span class="number">89</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(stu_score_date)</span><br><span class="line"><span class="built_in">print</span>(stu_score_date[<span class="string">&quot;zhoujielun&quot;</span>][<span class="string">&quot;shuxue&quot;</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;&#x27;wanglihong&#x27;: &#123;&#x27;yuwen&#x27;: 77, &#x27;shuxue&#x27;: 66, &#x27;yingyu&#x27;: 99&#125;, &#x27;zhoujielun&#x27;: &#123;&#x27;yuwen&#x27;: 87, &#x27;shuxue&#x27;: 65, &#x27;yingyu&#x27;: 89&#125;&#125;</span></span><br><span class="line"><span class="string">65</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="常用操作">常用操作</h3><h4 id="增加元素">增加元素</h4><blockquote><p>字典[key] = value</p><p>字典被修改，增加了新元素</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dict_1 = &#123;<span class="string">&quot;liming&quot;</span>: <span class="number">56</span>, <span class="string">&quot;wanglikong&quot;</span>: <span class="number">99</span>, <span class="string">&quot;zhoujielin&quot;</span>: <span class="number">88</span>, <span class="string">&quot;lindaju&quot;</span>: <span class="number">77</span>&#125;</span><br><span class="line">dict_1[<span class="string">&quot;zhangsan&quot;</span>] = <span class="number">88</span></span><br><span class="line"><span class="built_in">print</span>(dict_1)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;&#x27;liming&#x27;: 56, &#x27;wanglikong&#x27;: 99, &#x27;zhoujielin&#x27;: 88, &#x27;lindaju&#x27;: 77, &#x27;zhangsan&#x27;: 88&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="更新元素">更新元素</h4><blockquote><p>字典[key] = value</p><p>字典被修改</p></blockquote><p><strong>如果key存在则为更新，不存在即为修改</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dict_1 = &#123;<span class="string">&quot;liming&quot;</span>: <span class="number">56</span>, <span class="string">&quot;wanglikong&quot;</span>: <span class="number">99</span>, <span class="string">&quot;zhoujielin&quot;</span>: <span class="number">88</span>, <span class="string">&quot;lindaju&quot;</span>: <span class="number">77</span>&#125;</span><br><span class="line">dict_1[<span class="string">&quot;liming&quot;</span>] = <span class="number">88</span></span><br><span class="line"><span class="built_in">print</span>(dict_1)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;&#x27;liming&#x27;: 88, &#x27;wanglikong&#x27;: 99, &#x27;zhoujielin&#x27;: 88, &#x27;lindaju&#x27;: 77&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="删除元素">删除元素</h4><blockquote><p>字典.pop(key)</p><p>删除字典中key的内容，并返回key对应的value</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dict_1 = &#123;<span class="string">&quot;liming&quot;</span>: <span class="number">56</span>, <span class="string">&quot;wanglikong&quot;</span>: <span class="number">99</span>, <span class="string">&quot;zhoujielin&quot;</span>: <span class="number">88</span>, <span class="string">&quot;lindaju&quot;</span>: <span class="number">77</span>&#125;</span><br><span class="line">dict_1.pop(<span class="string">&quot;wanglikong&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(dict_1)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;&#x27;liming&#x27;: 56, &#x27;zhoujielin&#x27;: 88, &#x27;lindaju&#x27;: 77&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="清空元素">清空元素</h4><blockquote><p>字典.clear()</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dict_1 = &#123;<span class="string">&quot;liming&quot;</span>: <span class="number">56</span>, <span class="string">&quot;wanglikong&quot;</span>: <span class="number">99</span>, <span class="string">&quot;zhoujielin&quot;</span>: <span class="number">88</span>, <span class="string">&quot;lindaju&quot;</span>: <span class="number">77</span>&#125;</span><br><span class="line">dict_1.clear()</span><br><span class="line"><span class="built_in">print</span>(dict_1)</span><br></pre></td></tr></table></figure><h4 id="获取全部key">获取全部key</h4><blockquote><p>字典.keys()</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dict_1 = &#123;<span class="string">&quot;liming&quot;</span>: <span class="number">56</span>, <span class="string">&quot;wanglikong&quot;</span>: <span class="number">99</span>, <span class="string">&quot;zhoujielin&quot;</span>: <span class="number">88</span>, <span class="string">&quot;lindaju&quot;</span>: <span class="number">77</span>&#125;</span><br><span class="line">keys=dict_1.keys()</span><br><span class="line"><span class="built_in">print</span>(keys)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">dict_keys([&#x27;liming&#x27;, &#x27;wanglikong&#x27;, &#x27;zhoujielin&#x27;, &#x27;lindaju&#x27;])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="遍历字典">遍历字典</h4><p><strong>方法1:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dict_1 = &#123;<span class="string">&quot;liming&quot;</span>: <span class="number">56</span>, <span class="string">&quot;wanglikong&quot;</span>: <span class="number">99</span>, <span class="string">&quot;zhoujielin&quot;</span>: <span class="number">88</span>, <span class="string">&quot;lindaju&quot;</span>: <span class="number">77</span>&#125;</span><br><span class="line">keys=dict_1.keys()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> keys:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span>对应的键值是<span class="subst">&#123;dict_1[i]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">liming对应的键值是56</span></span><br><span class="line"><span class="string">wanglikong对应的键值是99</span></span><br><span class="line"><span class="string">zhoujielin对应的键值是88</span></span><br><span class="line"><span class="string">lindaju对应的键值是77</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>方法2:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dict_1 = &#123;<span class="string">&quot;liming&quot;</span>: <span class="number">56</span>, <span class="string">&quot;wanglikong&quot;</span>: <span class="number">99</span>, <span class="string">&quot;zhoujielin&quot;</span>: <span class="number">88</span>, <span class="string">&quot;lindaju&quot;</span>: <span class="number">77</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dict_1:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span>对应的键值是<span class="subst">&#123;dict_1[i]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">liming对应的键值是56</span></span><br><span class="line"><span class="string">wanglikong对应的键值是99</span></span><br><span class="line"><span class="string">zhoujielin对应的键值是88</span></span><br><span class="line"><span class="string">lindaju对应的键值是77</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>不支持下标索引，不适用于while循环</strong></p><h4 id="统计元素数量">统计元素数量</h4><blockquote><p>len(字典)</p></blockquote><h3 id="特点">特点</h3><ol><li><strong>可以容纳多个数据，容纳不同类型的数据。</strong></li><li><strong>每一份数据是keyvalue键值对</strong></li><li><strong>可以通过key获取value</strong></li><li><strong>不允许重复key存在</strong></li><li><strong>不支持下标索引</strong></li><li><strong>可以修改</strong></li><li><strong>支持for循环不支持while循环</strong></li></ol><h2 id="总结">总结</h2><p><img src="image-20240123161337038.png" alt="image-20240123161337038"></p><p><img src="image-20240123161352170.png" alt="image-20240123161352170"></p><p><img src="image-20240123161442232.png" alt="image-20240123161442232"></p><h2 id="通用操作">通用操作</h2><p>下面对于字典的操作基本是对于key值的操作</p><h3 id="len">len</h3><blockquote><p>统计元素个数</p></blockquote><h3 id="max-和min">max 和min</h3><blockquote><p>获取最大元素，获取最小元素</p></blockquote><p>对于字典，获取的是最大或最小的key</p><h3 id="类型转换">类型转换</h3><ul><li><p>list(容器)</p><p>转列表</p></li><li><p>str(容器)</p><p>转字符串</p></li><li><p>tuple(容器)</p><p>转元组</p></li><li><p>set(容器)</p><p>转集合</p></li></ul><h3 id="sorted">sorted</h3><p>排序，并返回列表对象的结果，字典会丢失value</p><blockquote><p>sorted(容器)    正向排序，从小到大</p><p>sorted(容器，reverse = True)    反向排序</p></blockquote><p><img src="image-20240123162933181.png" alt="image-20240123162933181"></p><h1 id="文件">文件</h1><blockquote><p>文件编码：编码的技术，记录了如何将内容翻译成二进制以及如何解密二进制，不同的编码对同一文本的翻译不同</p></blockquote><p>常见文件编码：</p><ul><li>UTF-8  全球通用 默认编码</li><li>GBK</li><li>Big5</li></ul><h2 id="读取文件">读取文件</h2><ol><li>打开文件</li><li>读写文件</li><li>关闭文件</li></ol><h2 id="打开文件">打开文件</h2><blockquote><p>open(name,mode,encoding)</p><p>name：文件的名字可以包含路径，字符串表示</p><p>mode：设置打开文件的模式，只读，写入，追加等</p><p>encoding：编码格式（推荐使用UFT-8）</p></blockquote><p><img src="image-20240124003300313.png" alt="image-20240124003300313"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;D:/桌面/test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding = <span class="string">&quot;UTF-8&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>encoding不是第三个参数，因此要使用关键字参数</strong></p><h2 id="读取文件">读取文件</h2><blockquote><p>文件对象.read(num)</p><p>num:表示要读取的数据的长度，单位是字节，如果没有传入num，那么就表示读取文件中所有数据</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;D:/桌面/test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding = <span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(f.read(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(f.read())<span class="comment">#全部内容</span></span><br></pre></td></tr></table></figure><p><strong>连续读取会从上一次读取的末尾开始读取</strong></p><blockquote><p>文件对象.readlines()</p><p>按照行的方法把文件中的内容进行一次性读取，并返回一个列表，其中每一行的数据为一个元素</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;D:/桌面/test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding = <span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">list1 = f.readlines()</span><br></pre></td></tr></table></figure><p><strong>可以使用for循环读取行</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;D:/桌面/test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding = <span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;每一行为<span class="subst">&#123;line&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>连续读取会从上一次读取的末尾开始读取</strong></p><blockquote><p>文件对象.readline()</p><p>一次读取一行内容</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;D:/桌面/test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding = <span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">list1 = f.readline()</span><br></pre></td></tr></table></figure><h2 id="写入文件">写入文件</h2><blockquote><p>文件对象.write()</p><p>把内容写入缓冲区</p></blockquote><blockquote><p>文件对象.flush()</p><p>内容刷新，写入硬盘中的文件</p></blockquote><p><strong>close方法内置了flush功能</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;D:/桌面/test.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,encoding = <span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">f.write(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">f.flush()</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><h2 id="关闭文件">关闭文件</h2><blockquote><p>文件对象.close()</p></blockquote><p>解除文件占用</p><blockquote><p>with open(name,mode,encoding) as 文件对象:</p><p>​            操作</p></blockquote><p>完成操作后自动关闭文件，避免遗忘close方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;D:/桌面/test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding = <span class="string">&quot;UTF-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    res = f.read()</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h1 id="类">类</h1><h2 id="定义">定义</h2><blockquote><p>class 类名:</p><p>​satement1</p><p>​satement2</p><p>​    …</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    school = <span class="string">&quot;null&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, tmp_name, tmp_school, tmp_gener, tmp_id</span>):</span><br><span class="line">        self.school = tmp_school</span><br><span class="line">        self.<span class="built_in">id</span> = tmp_id</span><br><span class="line">        self.name = tmp_name</span><br><span class="line">        self.gener = tmp_gener</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">return_school</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.school</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">&quot;xiaoming&quot;</span>, <span class="string">&quot;guangmingzhongxue&quot;</span>, <span class="string">&quot;girl&quot;</span>, <span class="string">&quot;1992&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s.return_school())</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">guangmingzhongxue</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="初始化函数">初始化函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, tmp_name, tmp_school, tmp_gener, tmp_id</span>):</span><br><span class="line">       self.school = tmp_school</span><br><span class="line">       self.<span class="built_in">id</span> = tmp_id</span><br><span class="line">       self.name = tmp_name</span><br><span class="line">       self.gener = tmp_gener</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">python基础语法记录</summary>
    
    
    
    <category term="Python" scheme="https://comeupklklkl.gitee.io/jluloser.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="https://comeupklklkl.gitee.io/jluloser.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>微积分A3</title>
    <link href="https://comeupklklkl.gitee.io/jluloser.github.io/2023/11/20/%E5%BE%AE%E7%A7%AF%E5%88%86A3/"/>
    <id>https://comeupklklkl.gitee.io/jluloser.github.io/2023/11/20/%E5%BE%AE%E7%A7%AF%E5%88%86A3/</id>
    <published>2023-11-20T12:01:38.000Z</published>
    <updated>2024-03-18T09:15:19.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="无穷级数">无穷级数</h1><p><img src="638408206233530013_snap.png" alt="638408206233530013_snap"></p><p><img src="638408206234802681_snap.png" alt="638408206234802681_snap"></p><p><img src="638408206235719021_snap.png" alt="638408206235719021_snap"></p><p><img src="638408206236580000_snap.png" alt="638408206236580000_snap"></p><p><img src="638408206237869452_snap.png" alt="638408206237869452_snap"></p><p><img src="638408206238913676_snap.png" alt="638408206238913676_snap"></p><p><img src="638408206239800296_snap.png" alt="638408206239800296_snap"></p><p><img src="638408206241720242_snap.png" alt="638408206241720242_snap"></p><p><img src="638408206242522972_snap.png" alt="638408206242522972_snap"></p><p><img src="638408206243413316_snap.png" alt="638408206243413316_snap"></p><p><img src="638408206245168132_snap.png" alt="638408206245168132_snap"></p><p><img src="638408206246069990_snap.png" alt="638408206246069990_snap"></p><p><img src="638408206246872655_snap.png" alt="638408206246872655_snap"></p><p><img src="638408206248020433_snap.png" alt="638408206248020433_snap"></p><p><img src="638408206249321765_snap.png" alt="638408206249321765_snap"></p><h1 id="常微分方程">常微分方程</h1><p>课程：<a href="https://www.bilibili.com/video/BV1a24y1a7Sg">3小时讲不完《常微分方程》</a></p><p><img src="0001.jpg" alt=""></p><p><img src="0002.jpg" alt="0002"></p><p><img src="0003.jpg" alt="0003"></p><p><img src="0004.jpg" alt="0004"></p><p><img src="0005.jpg" alt="0005"></p><p><img src="0006.jpg" alt="0006"></p><p><img src="0007.jpg" alt="0007"></p><p><img src="0008.jpg" alt="0008"></p><p><img src="0009.jpg" alt="0009"></p><p><img src="0010.jpg" alt="0010"></p><p><img src="0011.jpg" alt="0011"></p><p><img src="Inkodo-20231219_141437.png" alt="Inkodo-20231219_141437"></p><p><img src="638385913390558932_snap.png" alt="638385913390558932_snap"></p><p><img src="638385913394669519_snap.png" alt="638385913394669519_snap"></p><p><img src="638385913398852815_snap.png" alt="638385913398852815_snap"></p><p><img src="638385913403913144_snap.png" alt="638385913403913144_snap"></p><p><img src="638385913408000479_snap.png" alt="638385913408000479_snap"></p><p><img src="638385522251274427_snap.png" alt="638385522251274427_snap"></p><p><img src="638385536354837256_snap.png" alt="638385536354837256_snap"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;无穷级数&quot;&gt;无穷级数&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;638408206233530013_snap.png&quot; alt=&quot;638408206233530013_snap&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;638408206234802681_snap.pn</summary>
      
    
    
    
    <category term="class record" scheme="https://comeupklklkl.gitee.io/jluloser.github.io/categories/class-record/"/>
    
    
    <category term="微积分" scheme="https://comeupklklkl.gitee.io/jluloser.github.io/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>learning library windows.h</title>
    <link href="https://comeupklklkl.gitee.io/jluloser.github.io/2023/11/14/learning-library-windows-h/"/>
    <id>https://comeupklklkl.gitee.io/jluloser.github.io/2023/11/14/learning-library-windows-h/</id>
    <published>2023-11-14T11:56:18.000Z</published>
    <updated>2024-03-18T09:13:41.126Z</updated>
    
    
    
    
    <category term="windows" scheme="https://comeupklklkl.gitee.io/jluloser.github.io/categories/windows/"/>
    
    
    <category term="windows" scheme="https://comeupklklkl.gitee.io/jluloser.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>Learning from Effective C++</title>
    <link href="https://comeupklklkl.gitee.io/jluloser.github.io/2023/10/29/Learning-from-Effictive-C/"/>
    <id>https://comeupklklkl.gitee.io/jluloser.github.io/2023/10/29/Learning-from-Effictive-C/</id>
    <published>2023-10-29T13:49:13.000Z</published>
    <updated>2024-03-18T09:13:19.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="effective-c-读书笔记">《Effective C++》读书笔记</h1><h2 id="00-导读">00.导读</h2><h3 id="1-理解下列术语">1.理解下列术语</h3><h4 id="declaration-声明式">declaration（声明式）</h4><p>告诉编译器某个东西的名称和type，但<strong>略去细节</strong>。</p><h4 id="definition-定义式">definition（定义式）</h4><p>提供编译器一些声明式所遗漏的细节。</p><ul><li><p>对 对象而言，定义式是编译器为此对象<strong>拨内存</strong>的地点。</p></li><li><p>对于function或function template而言定义式提供了<strong>代码本体</strong>。</p></li><li><p>对class和class template而言，定义式<strong>列出他们的成员</strong></p></li></ul><h4 id="initialization-u-初始化-u">Initialization（<u>初始化</u>）</h4><p>给对象赋<strong>初值</strong>的过程</p><p>对于<strong>用户自定义类型</strong>的对象而言，初始化由构造函数执行</p><p><strong>default构造函数</strong>（缺省构造函数）：可被调用但不带任何实参者，要不没有参数要不每个参数都有缺省值。</p><p><strong>copy构造函数</strong>（拷贝构造函数）：用来“<em><em>以同型对象</em><u>初始化</u><em>自我对象</em></em>”</p><p><strong>copy assignment</strong>（拷贝复制）操作符：用来“<strong>从另一个同型对象中<u><em>拷贝</em></u>其值到自我对象</strong>”</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>();                                     <span class="comment">//default构造函数</span></span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp; rhs);                    <span class="comment">//copy构造函数</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs);         <span class="comment">//copy assignment操作符</span></span><br><span class="line">&#125;;</span><br><span class="line">Widget w1;                                   <span class="comment">//调用default构造函数</span></span><br><span class="line"><span class="function">Widget <span class="title">w2</span><span class="params">(w1)</span></span>;                               <span class="comment">//调用copy构造函数</span></span><br><span class="line">w1=w2;                                       <span class="comment">//调用copy assignment操作符</span></span><br><span class="line"><span class="comment">/////////////当看到 = 时要小心，有可能是copy assignment操作符，也有可能是copy构造函数</span></span><br><span class="line">Widget w3 = w2;                              <span class="comment">//copy构造函数</span></span><br></pre></td></tr></table></figure><p><strong>copy构造函数与passed by value</strong></p><p>copy构造函数定义了一个对象如何 passed by value（以值传递）</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasAcceptableQuality</span><span class="params">(Widget w)</span></span>;</span><br><span class="line">.</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">Widget aWidget;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">hasAcceptableQuality</span>(aWidget)) .....<span class="comment">//值传递，调用了copy构造函数将awidget的值复制到Widget内</span></span><br></pre></td></tr></table></figure><h2 id="01-让自己习惯c">01.让自己习惯C++</h2><h3 id="条款01-视c-为一个语言联邦">条款01: 视C++为一个语言联邦</h3><p>即我们可以将c++看成一个由<strong>四种次语言组成的语言联邦</strong>，四种次语言分别是</p><ul><li>C</li><li>Object-Oriented C++</li><li>Template C++</li><li>STL</li></ul><p>每个次语言都有自己的规约，C++高效编程守则视状况而变化，取决于你用C++的哪一个部分</p><p>例如：<br><img src="image-20231029225351042.png" alt="image-20231029225351042"></p><h2 id="条款02：尽量以const-enum-inline替换-define">条款02：尽量以const，enum，inline替换 #define</h2>]]></content>
    
    
    <summary type="html">读书记录</summary>
    
    
    
    <category term="专业书籍" scheme="https://comeupklklkl.gitee.io/jluloser.github.io/categories/%E4%B8%93%E4%B8%9A%E4%B9%A6%E7%B1%8D/"/>
    
    
    <category term="C++" scheme="https://comeupklklkl.gitee.io/jluloser.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://comeupklklkl.gitee.io/jluloser.github.io/2023/10/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://comeupklklkl.gitee.io/jluloser.github.io/2023/10/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2023-10-29T10:47:25.000Z</published>
    <updated>2024-03-18T09:15:12.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性表">线性表</h1><p>同种数据类型的集合，静态列表例如：数组（array），动态列表例如：链表（linked list）</p><h3 id="链表">链表</h3><p>与数组</p><p><strong>区别</strong>：数组更强调于整块大小固定的、连续的内存空间，并且不可以随意的插入数据，<strong>而链表则可以分段并且可以随意改变大小，随意插入数据，更好地利用了内存空间。</strong></p><p>对于链表来讲，我们只需要知道第一个节点的地址，便可以<strong>环环相扣</strong>得到链表上所有的数据。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">数组</th><th style="text-align:center">链表</th></tr></thead><tbody><tr><td style="text-align:center">内存空间</td><td style="text-align:center">连续且大小固定</td><td style="text-align:center">不连续且大小不固定</td></tr><tr><td style="text-align:center">访问方式（时间复杂度）</td><td style="text-align:center">直接（低）</td><td style="text-align:center">遍历链表（高）</td></tr><tr><td style="text-align:center">内存空间利用</td><td style="text-align:center">不充分</td><td style="text-align:center">充分</td></tr><tr><td style="text-align:center">总结</td><td style="text-align:center">更容易实现</td><td style="text-align:center">易出错</td></tr></tbody></table><h4 id="单链表">单链表</h4><p>定义节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">link</span>;</span><span class="comment">//c++中直接写Node *</span></span><br><span class="line">&#125;;<span class="comment">// 定义节点</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="创建">创建</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Node * A;<span class="comment">//头指针 永远</span></span><br><span class="line">A = <span class="literal">NULL</span>;</span><br><span class="line">Node* temp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));    <span class="comment">//创建节点  对于c++首选new</span></span><br><span class="line">(*temp).data = <span class="number">2</span>;    <span class="comment">//temp-&gt;data=2;</span></span><br><span class="line">(*temp).link = <span class="literal">NULL</span>;    <span class="comment">//temp-&gt;link=NULL;</span></span><br><span class="line">A = temp;</span><br><span class="line">temp = new Node();</span><br><span class="line">temp-&gt;data=<span class="number">4</span>;</span><br><span class="line">temp-&gt;link=<span class="literal">NULL</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="遍历">遍历</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//用循环遍历链表</span></span><br><span class="line">    Node* temp1=A;</span><br><span class="line">    <span class="keyword">while</span>(temp1-&gt;link!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    temp1=temp1-&gt;link;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//末尾添加节点</span></span><br><span class="line">  temp = new Node();</span><br><span class="line">  temp-&gt;data=<span class="number">4</span>;</span><br><span class="line">  temp-&gt;link=<span class="literal">NULL</span>;</span><br><span class="line">  temp1-&gt;link = temp;</span><br></pre></td></tr></table></figure><h5 id="增加节点">增加节点</h5><p>头部</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span>;</span></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">Insert</span><span class="params">(<span class="keyword">struct</span> Node* head,<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* temp = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    temp-&gt;data = x;</span><br><span class="line">    temp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(head!=<span class="literal">NULL</span>) temp-&gt;next = head;</span><br><span class="line">    head = temp;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    head=Insert(head,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任意节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//head=NULL or head!=NULL</span></span><br><span class="line"><span class="comment">//假定链表目前为 2——&gt;4——&gt;6</span></span><br><span class="line"><span class="comment">//要将其变成    2——&gt;4——&gt;8——&gt;6</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">()</span>&#123;...&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(<span class="type">int</span> data,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* temp1 = new Node();</span><br><span class="line">    temp1-&gt;data = data;</span><br><span class="line">    temp1-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)<span class="comment">//如果插入头部</span></span><br><span class="line">&#123;</span><br><span class="line">    temp1-&gt;next = head;</span><br><span class="line">    head = temp1;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">    Node* temp2 = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-2</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    temp2 = temp2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">    temp1-&gt;next=temp2-&gt;next;</span><br><span class="line">    temp2-&gt;next = temp1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    Insert(<span class="number">2</span>,<span class="number">1</span>);<span class="comment">// 2</span></span><br><span class="line">    Insert(<span class="number">3</span>,<span class="number">2</span>);<span class="comment">// 2 3</span></span><br><span class="line">    Insert(<span class="number">4</span>,<span class="number">1</span>);<span class="comment">// 4 2 3</span></span><br><span class="line">    Insert(<span class="number">5</span>,<span class="number">2</span>);<span class="comment">// 4 5 2 3</span></span><br><span class="line">    Print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除节点">删除节点</h5><p>任意节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(<span class="type">int</span> data)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Delete</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp1</span> =</span> head;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        head = temp1-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//（前面有节点后面也有 OR 前面有节点后面没有）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp1 = temp1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp2</span> =</span> temp1-&gt;next;</span><br><span class="line">        temp1-&gt;next = temp2-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp2);<span class="comment">//delete temp2;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    Insert(<span class="number">2</span>);</span><br><span class="line">    Insert(<span class="number">4</span>);</span><br><span class="line">    Insert(<span class="number">6</span>);</span><br><span class="line">    Insert(<span class="number">5</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a position \n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    Delete(n);</span><br><span class="line">    Print();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="反转链表">反转链表</h5><p>方法一：</p><p><strong>遍历，一个节点一个节点的反转</strong></p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(<span class="keyword">struct</span> Node* head)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span> =</span> head;</span><br><span class="line"><span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, temp-&gt;data);</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, temp-&gt;data);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">Insert</span><span class="params">(<span class="keyword">struct</span> Node* head, <span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">temp-&gt;data = x;</span><br><span class="line">temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (head != <span class="literal">NULL</span>) temp-&gt;next = head;</span><br><span class="line">head = temp;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">Reverse</span><span class="params">(<span class="keyword">struct</span> Node* head)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">current</span>,*<span class="title">prev</span>,*<span class="title">next</span>;</span></span><br><span class="line">current = head;</span><br><span class="line">prev = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (current != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">next = current-&gt;next;</span><br><span class="line">current-&gt;next = prev;</span><br><span class="line">prev = current;</span><br><span class="line">current = next;</span><br><span class="line">&#125;</span><br><span class="line">head = prev;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">head=Insert(head, <span class="number">2</span>);</span><br><span class="line">head=Insert(head, <span class="number">4</span>);</span><br><span class="line">head=Insert(head, <span class="number">6</span>);</span><br><span class="line">head=Insert(head, <span class="number">8</span>);</span><br><span class="line">Print(head);</span><br><span class="line">head = Reverse(head);</span><br><span class="line">Print(head);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：</p><p><strong>递归</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Reverse</span><span class="params">(<span class="keyword">struct</span> Node* p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    head = p;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Reverse(p-&gt;next);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">q</span>=</span>p-&gt;next;</span><br><span class="line">q-&gt;next = p;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>利用嵌套关系来代替前指针的作用</u></p><h4 id="双向链表">双向链表</h4><p>特点</p><p>节点有两个指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span> <span class="comment">//指向</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">prev</span>;</span><span class="comment">//指向前节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>优点：可以反向查询</p><p>缺点：增加了额外内存，对于一样的操作相对于单项链表需要更多的步骤</p><p>实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">GetNewNode</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">temp-&gt;data = x;</span><br><span class="line">temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">temp-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertAtHead</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//在链首添加</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newnode</span> =</span> GetNewNode(x);</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">head = newnode;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">head-&gt;prev = newnode;</span><br><span class="line">newnode-&gt;next = head;</span><br><span class="line">newnode-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">head = newnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertAtTail</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//在末尾添加</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newnode</span> =</span> GetNewNode(x);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span> =</span> head;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">head = newnode;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">temp-&gt;next = newnode;</span><br><span class="line">newnode-&gt;prev = temp;</span><br><span class="line">newnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//打印链表</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span> =</span> head;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, temp-&gt;data);</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, temp-&gt;data);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ReversePrint</span><span class="params">()</span> <span class="comment">//逆转链表</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span> =</span> head;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Reverse:%d\n&quot;</span>, temp-&gt;data);</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//当链表只有一个或没有节点时</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Reverse: &quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (temp-&gt;prev != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, temp-&gt;data);</span><br><span class="line">temp = temp-&gt;prev;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,temp-&gt;data);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">head = <span class="literal">NULL</span>; </span><br><span class="line">InsertAtTail(<span class="number">2</span>); Print(); ReversePrint();</span><br><span class="line">InsertAtTail(<span class="number">4</span>); Print(); ReversePrint();</span><br><span class="line">InsertAtHead(<span class="number">6</span>); Print(); ReversePrint();</span><br><span class="line">InsertAtTail(<span class="number">8</span>); Print(); ReversePrint();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环链表">循环链表</h4><h3 id="栈-stack">栈（stack）</h3><p><strong>特点 ：封闭性好，使用方便</strong></p><h4 id="顺序存储">顺序存储</h4><p>以存储数字为例，利用数组实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sstack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> top;</span><br><span class="line"><span class="type">char</span>* array;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">sstack</span>(<span class="type">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">top = <span class="number">-1</span>;</span><br><span class="line">size = k;</span><br><span class="line">array = <span class="keyword">new</span> <span class="type">char</span>[k]();</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">sstack</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[]array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">(<span class="type">char</span>&amp; item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">item = array[top];</span><br><span class="line">top--;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">push</span><span class="params">(<span class="type">const</span> <span class="type">char</span> item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (top == size - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">top++;</span><br><span class="line">array[top] = item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">(<span class="type">char</span>&amp; item)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">item = array[top];</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isempty</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isfull</span><span class="params">(<span class="type">void</span>)</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (top == size - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="链式存储">链式存储</h4><p>使用单链表实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SLNode</span><span class="comment">// 节点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T date;</span><br><span class="line">SLNode&lt;T&gt;* next;</span><br><span class="line"><span class="built_in">SLNode</span>() &#123; next = <span class="literal">NULL</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sstack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SLNode</span> &lt;T&gt;* top; <span class="comment">// 栈顶指针指向表头</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">sstack</span>() &#123; top = <span class="literal">NULL</span>; &#125; <span class="comment">// 构造函数</span></span><br><span class="line"></span><br><span class="line">~<span class="built_in">sstack</span>() &#123; <span class="built_in">clear</span>(); &#125; <span class="comment">// 析构函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SLNode</span>&lt;T&gt;* tmp = <span class="keyword">new</span> <span class="built_in">SLNode</span>&lt;T&gt;();</span><br><span class="line">tmp-&gt;date = item;</span><br><span class="line">tmp-&gt;next = top;</span><br><span class="line">top = tmp;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">(T&amp; item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (top == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">item = top-&gt;date;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SLNode</span>&lt;T&gt;* tmp = top;</span><br><span class="line">top = top-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">(T&amp; item)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (top == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">item = top-&gt;date;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isempty</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (top == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SLNode</span>&lt;T&gt;* p;</span><br><span class="line"><span class="keyword">while</span> (top != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">p = top-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> top;</span><br><span class="line">top = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="比较">比较</h4><ol><li>在空间复杂性上，顺序栈必须初始就申请固定的空间，当栈不满时，必然造成空间的浪费；链式栈所需空间是根据需要随时申请的，其代价是为每个元素提供空间以存储其next指针域。</li><li>在时间复杂性上，对于针对栈顶的基本操作（压入、弹出和栈顶元素存取），顺序栈和链式栈的时间复杂性均为O(1) .</li></ol><h4 id="双栈">*双栈</h4><p><img src="image-20231023173710839.png" alt="image-20231023173710839"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sstack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* left;</span><br><span class="line">T* right;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line"><span class="type">int</span> lefttop;</span><br><span class="line"><span class="type">int</span> righttop;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">sstack</span>(<span class="type">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">size = k;</span><br><span class="line">left = <span class="keyword">new</span> T[k]();</span><br><span class="line">right = left;</span><br><span class="line">lefttop = <span class="number">-1</span>;</span><br><span class="line">righttop = size;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">sstack</span>() &#123; <span class="keyword">delete</span>[]left; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; item, <span class="type">int</span> num)</span><span class="comment">//num选择的栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (righttop == lefttop + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;full&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//栈已经满</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">lefttop++;</span><br><span class="line">left[lefttop] = item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">righttop--;</span><br><span class="line">right[righttop] = item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">(T&amp; item, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (righttop == size &amp;&amp; lefttop == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;双栈为空无法出栈&quot;</span> &lt;&lt; endl;</span><br><span class="line">item = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (lefttop == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;左栈为空无法出栈&quot;</span> &lt;&lt; endl;</span><br><span class="line">item = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">item = left[lefttop];</span><br><span class="line">lefttop--;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (righttop == size)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;右栈为空无法出栈&quot;</span> &lt;&lt; endl;</span><br><span class="line">item = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">item = right[righttop];</span><br><span class="line">righttop++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">(T&amp; item, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (lefttop == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">item = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">item = left[lefttop];</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (righttop == size) &#123; item = <span class="number">-1</span>; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">item = right[righttop];</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">0</span>) lefttop = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">righttop = size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isempty</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">0</span> &amp;&amp; lefttop == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">1</span> &amp;&amp; righttop == size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isfull</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lefttop + <span class="number">1</span> == righttop)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">int</span> x, chose;</span><br><span class="line"><span class="function">sstack&lt;<span class="type">int</span>&gt; <span class="title">stac</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;选项：push pop peek clear isempty isfull&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; num;</span><br><span class="line"><span class="keyword">switch</span> (num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">case</span>(<span class="number">1</span>): cout &lt;&lt; <span class="string">&quot;push item  chose:&quot;</span> &lt;&lt; endl; cin &gt;&gt; x; cin &gt;&gt; chose; stac.<span class="built_in">push</span>(x, chose); <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">case</span>(<span class="number">2</span>):cout &lt;&lt; <span class="string">&quot;pop chose:&quot;</span> &lt;&lt; endl;  cin &gt;&gt; chose; stac.<span class="built_in">pop</span>(x, chose); cout &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; endl; <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">case</span>(<span class="number">3</span>):cout &lt;&lt; <span class="string">&quot;peek chose:&quot;</span> &lt;&lt; endl; cin &gt;&gt; chose; stac.<span class="built_in">peek</span>(x, chose); cout &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; endl; <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">case</span>(<span class="number">4</span>):cout &lt;&lt; <span class="string">&quot;clear chose:&quot;</span> &lt;&lt; endl; cin &gt;&gt; chose; stac.<span class="built_in">clear</span>(chose); <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">case</span>(<span class="number">5</span>):cout &lt;&lt; <span class="string">&quot;empty chose:&quot;</span> &lt;&lt; endl; cin &gt;&gt; chose; cout &lt;&lt; stac.<span class="built_in">isempty</span>(chose) &lt;&lt; endl; <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">case</span>(<span class="number">6</span>):cout &lt;&lt; <span class="string">&quot;full:&quot;</span> &lt;&lt; endl; cout &lt;&lt; stac.<span class="built_in">isfull</span>() &lt;&lt; endl; <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">case</span>(<span class="number">7</span>):<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="应用">应用</h4><p><strong>括号匹配</strong></p><p><strong>题目一：</strong></p><p><a href="https://leetcode.cn/problems/valid-parentheses/description/">有效的括号</a></p><p><strong>存在三种情况：</strong></p><p>左括号多于右括号</p><p>右括号多于左括号</p><p>括号不匹配（左右括号对不上）。</p><p><strong>题目二：</strong></p><p><a href="https://leetcode.cn/problems/minimum-remove-to-make-valid-parentheses/description/">移除括号使其有效</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">stack&lt;<span class="type">char</span>*&gt; p1;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Solution</span>() &#123;&#125;</span><br><span class="line"><span class="function">string <span class="title">minRemoveToMakeValid</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span>* x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">p1.<span class="built_in">push</span>(&amp;s[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!p1.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">p1.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">s[i] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p1.<span class="built_in">empty</span>() == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">x = p1.<span class="built_in">top</span>();</span><br><span class="line">*x = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">p1.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">string ss;</span><br><span class="line"><span class="keyword">for</span> (string::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*it != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">ss.<span class="built_in">push_back</span>(*it);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ss;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>数制转换</strong></p><p>数制转换</p><p><strong>中缀表达式求值</strong></p><p>已知中缀表达式，求值</p><p><strong>方法一：中后缀转换，后缀表达式求值</strong></p><p>​对于高于1位的数字无法处理。</p><p><strong>中后缀转换：</strong></p><blockquote><p>如果检测到<strong>数字</strong>，则直接加入到后缀表达式中</p><p>如果检测到运算符时：</p><ol><li>若为‘（’，入栈</li><li>若为‘）’，则依次将栈中的运算符加入后缀表达式，直到出现‘（’，并从栈中删除‘（’</li><li>若为‘+’，‘-’，‘*’，‘/’</li></ol><ul><li>栈空，入栈</li><li>栈顶元素为‘（’,入栈</li><li><strong>高于</strong>栈顶元素优先级，入栈</li><li>否则，依次弹出栈顶运算符，直到一个优先级比它低的运算符或‘（’为止</li></ul><p>遍历完成，若栈非空，依次弹出栈中所有元素</p></blockquote><p><strong>方法二：利用两个栈进行计算</strong></p><blockquote><ol><li>初始化一个操作数栈和一个运算符栈。</li><li>从左到右读入中缀表达式，若读到的是操作数，则将其压入操作数栈中。</li><li>若读到的是运算符，则和运算符栈栈顶的操作符进行比较：如果优先级比栈顶运算符<strong>高</strong>，则入栈；如果优先级比栈顶运算符低或者等于，则弹出栈顶运算符，再从操作数栈中弹出 2 个操作数，对其进行运算，将结果压入操作数栈中,重复，直到当前读到的运算符优先级<strong>高于</strong>运算符栈的栈顶运算符。</li><li>若读到的是左括号，则直接入栈；若读到的是右括号，则弹出栈中第一个左括号前所有的运算符，每次同时弹出 2 个操作数进行运算，并将结果压入操作数栈中，最后将左括号弹出。</li><li>重复以上过程直到遇到结束符，若此时操作数栈不为空，则将所有操作符弹出，进行和上面相同的运算操作，最终栈顶元素即为计算结果。</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">qpow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)        <span class="comment">//如果n的当前末位为1</span></span><br><span class="line">            ans *= a;  <span class="comment">//ans乘上当前的a</span></span><br><span class="line">        a *= a;        <span class="comment">//a自乘</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;       <span class="comment">//n往右移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">midop</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">char</span>&gt; ssop;</span><br><span class="line">stack&lt;<span class="type">long</span> <span class="type">long</span>&gt; ssnum;</span><br><span class="line"><span class="type">bool</span> tag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">littlecalu</span><span class="params">(<span class="type">long</span> <span class="type">long</span> lh, <span class="type">long</span> <span class="type">long</span> rh, <span class="type">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (ch)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">case</span>(<span class="string">&#x27;+&#x27;</span>):</span><br><span class="line">&#123;</span><br><span class="line">ssnum.<span class="built_in">push</span>(lh + rh);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">case</span>(<span class="string">&#x27;-&#x27;</span>):</span><br><span class="line">&#123;</span><br><span class="line">ssnum.<span class="built_in">push</span>(lh - rh);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">case</span>(<span class="string">&#x27;*&#x27;</span>):</span><br><span class="line">&#123;</span><br><span class="line">ssnum.<span class="built_in">push</span>(lh * rh);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">case</span>(<span class="string">&#x27;/&#x27;</span>):</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (rh != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ssnum.<span class="built_in">push</span>(lh / rh);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;INVALID&quot;</span>;</span><br><span class="line">tag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">case</span>(<span class="string">&#x27;^&#x27;</span>):</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res = <span class="built_in">qpow</span>(lh, rh);</span><br><span class="line">ssnum.<span class="built_in">push</span>(res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">op_compare</span><span class="params">(<span class="type">char</span> a, <span class="type">char</span> b)</span><span class="comment">//优先级计算</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> aa = <span class="number">0</span>, bb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="string">&#x27;+&#x27;</span> || a == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">aa = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="string">&#x27;+&#x27;</span> || b == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">bb = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="string">&#x27;*&#x27;</span> || a == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">aa = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="string">&#x27;*&#x27;</span> || b == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">bb = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="string">&#x27;^&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">aa = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="string">&#x27;^&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">bb = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> aa &gt; bb ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="built_in">caclulate</span>(string str)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>;</span><br><span class="line">tag = <span class="number">1</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> len = str.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch = str[i];</span><br><span class="line"><span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">ssnum.<span class="built_in">push</span>(ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">while</span> (str[i] &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; str[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; i &lt;= len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> tmp = ssnum.<span class="built_in">top</span>();</span><br><span class="line">ssnum.<span class="built_in">pop</span>();</span><br><span class="line">tmp = tmp * <span class="number">10</span> + (str[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">ssnum.<span class="built_in">push</span>(tmp);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">ssop.<span class="built_in">push</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (ssop.<span class="built_in">empty</span>() != <span class="literal">true</span> &amp;&amp; ssop.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch1 = ssop.<span class="built_in">top</span>();</span><br><span class="line">ssop.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> lh, rh;</span><br><span class="line">rh = ssnum.<span class="built_in">top</span>();</span><br><span class="line">ssnum.<span class="built_in">pop</span>();</span><br><span class="line">lh = ssnum.<span class="built_in">top</span>();</span><br><span class="line">ssnum.<span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">littlecalu</span>(lh, rh, ch1);</span><br><span class="line"><span class="keyword">if</span> (!tag) <span class="keyword">return</span>;<span class="comment">//无效则结束计算</span></span><br><span class="line">&#125;</span><br><span class="line">ssop.<span class="built_in">pop</span>();</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ssop.<span class="built_in">empty</span>() != <span class="literal">true</span> &amp;&amp; ssop.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span> &amp;&amp; ssop.<span class="built_in">top</span>() != <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">op_compare</span>(ch, ssop.<span class="built_in">top</span>())) <span class="comment">//ch&gt;top</span></span><br><span class="line">&#123;</span><br><span class="line">ssop.<span class="built_in">push</span>(ch);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (ssop.<span class="built_in">empty</span>() != <span class="literal">true</span> &amp;&amp; !<span class="built_in">op_compare</span>(ch, ssop.<span class="built_in">top</span>()))</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch1 = ssop.<span class="built_in">top</span>();</span><br><span class="line">ssop.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> rh = ssnum.<span class="built_in">top</span>();</span><br><span class="line">ssnum.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> lh = ssnum.<span class="built_in">top</span>();</span><br><span class="line">ssnum.<span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">littlecalu</span>(lh, rh, ch1);</span><br><span class="line"><span class="keyword">if</span> (!tag) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ssop.<span class="built_in">push</span>(ch);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!ssop.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch1 = ssop.<span class="built_in">top</span>();</span><br><span class="line">ssop.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> rh = ssnum.<span class="built_in">top</span>();</span><br><span class="line">ssnum.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> lh = ssnum.<span class="built_in">top</span>();</span><br><span class="line">ssnum.<span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">littlecalu</span>(lh, rh, ch1);</span><br><span class="line"><span class="keyword">if</span> (!tag) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ssnum.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>递归</strong></p><blockquote><p><strong>有些情况下，若采用迭代算法或递归算法的非递归实现，将大大提高效率</strong></p></blockquote><p>八皇后</p><p>汉诺塔</p><p>BS找最大最小元素</p><h3 id="队列-queue">队列（queue）</h3><p><strong>特点：先进先出，队首删除，队尾插入,与栈类似，队列的封闭性也非常好，使用起来很安全</strong></p><h4 id="顺序存储">顺序存储</h4><p><strong>实现: 使用数组实现队列</strong></p><p><strong>初始状态，rear和front均为0</strong></p><p><strong>1.删除队首元素</strong></p><p>**方法一：**front=front +1</p><p>​<strong>问题：会存在无法利用的空间</strong></p><p><strong>方法二：元素向前移动，front始终不变在数组的头部。</strong></p><p>​<strong>问题：效率低下</strong></p><p><strong>方法三：循环队列</strong></p><p><strong>很好地解决了方法一二的问题。</strong></p><p>​但要设置参数count计数器判断队列是否满和空</p><ul><li>front指向队首位置，<strong>删除一个元素</strong>就将front顺时针移动一位；<strong>front初识化为0</strong></li><li>rear指向元素<strong>要插入</strong>的位置，插入一个元素就将rear顺时针移动一位； <strong>rear初始化为0</strong>，<strong>若指向队尾的元素初始化为-1</strong></li><li>count存放队列中元素的个数，当count等于Size时，不可再向队列中插入元素。当count=0时队列为空</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCircularQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> count;<span class="comment">//计数器</span></span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;<span class="comment">//指向队尾的元素初始化为-1</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span>* array;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyCircularQueue</span>(<span class="type">int</span> k) </span><br><span class="line">    &#123;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="type">int</span>[k]();</span><br><span class="line">        size = k;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        front = <span class="number">0</span>; <span class="comment">////</span></span><br><span class="line">        rear = <span class="number">-1</span>;<span class="comment">////</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">enQueue</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == size) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        count++;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % size;</span><br><span class="line">        array[rear] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">deQueue</span><span class="params">()</span><span class="comment">//删除队首元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">front = (front + <span class="number">1</span>) % size;</span><br><span class="line">count--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Front</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> array[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Rear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> array[rear];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == size) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="链式存储">链式存储</h4><p><strong>实现：使用链表实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> date;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myqueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>* front;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>* rear;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Myqueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">front = <span class="literal">NULL</span>;</span><br><span class="line">rear = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Node</span>* tmp = <span class="keyword">new</span> <span class="keyword">struct</span> Node;</span><br><span class="line">        tmp-&gt;date = item;</span><br><span class="line"><span class="keyword">if</span> (rear != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">rear-&gt;next = tmp;</span><br><span class="line">rear = rear-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">            front=tmp；</span><br><span class="line">&#125;</span><br><span class="line">        rear=tmp;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (front == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> x = front-&gt;date;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Node</span>* tmp;</span><br><span class="line">tmp = front;</span><br><span class="line">front = front-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line">        <span class="keyword">if</span>(front==<span class="literal">NULL</span>) rear=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (front == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> front-&gt;date;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (front == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="顺序存储和链式存储">顺序存储和链式存储</h4><p><img src="image-20231025180959906.png" alt="image-20231025180959906"></p><h3 id="扩展">扩展</h3><p><img src="image-20231025181037056.png" alt="image-20231025181037056"></p><h4 id="优先队列">优先队列</h4><p><strong>定义与声明</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;template &lt;class T, class Container = vector&lt;T&gt;,  class Compare = less&lt;typename Container::value_type&gt; &gt; class priority_queue;</span><br></pre></td></tr></table></figure><p>第一个模板参数为为class T，代表每个元素的类型.</p><p>第二个模板参数为class Container，缺省值为vector<T>,代表存储这些数据的容器，可以是vector，deque等，<strong>但不能是list</strong>，因为它的内部空间不连续.</p><p>第三个模板参数为class Compare，缺省值为less<T>,其中less是个仿函数，是降序排序，既<strong>优先级最大的是容器中最大的元素</strong>.又叫比较函数.</p><p>当然<strong>可以升序排序，把less改为greater即可.</strong></p><p><strong>less 和 greater使用的前提是建立在这些数据类型是C++基本的数据类型.</strong></p><p>来源：<a href="https://blog.csdn.net/weixin_47257473/article/details/129262572">C++——优先级队列(priority_queue)的使用及实现_c++ 优先级队列-CSDN博客</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不写后面两个参数默认为vector，less</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq1;</span><br><span class="line"><span class="comment">//建立一个优先级队列(大堆)，数据类型是int，利用vector容器实现，less（降序）实现</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; pq2;</span><br><span class="line"><span class="comment">//建立一个优先级队列(小堆)，数据类型是int，利用vector容器实现，greater（降序）实现</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pq3;</span><br></pre></td></tr></table></figure><p><strong>常用接口：</strong></p><blockquote><p>它的操作与基本队列操作一样，主要有以下接口：</p><p><strong>top()</strong> ：返回元素中<strong>第一个元素的引用</strong>（优先级最高的元素都会被放到顶部，既第一个元素）.</p><p><strong>push()</strong>：插入一个元素，并重新维护堆，无返回值.</p><p><strong>pop()</strong> ：<strong>删除优先级最高的元素</strong>，并重新维护堆无返回值</p><p><strong>size()</strong> ：返回容器中<strong>有效元素的数量，返回队列的大小</strong></p><p><strong>empty()</strong> ：检测容器**是否为空.**返回“true”或者“false”.</p></blockquote><h2 id="字符串">字符串</h2><h4 id="模式匹配问题">模式匹配问题</h4><p><strong>「朴素模式匹配法 」</strong></p><p><img src="image-20231207212644104.png" alt="image-20231207212644104"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFstringMatching</span><span class="params">(<span class="type">const</span> string str,<span class="type">const</span> string pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=str.<span class="built_in">size</span>()-pattern.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[i]==pattern[j]&amp;&amp;j&lt;pattern.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">if</span>(j==pattern.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i-pattern.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法分析</strong></p><p><img src="image-20231207213113063.png" alt="image-20231207213113063"></p><p><img src="image-20231207213142891.png" alt="image-20231207213142891"></p><p><strong>「快速模式匹配算法」</strong></p><p><a href="https://www.bilibili.com/video/BV1Px411z7Yo/?spm_id_from=333.337.search-card.all.click&amp;vd_source=9a4fe569cfdfb26138828e9c87e1512d">b站 课程kmp1</a></p><p><a href="https://www.bilibili.com/video/BV1hW411a7ys/?spm_id_from=333.999.0.0&amp;vd_source=9a4fe569cfdfb26138828e9c87e1512d">b站 课程kmp2</a></p><p>对于BF算法的改进，BF算法的效率不高是因为进行了重复的字符比较</p><p><strong>算法思想：</strong></p><p>是指针i 只前进不后退，避免重复比较，让模式串向后滑动的距离最大化。</p><p>失败函数的确定：<br>求模式串的子串的最大相等子串,即计算前缀后缀相等表——next，next数组只和模式串有关系</p><p>next数组表示，当匹配失败的时候应该将j移动到哪个坐标。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">nextfun</span><span class="params">(string pattern, vector&lt;<span class="type">int</span>&gt;&amp; next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//生成前缀表</span></span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>, size = pattern.<span class="built_in">size</span>(), i = <span class="number">1</span>;</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pattern[i] == pattern[len])</span><br><span class="line">&#123;</span><br><span class="line">len++;</span><br><span class="line">next[i] = len;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">len = next[len - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">next[i] = <span class="number">0</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前缀表向右移一位，生成next数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">next[i] = next[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmp_search</span><span class="params">(string text, string pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> pat_size = pattern.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> text_size = text.<span class="built_in">size</span>();</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(pat_size)</span></span>;</span><br><span class="line"><span class="built_in">nextfun</span>(pattern, next);</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;<span class="comment">//text[i],pattern[j]</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; text_size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j == pat_size - <span class="number">1</span> &amp;&amp; text[i] == pattern[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i - j);</span><br><span class="line"><span class="comment">//return (i - j);//只找一个匹配的话</span></span><br><span class="line">j = next[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (text[i] == pattern[j])</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">j = next[j];</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于next数组的求值，仍存在<strong>改进</strong>之处：当匹配失败的时候，当前 j 指向的字符和 next[ j ] 指向的字符相等时，会重复比较</p><p>因此，可以基于next生成一个nextval数组：</p><p>​如果位置k的元素与位置next[k]元素<strong>相同</strong>时，nextval[k]=nextval[next[k]]</p><p>​如果位置k的元素与位置next[k]元素<strong>不同</strong>时，nextval[k]= next[k]</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">nextfun</span><span class="params">(<span class="built_in">string</span> pattern, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nextval)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//生成前缀表</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;next(nextval.size());</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>, size = pattern.size(), i = <span class="number">1</span>;</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pattern[i] == pattern[len])</span><br><span class="line">&#123;</span><br><span class="line">len++;</span><br><span class="line">next[i] = len;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">len = next[len - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">next[i] = <span class="number">0</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前缀表向右移一位</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">next[i] = next[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">       <span class="comment">//基于next生成nextval数组</span></span><br><span class="line">nextval[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pattern[i] == pattern[next[i]])</span><br><span class="line">nextval[i] = next[next[i]];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">nextval[i] = next[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习</strong>：</p><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">力扣——找出字符串中第一个匹配项的下标</a></p><h1 id="树">树</h1><h2 id="基本操作">基本操作</h2><p><strong>1、判树空：TREEEMPTY(T)</strong></p><p><strong>2、求根结点：ROOT(T)</strong></p><p><strong>3、求树的深度：TREEDEPTH(T)</strong></p><p><strong>4、求结点的兄弟节点：同一双亲的孩子互称</strong></p><p><strong>5、求结点的双亲：PARENT(T, e)</strong></p><p><strong>6、求结点的孩子：CHILD(T, e, i)</strong></p><p><strong>7、建立树：CREATE_TREE(T, T1 , T2 , … , Tm )</strong></p><p><strong>8、遍历树：TRAVERSAL(T)</strong></p><h2 id="二叉树">二叉树</h2><p><strong>树与二叉树</strong></p><ul><li>二叉树每个结点最多有 2 个子结点，树则无此限制；</li><li>二叉树中结点的子树分成左子树和右子树，即使某结点只 有一棵子树，也要指明该子树是左子树，还是右子树，<strong>就是说 二叉树是有序的。</strong></li></ul><h3 id="基本性质">基本性质</h3><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>二叉树中层数为</mtext><mi>i</mi><mtext>的结点至多有</mtext><msup><mn>2</mn><mi>i</mi></msup><mtext>个，</mtext><mi>i</mi><mo>≥</mo><mn>0</mn><mtext>。</mtext></mrow><annotation encoding="application/x-tex">二叉树中层数为 i 的结点至多有2^i个，i≥0。</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0106339999999998em;vertical-align:-0.13597em;"></span><span class="mord cjk_fallback">二</span><span class="mord cjk_fallback">叉</span><span class="mord cjk_fallback">树</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">层</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">为</span><span class="mord mathdefault">i</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">结</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">至</span><span class="mord cjk_fallback">多</span><span class="mord cjk_fallback">有</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8746639999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord cjk_fallback">。</span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>高度为</mtext><mi>k</mi><mtext>的二叉树中至多有</mtext><msup><mn>2</mn><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn><mo stretchy="false">(</mo><mi>k</mi><mo>≥</mo><mn>0</mn><mo stretchy="false">)</mo><mtext>个结点。</mtext></mrow><annotation encoding="application/x-tex">高度为k的二叉树中至多有2^{k+1}-1 (k≥0)个结点。</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9824379999999999em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">高</span><span class="mord cjk_fallback">度</span><span class="mord cjk_fallback">为</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">二</span><span class="mord cjk_fallback">叉</span><span class="mord cjk_fallback">树</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">至</span><span class="mord cjk_fallback">多</span><span class="mord cjk_fallback">有</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">结</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">。</span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>设</mtext><mi>T</mi><mtext>是由</mtext><mi>n</mi><mtext>个结点构成的二叉树，其中，叶结点个数为</mtext><msub><mi>n</mi><mn>0</mn></msub><mtext>，度为</mtext><mn>2</mn><mtext>的结点个数为</mtext><msub><mi>n</mi><mn>2</mn></msub><mtext>，则有</mtext><mo>:</mo><msub><mi>n</mi><mn>0</mn></msub><mtext>＝</mtext><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">设T是由n个结点构成的二叉树，其中，叶结点个数为n_0，度为2的结点个数为n_2，则有:n_0＝n_2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">设</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">由</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">结</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">构</span><span class="mord cjk_fallback">成</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">二</span><span class="mord cjk_fallback">叉</span><span class="mord cjk_fallback">树</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">叶</span><span class="mord cjk_fallback">结</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">为</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">度</span><span class="mord cjk_fallback">为</span><span class="mord">2</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">结</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">为</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">则</span><span class="mord cjk_fallback">有</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">＝</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>满二叉树</mtext><mo>:</mo><mtext>一棵非空高度为</mtext><mi>k</mi><mo stretchy="false">(</mo><mi>k</mi><mo>&gt;</mo><mo>=</mo><mn>0</mn><mo stretchy="false">)</mo><mtext>的满二叉树，是有</mtext><msup><mn>2</mn><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup><mtext>–</mtext><mn>1</mn><mtext>个结点的二叉树</mtext></mrow><annotation encoding="application/x-tex">满二叉树:一棵非空高度为k ( k &gt;= 0 )的满二叉树，是有2^{k+1} – 1个结点的二叉树</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">满</span><span class="mord cjk_fallback">二</span><span class="mord cjk_fallback">叉</span><span class="mord cjk_fallback">树</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">棵</span><span class="mord cjk_fallback">非</span><span class="mord cjk_fallback">空</span><span class="mord cjk_fallback">高</span><span class="mord cjk_fallback">度</span><span class="mord cjk_fallback">为</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">满</span><span class="mord cjk_fallback">二</span><span class="mord cjk_fallback">叉</span><span class="mord cjk_fallback">树</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">有</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord">–</span><span class="mord">1</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">结</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">二</span><span class="mord cjk_fallback">叉</span><span class="mord cjk_fallback">树</span></span></span></span></span></p><p><img src="image-20231028203341830.png" alt="image-20231028203341830"></p><p><strong>满二叉树的特点是：</strong><br><strong>① 叶结点都在第k层上；</strong><br><strong>② 每个分支结点都有两个子结点；</strong><br><strong>③ 叶结点的个数等于非叶结点个数加1。</strong></p><blockquote><p>一棵有 n 个结点、高为 k 的二叉树 T，一棵高为 k 的满二叉树 T* ， 用正整数按层次顺序分别编号 T 和 T* 的所有结点，如果T 之所有结 点恰好对应于T*的前 n 个结点，则称 T 为<strong>完全二叉树。</strong></p></blockquote><p><img src="image-20231028203822677.png" alt="image-20231028203822677"></p><h3 id="存储结构">存储结构</h3><p><strong>顺序存储</strong></p><p><img src="image-20231029140215064.png" alt="image-20231029140215064"></p><p><img src="image-20231029140236742.png" alt="image-20231029140236742"></p><p><strong>链式存储</strong></p><p><img src="image-20231029140316009.png" alt="image-20231029140316009"></p><p><img src="image-20231029140327999.png" alt="image-20231029140327999"></p><p><img src="image-20231029140412615.png" alt="image-20231029140412615"></p><h3 id="基本操作">基本操作</h3><h4 id="中根遍历">中根遍历</h4><p>力扣： <a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/?envType=study-plan-v2&amp;envId=top-100-liked">https://leetcode.cn/problems/binary-tree-inorder-traversal/description/?envType=study-plan-v2&amp;envId=top-100-liked</a></p><p><strong>递归算法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">       cout&lt;&lt;root-&gt;val; </span><br><span class="line">       <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>迭代算法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">     TreeNode *left;</span><br><span class="line">     TreeNode *right;</span><br><span class="line">     <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line">stack&lt;TreeNode*&gt; sstack;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span>||(!sstack.<span class="built_in">empty</span>()))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sstack.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* p = sstack.<span class="built_in">top</span>();</span><br><span class="line">        cout&lt;&lt;p-&gt;val;</span><br><span class="line">        sstack.<span class="built_in">pop</span>();</span><br><span class="line">        root = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="先根遍历">先根遍历</h4><p>力扣：<a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/submissions/478115880/">https://leetcode.cn/problems/binary-tree-preorder-traversal/submissions/478115880/</a></p><p><strong>算法基本等同于中根遍历，只是改了输出顺序，先输出根节点再遍历左右子树。</strong></p><p><strong>递归：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       cout&lt;&lt;root-&gt;val; </span><br><span class="line">       <span class="built_in">preorder</span>(root-&gt;left);</span><br><span class="line">       <span class="built_in">preorder</span>(root-&gt;right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>非递归算法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">     TreeNode *left;</span><br><span class="line">     TreeNode *right;</span><br><span class="line">     <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span>||(!sstack.<span class="built_in">empty</span>()))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;root-&gt;val;</span><br><span class="line">            sstack.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* p = sstack.<span class="built_in">top</span>();</span><br><span class="line">        sstack.<span class="built_in">pop</span>();</span><br><span class="line">        root = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="后根遍历">后根遍历</h4><p>力扣：<a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/submissions/478118154/">https://leetcode.cn/problems/binary-tree-postorder-traversal/submissions/478118154/</a></p><p>递归：与先根中根类似</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">       <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">       cout&lt;&lt;root-&gt;val; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>非递归：</strong></p><ul><li><strong>先/中根的非递归算法，一个结点只进出栈一次。结点进栈，表示遍历开始； 结点出栈，表示左子树遍历完毕；输出语句的位置为进/出栈时。</strong></li><li><strong>后根遍历，输出结点需在遍历完右子树之后；若每个结点还是进出栈一次， 无法完成，需多次进出栈。</strong></li></ul><p><strong>准备工作栈：</strong></p><p>​                                <img src="image-20231029145156512.png" alt=" "></p><p><img src="image-20231029145238195.png" alt="image-20231029145238195"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line">TreeNode* left;</span><br><span class="line">TreeNode* right;</span><br><span class="line"><span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"><span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"><span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode* left, TreeNode* right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">TreeNode* p;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="built_in">node</span>(TreeNode* root, <span class="type">int</span> num) :<span class="built_in">p</span>(root), <span class="built_in">num</span>(num) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;node&gt; sstack;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">sstack.<span class="built_in">push</span>(<span class="built_in">node</span>(root, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">while</span> (!sstack.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>* tmp;</span><br><span class="line">tmp = &amp;(sstack.<span class="built_in">top</span>());</span><br><span class="line">sstack.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">switch</span> (tmp-&gt;num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">case</span> (<span class="number">0</span>):</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">tmp-&gt;num = <span class="number">1</span>;</span><br><span class="line">sstack.<span class="built_in">push</span>(*tmp);</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;p-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">sstack.<span class="built_in">push</span>(<span class="built_in">node</span>(tmp-&gt;p-&gt;left, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">case</span>(<span class="number">1</span>):</span><br><span class="line">&#123;</span><br><span class="line">tmp-&gt;num = <span class="number">2</span>;</span><br><span class="line">sstack.<span class="built_in">push</span>(*tmp);</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;p-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">sstack.<span class="built_in">push</span>(<span class="built_in">node</span>(tmp-&gt;p-&gt;right, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">case</span> (<span class="number">2</span>):</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; tmp-&gt;p-&gt;val;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><p><strong>力扣官方题解</strong></p><p>​没有用标识区别是哪一个状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode *&gt; stk;</span><br><span class="line">        TreeNode *prev = <span class="literal">nullptr</span>;              <span class="comment">///用来记录前一个访问的节点</span></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">///////////////////////////////////////////////////</span></span><br><span class="line">            <span class="comment">//到此为止完全和中序遍历完全相同</span></span><br><span class="line">            <span class="comment">///////////////////////////////////////////////////</span></span><br><span class="line">           <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span> || root-&gt;right == prev)<span class="comment">////判断右子树是否访问过或存不存在</span></span><br><span class="line">           &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(root);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/binary-tree-postorder-traversal/submissions/478118154/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="层次遍历">层次遍历</h4><p>力扣：</p><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/submissions/480155496/">https://leetcode.cn/problems/binary-tree-level-order-traversal/submissions/480155496/</a></p><p>用队列辅助实现，和广度优先算法有点像，但经过优化，<strong>一次性移除一层的节点</strong></p><blockquote><p>我们可以用一种巧妙的方法修改广度优先搜索：</p><pre><code>首先根元素入队当队列不为空的时候    求当前队列的长度 sis_isi    依次从队列中取 sis_isi 个元素进行拓展，然后进入下一次迭代</code></pre><p>它和普通广度优先搜索的区别在于，普通广度优先搜索每次只取一个元素拓展，而这里每次取 sis_isi 个元素。在上述过程中的第 iii 次迭代就得到了二叉树的第 iii 层的 sis_isi 个元素。</p><p>为什么这么做是对的呢？我们观察这个算法，可以归纳出这样的循环不变式：第 iii 次迭代前，队列中的所有元素就是第 iii 层的所有元素，并且按照从左向右的顺序排列。证明它的三条性质（你也可以把它理解成数学归纳法）：</p><pre><code>初始化：i=1i = 1i=1 的时候，队列里面只有 root，是唯一的层数为 111 的元素，因为只有一个元素，所以也显然满足「从左向右排列」；保持：如果 i=ki = ki=k 时性质成立，即第 kkk 轮中出队 sks_ksk 的元素是第 kkk 层的所有元素，并且顺序从左到右。因为对树进行广度优先搜索的时候由低 kkk 层的点拓展出的点一定也只能是 k+1k + 1k+1 层的点，并且 k+1k + 1k+1 层的点只能由第 kkk 层的点拓展到，所以由这 sks_ksk 个点能拓展到下一层所有的 sk+1s_&#123;k+1&#125;sk+1 个点。又因为队列的先进先出（FIFO）特性，既然第 kkk 层的点的出队顺序是从左向右，那么第 k+1k + 1k+1 层也一定是从左向右。至此，我们已经可以通过数学归纳法证明循环不变式的正确性。终止：因为该循环不变式是正确的，所以按照这个方法迭代之后每次迭代得到的也就是当前层的层次遍历结果。至此，我们证明了算法是正确的。</code></pre><p>作者：力扣官方题解</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector &lt;vector &lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue &lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> currentLevelSize = q.<span class="built_in">size</span>();</span><br><span class="line">            ret.<span class="built_in">push_back</span>(vector &lt;<span class="type">int</span>&gt; ());</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= currentLevelSize; ++i)  &#123;<span class="comment">//移除处理本层所有节点</span></span><br><span class="line">                <span class="keyword">auto</span> node = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                ret.<span class="built_in">back</span>().<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/binary-tree-level-order-traversal/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="创建二叉树">创建二叉树</h4><ul><li><p><strong>先根序列和中根序列可以确定</strong></p><p><img src="image-20231106185651324.png" alt="image-20231106185651324"></p></li><li><p><strong>后根序列和中根序列可以确定</strong></p><p><img src="image-20231106185722158.png" alt="image-20231106185722158"></p></li><li><p><strong>先根序列和后根序列不能确定</strong></p></li></ul><p><strong>已知含空指针的先根序列</strong></p><p><strong>递归实现，规定所给的先序序列如果有空指针则用 ”#“ 标识</strong></p><p><img src="image-20231106192625787.png" alt="image-20231106192625787"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* root;</span><br><span class="line"><span class="type">char</span>* arry;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line"><span class="type">int</span> point;<span class="comment">//读到字符串的第几个了</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">solution</span>(<span class="type">char</span>* arr, <span class="type">int</span> si) :<span class="built_in">arry</span>(arr), <span class="built_in">size</span>(si)</span><br><span class="line">&#123;</span><br><span class="line">root = <span class="literal">NULL</span>;</span><br><span class="line">point = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* <span class="built_in">creatBinTree</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arry[point] == <span class="string">&#x27;#&#x27;</span> || point &gt; size - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">point++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> TreeNode* tmp = <span class="keyword">new</span> <span class="keyword">struct</span> TreeNode;</span><br><span class="line">tmp-&gt;val = arry[point];</span><br><span class="line"><span class="keyword">if</span> (point == <span class="number">0</span>) root = tmp;</span><br><span class="line">point++;</span><br><span class="line">tmp-&gt;left = <span class="built_in">creatBinTree</span>();</span><br><span class="line">tmp-&gt;right = <span class="built_in">creatBinTree</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>已知中根和后根序列</strong></p><p><strong>pta：</strong></p><p>给定非空二叉树的中根序列和后根序列，请编写程序创建该二叉树，计算其高度和先根序列；如给定的中根和后根序列不合法，则亦能识别。</p><p><strong>合法性</strong></p><blockquote><ul><li>长度要相同，可以都为0</li><li>任一字母的中序序列和后序序列<strong>左右元素相同</strong>，顺序可以不一致，通过递归实现</li></ul></blockquote><p><strong>已知先根和中根序列</strong></p><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/?envType=list&amp;envId=YAlgtJ0f">105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）</a></p><h4 id="复制二叉树">复制二叉树</h4><p>用<strong>遍历</strong>的方式进行复制</p><p>以后序遍历为例子</p><p>**复制过程：**先复制子结点，再复制父结点，然后将父结 点与子结点链接起来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* <span class="built_in">copy</span>(<span class="keyword">struct</span> TreeNode* tmp, <span class="keyword">struct</span> TreeNode* tmp1)</span><br><span class="line">&#123;</span><br><span class="line">tmp1 = <span class="keyword">new</span> <span class="keyword">struct</span> TreeNode;</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;left != <span class="literal">NULL</span>) tmp1-&gt;left = <span class="built_in">copy</span>(tmp-&gt;left, tmp1-&gt;left);</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;right != <span class="literal">NULL</span>)    tmp1-&gt;right = <span class="built_in">copy</span>(tmp-&gt;right, tmp1-&gt;right);</span><br><span class="line"></span><br><span class="line">tmp1-&gt;val = tmp-&gt;val;</span><br><span class="line"><span class="keyword">return</span> tmp1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计算树的高度">计算树的高度</h4><p><strong>注意根节点是第0层还是第1层</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">high</span><span class="params">(<span class="keyword">struct</span> Node* root)</span><span class="comment">//根所在的是第一层</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> h1, h2;</span><br><span class="line"><span class="keyword">if</span> (root)</span><br><span class="line">&#123;</span><br><span class="line">h1 = <span class="built_in">high</span>(root-&gt;left);</span><br><span class="line">h2 = <span class="built_in">high</span>(root-&gt;right);</span><br><span class="line"><span class="keyword">return</span> h1 &gt; h2 ? h1 + <span class="number">1</span> : h2 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计算树的路径">计算树的路径</h4><p><strong>练习</strong></p><p><a href="https://leetcode.cn/problems/path-sum/?utm_source=LCUS&amp;utm_medium=ip_redirect&amp;utm_campaign=transfer2china">112. 路径总和 - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode *root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum == root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left, sum - root-&gt;val) || <span class="built_in">hasPathSum</span>(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/path-sum/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归  广度优先搜索</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode *root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode *&gt; que_node;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que_val;</span><br><span class="line">        que_node.<span class="built_in">push</span>(root);</span><br><span class="line">        que_val.<span class="built_in">push</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">while</span> (!que_node.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode *now = que_node.<span class="built_in">front</span>();</span><br><span class="line">            <span class="type">int</span> temp = que_val.<span class="built_in">front</span>();</span><br><span class="line">            que_node.<span class="built_in">pop</span>();</span><br><span class="line">            que_val.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (now-&gt;left == <span class="literal">nullptr</span> &amp;&amp; now-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp == sum) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (now-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                que_node.<span class="built_in">push</span>(now-&gt;left);</span><br><span class="line">                que_val.<span class="built_in">push</span>(now-&gt;left-&gt;val + temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (now-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                que_node.<span class="built_in">push</span>(now-&gt;right);</span><br><span class="line">                que_val.<span class="built_in">push</span>(now-&gt;right-&gt;val + temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/path-sum/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/path-sum-ii/description/">113. 路径总和 II - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">        targetSum -= root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; targetSum == <span class="number">0</span>) &#123;</span><br><span class="line">            ret.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, targetSum);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, targetSum);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> targetSum) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, targetSum);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/path-sum-ii/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/path-sum-iii/description/?utm_source=LCUS&amp;utm_medium=ip_redirect&amp;utm_campaign=transfer2china">437. 路径总和 III - 力扣（LeetCode）</a></p><p>我的思路：暴利破解，遍历每个节点  之后递归搜索有无路径满足</p><p>改进算法：</p><p>前缀和，</p><p><strong>PTA：</strong></p><p>编写程序找出二叉树中和最大的路径，二叉树结点为不等于0的整数。本题的“路径”限定为<strong>以根结点为起点，以叶结点为终点</strong>的路径。路径的和，即该路径所包含的所有结点的数据值之和。</p><p><strong>输入格式:</strong></p><p>输入为一组用空格间隔的整数，个数不超过100个，表示带空指针信息的二叉树先根序列。</p><p><strong>输出格式:</strong></p><p>输出为两行，第一行为该二叉树路径和的最大值，第二行为一组整数，每个整数后一个空格，即该最大路径包含的结点值（按从根的叶的顺序），如果存在多条满足条件路径，则输出最左边一条。</p><p><strong>输入样例1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 0 0 3 0 0</span><br></pre></td></tr></table></figure><p><strong>输出样例1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 3 </span><br></pre></td></tr></table></figure><p><strong>输入样例2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1 2 0 0 3 0 0</span><br></pre></td></tr></table></figure><p><strong>输出样例2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">-1 3 </span><br></pre></td></tr></table></figure><h4 id="查找给定结点的父结点">查找给定结点的父结点</h4><p>遍历的同时进行比较</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* <span class="built_in">Father</span>(<span class="keyword">struct</span> TreeNode* root,<span class="type">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root || (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == root-&gt;left-&gt;val) <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == root-&gt;right-&gt;val) <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* res = <span class="built_in">Father</span>(root-&gt;left, value);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* res1 = <span class="built_in">Father</span>(root-&gt;right, value);</span><br><span class="line">    <span class="keyword">if</span> (res != <span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> res1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找符合数据域条件的结点">查找符合数据域条件的结点</h4><p>遍历的同时进行比较</p><p>例如：采用递归前序遍历进行查找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* <span class="built_in">Find</span>(<span class="keyword">struct</span> TreeNode*root,<span class="type">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)&#123;<span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line"><span class="keyword">if</span> (value == root-&gt;val) <span class="keyword">return</span> root;</span><br><span class="line"><span class="built_in">findpreorder</span>(root-&gt;left, value);</span><br><span class="line"><span class="built_in">findpreorder</span>(root-&gt;right, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="释放二叉树">释放二叉树</h4><p>遍历的同时进行释放</p><p>如：采用层次遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteTree</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">struct</span> TreeNode*&gt; list;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    list.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* tmp;</span><br><span class="line">    <span class="keyword">while</span> (!list.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = list.<span class="built_in">front</span>();</span><br><span class="line">        list.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;left != <span class="literal">NULL</span>) list.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;right != <span class="literal">NULL</span>) list.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入结点">插入结点</h4><ul><li>在二叉树中插入结点，要<strong>确定待插入结点与插入位置结点的父子关系</strong>。</li><li>设p为指向待插入结点的指针，简称结点 p；s为指向插入位置结点 的指针，简称结点s. 即要确定 p 作为 s 的左儿子还是右儿子，以 及如何维护 s 原来的父子关系。</li></ul><p>指定为左儿子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">struct</span> TreeNode* s,<span class="keyword">struct</span> TreeNode* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>||p==<span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    p-&gt;left=s-&gt;left;</span><br><span class="line">    p-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">    s-&gt;left=p;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除给定结点及其左右子树">删除给定结点及其左右子树</h4><p>相较于释放二叉树，我们还需要改变父节点的内容。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(<span class="keyword">struct</span> TreeNode* root,<span class="keyword">struct</span> TreeNode* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>||p==<span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(root==p) &#123;<span class="built_in">deleteTree</span>(root); <span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* father=<span class="built_in">Father</span>(p);<span class="comment">//查找p的父节点</span></span><br><span class="line">    <span class="keyword">if</span>(father-&gt;left==q) father-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> father-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">deleteTree</span>(p);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="表达式树">表达式树</h4><p><strong>概念</strong></p><p>表达式有一个内在二叉树结构，即表达式(a+b) * (c−d)−e对应的二叉树，二叉树中叶结点是表达式中的变量或常数（如：a，b），非叶结点是操作符。</p><p><img src="image-20231106213745029.png" alt="image-20231106213745029"></p><p><strong>后缀表达式构造对应的表达式树</strong></p><p><img src="image-20231106214008659.png" alt="image-20231106214008659"></p><p>实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* <span class="built_in">creatBinTree</span>(<span class="type">char</span>* array, <span class="type">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* tmp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> point = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (point &lt;= size - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (array[point] == <span class="string">&#x27;+&#x27;</span> || array[point] == <span class="string">&#x27;-&#x27;</span> || array[point] == <span class="string">&#x27;*&#x27;</span> || array[point] == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">tmp = <span class="keyword">new</span> <span class="keyword">struct</span> <span class="built_in">TreeNode</span>(array[point]);</span><br><span class="line">tmp-&gt;left = ss.<span class="built_in">top</span>();</span><br><span class="line">ss.<span class="built_in">pop</span>();</span><br><span class="line">tmp-&gt;right = ss.<span class="built_in">top</span>();</span><br><span class="line">ss.<span class="built_in">pop</span>();</span><br><span class="line">ss.<span class="built_in">push</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tmp = <span class="keyword">new</span> <span class="keyword">struct</span> <span class="built_in">TreeNode</span>(array[point]);</span><br><span class="line">ss.<span class="built_in">push</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line">point++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ss.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>已知表达式树，计算其对应的值</strong></p><p>将表达式树转换为后缀表达式，再利用栈计算后缀表达式的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">double</span>&gt; cacu;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* root;</span><br><span class="line">vector&lt;<span class="type">char</span>&gt; v;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tree2array</span><span class="params">(<span class="keyword">struct</span> TreeNode* tmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (tmp-&gt;left != <span class="literal">NULL</span>) <span class="built_in">Tree2array</span>(tmp-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (tmp-&gt;right != <span class="literal">NULL</span>) <span class="built_in">Tree2array</span>(tmp-&gt;right);</span><br><span class="line">    v.<span class="built_in">push_back</span>(tmp-&gt;val);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Treecaculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> lh = <span class="number">0</span>, rh = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Tree2array</span>(root);</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">char</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it &lt; v.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*it == <span class="string">&#x27;+&#x27;</span> || *it == <span class="string">&#x27;-&#x27;</span> || *it == <span class="string">&#x27;*&#x27;</span> || *it == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (*it)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">case</span>(<span class="string">&#x27;+&#x27;</span>):</span><br><span class="line">                    &#123;rh = cacu.<span class="built_in">top</span>();</span><br><span class="line">                     cacu.<span class="built_in">pop</span>();</span><br><span class="line">                     lh = cacu.<span class="built_in">top</span>();</span><br><span class="line">                     cacu.<span class="built_in">pop</span>();</span><br><span class="line">                     cacu.<span class="built_in">push</span>(lh + rh);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="built_in">case</span>(<span class="string">&#x27;-&#x27;</span>):</span><br><span class="line">                    &#123;rh = cacu.<span class="built_in">top</span>();</span><br><span class="line">                     cacu.<span class="built_in">pop</span>(); </span><br><span class="line">                     lh = cacu.<span class="built_in">top</span>(); </span><br><span class="line">                     cacu.<span class="built_in">pop</span>(); </span><br><span class="line">                     cacu.<span class="built_in">push</span>(lh - rh); </span><br><span class="line">                     <span class="keyword">break</span>; &#125;</span><br><span class="line">                <span class="built_in">case</span>(<span class="string">&#x27;*&#x27;</span>): </span><br><span class="line">                    &#123;rh = cacu.<span class="built_in">top</span>(); </span><br><span class="line">                     cacu.<span class="built_in">pop</span>(); </span><br><span class="line">                     lh = cacu.<span class="built_in">top</span>();</span><br><span class="line">                     cacu.<span class="built_in">pop</span>(); </span><br><span class="line">                     cacu.<span class="built_in">push</span>(lh * rh);</span><br><span class="line">                     <span class="keyword">break</span>; &#125;</span><br><span class="line">                <span class="built_in">case</span>(<span class="string">&#x27;/&#x27;</span>): </span><br><span class="line">                    &#123;rh = cacu.<span class="built_in">top</span>();</span><br><span class="line">                     cacu.<span class="built_in">pop</span>(); </span><br><span class="line">                     lh = cacu.<span class="built_in">top</span>();</span><br><span class="line">                     cacu.<span class="built_in">pop</span>();</span><br><span class="line">                     cacu.<span class="built_in">push</span>(lh / rh);</span><br><span class="line">                     <span class="keyword">break</span>; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cacu.<span class="built_in">push</span>(*it - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (cacu.<span class="built_in">top</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线索化二叉树">*线索化二叉树</h2><p><strong>概念</strong></p><blockquote><p>通过遍历二叉树可得到结点的一个线性序列，在<strong>线性序列</strong>中，除第一个结点外，每个结点有且仅有一个前驱， 除最后一个结点外，每个结点有且仅有一个后继。 但在二叉树中只能找到结点的左孩子、右孩子，结点在<strong>线性序列中的前驱和后继</strong>只有在遍历过程中才能得到</p></blockquote><p>为了与结点在二叉树中所具有的前驱（即父结点）和后继即子结 点）区别开来，通常把某种序列中结点的前驱或后继冠以某种遍历 的名称，如把中根序列中结点的前驱称作中根前驱，结点的后继称 作中根后继。</p><p><strong>节点变化：</strong></p><p><img src="image-20231107190809887.png" alt="image-20231107190809887"></p><p><img src="image-20231107190947535.png" alt="image-20231107190947535"></p><p><img src="image-20231107191653826.png" alt="image-20231107191653826"></p><p><strong>[目的]</strong></p><p>​在<strong>中序线索二叉树</strong>中不需要对二叉树进行遍历就可以方便地找到给定结点的<strong>中序前驱和中序后继结点</strong>，并且不需要太多额外的空间。</p><p><strong><u>线索二叉树中一个结点是叶结点的充要条件为：左、 右标识(LThread、RThread)均为1。</u></strong></p><h4 id="相关操作">相关操作</h4><p><strong>搜索以t为根的线索二叉树的中根序列的第一个结点</strong></p><p><strong>【算法思想】：</strong></p><ol><li>若t有左子树，则第一个节点是左子树最左下的节点。</li><li>若t无左子树，则第一个节点是t。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> Lthread;</span><br><span class="line">    <span class="type">bool</span> Rthread;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* left;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">returnfirst</span>(<span class="keyword">struct</span> ThreadBinTree* root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* p=root;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;Lthread==<span class="number">0</span>) p=p-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>搜索以t为根的线索二叉树的中根序列的最后一个结点</strong></p><p><strong>『算法思想』</strong></p><ol><li>若t有右子树则最后一个为最右下方的节点</li><li>若没有，则t即为最后一个</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">returnlast</span>(<span class="keyword">struct</span> ThreadBinTree* root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* p=root;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;Rthread==<span class="number">0</span>) p=p-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在中序线索二叉树中,查找结点p的<u>中根前驱</u>结点</strong></p><p><strong>『算法思想』</strong></p><ol><li>若p节点的Lthread=1，则left指向的即为中序前驱节点</li><li>若为Lthread=0，则p的左子树的中根序列最后一个结点即为p的中根前驱节点</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">returnlast</span>(<span class="keyword">struct</span> ThreadBinTree* root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">returnpre</span>(<span class="keyword">struct</span> ThreadBinTree* p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;Lthread) <span class="keyword">return</span> p-&gt;left;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span>(<span class="built_in">returnlast</span>(p-&gt;left));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在中序线索二叉树中,查找结点p的<u>中根后继</u>结点</strong></p><p><strong>『算法思想』</strong></p><ol><li>若p节点的Rthread=1，则right指向的即为中序前驱节点</li><li>若为Rthread=0，则p的右子树的中根序列第一个结点即为p的中根前驱节点</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">returnfirst</span>(<span class="keyword">struct</span> ThreadBinTree* root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">returnafter</span>(<span class="keyword">struct</span> ThreadBinTree* p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;Rthread) <span class="keyword">return</span> p-&gt;right;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span>(<span class="built_in">returnlast</span>(p-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>中序遍历线索二叉树</strong></p><p>正向遍历</p><p><strong>『算法思想』</strong></p><p>只要先找到中序序列中的<strong>第一个结点</strong>，然后依次找结点的<strong>中序后继</strong>直至其为 空时止</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">returnfirst</span>(<span class="keyword">struct</span> ThreadBinTree* root);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">returnafter</span>(<span class="keyword">struct</span> ThreadBinTree* p);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(<span class="keyword">struct</span> ThreadBinTree* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* first=<span class="built_in">returnfirst</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(first!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;first-&gt;val;</span><br><span class="line">        first=<span class="built_in">returnafter</span>(first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>反向遍历</strong></p><p><strong>『算法思想』</strong></p><p>只要先找到中序序列中的<strong>最后一个结点</strong>，然后依次找结点的<strong>中序前驱</strong>直至其为空时止</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">returnlast</span>(<span class="keyword">struct</span> ThreadBinTree* root);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">returnpre</span>(<span class="keyword">struct</span> ThreadBinTree* p);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deinorder</span><span class="params">(<span class="keyword">struct</span> ThreadBinTree* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* last=<span class="built_in">returnpre</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(last!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;last-&gt;val;</span><br><span class="line">        last=<span class="built_in">returnpre</span>(last);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>中根序列线索二叉树插入节点</strong></p><p>**例如：**在线索二叉树中插入结点p作为结点s的右子结点，</p><p><strong>『算法思想』</strong></p><ol><li><p><strong>s没有右子节点</strong></p><p>​<img src="image-20231109190718789.png" alt="image-20231109190718789"></p></li></ol><p>此时对于结点s我们需要改变以下内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;Rthread=s-&gt;Rthread;</span><br><span class="line">p-&gt;right=s-&gt;right;</span><br><span class="line">s-&gt;right=p;</span><br><span class="line">s-&gt;Rthread=<span class="number">0</span>;</span><br><span class="line">p-&gt;Lthread=<span class="number">1</span>;</span><br><span class="line">p-&gt;left=s;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>s有右子节点</strong></li></ol><p><img src="image-20231109191109896.png" alt="image-20231109191109896"></p><p>此时对于结点s我们需要改变以下内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;Rthread=s-&gt;Rthread;</span><br><span class="line">p-&gt;right=s-&gt;right;</span><br><span class="line">p-&gt;Lthread=<span class="number">1</span>;</span><br><span class="line">p-&gt;left=s;</span><br><span class="line">s-&gt;right=p;</span><br><span class="line">q=p-&gt;right;</span><br><span class="line">q=<span class="built_in">returnfirst</span>(q);</span><br><span class="line">q-&gt;left=p;</span><br></pre></td></tr></table></figure><p>综上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">struct</span> ThreadBinTree* s,<span class="keyword">struct</span> ThreadBinTree* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;right=s-&gt;right;</span><br><span class="line">    p-&gt;Rthread=s-&gt;Rthread;</span><br><span class="line">    p-&gt;left=s;</span><br><span class="line">    p-&gt;Lthread=<span class="number">1</span>;</span><br><span class="line">    s-&gt;right=p;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(s-&gt;Rthread==<span class="number">1</span>)<span class="comment">//s没有右子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;Rthread=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有右子树</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* tmp=p-&gt;right;</span><br><span class="line">    tmp=<span class="built_in">returnfirst</span>(tmp);</span><br><span class="line">    tmp-&gt;left=p;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线索二叉树删除节点</strong></p><p><strong>以删除右孩子为例讨论删除算法：</strong></p><p>即：在一棵中序线索二叉树中，结点 s 的右子结点 p 存在，删除 p</p><p><strong>『算法思想』</strong></p><p><strong>分类：</strong></p><ol><li><p>p为叶子节点，没有左右子树</p><p><img src="image-20231109193435838.png" alt="image-20231109193435838"></p></li><li><p>p没有左子树，但有右子树</p><p><img src="image-20231109193507445.png" alt="image-20231109193507445"></p></li><li><p>p没有右子树，但有左子树</p><p><img src="image-20231109193631495.png" alt="image-20231109193631495"></p></li><li><p>p既有左子树，又有右子树</p></li></ol><p>​<img src="image-20231109193648175.png" alt="image-20231109193648175"></p><p><strong>线索化二叉树</strong></p><p>遍历的同时复制并修改结点域</p><p>例如：中序线索化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadBinTree</span>* <span class="built_in">BinTree2ThreadTree</span>(<span class="keyword">struct</span> TreeNode* root,)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">BinTree2ThreadTree</span>(root-&gt;left);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哈夫曼树">哈夫曼树</h2><p><img src="image-20231109200421248.png" alt="image-20231109200421248"></p><p><img src="image-20231109200432792.png" alt="image-20231109200432792"></p><p><strong>预备知识</strong></p><p><img src="image-20231109200554739.png" alt="image-20231109200554739"></p><blockquote><p><strong>「定义5.6」</strong> 扩充二叉树的外通路长度定义为<strong>从根到每个外结点的路径长度之 和</strong>，内通路长度定义为从根到<strong>每个内结点的路径长度之和</strong>。</p></blockquote><p><img src="image-20231109200749078.png" alt="image-20231109200749078"></p><blockquote><p><strong>「定义5.7」</strong></p><p>给扩充二叉树的 n 个外结点分别赋上一个实数权。扩充二叉树 的加权外通路长度定义为:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mi>P</mi><mi>L</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>w</mi><mi>i</mi></msub><msub><mi>L</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">WPL=\sum\limits_{i=1}^{n}w_iL_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>其中 n 表示外结点的个数，wi 和 Li 分别 表示外结点 ki的权值和根到 ki的路径长度。</p></blockquote><p><img src="image-20231109201819723.png" alt="image-20231109201819723"></p><blockquote><p><strong>「定义5.8」</strong></p><p>在外结点权值分别为 w1 , w2 , … , wn的所有扩充二叉树中，加权外通路长度最小的扩充二叉树称为最优二叉树</p></blockquote><p><img src="image-20231109201854960.png" alt="image-20231109201854960"></p><p><strong>构造哈夫曼树</strong></p><p><strong>「算法思想」</strong></p><p><img src="image-20231109202023891.png" alt="image-20231109202023891"></p><p><img src="image-20231109202220497.png" alt="image-20231109202220497"></p><p><img src="image-20231109202410225.png" alt="image-20231109202410225"></p><blockquote><p>在外结点权值分别为w1 ,w2 ,…,wn的扩充二叉树中，由哈 夫曼算法构造出的哈夫曼树的带权路径长度最小，因此哈夫曼树为<strong>最优二叉树</strong>。</p></blockquote><blockquote><p>由观察可知，字符集中的字符所在的结点均是哈夫曼树中的外结点。哈夫曼树中<strong>没有度为 1 的结点</strong></p></blockquote><blockquote><p>在构造哈夫曼树的过程中，没有一片树叶是其他树叶的 祖先，所以**每个叶结点对应的编码不可能是其他叶结点 对应的编码的前缀，**由此可知哈夫曼编码是二进制的前缀码。</p></blockquote><p><strong>「代码实现」</strong></p><p><img src="image-20231109203436647.png" alt="image-20231109203436647"></p><p>假设给定m个实数（代表权值）对应结点的地址存于一维数组H[1:  m+1]中，该数组已按结点的Weight域排序，即：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">(</mo><mi>H</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>≤</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>≤</mo><mi>W</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">(</mo><mi>H</mi><mo stretchy="false">[</mo><mi>m</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>≤</mo><mi>W</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>l</mi><mi>e</mi><mi>q</mi><mo>≤</mo><mo>+</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">Weight(H[1])\leq..\leq  Weight(H[m])\leq  Weightleq\leq +\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">∞</span></span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HuffmanTreeNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HuffmanTreeNode</span>* Llink;</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line"><span class="comment">//也可以加一个info字段代表是什么字符</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HuffmanTreeNode</span>* Rlink;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HuffmanTreeNode</span>* <span class="built_in">createHuffmanTree</span>(<span class="type">int</span>* arr, <span class="type">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> root;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HuffmanTreeNode</span>* H = <span class="keyword">new</span> <span class="keyword">struct</span> HuffmanTreeNode[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= size - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">H[i].Llink = <span class="literal">NULL</span>;</span><br><span class="line">H[i].Rlink = <span class="literal">NULL</span>;</span><br><span class="line">H[i].weight = arr[i];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= size - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HuffmanTreeNode</span> tmp;</span><br><span class="line">tmp.weight = H[i].weight + H[i + <span class="number">1</span>].weight;</span><br><span class="line">tmp.Llink = &amp;H[i];</span><br><span class="line">tmp.Rlink = &amp;H[i + <span class="number">1</span>];</span><br><span class="line"><span class="comment">//插入排序，将tmp插入原来的序列并保持有序</span></span><br><span class="line">root = i + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (tmp.weight &gt; H[root].weight)</span><br><span class="line">&#123;</span><br><span class="line">H[root - <span class="number">1</span>] = H[root];</span><br><span class="line">root++;</span><br><span class="line">&#125;</span><br><span class="line">H[root - <span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;H[root];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20231109211156143.png" alt="image-20231109211156143"></p><p><img src="image-20231109211225493.png" alt="image-20231109211225493"></p><p><strong>PTA</strong></p><blockquote><p>编写一个哈夫曼编码译码程序。针对一段文本，根据文本中字符出现频率构造哈夫曼树，给出每个字符的哈夫曼编码，并进行译码，计算编码前后文本大小。<br>为确保构建的哈夫曼树唯一，本题做如下限定：</p><ol><li>选择根结点权值最小的两棵二叉树时，选取<strong>权值较小者作为左子树</strong>。</li><li>若多棵二叉树根结点权值相等，则<strong>先生成的作为左子树</strong>，后生成的作为右子树，具体来说：i) 对于单结点二叉树，优先选择根结点对应字母在文本中最先出现者，如文本为cba，三个字母均出现1次，但c在文本中最先出现，b第二出现，故则选择c作为左子树，b作为右子树。ii) 对于非单结点二叉树，先生成的二叉树作为左子树，后生成的二叉树作为右子树。iii. 若单结点和非单结点二叉树根结点权值相等，优先选择单结点二叉树。</li><li>生成哈夫曼编码时，哈夫曼树<strong>左分支标记为0，右分支标记为1</strong>。</li></ol><p><strong>输入格式:</strong></p><p>输入为3行。第1行为一个字符串，包含不超过5000个字符，至少包含两个不同的字符，每个字符为a-z的小写字母。第2、3行为两个由0、1组成的字符串，表示待译码的哈夫曼编码。</p><p><strong>输出格式:</strong></p><p>输出第一行为用空格间隔的2个整数，分别为压缩前后文本大小，以字节为单位，一个字符占1字节，8个二进制位占1字节，若压缩后文本不足8位，则按1字节算。输出从第二行开始，每行为1个字符的哈夫曼编码，按各字符在文本中出现次数递增顺序输出，若多个字符出现次数相同，则按其在文本出现先后排列。每行格式为“字母:编码”。最后两行为两行字符串，表示译码结果，若译码失败，则输出INVALID。</p><p><strong>输入样例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cbaxyyzz</span><br><span class="line">0100</span><br><span class="line">011</span><br></pre></td></tr></table></figure><p><strong>输出样例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">8 3</span><br><span class="line">c:100</span><br><span class="line">b:101</span><br><span class="line">a:110</span><br><span class="line">x:111</span><br><span class="line">y:00</span><br><span class="line">z:01</span><br><span class="line">zy</span><br><span class="line">INVALID</span><br></pre></td></tr></table></figure></blockquote><h2 id="树的存储与操作">树的存储与操作</h2><p>略</p><p>待更新</p><h2 id="等价类与并查集">等价类与并查集</h2><p><img src="image-20231109211344638.png" alt="image-20231109211344638"></p><p>学习途径：<a href="https://zhuanlan.zhihu.com/p/93647900">并查集——Pecco    知乎详解</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>* left;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>* right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DSU</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; parent;<span class="comment">//一开始，我们先将它们的父节点设为自己</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; rank; <span class="comment">//每个节点对应的树的高度，初值为1</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">DSU</span>(<span class="type">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">parent.<span class="built_in">resize</span>(size + <span class="number">1</span>);</span><br><span class="line">rank.<span class="built_in">resize</span>(size + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size + <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">parent[i] = i;</span><br><span class="line">rank[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">// 寻找x所在的树的根节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (parent[x] == x)<span class="comment">//自己就是父节点即找到了根节点则返回</span></span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">parent[x] = <span class="built_in">find</span>(parent[x]);<span class="comment">//找父亲的父节点</span></span><br><span class="line"><span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">find</span>(i), y = <span class="built_in">find</span>(j);</span><br><span class="line"><span class="keyword">if</span> (rank[x] &lt;= rank[y]) <span class="comment">//x高度低于y或相等时，把i挂在j的树上</span></span><br><span class="line">&#123;</span><br><span class="line">parent[x] = y;<span class="comment">//i所在树的根节点x 的父节点是j所在树的根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">parent[y] = x;<span class="comment">//j所在树的根节点的父节点是i所在树的根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rank[x] == rank[y] &amp;&amp; x != y) <span class="comment">//如果高度相等并且 i和j所在的树不相同 则j的树高度要加一</span></span><br><span class="line">&#123;</span><br><span class="line">rank[y]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="图">图</h1><h2 id="存储结构">存储结构</h2><h3 id="邻接矩阵">邻接矩阵</h3><p><img src="image-20231112090728805.png" alt="image-20231112090728805"></p><p><img src="image-20231112090748991.png" alt="image-20231112090748991"></p><p><img src="image-20231112090816704.png" alt="image-20231112090816704"></p><blockquote><p>无向图的邻接矩阵对称，可压缩存储；有n个顶点的无向图所需存储空间为n(n+1)/2；</p><p>有向图的邻接矩阵不一定对称；有n个顶点的有向图所需存储空间为n²</p></blockquote><h3 id="邻接表">邻接表</h3><p><img src="image-20231112091633952.png" alt="image-20231112091633952"></p><blockquote><p>边链表里VerAdj是与顶点相连的节点编号，cost是权值，link指向下一个与顶点相连的节点</p></blockquote><blockquote><p>VerName是顶点名字，adjacent指向与其相连的节点链表</p></blockquote><p><img src="image-20231112091849162.png" alt="image-20231112091849162"></p><p><img src="image-20231112091952212.png" alt="image-20231112091952212"></p><blockquote><p>对于边很多的图（也称稠密图），适于用邻接矩阵存储，因为占用的空间少。</p><p>而对于顶点多而边少的图（也称稀疏图），若用邻接矩阵存储， 对应的邻接矩阵将是一个稀疏矩阵，存储利用率很低。因此，顶点多而边少的图适于用邻接表存储</p></blockquote><h3 id="其他存储结构">其他存储结构</h3><p><img src="image-20231112092304534.png" alt="image-20231112092304534"></p><p><img src="image-20231112092317950.png" alt="image-20231112092317950"></p><h2 id="图的遍历">图的遍历</h2><p><a href="https://www.luogu.com.cn/problem/P3916">图的遍历 洛谷</a></p><h3 id="深度优先遍历">深度优先遍历</h3><p><strong>递归算法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> VerAdj;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>* link;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> name;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>* adjacent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DepthFirstSearch</span><span class="params">(<span class="keyword">struct</span> Node* head,<span class="type">int</span> v,<span class="type">int</span>* visit,<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; head[v].name&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">visit[v] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>* p = head[v].adjacent;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (visit[p-&gt;VerAdj] != <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DepthFirstSearch</span>(head, p-&gt;VerAdj, visit, size);</span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;link;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">struct</span> Node* head,<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* visited=<span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= size<span class="number">-1</span>; i++) visited[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= size<span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (visited[i] != <span class="number">0</span>)</span><br><span class="line"><span class="built_in">DepthFirstSearch</span>(head, i, visited, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20231112165358070.png" alt="image-20231112165358070"></p><p><strong>迭代算法</strong></p><p>利用栈进行访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> VerAdj;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span>* link;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> name;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span>* adjacent;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">struct</span> Node* head, <span class="type">int</span> size,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* visited = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; ss;</span><br><span class="line">    ss.<span class="built_in">push</span>(v);</span><br><span class="line">    <span class="keyword">while</span> (!ss.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Node</span> p = head[ss.<span class="built_in">top</span>()];</span><br><span class="line">        <span class="keyword">if</span> (visited[p.name] != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; p.name &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            visited[p.name] = <span class="number">1</span>;</span><br><span class="line">            ss.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">edge</span>* q = p.adjacent;</span><br><span class="line">            <span class="keyword">while</span> (q != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited[q-&gt;VerAdj] != <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ss.<span class="built_in">push</span>(q-&gt;VerAdj);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                q = q-&gt;link;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20231112175225401.png" alt="image-20231112175225401"></p><h3 id="广度优先遍历">广度优先遍历</h3><p>使用<strong>队列</strong>实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> VerAdj;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span>* link;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> name;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span>* adjacent;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">struct</span> Node* head, <span class="type">int</span> size, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* visited = <span class="keyword">new</span> <span class="type">int</span>[size + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= size; i++)  visited[i] = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">    cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    list.<span class="built_in">push</span>(v);</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!list.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">edge</span>* p = head[list.<span class="built_in">front</span>()].adjacent;</span><br><span class="line">        list.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[p-&gt;VerAdj] != <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; p-&gt;VerAdj &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                visited[p-&gt;VerAdj] = <span class="number">1</span>;</span><br><span class="line">                list.<span class="built_in">push</span>(p-&gt;VerAdj);</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20231112181329874.png" alt="image-20231112181329874"></p><p><img src="image-20231112181406328.png" alt="image-20231112181406328"></p><p><img src="image-20231112181546799.png" alt="image-20231112181546799"></p><h2 id="拓扑排序">拓扑排序</h2><blockquote><p><strong>AOV</strong>网：<strong>在有向图中</strong>，用顶点表示活动，用有向边表示活动之间的<strong>先后关系</strong>，称这样的有向图为AOV网(Activity On Vertex Network)。重点在于研究结点Verterx</p></blockquote><blockquote><p>在AOV网络中，如果活动Vi 必须在活动Vj 之前进行，则存在有向边，**AOV网络中不能出现有向回路，**即有向环。 在AOV网络中如果出现了有向环，则意味着某项活动应以自己作为先决条件。 因此，对给定的AOV网络，应判断它是否存在有向环</p></blockquote><p><img src="image-20231112182247852.png" alt="image-20231112182247852"></p><blockquote><p>如果通过拓扑排序能将AOV网络的所有顶点都排入一个拓扑有序的序列中，则该AOV网络中必定不会出现有向环；<strong>相反，如果得不到满足要求的拓扑有序序列，则说明AOV网络中存在有向环</strong>， 此AOV网络所代表的工程是不可行的</p></blockquote><p><strong>「算法思想」</strong></p><ol><li>从网中选择一个入度为0的顶点并将其输出。</li><li>从网中删除该顶点及其所有出边。</li><li>执行1 、2 ，直至所有顶点都已输出，或者网中剩余顶点的度均不为0（说明网中存在回路，无法继续拓扑排序）。</li></ol><p><strong>注意：对于任何无回路的AOV网，其顶点均可排成拓扑序列，但其拓扑序列未必唯一</strong></p><p><img src="image-20231114200441806.png" alt="image-20231114200441806"></p><p><img src="image-20231114200505007.png" alt="image-20231114200505007"></p><p><img src="image-20231114200610199.png" alt="image-20231114200610199"></p><p><strong>入栈时：count[i]记录当前的栈顶，top赋值为新的栈顶</strong></p><p><strong>出栈时：top即为栈顶的编号，count[top]为栈顶下面的元素编号</strong></p><p><strong>实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TopoOrder</span><span class="params">(<span class="keyword">struct</span> Node* Head,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* count = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n<span class="number">-1</span>; i++)<span class="comment">//初始化count数组</span></span><br><span class="line">&#123;</span><br><span class="line">count[n] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i++)<span class="comment">//初始化count数组</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>* p = Head[i].adjacent;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">count[p-&gt;VerAdj]++;</span><br><span class="line">p = p-&gt;link;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> top = <span class="number">-1</span>; <span class="comment">// 将数组变成虚拟栈</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (count[i] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">count[i] = top;</span><br><span class="line">top=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i++)<span class="comment">//已经无 有向环 的前提下</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (top == <span class="number">-1</span>) <span class="keyword">return</span> ;<span class="comment">//无度为0的结点</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp = <span class="number">-1</span>;</span><br><span class="line">temp = top;</span><br><span class="line">top = count[top];</span><br><span class="line">std::cout &lt;&lt; temp&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>* p = Head[temp].adjacent;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)<span class="comment">//更新count数组和虚拟栈</span></span><br><span class="line">&#123;</span><br><span class="line">count[p-&gt;VerAdj]--;</span><br><span class="line"><span class="keyword">if</span> (count[p-&gt;VerAdj] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">count[p-&gt;VerAdj] = top;</span><br><span class="line">top = p-&gt;VerAdj;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">                p = p-&gt;link;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习一：</strong></p><p><a href="https://leetcode.cn/problems/course-schedule/description/">课程表</a></p><p><strong>要注意判断是否有有向环</strong></p><p>官方题解：</p><p>一：深度优先搜索</p><p>深度优先搜索，将拓扑排序与深度优先搜索联系在一起，二者都是先完成前一个结点再完成后一个结点</p><blockquote><p>对于图中的任意一个节点，它在搜索的过程中有三种状态，即：</p><ul><li><p>「未搜索」：我们还没有搜索到这个节点；</p></li><li><p>「搜索中」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成；</p></li><li><p>「已完成」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的<strong>更底部的位置</strong>，满足拓扑排序的要求。</p></li></ul><p>通过上述的三种状态，我们就可以给出使用深度优先搜索得到拓扑排序的算法流程，在每一轮的搜索搜索开始时，我们任取一个「未搜索」的节点开始进行深度优先搜索。</p><ul><li><p>我们将当前搜索的节点 u 标记为「搜索中」，遍历该节点的每一个相邻节点 v：</p></li><li><p>​    如果 v为「未搜索」，那么我们开始搜索 v，待搜索完成回溯到 u；</p></li><li><p>​    如果 v为「搜索中」，那么我们就找到了图中的一个环，因此是不存在拓扑排序的；</p></li><li><p>​    如果 v为「已完成」，那么说明 v已经在栈中了，而 u还不在栈中，因此 u 无论何时入栈都不会影响到 (u,v) 之前的拓扑关系，以及不用进行任何操作。</p></li><li><p>当 u 的所有相邻节点都为「已完成」时，我们将 u 放入栈中，并将其标记为「已完成」。</p></li></ul><p>在整个深度优先搜索的过程结束后，如果我们没有找到图中的环，那么栈中存储这所有的 n个节点，从栈顶到栈底的顺序即为一种拓扑排序。</p></blockquote><blockquote><p><strong>优化</strong></p><p>由于我们只需要判断是否存在一种拓扑排序，而栈的作用仅仅是存放最终的拓扑排序结果，因此我们可以只记录每个节点的状态，而省去对应的栈。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; visited;</span><br><span class="line">    <span class="type">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        visited[u] = <span class="number">1</span>;<span class="comment">//将本结点标记为搜索中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v: edges[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>)</span><br><span class="line">            &#123;<span class="comment">//如果邻接结点未搜索，则开始搜索</span></span><br><span class="line">                <span class="built_in">dfs</span>(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;<span class="comment">//搜索完V发现有环，结束,上面几层均是结束</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;<span class="comment">//如果结点在搜索中存在环，记录并返回</span></span><br><span class="line">                valid = <span class="literal">false</span>;<span class="comment">//记录</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//不存在环则邻接结点完全搜索完，将本结点标记</span></span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">resize</span>(numCourses);<span class="comment">//初始化边结点的数目</span></span><br><span class="line">        visited.<span class="built_in">resize</span>(numCourses);<span class="comment">//初始化访问标记的数目</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;<span class="comment">//结点状态为0则开始搜索</span></span><br><span class="line">                <span class="built_in">dfs</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/course-schedule/description/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>二：广度优先搜索</p><p>这个方法类似与课本上的解法，只不过是用队列进行实现。</p><p><strong>重点是判断能否产生拓扑序列</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; indeg;<span class="comment">//入度记录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        indeg.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]);</span><br><span class="line">            ++indeg[info[<span class="number">0</span>]];<span class="comment">//更新入度表</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;<span class="comment">//建立度为0的队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> visited = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;<span class="comment">//计算可以去掉的结点有多少个</span></span><br><span class="line">            ++visited;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v: edges[u]) &#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> visited == numCourses;<span class="comment">//如果全可以去掉则不存在有向环则可以产生拓扑序列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/course-schedule/description/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>练习二：</p><p><a href="https://leetcode.cn/problems/course-schedule-ii/description/">课程表二</a></p><h2 id="关键路径">关键路径</h2><blockquote><p>如果在<strong>有向无环</strong>的<strong>带权</strong>图中 ：</p><ul><li>用有向边表示一个工程中的各项活动(Activity) •</li><li>用边上的权值表示活动的持续时间(Duration)</li><li>用顶点表示事件(Event)</li></ul><p>则这样的有向图叫做用边表示活动的网络，简称AOE (Activity  On <strong>Edges</strong>)网络。</p></blockquote><blockquote><p>● 源点：表示整个工程的开始（入度为零）。</p><p>● 汇点：表示整个工程的结束（出度为零）</p></blockquote><p><img src="image-20231115170037611.png" alt="image-20231115170037611"></p><blockquote><p>在AOE网络中, 有些活动必须顺序进行，有些活动可以并行进行。</p><p>从源点到各个顶点，以至从源点到汇点的有向路径可能不止一条。 这些路径的长度也可能不同。完成不同路径的活动所需的时间虽 然不同，但<strong>只有各条路径上的所有活动都完成了，整个工程才算完成</strong>。</p><p>因此，<strong>完成整个工程所需的时间</strong>取决于从源点到汇点的最长路径长度，<strong>即路径上所有活动的持续时间之和</strong>。路径长度最长的路径被称为<strong>关键路径</strong>(Critical Path)。</p></blockquote><p><img src="image-20231115170628128.png" alt="image-20231115170628128"></p><p><img src="image-20231115172253166.png" alt="image-20231115172253166"></p><p><img src="image-20231115172306261.png" alt="image-20231115172306261"></p><p><strong>事件——结点</strong></p><p>最早事件<strong>发生</strong>时间 ve(i) 源点到i点的最长路径长度，即前一个邻接结点的ve加上路径权值最大的那一个</p><p>最晚事件<strong>发生</strong>时间 vl(i)  即后一个邻接结点的vl减去路径权值取最小的那一个，即减去了<strong>时间最长的活动</strong>（“关键活动”）的时长</p><p><strong>活动——边</strong></p><p>最早活动<strong>开始</strong>时间 e(i)</p><p>最晚活动<strong>开始</strong>时间 e(i)</p><p><strong>「算法」</strong></p><ol><li><strong>判断是否存在有向环</strong>，通过拓扑排序进行判断，如果有有向环则中止算法，如果没有，则<strong>按照拓扑排序的顺序</strong>求出各个事件的最早发生时间ve</li><li>按照拓扑排序的<strong>逆序列</strong>求出每个事件的最晚发生事件vl</li><li>根据ve和vl确定活动的最早开始时间e(i)和最晚开始时间l(i)，如果<strong>二者相等则为关键活动</strong></li></ol><p><strong>「实现」</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> name;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span>* link;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> Veradj;</span><br><span class="line">    <span class="type">int</span> cost;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span>* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AOE</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>* Head;<span class="comment">//经过拓扑排序后的结点序列</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    vector&lt;<span class="keyword">struct</span> edge&gt; critical;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">criticalPath</span><span class="params">(<span class="keyword">struct</span> Node* Head, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//求关键路径之前先判断是否存在有向环，不存在则将结点按拓扑排序排好送入Head</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ve</span><span class="params">(num)</span>, <span class="title">vl</span><span class="params">(num)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= num - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ve[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num - <span class="number">1</span>; i++)<span class="comment">//汇点不在范围内,因为没有出边</span></span><br><span class="line">        &#123;<span class="comment">//按拓扑序列进行计算</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">edge</span>* p = Head[i].link;</span><br><span class="line">            <span class="type">int</span> k = Head[i].name;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">NULL</span>)<span class="comment">//求事件最早happen时间</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;cost + ve[k] &gt; ve[p-&gt;Veradj])</span><br><span class="line">                &#123;</span><br><span class="line">                    ve[p-&gt;Veradj] = p-&gt;cost + ve[i];</span><br><span class="line">                &#125;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= num - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vl[i] = ve[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = num - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;<span class="comment">//求事件最晚发生时间</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">edge</span>* p = Head[i].link;</span><br><span class="line">            <span class="type">int</span> k = p-&gt;Veradj;</span><br><span class="line">            <span class="keyword">while</span> (p)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (vl[k] - p-&gt;cost &lt; vl[Head[i].name])</span><br><span class="line">                &#123;</span><br><span class="line">                    vl[Head[i].name] = vl[k] - p-&gt;cost;</span><br><span class="line">                &#125;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= num - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;<span class="comment">//求活动的最晚最早开始事件</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">edge</span>* p = Head[i].link;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>, e = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> k = p-&gt;Veradj;</span><br><span class="line">                e = ve[Head-&gt;name];</span><br><span class="line">                l = vl[k] - p-&gt;cost;</span><br><span class="line">                <span class="keyword">if</span> (e == l)<span class="comment">//相等即为关键活动</span></span><br><span class="line">                &#123;</span><br><span class="line">                    critical.<span class="built_in">push_back</span>(*p);</span><br><span class="line">                &#125;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>「时间复杂度」</strong></p><p><img src="image-20231115223943001.png" alt="image-20231115223943001"></p><blockquote><p>定理 6.3     任意的非空AOE网<strong>至少</strong>存在一条关键路径。</p></blockquote><blockquote><p>推论 6.1     假设&lt;Ti,Tj&gt;边属于AOE网，则有</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi>l</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>−</mo><mi>v</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>≥</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">(</mo><mo>&lt;</mo><mi>T</mi><mi>i</mi><mo separator="true">,</mo><mi>T</mi><mi>j</mi><mo>&gt;</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">vl[j]-ve[i]\geq weight(&lt;Ti,Tj&gt;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span></span></span></span></span></p><p>如果属于关键路径则：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi>l</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>−</mo><mi>v</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">(</mo><mo>&lt;</mo><mi>T</mi><mi>i</mi><mo separator="true">,</mo><mi>T</mi><mi>j</mi><mo>&gt;</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">vl[j]-ve[i]= weight(&lt;Ti,Tj&gt;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span></span></span></span></span></p></blockquote><h2 id="最短路径问题">最短路径问题</h2><p><a href="https://www.luogu.com.cn/training/5312#problems">洛谷最短路径问题题单</a></p><h3 id="单源最短路径">单源最短路径</h3><p><strong>单源：即只有一个出发点</strong></p><p><strong>1.无权最短路径</strong></p><blockquote><p>无权：即每条边的权值都为1</p></blockquote><blockquote><p>源点到各顶点的路径<strong>所经历的边的数目</strong>就是路径的长度</p><p>相对于源点<strong>由近及远</strong>依次求各顶点的最短路径</p></blockquote><p><strong>「算法思想」</strong></p><blockquote><p>Di 为源点S到顶点 i 的最短路径长度;初始：Ds =0 ∀i ≠ S，Di = -1</p><ol><li>访问初始顶点S，对S的所有邻接顶点w, 若Dw = -1，则Dw =Ds+1</li><li>v是当前被访问的顶点，对于v的所有邻接顶点w, 若Dw = -1，则 Dw =Dv +1</li><li>处理完v的所有邻接顶点后，访问另一个满足Du =Dv的顶点u，若不存 在这样的顶点，则访问满足Du =Dv +1的顶点u，若仍不存在，算法结束.</li></ol></blockquote><p><strong>图的广度优先遍历。</strong></p><p><img src="image-20231116163259067.png" alt="image-20231116163259067"></p><p><img src="image-20231116163444506.png" alt="image-20231116163444506"></p><p><strong>「实现」</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">noValueMap</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;<span class="keyword">struct</span> Node&gt;Head;<span class="comment">//邻接表的首节点</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; list;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShortestPath</span><span class="params">(<span class="type">int</span> v)</span><span class="comment">//v是起点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">path</span><span class="params">(Head.size())</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(Head.size())</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= Head.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">path[i] = <span class="number">-1</span>;</span><br><span class="line">dist[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">dist[v] = <span class="number">0</span>;</span><br><span class="line">list.<span class="built_in">push</span>(v);</span><br><span class="line"><span class="keyword">while</span> (!list.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tmp = list.<span class="built_in">front</span>();</span><br><span class="line">list.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>* p = Head[tmp].adjacent;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> k = p-&gt;VerAdj;</span><br><span class="line"><span class="keyword">if</span> (dist[k] == <span class="number">-1</span>)<span class="comment">//没被访问过</span></span><br><span class="line">&#123;</span><br><span class="line">dist[k] = dist[tmp]+<span class="number">1</span>;</span><br><span class="line">list.<span class="built_in">push</span>(k);</span><br><span class="line">path[k] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;link;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>「复杂度」</strong></p><p><img src="image-20231116165054100.png" alt="image-20231116165054100"></p><p><strong>2.正权最短路径</strong></p><p><strong>「前提」</strong></p><p><strong>每条边的权值为正数</strong></p><p><img src="image-20231116165552262.png" alt="image-20231116165552262"></p><p><strong>迪杰斯特拉算法</strong></p><p><strong>「算法思想」</strong></p><blockquote><p>把图中所有顶点分成两个集合，</p><p>​第一个集合 包含已确定最短路径的顶点，</p><p>​第二个集合 包含尚未确定最短路径的顶点。</p><p>按照<strong>最短路径长度递增</strong>的顺序逐 个把第二个集合的顶点加到第一个集合中去，直至从源点出发可以到达的所有顶点都包含到第一个集合中</p></blockquote><blockquote><p>步骤：</p><ol><li>初始时( S为初始顶点） D[s] =0 (<strong>起点的距离</strong>为0)且∀ i ≠ S 有D[ i ] =MAX(无穷，根据题目换成权值的最大值+1)。</li><li>在未访问的顶点中选择<strong>D值最小</strong>的顶点v，访问v，令 S[v]=1（表示已被访问）。</li><li>依次考察v的<strong>邻接顶点</strong>w，若 D[ v ]+weight(&lt;v，w&gt;) &lt; Dw ， 则改变Dw的值，使Dw = Dv + weight(&lt;v，w&gt;) 。</li><li>重复 2、3，直至所有顶点皆被访问（找到源点到该顶点的最短路径）</li></ol></blockquote><p><img src="image-20231119105737954.png" alt="image-20231119105737954"></p><p><strong>「实现」</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> VerAdj;</span><br><span class="line"><span class="type">int</span> cost;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>* link;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> name;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>* adjacent;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PositiveValuePath</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;<span class="keyword">struct</span> Node&gt; Head;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dist;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> Max = <span class="number">1000</span>;<span class="comment">//取决于题目权值的约束条件，一定要比最大值大</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DshortsPath</span><span class="params">(<span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dist.<span class="built_in">resize</span>(Head.<span class="built_in">size</span>());</span><br><span class="line">path.<span class="built_in">resize</span>(Head.<span class="built_in">size</span>());</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(Head.size())</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= Head.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">dist[i] = Max;</span><br><span class="line">path[i] = <span class="number">-1</span>;</span><br><span class="line">visited[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">dist[start] = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> next = start;</span><br><span class="line">visited[next] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= Head.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>* p = Head[next].adjacent;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> k = p-&gt;VerAdj;</span><br><span class="line"><span class="keyword">if</span> (visited[k] == <span class="number">0</span> &amp;&amp; dist[next] + p-&gt;cost &lt; dist[k])</span><br><span class="line">&#123;</span><br><span class="line">dist[k] = dist[next] + p-&gt;cost;</span><br><span class="line">path[k] = next;<span class="comment">//在源点到k点的最短路中，k的上一个节点是next</span></span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;link;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> min = Max;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= Head.<span class="built_in">size</span>() - <span class="number">1</span>; i++)<span class="comment">//更新next，在未访问节点中选取距离最近的节点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dist[i] &lt; min &amp;&amp; visited[i] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">next = i;</span><br><span class="line">min = dist[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">visited[next] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="image-20231119111932519.png" alt="image-20231119111932519"></p><p><strong><u>算法结束时</u>，dist[x]将包括所有最短路径的长度。</strong></p><p><strong>「练习」</strong></p><p><a href="https://leetcode.cn/problems/network-delay-time/description/">网络延迟时间</a></p><p><img src="image-20231119122232538.png" alt="image-20231119122232538"></p><p>对于<strong>稀疏图</strong>，即边的个数远小于点的个数时，<strong>时间效率不高</strong>，可以采用<strong>优先队列</strong>进行改进。</p><p>优先队列相关内容见线性表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DshortsPath</span><span class="params">(<span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; plist;</span><br><span class="line">       <span class="comment">//优先队列，按照piar的第一个数据升序排列</span></span><br><span class="line">dist[start] = <span class="number">0</span>;</span><br><span class="line">plist.<span class="built_in">push</span>(&#123; <span class="number">0</span>,start &#125;);<span class="comment">//&lt;距离，节点号&gt;</span></span><br><span class="line"><span class="type">int</span> node_size = date.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span> (plist.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> t = plist.<span class="built_in">top</span>();</span><br><span class="line">plist.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">int</span> tindex = t.second, distance = t.first;</span><br><span class="line"><span class="keyword">if</span> (visited[tindex])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">visited[tindex] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EDGE</span>* p = date[tindex].next;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> index = p-&gt;adj_index;</span><br><span class="line"><span class="keyword">if</span> (!visited[index] &amp;&amp; dist[tindex] + p-&gt;val &lt; dist[index])</span><br><span class="line">&#123;</span><br><span class="line">dist[index] = dist[tindex] + p-&gt;val;</span><br><span class="line">plist.<span class="built_in">push</span>(&#123; dist[index],index &#125;);<span class="comment">//将求过距离的节点放入优先队列中排序，以便生成下次访问的节点</span></span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; node_size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dist[i] != Max)<span class="comment">//可以到达</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, dist[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="每对顶点之间的最短路径">每对顶点之间的最短路径</h3><p><strong>Floyd算法</strong></p><p><strong>「基本思想」</strong></p><p><img src="image-20231121215600271.png" alt="image-20231121215600271"></p><p><img src="image-20231121220114159.png" alt="image-20231121220114159"></p><p><img src="image-20231121220247584.png" alt="image-20231121220247584"></p><p><strong>「实现」</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myMap</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edge;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dist;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> MAX ;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AllLength</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">A</span>(edge.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;=edge.<span class="built_in">size</span>()<span class="number">-1</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= edge.<span class="built_in">size</span>() - <span class="number">1</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                A[i][j] = edge[i][j];</span><br><span class="line">                <span class="keyword">if</span> (edge[i][j] &lt; MAX &amp;&amp; i != j) path[i][j] = i;<span class="comment">//i到j的路上前一个节点是i</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    path[i][j] = <span class="number">-1</span>;<span class="comment">//无路可走</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= edge.<span class="built_in">size</span>() - <span class="number">1</span>; k++)<span class="comment">//不断添加经过的范围</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= edge.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j&lt;= edge.<span class="built_in">size</span>() - <span class="number">1</span>; j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (j != k &amp;&amp; j != i &amp;&amp; A[i][k] &lt; MAX &amp;&amp; A[k][j] &lt; MAX &amp;&amp; A[i][k] + A[k][j] &lt; A[i][j])</span><br><span class="line">                            <span class="comment">//i到k可及，k到j可及</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            A[i][j] = A[i][k] + A[k][j];</span><br><span class="line">                            path[i][j] = path[k][j];<span class="comment">//i经由k到j的路上前一个节点是 k到j上的前一个节点</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> myMap::MAX = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p><strong>「复杂度」</strong></p><p><img src="image-20231121222347936.png" alt="image-20231121222347936"></p><p><strong>「练习」</strong></p><p><a href="https://leetcode.cn/problems/evaluate-division/description/?utm_source=LCUS&amp;utm_medium=ip_redirect&amp;utm_campaign=transfer2china">力扣 除法求值</a></p><h3 id="满足约束的最短路径">*满足约束的最短路径</h3><p><img src="image-20231125110927125.png" alt="image-20231125110927125"></p><p><strong>「算法思路」</strong></p><p><img src="image-20231125111316497.png" alt="image-20231125111316497"></p><p><img src="image-20231125112146476.png" alt="image-20231125112146476"></p><p><img src="image-20231125112206584.png" alt="image-20231125112206584"></p><h2 id="最小支撑树">最小支撑树</h2><blockquote><p>对于一个无向网络——无向加权连通图N=(V, E, C)（C表示该图为 权图），其顶点个数为|V|=n，图中边的个数为|E|，可以从它的|E|条边 中选出n-1条边，使之满足：</p><p>(1) 这n-1条边和图的n个顶点构成一个连通图。</p><p>(2) 该连通图的代价（n-1条边上的权值之和）是所有满足条件(1)的 连通图的代价的最小值。</p><p>这样的连通图被称为网络的最小支撑树</p></blockquote><p><img src="image-20231125112342879.png" alt="image-20231125112342879"></p><h3 id="prim算法">Prim算法</h3><p><strong>「算法思路」</strong></p><p><img src="image-20231125112558260.png" alt="image-20231125112558260"></p><p>​<img src="image-20231125144316659.png" alt="image-20231125144316659"></p><p><strong>「实现」</strong></p><p>假定编号从1开始</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">EDGE</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> head;</span><br><span class="line"><span class="type">int</span> tail;</span><br><span class="line"><span class="type">int</span> cost;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myMap</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> MAX;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adjcent;<span class="comment">//邻接矩阵</span></span><br><span class="line">vector&lt;<span class="keyword">struct</span> EDGE&gt; TE;<span class="comment">//最小支撑树边的集合</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prim</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TE.<span class="built_in">resize</span>(adjcent.<span class="built_in">size</span>());</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">closedge</span>(adjcent.<span class="built_in">size</span>());<span class="comment">//lowcost vex 权值和U中的顶点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= adjcent.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">closedge[i].first = adjcent[<span class="number">1</span>][i];<span class="comment">// 初始状态U中只有起点1</span></span><br><span class="line">closedge[i].second = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">closedge[<span class="number">1</span>].second = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= adjcent.<span class="built_in">size</span>(); j++)<span class="comment">//有n个点，n-1条边加入TE</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> v = <span class="number">0</span>, min = MAX;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= adjcent.<span class="built_in">size</span>(); i++)<span class="comment">//找最短的</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (closedge[i].second != <span class="number">-1</span> &amp;&amp; closedge[i].first &lt; min)</span><br><span class="line">&#123;</span><br><span class="line">v = i;</span><br><span class="line">min = closedge[i].first;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (v != <span class="number">0</span>)<span class="comment">//找到了</span></span><br><span class="line">&#123;</span><br><span class="line">TE[count].head = closedge[v].second;</span><br><span class="line">TE[count].tail = v;</span><br><span class="line">TE[count].cost = closedge[v].first;</span><br><span class="line">count++;</span><br><span class="line">closedge[v].first = <span class="number">0</span>;<span class="comment">//v is putted in group U</span></span><br><span class="line">closedge[v].second = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= adjcent.<span class="built_in">size</span>(); k++)<span class="comment">//更新closedge数组</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (closedge[k].second != <span class="number">-1</span> &amp;&amp; adjcent[v][k] &lt; closedge[k].first)</span><br><span class="line">&#123;</span><br><span class="line">closedge[k].first = adjcent[v][k];</span><br><span class="line">closedge[k].second = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//图不连通</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;NOT CONNECTED&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> myMap::MAX = <span class="number">100</span>;<span class="comment">/////</span></span><br></pre></td></tr></table></figure><p><strong>注意MAX的值一定要大于边界条件</strong></p><p><img src="image-20231125163221574.png" alt="image-20231125163221574"></p><p><strong>「练习」</strong></p><p><a href="https://leetcode.cn/problems/min-cost-to-connect-all-points/description/">力扣 连接所有点的最小费用</a></p><h3 id="kruskal算法">Kruskal算法</h3><p><strong>「算法思路」</strong></p><p><img src="image-20231125162612696.png" alt="image-20231125162612696"></p><p><s>Prim是重点在于已知一个点在U中找与其相邻的最小权值边，而Kruskal算法在于已知所有点在不同的连通分量里找权值最小的边</s></p><p><img src="image-20231125162944745.png" alt="image-20231125162944745"></p><p><img src="image-20231125163134781.png" alt="image-20231125163134781"></p><p><strong>「实现」</strong></p><p>依旧要借用辅助数组TE来记录支撑树的边,还要由数组E保存图中的边</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">EDGE</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> head;</span><br><span class="line"><span class="type">int</span> tail;</span><br><span class="line"><span class="type">int</span> cost;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myMap</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> T;<span class="comment">//连通分量，初识也是点的个数</span></span><br><span class="line">vector&lt;EDGE&gt; E;<span class="comment">//图中所有边集合</span></span><br><span class="line">vector&lt;<span class="keyword">struct</span> EDGE&gt; TE;<span class="comment">//最小支撑树边的集合</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(EDGE a, EDGE b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.cost &lt;= b.cost;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TE.<span class="built_in">resize</span>(E.<span class="built_in">size</span>());</span><br><span class="line">std::<span class="built_in">sort</span>(E.<span class="built_in">begin</span>(), E.<span class="built_in">end</span>(),cmp);</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (T &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> v1 = E[j].head;</span><br><span class="line"><span class="type">int</span> v2 = E[j].tail;</span><br><span class="line"><span class="type">int</span> cost = E[j].cost;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Find</span>(v1) != <span class="built_in">Find</span>(v2))<span class="comment">//不在一个连通分支中</span></span><br><span class="line">&#123;</span><br><span class="line">TE[count].head = v1;</span><br><span class="line">TE[count].tail = v2;</span><br><span class="line">TE[count].cost = cost;</span><br><span class="line">count++;</span><br><span class="line"><span class="built_in">merge</span>(v1, v2);</span><br><span class="line">T--;</span><br><span class="line">&#125;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="图的应用">图的应用</h2><h3 id="可及性与传递闭包">可及性与传递闭包</h3><p><strong>warshall算法</strong></p><p><strong>「基本概念」</strong></p><p><img src="image-20231125170212022.png" alt="image-20231125170212022"></p><blockquote><p><strong>沃尔肖（Warshall）算法：</strong><br>求有向图G可及矩阵的算法，递推公式如下：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mi>S</mi><msup><mi>M</mi><mrow><mo stretchy="false">(</mo><mi>K</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>W</mi><mi>S</mi><msup><mi>M</mi><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mspace width="1em"/><mi>O</mi><mi>R</mi><mspace width="1em"/><mo stretchy="false">(</mo><mi>W</mi><mi>S</mi><msup><mi>M</mi><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mspace width="1em"/><mi>A</mi><mi>N</mi><mi>D</mi><mspace width="1em"/><mi>W</mi><mi>S</mi><msup><mi>M</mi><mrow><mo stretchy="false">(</mo><mi>K</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mspace width="2em"/><mspace width="2em"/><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">WSM^{(K)}[i][j]=WSM^{(k-1)}[i][j]\quad OR\quad(WSM^{(k-1)}[i][k]\quad AND\quad WSM^{(K-1)}[k][j])\\ \qquad \qquad 1\leq k \leq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.188em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.188em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mspace" style="margin-right:2em;"></span><span class="mspace" style="margin-right:2em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></span></p><p>其中</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mi>S</mi><msup><mi>M</mi><mn>0</mn></msup><mo>=</mo><mi>A</mi><mspace width="1em"/><mo stretchy="false">(</mo><mtext>加上主对角线元素</mtext><mn>1</mn><mo stretchy="false">)</mo><mspace width="1em"/><mi>A</mi><mtext>是有向图</mtext><mi>G</mi><mtext>的邻接矩阵</mtext><mspace linebreak="newline"></mspace><mi>W</mi><mi>S</mi><msup><mi>M</mi><mrow><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mtext>表示定点</mtext><mi>i</mi><mtext>只经过顶点</mtext><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>k</mi><mtext>到达</mtext><mi>j</mi><mtext>的可及性</mtext></mrow><annotation encoding="application/x-tex">WSM^0 = A\quad (加上主对角线元素1) \quad A是有向图G的邻接矩阵\\WSM^{(k)}[i][j]表示定点i只经过顶点1,2,...,k到达j的可及性</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">加</span><span class="mord cjk_fallback">上</span><span class="mord cjk_fallback">主</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">角</span><span class="mord cjk_fallback">线</span><span class="mord cjk_fallback">元</span><span class="mord cjk_fallback">素</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">A</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">向</span><span class="mord cjk_fallback">图</span><span class="mord mathdefault">G</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">邻</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">矩</span><span class="mord cjk_fallback">阵</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.188em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">点</span><span class="mord mathdefault">i</span><span class="mord cjk_fallback">只</span><span class="mord cjk_fallback">经</span><span class="mord cjk_fallback">过</span><span class="mord cjk_fallback">顶</span><span class="mord cjk_fallback">点</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">达</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">及</span><span class="mord cjk_fallback">性</span></span></span></span></span></p></blockquote><p><strong>「实现」</strong></p><p><img src="image-20231130191358878.png" alt="image-20231130191358878"></p><p><img src="image-20231130192912825.png" alt="image-20231130192912825"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myMAP</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">Warshall</span>()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; wsm = A;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= A.<span class="built_in">size</span>() - <span class="number">1</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= A.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (wsm[i][k] = <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= A.<span class="built_in">size</span>() - <span class="number">1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">wsm[i][j] = wsm[i][j] + wsm[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> wsm;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>拓扑逆序算法</strong></p><p><strong>「算法思想」</strong></p><p><img src="image-20231130193447217.png" alt="image-20231130193447217"></p><p><img src="image-20231130193415347.png" alt="image-20231130193415347"></p><p>「实现」</p><p><img src="image-20231130194254569.png" alt="image-20231130194254569"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myMAP</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;Node&gt; head;<span class="comment">//图的邻接表已经按照拓扑序列排列过</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tranclo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; REACH;</span><br><span class="line">vector&lt;<span class="type">int</span> &gt; Breach;</span><br><span class="line">Breach.<span class="built_in">resize</span>(head.<span class="built_in">size</span>());</span><br><span class="line">REACH.<span class="built_in">resize</span>(head.<span class="built_in">size</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= head.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">Breach[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = head.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">Breach[i] = <span class="number">1</span>;</span><br><span class="line">REACH[i].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EDGE</span>* p = head[i].link;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = p-&gt;num;</span><br><span class="line"><span class="keyword">if</span> (Breach[j] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= REACH[j].<span class="built_in">size</span>() - <span class="number">1</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Breach[k] ==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">REACH[i].<span class="built_in">push_back</span>(k);</span><br><span class="line">Breach[k] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= head.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">Breach[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="连通分量">连通分量</h3><p><strong>「算法思想」</strong></p><p><img src="image-20231130202654827.png" alt="image-20231130202654827"></p><p><strong>在求出可及性的基础上进行计算，wsm[ i ] [ j ] =1&amp;&amp;wsm[ j ] [ i ]=1  成立即i和j在一个连通分量里。</strong></p><h1 id="排序">排序</h1><h2 id="基本概念和指标">基本概念和指标</h2><blockquote><p>关键字域（key）：排序依据</p><p>主关键词：如果在数据表中各个对象的关键词互不相同，这种关键词即主关键词。按照主关键词进行排序，排序的结果是唯一的。</p><p>次关键词：数据表中有些对象的关键词可能相同，这种关键词称为次关键词。按照次关键词进行排序，排序的结果不一定唯一</p></blockquote><blockquote><p>稳定性：对于一开始表中主关键词域相同的对象，排序前后相对顺序不变</p><p>排序的时间开销：即排序算法的时间复杂度，是衡量算法好坏的 最重要的标志，可用算法执行过程中关键词的比较次数与记录的 移动次数来衡量。</p></blockquote><blockquote><p>有些排序算法的时间复杂度受记录关键词序列初始排列及记录个数影响较大，此时，按最好情况、最坏情况及平均情况，分别估算比较次数和移动次数。</p><p>算法执行时所需的附加存储空间，是评价排序算法好坏的另外一 个指标</p></blockquote><p><img src="image-20231130203508041.png" alt="image-20231130203508041"></p><h2 id="插入排序">插入排序</h2><h3 id="直接插入排序">直接插入排序</h3><p><strong>「算法思想」</strong></p><p>将一个记录插入到已经排好序的有序表中，从而获得一个新的、记录数增加1的有序表。</p><p><strong>「实现」</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>「分析」</strong></p><p><img src="image-20231228185940386.png" alt="image-20231228185940386"></p><p><strong>「稳定性」</strong></p><p><strong>具有稳定性。</strong></p><p>「改进」</p><p>将<strong>顺序查找</strong>改为<strong>二分查找</strong>，构造二分/对半插入排序算法</p><p>也是个稳定的排序方法</p><h3 id="希尔排序">希尔排序</h3><p>对直接插入排序的改进</p><p><strong>「算法思想」</strong></p><p><img src="image-20231228190556468.png" alt="image-20231228190556468"></p><p><img src="image-20231228190623271.png" alt="image-20231228190623271"></p><p><img src="image-20231228190713082.png" alt="image-20231228190713082"></p><p><img src="image-20231228190809518.png" alt="image-20231228190809518"></p><p><strong>「实现」</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>「增量的取法」</strong></p><p><img src="image-20231228190906374.png" alt="image-20231228190906374"></p><p><strong>「复杂度」</strong></p><p><img src="image-20231228191037103.png" alt="image-20231228191037103"></p><p><img src="image-20231228191043450.png" alt="image-20231228191043450"></p><p><img src="image-20231228191246262.png" alt="image-20231228191246262"></p><p><strong>「稳定性」</strong></p><p><strong>不稳定</strong></p><h2 id="交换排序">交换排序</h2><h3 id="冒泡排序">冒泡排序</h3><p><strong>「算法思想」</strong></p><p>从左到右/从上到下 比较相邻记录的关键词，交换存在逆序的记录</p><blockquote><p>经过一次冒泡排序可以把最大关键词的记录移动到最后</p><p>经过n-1次，就可以对所有记录排序</p><p>发生一次记录交换，反序对少一个</p></blockquote><p><strong>「实现」</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>「改进」</strong></p><p>某趟扫描没有任何记录交换的时候就算法终止</p><p><strong>「复杂度」</strong></p><p><img src="image-20231228191947851.png" alt="image-20231228191947851"></p><p><img src="image-20231228192251995.png" alt="image-20231228192251995"></p><p><strong>「稳定性」</strong></p><p><strong>稳定</strong></p><h3 id="快速排序-分划交换排序">快速排序(分划交换排序)</h3><p><strong>「算法思想」</strong></p><p><img src="image-20231228192527737.png" alt="image-20231228192527737"></p><p><strong>「实现」</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>「复杂度」</strong></p><p><img src="image-20231228193524847.png" alt="image-20231228193524847"></p><p><strong>改进：</strong><br><img src="image-20231228194055159.png" alt="image-20231228194055159"></p><p><img src="image-20231228194133557.png" alt="image-20231228194133557"></p><p><strong>「稳定性」</strong></p><p><strong>不稳定</strong></p><h2 id="选择排序">选择排序</h2><h3 id="直接选择排序">直接选择排序</h3><p><strong>「算法思想」</strong></p><p><img src="image-20231228200101145.png" alt="image-20231228200101145"></p><p><strong>「实现」</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>「复杂度」</strong></p><p><img src="image-20231228200243718.png" alt="image-20231228200243718"></p><p><img src="image-20231228200411426.png" alt="image-20231228200411426"></p><p><strong>改进：</strong></p><blockquote><p>选择排序的关键是找最大或者最小记录，利用树形保存前面的比较结果，下一次选择时直接利用，可以大大减少比较次数</p><p><img src="image-20231228200859044.png" alt="image-20231228200859044"></p><p><strong>相关概念</strong></p><p>比赛树：每次两两比较的结果把关键词大者作为优胜者上升到父结点，，称 这种树为比赛树<br>外结点：位于最底层的叶结点      内结点：非叶结点</p><p><img src="image-20231228201249293.png" alt="image-20231228201249293"></p><p><img src="image-20231228201415248.png" alt="image-20231228201415248"></p></blockquote><p><strong>「稳定性」</strong></p><p><strong>不稳定</strong></p><h3 id="堆排序">堆排序</h3><blockquote><p>堆：：<strong>完全二叉树</strong>中的任意结点的关键词大于等于它的两个子结点的关键词，把这样的数据结构称为堆（<strong>大根堆</strong> ）</p><p>大根堆中根结点的关键词最大，小根堆中根结点的关键词最小。</p></blockquote><p><img src="image-20231228201723577.png" alt="image-20231228201723577"></p><p><strong>「算法思想」</strong></p><p><img src="image-20231228201835198.png" alt="image-20231228201835198"></p><p><strong>过程：</strong></p><ol><li><p>建堆</p></li><li><p>交换再重建堆</p><p><img src="image-20231228202751553.png" alt="image-20231228202751553"></p></li></ol><p><img src="image-20231228202716431.png" alt="image-20231228202716431"></p><p>​<img src="image-20231228203139519.png" alt="image-20231228203139519"></p><p><strong>「实现」</strong></p><p><strong>堆存储于顺序线性表（数组）中</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>「复杂度」</strong></p><p><img src="image-20231228204228279.png" alt="image-20231228204228279"></p><p><strong>「稳定性」</strong></p><p><strong>不稳定</strong></p><h2 id="合并排序">合并排序</h2><blockquote><ol><li>合并/归并：把两个或多个有序文件组成一个单一的有序文件。</li><li>基于合并操作完成排序。</li></ol></blockquote><blockquote><p>当 i 和 j 分别在两个表内变化时，通过比较A[i]与B[j]的关键词大小，依次把 <strong>关键词小</strong>的对象放到新表X[k]中；</p><p>当 i与 j中有一个<strong>超出表长</strong>时，将另一个表中的<strong>剩余部分</strong>照抄到新表X中</p></blockquote><p><img src="image-20231228204800031.png" alt="image-20231228204800031"></p><p><strong>「实现」</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>改进：</strong></p><blockquote><p>分析合并排序算法，不难发现它的两个缺点：</p><ol><li>当数据集非常小 时，比如只有2个元素，仍然采用分治策略，影响效率。</li><li>Merge算法基于元素移动，当元素比较大时，移动操作比较费时</li></ol><p>➢针对这两个问题的解决办法：</p><ol><li>对于小数据集以及前几趟合并操作，调用直接插入排序算法 。</li><li>将数组存储改为链表存储，这样记录移动变为指针移动</li></ol></blockquote><p><strong>「复杂度」</strong></p><p><img src="image-20231228210738722.png" alt="image-20231228210738722"></p><p><strong>「稳定性」</strong></p><p><strong>稳定</strong></p><h2 id="基于关键词比较的排序算法分析">基于关键词比较的排序算法分析</h2><p><img src="image-20231228211003577.png" alt="image-20231228211003577"></p><h2 id="分治排序的一般方法">分治排序的一般方法</h2><blockquote><p>快速排序、合并排序，应用了分治策略</p></blockquote><p><img src="image-20231228211507430.png" alt="image-20231228211507430"></p><h2 id="分布排序">分布排序</h2><p><img src="image-20231228211613438.png" alt="image-20231228211613438"></p><p><strong>「复杂度」</strong></p><p>时间复杂度可以达到线性阶。</p><h3 id="基数分布排序">基数分布排序</h3><p><img src="image-20231228212050722.png" alt="image-20231228212050722"></p><blockquote><p><strong>基于基数分布的排序（基数排序）</strong></p><ol><li>最高次序位法 ：先按高位分桶，然后桶内进行排序  如：英文单词，扑克牌</li><li>最低次序位法 ：先按最低位排序，然后按下一个次低位排序，…， 最后按最高位排序。</li></ol></blockquote><p><img src="image-20231228212242265.png" alt="image-20231228212242265"></p><p><strong>「实现」</strong></p><p><img src="image-20240106192844493.png" alt="image-20240106192844493"></p><h3 id="值分布排序">值分布排序</h3><p><img src="image-20231228212717956.png" alt="image-20231228212717956"></p><p><strong>「实现」</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>例如：堆三元组表存储的稀疏矩阵，求转置矩阵，可以利用值排序</p><p><img src="image-20231228213101065.png" alt="image-20231228213101065"></p><p><img src="image-20231228213111411.png" alt="image-20231228213111411"></p><h1 id="查找">查找</h1><h2 id="线性表的查找">线性表的查找</h2><h3 id="顺序查找">顺序查找</h3><p><strong>「无序表顺序查找」</strong></p><p>查找失败的查找长度：n+1</p><p>分析：</p><p><img src="image-20240101220318755.png" alt="image-20240101220318755"></p><p>改进： 自组织表</p><p><img src="image-20240101220409170.png" alt="image-20240101220409170"></p><p><strong>「有序表的顺序查找」</strong></p><blockquote><p>但如果只对表查找一次，则顺序查找要比排序快； 如果要在同一个文件中不断查找，将表按序排列再查找是个很好的方法</p></blockquote><h3 id="对半查找">对半查找</h3><p><strong>算法思想</strong></p><p><img src="image-20240103223229203.png" alt="image-20240103223229203"></p><p><strong>算法分析</strong></p><p><img src="image-20240103223348132.png" alt="image-20240103223348132"></p><p><img src="image-20240103225607803.png" alt="image-20240103225607803"></p><h4 id="一致对半查找">一致对半查找</h4><p><img src="image-20240103230244102.png" alt="image-20240103230244102"></p><p><img src="image-20240103230341008.png" alt="image-20240103230341008"></p><p><img src="image-20240103230837327.png" alt="image-20240103230837327"></p><p><img src="image-20240103230908047.png" alt="image-20240103230908047"></p><h3 id="斐波那契查找">斐波那契查找</h3><p><img src="image-20240103231158412.png" alt="image-20240103231158412"></p><p><img src="image-20240103231110183.png" alt="image-20240103231110183"></p><p><img src="image-20240103231126829.png" alt="image-20240103231126829"></p><p><img src="image-20240103231302067.png" alt="image-20240103231302067"></p><p><img src="image-20240103231518508.png" alt="image-20240103231518508"></p><h3 id="插值查找">插值查找</h3><p><img src="image-20240105222143570.png" alt="image-20240105222143570"></p><p><strong>算法思想</strong></p><p><img src="image-20240105222226192.png" alt="image-20240105222226192"></p><p><img src="image-20240105222431296.png" alt="image-20240105222431296"></p><h2 id="树形结构的查找">树形结构的查找</h2><h3 id="字典树-trie树">字典树（trie树）</h3><p><strong>常用来解决根据前缀查询字符串的问题</strong></p><p><img src="image-20240310165419879.png" alt="image-20240310165419879"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TrieNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TrieNode</span>* next[<span class="number">36</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">     <span class="type">bool</span> end=<span class="literal">false</span>;</span><br><span class="line"><span class="type">char</span> word[<span class="number">30</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉查找树-bst">二叉查找树（BST）</h3><blockquote><p>一棵<strong>二叉查找树</strong>是一棵可能为空的二叉树形，并且关键词 各不相同。二叉查找树中的任一结点P，它的左子树中结点的关键 词都小于KEY§，而右子树中结点的关键词都大于KEY§</p></blockquote><blockquote><p>二叉查找树 （或称二叉搜索树、排序树）是一棵可能为空 的二叉树形，一棵非空的二叉查找树中的所有结点在<strong>中根次序</strong>下 按其关键词由<strong>小到大</strong>排序，并且<strong>关键词各不相同</strong></p></blockquote><p><img src="image-20240105222809843.png" alt="image-20240105222809843"></p><p><img src="image-20240105222820415.png" alt="image-20240105222820415"></p><p><strong>查找</strong></p><p>走过每层</p><p><img src="image-20240105223017035.png" alt="image-20240105223017035"></p><p>实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BSTNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BSTnode</span>* left;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BSTnode</span>* right;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="function">BSTnode* <span class="title">Search</span><span class="params">(BSTnode* root,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="literal">NULL</span>||root-&gt;key==k) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;root-&gt;key) <span class="keyword">return</span> <span class="built_in">Search</span>(root-&gt;left,k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Search</span>(root-&gt;right,k);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代版本****时间复杂度O(h)  h为树的高度******</span></span><br><span class="line"><span class="function">BSTnode* <span class="title">Search</span><span class="params">(BSTnode* root,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BSTnode* p =root;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;p-&gt;key) p=p-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k&gt;p-&gt;key) p=p-&gt;right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入</strong></p><p><img src="image-20240105223155417.png" alt="image-20240105223155417"></p><p><img src="image-20240105223457083.png" alt="image-20240105223457083"></p><p><img src="image-20240105223523711.png" alt="image-20240105223523711"></p><p><img src="image-20240310174139175.png" alt="image-20240310174139175"></p><p><img src="image-20240310174614936.png" alt="image-20240310174614936"></p><p><strong>实现</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(BSTnode* &amp;root,<span class="type">int</span> k )</span>    <span class="comment">//返回值为空，采用引用的方法进行修改根节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>) root = <span class="keyword">new</span> <span class="built_in">BSTnode</span>(k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&lt;root-&gt;key) <span class="built_in">Insert</span>(root-&gt;left,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&gt;root-&gt;key) <span class="built_in">Insert</span>(root-&gt;right,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BSTnode* <span class="title">Insert</span><span class="params">(BSTnode* root,<span class="type">int</span> k)</span>  <span class="comment">//返回值为指针，采用值传递的方法更改</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>) root = <span class="keyword">new</span> <span class="built_in">BSTnode</span>(k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&lt;root-&gt;key) root-&gt;left = <span class="built_in">Insert</span>(root-&gt;left,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&gt;root-&gt;key)root-&gt;right = <span class="built_in">Insert</span>(root-&gt;right,k);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除</strong></p><p><img src="image-20240105223607737.png" alt="image-20240105223607737"></p><p><img src="image-20240105223651585.png" alt="image-20240105223651585"></p><p><img src="image-20240105223731685.png" alt="image-20240105223731685"></p><p><img src="image-20240105223832556.png" alt="image-20240105223832556"></p><p><img src="image-20240105224144290.png" alt="image-20240105224144290"></p><p><img src="image-20240310185938404.png" alt="image-20240310185938404"></p><p>其实只用分成三类</p><p>没有孩子：不做操作</p><p>有一个孩子：子承父业</p><p>有两个孩子：右子树的中序顺序的第一个（即右子树的最小的一个或者说是k的中序后继）换到k的位置</p><p><strong>算法分析</strong></p><p><img src="image-20240105224222452.png" alt="image-20240105224222452"></p><h3 id="最优二叉查找树">最优二叉查找树</h3><p><img src="image-20240105224454142.png" alt="image-20240105224454142"></p><h3 id="高度平衡树-avl">高度平衡树（AVL）</h3><p>上述所介绍的二叉查找树各个操作的时间复杂度由树的高度决定的，因此我们希望树的高度越低越好，即树矮胖是好的，效率是高的，但达到完全二叉树或者是满二叉树条件较为苛刻，所以我们引入了高度平衡树：</p><p><img src="image-20240106094728254.png" alt="image-20240106094728254"></p><p><img src="image-20240106094807446.png" alt="image-20240106094807446"></p><p><strong>高度的粗略计算</strong></p><p><img src="image-20240310202636483.png" alt="image-20240310202636483"></p><p><img src="image-20240310202742527.png" alt="image-20240310202742527"></p><p><strong>实现</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AVLnode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    AVLnode* left,*right;</span><br><span class="line">    <span class="built_in">AVLnode</span>(<span class="type">int</span> k) &#123;key=k;height=<span class="number">0</span>;left=right=<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Height</span><span class="params">(AVLnode* t )</span></span>&#123;<span class="keyword">return</span> (t==<span class="literal">NULL</span>)? <span class="number">-1</span>:t-&gt;height;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;<span class="keyword">return</span> (a&gt;b)?  a:b;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpdateHeight</span><span class="params">(ALVnode* t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t-&gt;height = <span class="number">1</span>+<span class="built_in">max</span>(<span class="built_in">Height</span>(t-&gt;left),<span class="built_in">Height</span>(t-&gt;right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查找</strong></p><p><strong>与普通的二叉查找树一致</strong></p><p><strong>插入</strong></p><p>为了保持树仍是<strong>高度平衡树</strong>会有以下四种插入情况</p><blockquote><p>LL型(R旋转): 新结点P插到A的左子树的左子树上</p><p>RR型(L旋转): 新结点P插入到A的右子树的右子树上</p><p>LR型(LR旋转): 结点P 插入到A的左子树的右子树上</p><p>RL型(RL旋转): 结点P插入到A的右子树的左子树上</p></blockquote><p><img src="image-20240106095023563.png" alt="image-20240106095023563"></p><p>实现</p><p><img src="image-20240310204430867.png" alt="image-20240310204430867"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LL</span><span class="params">(AVLndoe* &amp;A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AVLnode*B = A-&gt;left;</span><br><span class="line">    A-&gt;left = B-&gt;right;</span><br><span class="line">    <span class="built_in">UpdateHeight</span>(A);</span><br><span class="line">    <span class="built_in">UpdateHright</span>(B);</span><br><span class="line">    A=B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20240106095039512.png" alt="image-20240106095039512"></p><p>实现：<br><img src="image-20240310204602220.png" alt="image-20240310204602220"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RR</span><span class="params">(AVLnode* &amp;A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ALVnode*B = A-&gt;right;</span><br><span class="line">    A-&gt;right=B-&gt;left;</span><br><span class="line">    B-&gt;left = A;</span><br><span class="line">    <span class="built_in">UpdateHeight</span>(A);</span><br><span class="line">    <span class="built_in">UpdateHeight</span>(B);</span><br><span class="line">    A=B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20240106095216226.png" alt="image-20240106095216226"></p><p>实现：</p><p><img src="image-20240310205153288.png" alt="image-20240310205153288"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="image-20240106095504100.png" alt="image-20240106095504100"></p><p><img src="image-20240310205424816.png" alt="image-20240310205424816"></p><p><strong>通过上述四种操作，在插入前后数的高度和平衡性不受影响</strong></p><p><img src="image-20240310210443974.png" alt="image-20240310210443974"></p><p><img src="image-20240310210827325.png" alt="image-20240310210827325"></p><p><strong>删除</strong></p><p><img src="image-20240106095744779.png" alt="image-20240106095744779"></p><p>先采用二叉查找树的删除算法删除，再调整平衡性</p><p><img src="image-20240310211117006.png" alt="image-20240310211117006"></p><p><img src="image-20240310211217942.png" alt="image-20240310211217942"></p><p><img src="image-20240106100430797.png" alt="image-20240106100430797"></p><p><img src="image-20240106100814938.png" alt="image-20240106100814938"></p><h3 id="红黑树">红黑树</h3><p><img src="image-20240310211647955.png" alt="image-20240310211647955"></p><p><img src="image-20240310212033556.png" alt="image-20240310212033556"></p><p><img src="image-20240310212238453.png" alt="image-20240310212238453"></p><p><img src="image-20240310212437504.png" alt="image-20240310212437504"></p><p><img src="image-20240310212659183.png" alt="image-20240310212659183"></p><p><strong>插入</strong></p><p>1.原本为空树，插入后将根涂成黑色，不用做其他操作</p><p>2.插入节点的<strong>父节点是黑色</strong>，插入节点染成红色，不影响红黑树的性质，不用做任何操作</p><p>3.当<strong>父节点为红色，插入节点也为红色</strong>，为满足性质2，在不同的前提条件下要做不同的修改：</p><ul><li>如果<strong>当前节点的叔叔节点是红色</strong>，则父节点和叔叔节点都变为黑色，祖父染成红色</li><li>如果<strong>当前节点的叔叔节点是黑色或者叔叔节点不存在</strong>：则按照路径进行RL LR LL RR 旋转，最后根染成黑色，子节点染成红色。</li></ul><p><img src="image-20240310213236445.png" alt="image-20240310213236445"></p><p><img src="image-20240310213215470.png" alt="image-20240310213215470"></p><p><img src="image-20240310213404065.png" alt="image-20240310213404065"></p><p><img src="image-20240310213524549.png" alt="image-20240310213524549"></p><p><img src="image-20240310213637500.png" alt="image-20240310213637500"></p><p><img src="image-20240310214037548.png" alt="image-20240310214037548"></p><p><img src="image-20240310214405411.png" alt="image-20240310214405411"></p><p><strong>删除：</strong></p><p><img src="image-20240312110640554.png" alt="image-20240312110640554"></p><p>1.<strong>删除含有两个孩子的节点</strong>，可以归结为删除一个孩子的节点或者删除叶子节点（用中根后继的值替换被删除的节点的值，再删除中根后继）。</p><p>2**.删除一个孩子的节点或者是叶子节点**：</p><ul><li><p>​<strong>x为红色</strong>，则一定是叶子节点，直接删除</p></li><li><p>​<strong>x为黑色</strong>，<strong>替换的节点为红色</strong>，用r替换x，并将r染成黑色</p></li><li><p>​x为黑色，r为黑色，即<strong>双黑缺陷</strong>，又可以分为三种情况</p></li></ul><p>​  <img src="image-20240312111328699.png" alt="image-20240312111328699"></p><p><img src="image-20240312111649302.png" alt="image-20240312111649302"></p><p><img src="image-20240312111836712.png" alt="image-20240312111836712"></p><p><img src="image-20240312112005940.png" alt="image-20240312112005940"></p><p><img src="image-20240312112241241.png" alt="image-20240312112241241"></p><p><img src="image-20240312112410625.png" alt="image-20240312112410625"></p><p><img src="image-20240312112539622.png" alt="image-20240312112539622"></p><p><img src="image-20240312112622044.png" alt="image-20240312112622044"></p><p><img src="image-20240312112829179.png" alt="image-20240312112829179"></p><p><img src="image-20240312113017077.png" alt="image-20240312113017077"></p><h3 id="b树及其变形树">B树及其变形树</h3><p><strong>外查找</strong></p><p><img src="image-20240106100852098.png" alt="image-20240106100852098"></p><p>B树</p><p><img src="image-20240106100930019.png" alt="image-20240106100930019"></p><p><img src="image-20240106101133799.png" alt="image-20240106101133799"></p><p><img src="image-20240106101153223.png" alt="image-20240106101153223"></p><p><img src="image-20240106101329481.png" alt="image-20240106101329481"></p><p><img src="image-20240106101651230.png" alt="image-20240106101651230"></p><p><strong>插入</strong></p><p><img src="image-20240106101936483.png" alt="image-20240106101936483"></p><p><strong>删除</strong></p><p><img src="image-20240106103136080.png" alt="image-20240106103136080"></p><p><img src="image-20240106103155393.png" alt="image-20240106103155393"></p><p><img src="image-20240106103307884.png" alt="image-20240106103307884"></p><p><strong>B+树</strong></p><p><img src="image-20240106103352250.png" alt="image-20240106103352250"></p><p><img src="image-20240106103453737.png" alt="image-20240106103453737"></p><p><img src="image-20240106103503815.png" alt="image-20240106103503815"></p><p><img src="image-20240106103529896.png" alt="image-20240106103529896"></p><h3 id="数字查找">数字查找</h3><p><img src="image-20240106104151508.png" alt="image-20240106104151508"></p><p><img src="image-20240106104418518.png" alt="image-20240106104418518"></p><p><img src="image-20240106104511300.png" alt="image-20240106104511300"></p><p><img src="image-20240106104549177.png" alt="image-20240106104549177"></p><h2 id="散列">散列</h2><blockquote><p>前面所介绍的查找方法有两种，一种是<strong>基于表中关键词</strong>与给定 变元K的比较, 另一种是进行<strong>数字的匹配</strong>。这两种方法，在找到以 给定K为关键词的记录之前都要检查若干数目的关键词。</p></blockquote><blockquote><p>但散列方法却几乎完全免去了对表的搜索。以给定变元K为自变 量，通过<strong>某种函数h(K)</strong> 直接计算出函数值，此值被解释为存放以 K为关键词的记录的地址。查找时，用相同方法计算出与给定变 元K对应之记录的存储地址A，进而到A所指的存储单元中取出要 查的记录</p></blockquote><p><img src="image-20240106104706595.png" alt="image-20240106104706595"></p><p><img src="image-20240106104923458.png" alt="image-20240106104923458"></p><p><img src="image-20240106104941486.png" alt="image-20240106104941486"></p><p><img src="image-20240106105012495.png" alt="image-20240106105012495"></p><h3 id="冲突调节">冲突调节</h3><p><strong>拉链法</strong></p><p><img src="image-20240106110042989.png" alt="image-20240106110042989"></p><p><img src="image-20240106110126481.png" alt="image-20240106110126481"></p><p><img src="image-20240106110229273.png" alt="image-20240106110229273"></p><p><img src="image-20240106110252632.png" alt="image-20240106110252632"></p><h3 id="删除"><strong>删除</strong></h3><p><img src="image-20240106111448484.png" alt="image-20240106111448484"></p><p><img src="image-20240106111742833.png" alt="image-20240106111742833"></p><p><img src="image-20240106112145372.png" alt="image-20240106112145372"></p>]]></content>
    
    
    <summary type="html">数据结构笔记</summary>
    
    
    
    <category term="class record" scheme="https://comeupklklkl.gitee.io/jluloser.github.io/categories/class-record/"/>
    
    
    <category term="数据结构" scheme="https://comeupklklkl.gitee.io/jluloser.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Linux课程复习笔记</title>
    <link href="https://comeupklklkl.gitee.io/jluloser.github.io/2023/09/26/Linux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <id>https://comeupklklkl.gitee.io/jluloser.github.io/2023/09/26/Linux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</id>
    <published>2023-09-26T14:30:07.000Z</published>
    <updated>2024-03-18T09:14:07.598Z</updated>
    
    <content type="html"><![CDATA[<p><strong>声明：本篇文章参考和引用了2023下半年吉林大学郭东老师的PPT，如有侵权，请联系我，我将会立马删除</strong></p><h1 id="一-unix操作系统">一、UNIX操作系统</h1><h2 id="1-历史简介">1.历史简介</h2><p>1969年诞生于AT&amp;T贝尔试验室</p><p>开发者是Ken Thompson  和  Dennis Ritchie</p><p>最初使用汇编语言开发，后用C语言重写UNIX源码，UNIX和C完美地结合成一个统一的整体</p><p>UNIX以源代码的形式发行，形成了两个重要的流派:<br>UNIX SYSTEM V （AT&amp;T）和  Berkeley UNIX(UCB)</p><h2 id="2-标准化">2.标准化</h2><p>即对每种实现必须定义的各种限制进行说明</p><p>有两个重要的UNXI标准：</p><ol><li>系统V接口定义 SVID         例如： at&amp;t</li><li>可移植操作系统接口 POSIX  例如：IEEE、 ISO</li></ol><h2 id="3-其他的unix系统">3.其他的UNIX系统</h2><h3 id="1-linux">1&gt; Linux</h3><p>目前应用最为广泛的<strong>类UNIX系统</strong></p><h4 id="背景">背景</h4><h5 id="两个人-：">「两个人」：</h5><p>Richard Stallman和 Linus Torvalds，前者启动GNU项目 创建FSF组织 提出copyleft理念 制订GPL协议 发起开源运动</p><h5 id="四个一-："><strong>「四个一」</strong>：</h5><ul><li>一个项目 GNU</li></ul><p>​        <strong>G</strong>NU’s NOT <strong>U</strong>NIX</p><p>​        <strong>目标</strong>：</p><p>​创建一个自有共享 可以被任何人修改的类UNIX操作系统</p><p>​与UNIX系统兼容</p><p>​不受UNIX名字和源代码私有权限制</p><p>​能运行UNIX程序</p><p>​GNU项目完成了许多UNIX系统上应用程序的仿制品</p><p>​        GNU项目开发的重要软件工具有：</p><p>​ GCC:GNU编译器套件，包括GNU c编译器</p><p>​ G++：C++编译器 是GCC的一部分</p><p>​GDB：源代码级的调试器，支持多种语言</p><p>​GNU make: UNUX make命令的免费版本</p><p>​ bash:  命令解释器（shell）</p><p>​ GNU Emacs :  文本编辑器及环境</p><p>​       <strong>未成功开发操纵系统内核</strong></p><ul><li><p>一个组织 FSF</p><p>自由软件基金会</p><p>目标：<br>执行GNU计划</p><p>​提供技术 法律以及财政支持</p><p>​开发更多的自有软件</p></li><li><p>一个理念 Copy<strong>left</strong></p></li><li><p>一个许可证 GPL</p><p><strong>背景：</strong><br>发行大型软件需要的合适许可协议</p><p>已经有的许可协议：</p><p><img src="image-20231125202333757.png" alt="image-20231125202333757"></p><blockquote><p>Copyright©：版权所有，即软件的一切权利归软件作者私有，用户只有使用权没有其他权利包括复制软件的权利</p></blockquote></li></ul><p>​Richard Stallman提出Copyleft的概念（著<strong>左</strong>权）</p><p><img src="image-20231125202957871.png" alt="image-20231125202957871"></p><blockquote><p>利用现有的著作体制来保护所有用户和二次开发者的自由授权方式</p><p>它赋予所有人运行程序，复制程序，修改程序和发行修改程序的权限，但是使用者不能在修改后的软件上添加限制</p></blockquote><p>​基于copyleft Stallman提出来了GPL许可证，GNU通用的公共许可证</p><blockquote><p>GPL授予程序接受人以下权利，或称“自由”：</p><ul><li>赋予所有人运行程序，复制程序，修改程序和发行修改程序的自有</li><li>重新发行软件的人不能在修改后的软件上添加限制</li></ul></blockquote><p>GNU开发的工具都在GPL下发行</p><p>意义：<br><img src="image-20231125203240445.png" alt="image-20231125203240445"></p><p><strong>其他开源许可证：</strong><br>Apache ,BSD,MIT,Mozilla</p><p><img src="image-20231125203426215.png" alt="image-20231125203426215"></p><h4 id="linux的诞生">Linux的诞生</h4><p>内核在GPL协议下发布，参与了开源运动，Linux内核更新速度极其快</p><p>吉祥物：tux</p><p><img src="image-20231125203724965.png" alt="image-20231125203724965"></p><p>Linux的含义：操作系统内核或者是基于linux内核的操作系统</p><p><strong>Linux操作系统版本：包括内核版本和发行版本</strong></p><p>[内核版本]：有Linux内核社区统一进行发布，包括主版本号 次版本号和修订次数，奇数表示开发版本，偶数表示稳定版本，修订次数标明内核被修改的次数</p><p><img src="image-20231125204046584.png" alt="image-20231125204046584"></p><p>「发行版本」 发行版的名称或版本号是由发行版的维护者决定</p><p><img src="image-20231125204139444.png" alt="image-20231125204139444"></p><p><img src="image-20231125204157090.png" alt="image-20231125204157090"></p><h3 id="2-unix操作系统概要">2&gt; UNIX操作系统概要</h3><p>计算机系统= 硬件+系统软件+应用软件</p><p>UNIX操作系统是包含了文本编辑器 编译器 和其他系统工具程序的程序集</p><p>UNIX操作系统是按照分层软件模型实现的</p><p><img src="image-20231125204400373.png" alt="image-20231125204400373"></p><p>内核：</p><p><img src="image-20231125204440090.png" alt="image-20231125204440090"></p><p><img src="image-20231125204501355.png" alt="image-20231125204501355"></p><p><img src="image-20231125204515488.png" alt="image-20231125204515488"></p><p><img src="image-20231125204551016.png" alt="image-20231125204551016"></p><h5 id="相关概念">「相关概念」</h5><p>虚拟计算机：UNIX向系统中每个用户指定一个执行环境，这个环境称为虚拟计算机，包括一个用户接口终端和共享的其他计算机资源，UNIX是多用户操作系统 虚拟计算机的集合，而从用户视角是独想计算机</p><p>进程：UNUX系统通过进程向用户分配资源</p><h5 id="特征">「特征」</h5><p>可移植性（c语言保证）</p><p>多用户性：多用户同时共同使用计算机，各个用户执行不同的程序，提供安全机制隔离用户</p><p>多任务性：启动一个任务后继续执行其他任务，允许用户在前台和后台多个任务之间进行切换</p><p>分级文件系统：对数据和程序文件进行分组管理，便于查找文件和程序</p><p>与设备独立的输入输出操作：</p><p>用户界面shell：</p><p>​命令解释器： 控制用户与系统的交互，实现用户命令输入与结果输出</p><p>​shell脚本： UNIX Shell是一种成熟的编程语言，Shell 脚本 包含一系列命令， 实现较为复杂 的功能</p><p>系统工具与服务：UNIX系统包括100多个系统工具程序（命令），标准的UNIX系统组成部分完成用户所需要的各种功能</p><h1 id="二-linux入门">二、Linux入门</h1><h2 id="1-登录系统">1.登录系统</h2><h3 id="登录作用">「登录作用」</h3><ol><li>UNIX是一个多用户操作系统。</li><li>用户在使用UNIX系统前必须进行登录</li></ol><h3 id="登录方式">「登录方式」</h3><ol><li>本地登录：在本地输入用户名和密码登录</li><li>远程登录：使用远程登录软件登录 eg: ssh</li></ol><h3 id="命令提示符">「命令提示符」</h3><p>最简单的命令提示符只有一个字符，一般root根用户是#，普通用户是$，用户可以设置提示符，显示丰富系统信息。</p><p><img src="image-20231128105235339.png" alt="image-20231128105235339"></p><p>普通用户</p><h3 id="修改口令">「修改口令」</h3><p><strong>passwd命令</strong>来修改或创建口令</p><p>1.可以修改自己的口令:</p><p><img src="image-20231128105425593.png" alt="image-20231128105425593"></p><p>2.修改别人的口令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd username</span><br></pre></td></tr></table></figure><p>只有root可以</p><p>3.创建口令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd username</span><br></pre></td></tr></table></figure><p>应用场景：root创建普通用户后，为其分配初始口令</p><h3 id="退出系统">「退出系统」</h3><p>用户完成工作后离开系统的过程，退出意味着和系统断开连接结束对话</p><p>三种方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br><span class="line">[Ctrl-d]</span><br><span class="line"><span class="built_in">logout</span></span><br></pre></td></tr></table></figure><p>logout需要在登录shell中</p><h2 id="2-命令">2.命令</h2><ul><li>UNIX系统有几百条命令/系统工具</li><li>绝大多数命令格式相同</li><li>大部分UNIX提供在线帮助 help man info</li><li>通过输入命令告诉系统要做什么事</li><li>命令行中回车键解释为命令行的结束符</li></ul><p>例子：<br><img src="image-20231128110218045.png" alt="image-20231128110218045"></p><h3 id="命令格式">「命令格式」</h3><h4 id="基本格式">基本格式</h4><p><img src="image-20231128110252691.png" alt="image-20231128110252691"></p><p><img src="image-20231128110324019.png" alt="image-20231128110324019"></p><p>命令本身  和   命令+选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#命令+选项</span></span><br><span class="line"><span class="built_in">ls</span> -a     <span class="comment">#显示目录中的隐藏文件</span></span><br><span class="line"><span class="built_in">ls</span> -a -l  <span class="comment">#将隐含的文件用长格式形式显示</span></span><br><span class="line"><span class="built_in">ls</span> -la    <span class="comment">#作用同上，写法不同</span></span><br><span class="line"><span class="comment">#命令+参数</span></span><br><span class="line"><span class="built_in">ls</span> /home  <span class="comment">#显示指定目录的文件 </span></span><br><span class="line"><span class="comment">#命令+选项+参数</span></span><br><span class="line"><span class="built_in">ls</span> -a /home  <span class="comment">#命令+选项+参数</span></span><br></pre></td></tr></table></figure><p><img src="image-20231128110819617.png" alt="image-20231128110819617"></p><p><img src="image-20231128111034774.png" alt="image-20231128111034774"></p><h4 id="不同流派">不同流派</h4><p><img src="image-20231128111303688.png" alt="image-20231128111303688"></p><p><img src="image-20231128111426160.png" alt="image-20231128111426160"></p><p><img src="image-20231128111413828.png" alt="image-20231128111413828"></p><p><img src="image-20231128111346324.png" alt="image-20231128111346324"></p><p><img src="image-20231128111534508.png" alt="image-20231128111534508"></p><h3 id="日期和时间的显示">「日期和时间的显示」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span></span><br></pre></td></tr></table></figure><p><img src="image-20231128111633306.png" alt="image-20231128111633306"></p><p><strong>UNIX使用24小时制</strong></p><h3 id="用户信息">「用户信息」</h3><p><strong>who命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">who</span></span><br></pre></td></tr></table></figure><p><img src="image-20231128111741085.png" alt="image-20231128111741085"></p><p>第一列：登录用户名，登录用户名</p><p>第二列：登录终端号，登录到哪里</p><p>第三列：登录时间</p><p>第四列：登录主机，从哪里登录的</p><h3 id="终端">「终端」</h3><p><strong>物理终端</strong>：一套输入输出设备，用于用户登录和使用计算机，如连接在计算机上的显示器，鼠标，键盘与名词主机对应</p><p><strong>虚拟终端</strong>（tty）</p><p><strong>本地</strong>的linux系统提供的，例如虚拟机或者是linux系统服务器之类的，</p><p><img src="image-20231128112152987.png" alt="image-20231128112152987"></p><p><img src="image-20231128112440981.png" alt="image-20231128112440981"></p><p><img src="image-20231128142651757.png" alt="虚拟机登录"></p><p>使用虚拟机登录终端为tty</p><p><img src="capture_20231128142808500.bmp" alt="capture_20231128142808500"></p><p>对于Ununtu图形化界面</p><p><img src="image-20231128151721044.png" alt="image-20231128151721044"></p><p><strong>伪终端</strong>（pty）</p><p>由<strong>远程登录软件或终端模拟软件</strong>模拟出的终端</p><p><img src="image-20231128141759139.png" alt="image-20231128141759139"></p><p><img src="image-20231128141823390.png" alt="image-20231128141823390"></p><p><img src="image-20231128142451870.png" alt="手机软件远程登录"></p><h3 id="常用其他命令">「常用其他命令」</h3><h4 id="who-am-i和whoami命令">who am i和whoami命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">who</span> am i</span><br><span class="line"><span class="built_in">who</span> am I</span><br></pre></td></tr></table></figure><p>显示终端上登录的用户信息</p><p><img src="image-20231128152126549.png" alt="image-20231128152126549"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">whoami</span></span><br></pre></td></tr></table></figure><p>显示用户名</p><p><img src="image-20231128153157246.png" alt="image-20231128153157246"></p><h4 id="显示日历-cal命令">显示日历 cal命令</h4><p>默认显示当月日历</p><p><img src="image-20231128152807363.png" alt="image-20231128152807363"></p><p>参数中可以指定年和月，显示指定年月的日历表</p><h4 id="help命令-man命令-info命令">help命令 man命令 info命令</h4><p>「内部命令」 shell代码中的一部分，shell启动后驻留内存，执行速度快</p><p>「外部命令」保存在文件系统中的程序，被调用时才载入内存执行</p><p><img src="image-20231128154054687.png" alt="image-20231128154054687"></p><p><img src="image-20231128154113516.png" alt="image-20231128154113516"></p><p><img src="image-20231128154124919.png" alt="image-20231128154124919"></p><p><img src="image-20231128154138497.png" alt="image-20231128154138497"></p><p><img src="image-20231128154231499.png" alt="image-20231128154231499"></p><h4 id="last命令">last命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">last</span><br></pre></td></tr></table></figure><p>它用来展示关于系统用户最后登录会话的信息</p><p><img src="capture_20231128153410861.bmp" alt="capture_20231128153410861"></p><blockquote><p>输出的每一行从左到右包含的列分别是：</p><ul><li>用户名。 当系统重启或者关闭时，<code>last</code>显示指定用户为<code>reboot</code>或者<code>shutdown</code>。</li><li>会话占用的 tty。<code>:0</code>通常意味着用户登录了一个桌面环境</li><li>IP 地址或者用户登录的主机名</li><li>会话开始时间和停止时间</li><li>会话时长。如果会话仍然是激活的，或者用户没有登出，last 将会显示信息，而不是时长</li></ul></blockquote><h4 id="history">history</h4><p>显示输入的所有命令记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span></span><br></pre></td></tr></table></figure><p><img src="image-20231128153900626.png" alt="image-20231128153900626"></p><h3 id="命令行快捷键与命令补齐">「命令行快捷键与命令补齐」</h3><p><img src="image-20231128154332308.png" alt="image-20231128154332308"></p><h2 id="3-shell">3.shell</h2><p><img src="image-20231128154719823.png" alt="image-20231128154719823"></p><p><img src="image-20231128154736510.png" alt="image-20231128154736510"></p><p><img src="image-20231129211049340.png" alt="image-20231129211049340"></p><p><img src="image-20231129211156849.png" alt="image-20231129211156849"></p><p><img src="image-20231129211302220.png" alt="image-20231129211302220"></p><h2 id="4-软件的安装与卸载">4.软件的安装与卸载</h2><h4 id="安装软件">「安装软件」</h4><p><strong>1.两种方法</strong></p><ul><li><p>下载软件源代码后编译安装</p></li><li><p>基于网络存储库安装/更新软件</p><p>两种基于网络存储库的软件安装方法：</p><p>1.yum后继为dnf     eg：Redhat OpenEluer</p><p>2.apt                       eg:Ubuntu  Debian</p></li></ul><p><strong>2.使用yum（dnf）安装软件包</strong></p><p><img src="image-20231129211838221.png" alt="image-20231129211838221"></p><blockquote><p>软件包集合：服务于一个共同的目的一组软件包，例如系统工具集等</p></blockquote><p><strong>使用dnf可以对软件包组进行安装和删除等操作，使相关操作更高效</strong></p><p><img src="image-20231129212018114.png" alt="image-20231129212018114"></p><h2 id="5-登录过程">5.登录过程</h2><h3 id="启动过程">启动过程</h3><p><strong>操作系统常驻部分载入内存</strong>其余部分保留在磁盘上，用户请求时候再载入内存，用户登录时 shell程序载入内存。</p><p><strong>[init进程]</strong>：UNIX系统所有进程的祖先进程，启动所有系统服务和后台进程，系统启动后init创建虚拟终端为用户登录做准备</p><h1 id="三-vi编辑器">三、vi编辑器</h1><blockquote><p>工具软件，文本编辑器，用于创建新文件或修改旧文本文件，编辑对象是文本文件，相对简化的字处理器</p></blockquote><p><img src="image-20231129213205077.png" alt="image-20231129213205077"></p><h3 id="1-工作模式">1.工作模式</h3><h4 id="命令模式">「命令模式」</h4><p>启动后默认进入，所有的输入都被看作命令，不显示，被执行，通过按键删除字 行 段落，移动光标或者执行其他操作</p><h4 id="末行模式">「末行模式」</h4><p>按下冒号，在最后一行输入命令，回车结束命令</p><h4 id="文本输入模式">「文本输入模式」</h4><p>键盘输入文本字符，屏幕显示用户输入</p><h4 id="模式切换">「模式切换」</h4><p><img src="image-20231129213525501.png" alt="image-20231129213525501"></p><p><strong>注意大小写和英文字符</strong></p><h3 id="2-基本操作">2.基本操作</h3><h3 id="打开或创建文件">「打开或创建文件」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi     <span class="comment">#在当前工作目录新建一个文件并打开</span></span><br><span class="line"></span><br><span class="line">vi myfirst <span class="comment">#存在myfirst文件则为打开文件，不存在则新建并打开</span></span><br></pre></td></tr></table></figure><p><img src="image-20231129213840486.png" alt="image-20231129213840486"></p><p><img src="image-20231129213850965.png" alt="image-20231129213850965"></p><h3 id="编辑文件">「编辑文件」</h3><ul><li>按下小写字母 i 进入文本输入模式</li><li>通过键盘进行输入文本</li><li>按下 BackSpace或者Ctrl+h删除字符</li><li>每行结束后按Enter进入下一行</li></ul><h3 id="保存文件与退出">「保存文件与退出」</h3><p>按下ESC退出文本编辑模式进入命令模式，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:wq</span><br><span class="line">:x</span><br><span class="line">ZZ</span><br></pre></td></tr></table></figure><p>上述三种的其中一种，按下回车即为保存并退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:q</span><br></pre></td></tr></table></figure><p>若文件没被修改即为退出，已经被修改未保存则无法退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:q!</span><br></pre></td></tr></table></figure><p>不保存文件直接退出</p><h3 id="存储缓冲区">「存储缓冲区」</h3><p><img src="image-20231129214521276.png" alt="image-20231129214521276"></p><h3 id="光标的移动">「光标的移动」</h3><p><strong>命令模式下</strong></p><p><img src="image-20231129214614398.png" alt="image-20231129214614398"></p><p><strong>命令模式进入文本输入模式不同的命令键有不同的效果：</strong></p><p><img src="image-20231129214707433.png" alt="image-20231129214707433"></p><p><strong>光标移动键(命令模式)</strong></p><p><img src="image-20231129215354489.png" alt="image-20231129215354489"></p><p><strong>精准定位</strong></p><p>命令模式：</p><p><img src="image-20231129215414056.png" alt="image-20231129215414056"></p><p>末行模式：</p><p><img src="image-20231129215526241.png" alt="image-20231129215526241"></p><p><strong>翻页：</strong></p><p><img src="image-20231129215624206.png" alt="image-20231129215624206"></p><p><strong>文件修改：</strong></p><p>命令模式下：</p><p><img src="image-20231130144409680.png" alt="image-20231130144409680"></p><p>删除字符：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除单个字符</span></span><br><span class="line">x</span><br><span class="line"><span class="comment">#数字n+x删除n个字符</span></span><br><span class="line">2x</span><br><span class="line"><span class="comment">#撤销当前行的修改</span></span><br><span class="line">U</span><br><span class="line"><span class="comment">#撤销最近的修改</span></span><br><span class="line">u</span><br></pre></td></tr></table></figure><p>删除行和单词</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除光标所在行</span></span><br><span class="line"><span class="built_in">dd</span></span><br><span class="line"><span class="comment">#数字n+dd删除n行</span></span><br><span class="line">2dd<span class="comment">#删除两行</span></span><br><span class="line"><span class="comment">#删除光标所在单词</span></span><br><span class="line">dw</span><br></pre></td></tr></table></figure><p>重复上一次操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.</span><br></pre></td></tr></table></figure><p>替换字符</p><p><img src="image-20231130145148593.png" alt="image-20231130145148593"></p><p>载入文本</p><p>从其他文件中载入文本内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:r 文件名</span><br><span class="line"><span class="comment">#指定文本副本插入当前文件光标的下一行</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:a,b w file</span><br><span class="line">#把文件的a到b行写到file中</span><br></pre></td></tr></table></figure><p><strong>文件重排：</strong></p><p><img src="image-20231130150229039.png" alt="image-20231130150229039"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#复制当前行</span></span><br><span class="line">yy</span><br><span class="line"><span class="comment">#删除当前行</span></span><br><span class="line"><span class="built_in">dd</span></span><br></pre></td></tr></table></figure><p>使用<strong>操作符和域控制键</strong>修改/重排文本</p><p><img src="image-20231130152354930.png" alt="image-20231130152354930"></p><h3 id="3-定制vi">3.定制vi</h3><p><img src="image-20231130152759807.png" alt="image-20231130152759807"></p><h3 id="选项格式">「选项格式」</h3><p><img src="image-20231130152856213.png" alt="image-20231130152856213"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#只显示修改过的选项</span></span><br><span class="line">:<span class="built_in">set</span></span><br><span class="line"><span class="comment">#显示X的值</span></span><br><span class="line">:<span class="built_in">set</span> X?</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#显示行号</span></span><br><span class="line">:<span class="built_in">set</span> nu</span><br><span class="line"><span class="comment">#取消显示行号</span></span><br><span class="line">:<span class="built_in">set</span> nonu</span><br></pre></td></tr></table></figure><h3 id="vim配置文件">「vim配置文件」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/.exrc</span><br><span class="line">~/.vimrc</span><br></pre></td></tr></table></figure><p>vi编辑器中使用命令设置的所有选项都是临时的，退出vi就会失效</p><p>在用户主目录创建 ~/.exrc 或 ~/.vimrc 配置文件，设置选项后，可使每次启动时选项保持不变</p><h3 id="4-搜索替换与命令执行">4.搜索替换与命令执行</h3><h4 id="搜索">「搜索」</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#命令模式下输入</span></span><br><span class="line">/+要搜索的字符即为从光标所在的位置查找字符</span><br><span class="line"><span class="comment">#例如：</span></span><br><span class="line">/A</span><br></pre></td></tr></table></figure><p><strong>按下N是下一个匹配与命令搜索方向相反，按下n为下一个匹配，与命令搜索方向相同</strong></p><h4 id="搜索并替换">「搜索并替换」</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:「行范围」 s/被替换单词/新单词/[g]</span><br><span class="line"><span class="comment">#g是全行替换，行范围默认为当前行</span></span><br></pre></td></tr></table></figure><p><img src="image-20231202185736902.png" alt="image-20231202185736902"></p><h4 id="运行shell命令">「运行shell命令」</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#: ! command</span></span><br><span class="line">: ! <span class="built_in">date</span></span><br><span class="line"><span class="comment">#将命令执行结果加到文本中：</span></span><br><span class="line">:r! <span class="built_in">command</span></span><br></pre></td></tr></table></figure><h1 id="四-linux文件系统">四、Linux文件系统</h1><h2 id="1-磁盘组织">1.磁盘组织</h2><blockquote><p>目录：Linux文件系统的组织单元</p></blockquote><p>Linux文件系统通过目录对文件进行组织管理，</p><h2 id="2-文件类型">2.文件类型</h2><p>UNIX文件视角：</p><ul><li>文件是字节序列，一切都是文件</li><li>文件可以分为，普通文件、目录文件、特殊文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看文件类型</span></span><br><span class="line">file 文件名</span><br></pre></td></tr></table></figure><p><img src="image-20231202191624635.png" alt="image-20231202191624635"></p><p><img src="image-20231202191641349.png" alt="image-20231202191641349"></p><h2 id="3-目录详述">3.目录详述</h2><p><strong>目录结构以层次结构进行组织</strong></p><p><img src="image-20231202191741582.png" alt="image-20231202191741582"></p><blockquote><p>父子关系：相邻两层目录间的关系</p><p>上层目录是下层目录的父目录，下层目录是上层目录的子目录</p></blockquote><p><img src="image-20231202191842230.png" alt="image-20231202191842230"></p><blockquote><p>重要目录：Linux系统的标准目录</p></blockquote><p><img src="image-20231202192035623.png" alt="image-20231202192035623"></p><h3 id="重要目录作用"><strong>「重要目录作用」</strong></h3><p><img src="image-20231202192347215.png" alt="image-20231202192347215"></p><p><img src="image-20231202192539500.png" alt="image-20231202192539500"></p><p><img src="image-20231202192558821.png" alt="image-20231202192558821"></p><p><img src="image-20231202192723221.png" alt="image-20231202192723221"></p><h3 id="主目录"><strong>「主目录」</strong></h3><blockquote><p>主目录：管理员在创建用户的时候为其分配的特定目录</p></blockquote><ul><li>用户登录时，自动进入主目录</li><li>用户在其主目录拥有读、写和执行权限</li><li>用户在其主目录可以创建任意多的子目录</li><li>主目录名字通常和用户名相同</li></ul><h3 id="工作目录">「工作目录」</h3><blockquote><p>工作目录：用户先在在文件系统中的目录</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br><span class="line"><span class="comment">#查看目前的工作目录</span></span><br></pre></td></tr></table></figure><h3 id="路径">「路径」</h3><blockquote><p>路径：文件在文件系统中的位置描述方式</p></blockquote><p><strong>路径名用来定义文件。</strong></p><blockquote><p>绝对路径：从根目录开始到文件的路径</p></blockquote><p><img src="image-20231202193349892.png" alt="image-20231202193349892"></p><blockquote><p>相对路径：从当前目录开始到达文件的路径</p></blockquote><p><img src="image-20231202193359114.png" alt="image-20231202193359114"></p><h3 id="特殊符号"><strong>「特殊符号」</strong></h3><p><strong>点（.）：表示当前目录</strong></p><p><strong>点点（…）：表示当前目录的父目录</strong></p><h3 id="命名约束">「命名约束」</h3><p>文件和目录如何命名。</p><p><img src="image-20231202193529448.png" alt="image-20231202193529448"></p><h2 id="4-目录操作命令">4.目录操作命令</h2><h3 id="cd命令">「cd命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> [目录名]</span><br><span class="line"><span class="comment">#改变工作目录</span></span><br></pre></td></tr></table></figure><p><img src="image-20231202193744996.png" alt="image-20231202193744996"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span></span><br><span class="line"><span class="comment">#返回用户主目录</span></span><br><span class="line"><span class="built_in">cd</span> .</span><br><span class="line"><span class="comment">#进入当前目录</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="comment">#进入上一级目录</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="comment">#进入当前用户的主目录</span></span><br><span class="line"><span class="built_in">cd</span> ~tux</span><br><span class="line"><span class="comment">#进入tux主目录，前提是你有权限进入</span></span><br></pre></td></tr></table></figure><h3 id="mkdir命令">「mkdir命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> 目录名</span><br><span class="line"><span class="comment">#创建目录</span></span><br><span class="line"><span class="built_in">mkdir</span> 目录名1 目录名2 目录名3</span><br><span class="line"><span class="comment">#创建多个目录</span></span><br></pre></td></tr></table></figure><p><img src="image-20231202194116992.png" alt="image-20231202194116992"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一次创建多层目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p xx/yy/zz</span><br></pre></td></tr></table></figure><h3 id="rmdir命令">「rmdir命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除目录，只能删除空目录，即目录中只含有.和..</span></span><br><span class="line"><span class="built_in">rmdir</span> 「目录名」</span><br></pre></td></tr></table></figure><h3 id="ls命令">「ls命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#显示指定目录内容</span></span><br><span class="line"><span class="built_in">ls</span> 「目录名」</span><br></pre></td></tr></table></figure><p><img src="image-20231202194341628.png" alt="image-20231202194341628"></p><p><strong>选项 -l：</strong></p><p><img src="image-20231202194434138.png" alt="image-20231202194434138"></p><p><img src="image-20231202194520579.png" alt="image-20231202194520579"></p><p>第二列：文件的链接数</p><p>第三列：文件的所有者，通常与文件创建者用户名相同，文件的所有者发生转移，则两者不同</p><p>第四列：文件所属的组，管理员创建用户时，指定用户隶属于某个组，用户创建文件时，文件属于用户默认隶属的组</p><p>第五列：文件大小，单位字节</p><p>第六列：文件上一次修改的日期和时间</p><p>第七列：文件的名称</p><p><strong>选项 -a：</strong><br>查看隐藏文件</p><p><img src="image-20231202194822252.png" alt="image-20231202194822252"></p><h3 id="cat命令">「cat命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#显示一个或多个文件的内容</span></span><br><span class="line"><span class="built_in">cat</span> 文件名1 文件名2 </span><br></pre></td></tr></table></figure><p><img src="image-20231202194922602.png" alt="image-20231202194922602"></p><h3 id="rm命令">「rm命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除文件</span></span><br><span class="line"><span class="built_in">rm</span> 文件名</span><br></pre></td></tr></table></figure><p><img src="image-20231202194955122.png" alt="image-20231202194955122"></p><p><img src="image-20231202195022506.png" alt="image-20231202195022506"></p><h1 id="五-unix文件系统高级操作">五、UNIX文件系统高级操作</h1><h2 id="1-shell重定向">1.shell重定向</h2><p><img src="image-20231202195437195.png" alt="image-20231202195437195"></p><h3 id="输出重定向">「输出重定向」</h3><p>输出重定向允许用户将命令（进程）的输出保存到文件中</p><p>shell使用&gt;和&gt;&gt;作为输出重定向操作符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> &gt; filename <span class="comment">#覆盖重定向</span></span><br><span class="line"><span class="built_in">command</span> &gt;&gt; filename  <span class="comment">#追加重定向</span></span><br></pre></td></tr></table></figure><p><img src="image-20231202200457240.png" alt="image-20231202200457240"></p><h3 id="输入重定向">「输入重定向」</h3><p>输入重定向允许用户从指定文件得到输入来运行命令</p><p><img src="image-20231202200542587.png" alt="image-20231202200542587"></p><p><strong>shell使用&lt;和 &lt;&lt;作为输出重定向操作符</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">comand &lt; filename <span class="comment">#命令行中使用</span></span><br><span class="line"><span class="built_in">command</span> &lt;&lt; 分界符<span class="comment">#脚本编程中使用</span></span><br></pre></td></tr></table></figure><h2 id="2-文件操作命令">2.文件操作命令</h2><h3 id="cat命令">「cat命令」</h3><p><img src="image-20231202200855618.png" alt="image-20231202200855618"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> filename <span class="comment">#命令参数</span></span><br><span class="line"><span class="built_in">cat</span> &lt; filename <span class="comment">#输入重定向</span></span><br></pre></td></tr></table></figure><p><img src="image-20231202200950422.png" alt="image-20231202200950422"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; filename <span class="comment">#使用cat和输出重定向可以创建文件</span></span><br></pre></td></tr></table></figure><p><img src="image-20231202201039530.png" alt="image-20231202201039530"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt;&gt; filename <span class="comment"># 若文件不存在则会创建文件并将键盘输入内容输入到文件中，如存在则追加输入</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> filename &gt; filename.copy <span class="comment">#复制文件</span></span><br><span class="line"><span class="built_in">cat</span> filename1 filename2 &gt; filename.copy <span class="comment">#复制多个到一个</span></span><br></pre></td></tr></table></figure><p><img src="image-20231202201447583.png" alt="image-20231202201447583"></p><h3 id="cp命令">「cp命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> 文件名1 文件名2 <span class="comment">#创建文件副本</span></span><br><span class="line"><span class="built_in">cp</span>  filename1 filename2 目录名 <span class="comment">#将一个或多个文件复制到指定目录</span></span><br></pre></td></tr></table></figure><p><img src="image-20231202201742015.png" alt="image-20231202201742015"></p><p><img src="image-20231202201803414.png" alt="image-20231202201803414"></p><p><img src="image-20231202201823928.png" alt="image-20231202201823928"></p><p><strong>命令选项：</strong></p><blockquote><p><strong>-i</strong>：如果目标文件已经存在要求确认</p></blockquote><p><img src="image-20231202201932935.png" alt="image-20231202201932935"></p><blockquote><p><strong>-r</strong>：将目录复制到新的目录</p></blockquote><p><img src="image-20231202202013511.png" alt="image-20231202202013511"></p><h3 id="mv命令">「mv命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> 文件名（s） 目录 <span class="comment">#将文件移到其他目录（非文件所在目录）</span></span><br><span class="line"><span class="built_in">mv</span> 文件名1 文件名2 <span class="comment">#移动并改变文件名 </span></span><br></pre></td></tr></table></figure><p><img src="image-20231202204134259.png" alt="image-20231202204134259"></p><p><img src="image-20231202204154232.png" alt="image-20231202204154232"></p><p><img src="image-20231202204205615.png" alt="image-20231202204205615"></p><p><strong>命令选项：</strong></p><blockquote><p><strong>-i</strong> ：如果目标文件已经存在要求确认</p></blockquote><p><img src="image-20231202204258626.png" alt="image-20231202204258626"></p><h3 id="ln-命令">「ln 命令」</h3><p><strong>在已存在和新文件名之间创建链接，为已存在的文件起新名字，使用不同的名字引用同一文件</strong></p><ul><li>在不同目录中频繁操作同一文件</li><li>在每个目录中建立该文件的链接文件，通过链接文件对原文件进行操作</li><li>链接文件不占用过多的磁盘空间</li></ul><p>涉及文件存储的三个部分</p><p><img src="image-20231202204606759.png" alt="image-20231202204606759"></p><p><img src="image-20231203102033260.png" alt="image-20231203102033260"></p><p><img src="image-20231203102140610.png" alt="image-20231203102140610"></p><p>「wc命令」</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#计算一个或者多个文件的行数、字数和字符数</span></span><br><span class="line"><span class="built_in">wc</span> [文件名]</span><br><span class="line"><span class="comment">#无参数默认键盘输入</span></span><br><span class="line"><span class="built_in">wc</span></span><br><span class="line"><span class="comment">#统计多个文件</span></span><br><span class="line"><span class="built_in">wc</span> [文件名] [文件名]</span><br></pre></td></tr></table></figure><p><img src="image-20231203102458849.png" alt="image-20231203102458849"></p><p>选项：</p><blockquote><p>-l  ：统计行数</p><p>-c：统计字符数</p><p>-w：统计字数</p></blockquote><p><img src="image-20231203102721023.png" alt="image-20231203102721023"></p><p><img src="image-20231203102735066.png" alt="image-20231203102735066"></p><h2 id="3-文件名替换">3.文件名替换</h2><p><img src="image-20231203103037503.png" alt="image-20231203103037503"></p><p>「?通配符」</p><blockquote><p>代表单个字符,不可为空</p></blockquote><p><img src="image-20231203103420980.png" alt="image-20231203103420980"></p><p>「*通配符」</p><blockquote><p>文件名中的任意个字符（包括0个）</p></blockquote><p><img src="image-20231203103547461.png" alt="image-20231203103547461"></p><p><img src="image-20231203103559206.png" alt="image-20231203103559206"></p><p>「[] 通配符」</p><blockquote><p>包含括号中指定的任一<strong>字符</strong></p></blockquote><p><img src="image-20231203103837817.png" alt="image-20231203103837817"></p><p><img src="image-20231203103924092.png" alt="image-20231203103924092"></p><h2 id="4-其它文件操作命令">4.其它文件操作命令</h2><h3 id="find命令">「find命令」</h3><blockquote><p>在多层目录中搜索指定文件，快速查看文件指定部分</p></blockquote><p><img src="image-20231203104202314.png" alt="image-20231203104202314"></p><p><img src="image-20231203104329792.png" alt="image-20231203104329792"></p><p>搜索选项：</p><p><img src="image-20231203104352656.png" alt="image-20231203104352656"></p><blockquote><p>-name  :  通过文件名查找文件</p></blockquote><p><img src="image-20231203104459455.png" alt="image-20231203104459455"></p><blockquote><p>-type: 通过文件类型查找文件</p></blockquote><p><img src="image-20231203104629325.png" alt="image-20231203104629325"></p><p>动作选项：</p><p><img src="image-20231203104715277.png" alt="image-20231203104715277"></p><blockquote><p>-exec:用户给出命令，对找到的文件进行操作</p></blockquote><p><img src="image-20231203104903043.png" alt="image-20231203104903043"></p><blockquote><p>-ok:用户执行命令前需要确认</p></blockquote><p><img src="image-20231203105155036.png" alt="image-20231203105155036"></p><h3 id="head命令">「head命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#显示文件头部若干行</span></span><br><span class="line"><span class="built_in">head</span> [filenames]  <span class="comment">#默认显示前10行</span></span><br></pre></td></tr></table></figure><blockquote><p>-n： 显示文件前n行</p></blockquote><p><img src="image-20231204090519119.png" alt="image-20231204090519119"></p><h3 id="tail命令">「tail命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#显示文件尾部若干行</span></span><br><span class="line"><span class="built_in">tail</span> [filenames] <span class="comment">#默认后10行</span></span><br></pre></td></tr></table></figure><blockquote><p>-n ： 显示文件后n行</p></blockquote><p><img src="image-20231204090715118.png" alt="image-20231204090715118"></p><h3 id="cut命令">「cut命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从文件中取出指定域或列</span></span><br><span class="line"><span class="built_in">cut</span> 选项 文件名</span><br></pre></td></tr></table></figure><blockquote><p>-f : 指定域位置 ，1，3，5       1-3，5</p></blockquote><p><img src="image-20231204091146132.png" alt="image-20231204091146132"></p><p><img src="image-20231204091217513.png" alt="image-20231204091217513"></p><blockquote><p>-c ：指定字符的位置</p></blockquote><p><img src="image-20231204091313084.png" alt="image-20231204091313084"></p><blockquote><p>-d  ：指定域分隔字符</p></blockquote><p><img src="image-20231204091403924.png" alt="image-20231204091403924"></p><h3 id="paste命令">「paste命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逐行连接两个或多个文件</span></span><br><span class="line"><span class="built_in">paste</span> file1 file2+（s）</span><br></pre></td></tr></table></figure><blockquote><p>-d：指定具体分隔符，默认为制表符</p></blockquote><p><img src="image-20231204091627160.png" alt="image-20231204091627160"></p><p><img src="image-20231204091647719.png" alt="image-20231204091647719"></p><h3 id="more命令">「more命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#另页查看工具</span></span><br><span class="line">more filename</span><br></pre></td></tr></table></figure><blockquote><p>-lines:每屏显示的行数</p><p>+line-number:从第line-number 行开始显示</p><p>+/pattern  : 从包含pattern的行的上两行开始显示</p><p>-c:在显示每页之前清屏</p><p>-d:显示提示[Press space to continue, ‘q’ to quit]</p></blockquote><p><img src="image-20231204091933287.png" alt="image-20231204091933287"></p><h3 id="less命令">「less命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#分页查看工具，允许在文件中向后和向前移动</span></span><br><span class="line">less filename</span><br></pre></td></tr></table></figure><p>基于more 和 vi 更高级的工具</p><h2 id="5-unix-内部：文件系统">5.UNIX 内部：文件系统</h2><p><img src="image-20231204092210032.png" alt="image-20231204092210032"></p><p><img src="image-20231204092224326.png" alt="image-20231204092224326"></p><p><img src="image-20231204092310347.png" alt="image-20231204092310347"></p><h1 id="六-探索shell">六、探索shell</h1><h2 id="1-启动shell">1.启动shell</h2><p>用户成功登录系统，shell启动，用户退出，shell进程结束</p><p>系统中每个用户都有一个默认的shell，在系统口令文件/etc/passwd指定</p><p><img src="image-20231204093910980.png" alt="image-20231204093910980"></p><p><img src="image-20231204093928448.png" alt="image-20231204093928448"></p><p><img src="image-20231204094005033.png" alt="image-20231204094005033"></p><h2 id="2-shell的主要功能">2.shell的主要功能</h2><p><img src="image-20231204094146647.png" alt="image-20231204094146647"></p><p><img src="image-20231204094215586.png" alt="image-20231204094215586"></p><h3 id="正则表达式">「正则表达式」</h3><p><img src="image-20231204133415834.png" alt="image-20231204133415834"></p><p><img src="image-20231204133446879.png" alt="image-20231204133446879"></p><p><img src="image-20231204133543972.png" alt="image-20231204133543972"></p><p>例子：</p><p><img src="image-20231204133732850.png" alt="image-20231204133732850"></p><p><strong>POSIX标准正则表达式：</strong></p><p><img src="image-20231204133904964.png" alt="image-20231204133904964"></p><p><strong>扩展正则表达式：仅在部分程序中支持，例如 egrep、awk 等</strong></p><p><img src="image-20231204134201536.png" alt="image-20231204134201536"></p><p>例子：</p><p><img src="image-20231204134254841.png" alt="image-20231204134254841"></p><p><strong>正则表达式与通配符区别：</strong><br><img src="image-20231204134330146.png" alt="image-20231204134330146"></p><h3 id="echo命令">「echo命令」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将消息参数显示在用户终端上，没有参数输出空行</span></span><br><span class="line"><span class="built_in">echo</span> message</span><br></pre></td></tr></table></figure><p><img src="image-20231204094319850.png" alt="image-20231204094319850"></p><blockquote><p>-n ：禁止换行，输出后不换行</p></blockquote><p><img src="image-20231204135140526.png" alt="image-20231204135140526"></p><blockquote><p>-e ：解释反斜杠引导的转义字符（用于控制消息格式的字符，字符串的一部分，以\开始由shell解释为用户想要得到的输出）</p></blockquote><p><img src="image-20231204094459579.png" alt="image-20231204094459579"></p><p><img src="image-20231204133102241.png" alt="image-20231204133102241"></p><p><img src="image-20231204133128633.png" alt="image-20231204133128633"></p><p><img src="image-20231204135012223.png" alt="image-20231204135012223"></p><p><img src="image-20231204133213407.png" alt="image-20231204133213407"></p><h3 id="消除元字符的特殊含义">「消除元字符的特殊含义」</h3><blockquote><p>元字符：shell中具有特殊含义和用途的字符，在shell中出现时不代表字面含义</p></blockquote><p>如：<br><img src="image-20231204135653676.png" alt="image-20231204135653676"></p><p>消除元字符特殊含义的<strong>元字符</strong>：</p><p><img src="image-20231204135735214.png" alt="image-20231204135735214"></p><blockquote><p>\ :后面的元字符按照字符的字面量解释</p></blockquote><blockquote><p>&quot;  &quot; ： 取消除$、`、\外元字符的特殊含义。双引号中保留空白字符（空格、制表和换行符等）</p></blockquote><p><img src="image-20231204140215379.png" alt="image-20231204140215379"></p><blockquote><p>’ ’ ： 单引号中任何字符都失去特殊含义，单引号中保留空白字符（空格、制表和换行符等）</p></blockquote><p><img src="image-20231204140531736.png" alt="image-20231204140531736"></p><h2 id="3-shell变量">3.shell变量</h2><blockquote><ul><li>shell为响应用户请求，保存一些信息到shell变量中</li><li>变量有名称，可以通过赋值来控制或定制系统环境</li></ul></blockquote><p><img src="image-20231204140700159.png" alt="image-20231204140700159"></p><h3 id="显示和清除变量：set和unset">「显示和清除变量：set和unset」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看当前使用的shell变量（环境变量和局部变量）</span></span><br><span class="line"><span class="built_in">set</span></span><br></pre></td></tr></table></figure><p><img src="image-20231204140851846.png" alt="image-20231204140851846"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除不需要的变量</span></span><br><span class="line"><span class="built_in">unset</span></span><br></pre></td></tr></table></figure><p><img src="image-20231204141227863.png" alt="image-20231204141227863"></p><p><strong>赋值时，等号左右无空格</strong></p><h3 id="给变量赋值">「给变量赋值」</h3><p><img src="image-20231204141317503.png" alt="image-20231204141317503"></p><h3 id="显示shell变量的值">「显示shell变量的值」</h3><p><img src="image-20231204141350586.png" alt="image-20231204141350586"></p><blockquote><p>shell变量可用于在命令行中帮助保存复杂选项或参数</p></blockquote><p><img src="image-20231204142142961.png" alt="image-20231204142142961"></p><h3 id="shell的标准变量">「shell的标准变量」</h3><p><img src="image-20231204142211346.png" alt="image-20231204142211346"></p><p><strong>标准变量：</strong></p><blockquote><p>HOME:保存用户主目录；用于其他命令定位主目录</p></blockquote><p><img src="image-20231204142314306.png" alt="image-20231204142314306"></p><blockquote><p>PATH : 设置shell载入外部命令（程序）时所要查找的目录</p></blockquote><p><img src="image-20231204142634082.png" alt="image-20231204142634082"></p><p><strong>路径间的分隔符是 ：</strong></p><p><img src="image-20231204143119671.png" alt="image-20231204143119671"></p><blockquote><p>PS1 : 设置作为命令提示符的字符串</p></blockquote><p><img src="image-20231204143511681.png" alt="image-20231204143511681"></p><p><img src="image-20231204143529264.png" alt="image-20231204143529264"></p><p><img src="image-20231204143619476.png" alt="image-20231204143619476"></p><p><img src="image-20231204143657006.png" alt="image-20231204143657006"></p><blockquote><p>PS2 : 多行输入一条命令时，设置第二行及以后行的提示符，默认为&gt;</p></blockquote><p><img src="image-20231204144200378.png" alt="image-20231204144200378"></p><p><img src="image-20231204144144616.png" alt="image-20231204144144616"></p><p><img src="image-20231204144216316.png" alt="image-20231204144216316"></p><blockquote><p>SHELL：设置登录的shell的完整路径</p></blockquote><p><img src="image-20231204144325814.png" alt="image-20231204144325814"></p><blockquote><p>TERM ： 设置终端类型</p></blockquote><p><img src="image-20231204144401392.png" alt="image-20231204144401392"></p><h2 id="4-其他元字符">4.其他元字符</h2><h3 id="执行命令：使用重音符号">「执行命令：使用重音符号  ` 」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># `告诉shell先执行重音符号扩起来的命令，结果替换命令行中原来扩起来的命令，也称命令替换符</span></span><br></pre></td></tr></table></figure><p><img src="image-20231204150134375.png" alt="image-20231204150134375"></p><p><img src="image-20231204150428115.png" alt="image-20231204150428115"></p><h3 id="命令序列：使用分号">「命令序列：使用分号  ; 」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在一个命令行中分隔多个命令，shell从左到右执行</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p><img src="image-20231204150612587.png" alt="image-20231204150612587"></p><h3 id="命令编组：使用括号">「命令编组：使用括号 ( )」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#几个命令放在一对括号中，编为一组执行，编组命令可以被重定向</span></span><br><span class="line">()</span><br></pre></td></tr></table></figure><p><img src="image-20231204150730847.png" alt="image-20231204150730847"></p><h3 id="后台处理：使用-符号">「后台处理：使用 &amp; 符号」</h3><blockquote><p>UNIX 是多任务系统，允许同时执行多个程序</p></blockquote><p><img src="image-20231204151039451.png" alt="image-20231204151039451"></p><p><img src="image-20231204151240267.png" alt="image-20231204151240267"></p><h3 id="链接命令：使用管道操作符">「链接命令：使用管道操作符  | 」</h3><blockquote><p>| ： 将一个命令的标准输出作为另一个命令的标准输入</p></blockquote><p><img src="image-20231204151409765.png" alt="image-20231204151409765"></p><h2 id="5-其他unix系统工具">5.其他UNIX系统工具</h2><h3 id="sleep命令">「sleep命令」</h3><blockquote><p>sleep：使执行该命令的进程延时指定的秒数</p></blockquote><h3 id="ps-命令">「ps 命令」</h3><blockquote><p>ps：查看进程详细信息</p></blockquote><p><img src="image-20231204151807585.png" alt="image-20231204151807585"></p><p>选项：</p><blockquote><p>-e：显示所有进程<br>-f： 显示信息的完整列表（包括完整的命令行）</p></blockquote><h3 id="kill命令">「kill命令」</h3><blockquote><p>kill ：发信号给指定进程，进行进程间的通信</p></blockquote><p><img src="image-20231204152126562.png" alt="image-20231204152126562"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> [-signal] PID</span><br></pre></td></tr></table></figure><p><img src="image-20231204152231320.png" alt="image-20231204152231320"></p><p><img src="image-20231204152509331.png" alt="image-20231204152509331"></p><h3 id="tee命令">「tee命令」</h3><p><img src="image-20231204152538886.png" alt="image-20231204152538886"></p><p><img src="image-20231204152651165.png" alt="image-20231204152651165"></p><p><img src="image-20231204152757094.png" alt="image-20231204152757094"></p><p><strong>注意：覆盖式输出。</strong></p><p><strong>选项：</strong></p><blockquote><p>-a ： 追加而非覆盖</p></blockquote><h3 id="grep命令">「grep命令」</h3><blockquote><p>在一个或多个文件中查找满足特定格式的行</p></blockquote><p><img src="image-20231204152855243.png" alt="image-20231204152855243"></p><p><img src="image-20231204152908288.png" alt="image-20231204152908288"></p><p><img src="image-20231204152945454.png" alt="image-20231204152945454"></p><h3 id="sort命令">「sort命令」</h3><blockquote><p>对文件内容按照字母或者数字顺序排序</p></blockquote><p><img src="image-20231204153040406.png" alt="image-20231204153040406"></p><p><img src="image-20231204153056280.png" alt="image-20231204153056280"></p><h2 id="6-启动文件">6.启动文件</h2><h3 id="shell环境配置文件">「shell环境配置文件」</h3><p><img src="image-20231204153205012.png" alt="image-20231204153205012"></p><h3 id="登录shell与非登录shell">「登录shell与非登录shell」</h3><p><img src="image-20231204153352222.png" alt="image-20231204153352222"></p><h3 id="配置文件功能">「配置文件功能」</h3><p><img src="image-20231204153421749.png" alt="image-20231204153421749"></p><p><img src="image-20231204153515457.png" alt="image-20231204153515457"></p><p><img src="image-20231204153646249.png" alt="image-20231204153646249"></p><p><img src="image-20231204153736701.png" alt="image-20231204153736701"></p><p><img src="image-20231204153748650.png" alt="image-20231204153748650"></p><h3 id="alias命令">「alias命令」</h3><p><img src="image-20231204153904462.png" alt="image-20231204153904462"></p><p><img src="image-20231204153958644.png" alt="image-20231204153958644"></p><h2 id="7-unix进程管理">7.UNIX进程管理</h2><p><img src="image-20231204154021259.png" alt="image-20231204154021259"></p><p><img src="image-20231204154035124.png" alt="image-20231204154035124"></p><p><img src="image-20231204154101766.png" alt="image-20231204154101766"></p><p><img src="image-20231204154119984.png" alt="image-20231204154119984"></p><p><img src="image-20231204154131717.png" alt="image-20231204154131717"></p><h1 id="七-程序开发">七、程序开发</h1><h2 id="1-程序的编辑-翻译与执行">1.程序的编辑、翻译与执行</h2><h3 id="建立可执行程序的步骤">「建立可执行程序的步骤」</h3><ol><li>编写源文件（源代码）</li><li>建立目标文件（目标代码/目标模块）</li><li>建立可执行文件（可执行代码/载入模块）</li></ol><p><img src="image-20231204160927261.png" alt="image-20231204160927261"></p><h3 id="编译-解释程序">「编译/解释程序」</h3><p><img src="image-20231204161014316.png" alt="image-20231204161014316"></p><h2 id="2-编译-链接c-c-程序">2.编译、链接C/C++程序</h2><blockquote><p>gcc ： GNU C 编译器，Linux通用 C 语言编译器</p><p>g++：GNU C++ 语言编译器</p></blockquote><h3 id="gcc-g-执行编译的步骤">「gcc / g++ 执行编译的步骤」</h3><ol><li><p>预处理：把头文件展开，去掉注释，宏替换，条件编译等；</p><p>​         生成 <strong>.i</strong> 文件</p></li><li><p>编  译：将预处理后的文件转换成<strong>汇编语言</strong></p><p>​         生成 <strong>.s</strong> 文件</p></li><li><p>汇  编：由汇编语言变为<strong>目标代码（机器代码）</strong></p><p>​         生成 <strong>.o</strong> 文件</p></li><li><p>链 接：链接目标代码，生成<strong>可执行程序</strong></p></li></ol><p><img src="image-20231204161322195.png" alt="image-20231204161322195"></p><h3 id="gcc-g-编译程序">「gcc  /  g++编译程序」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc [选项] 源文件名</span><br></pre></td></tr></table></figure><p>选项：</p><blockquote><p>-c ：只进行<strong>预处理、编译和汇编</strong>，只生成程序的目标代码文件</p><p>-o ： 指定<strong>生成的可执行程序名</strong>，缺省时候生成的可执行程序名是 a.out ；语法: -o 文件名</p></blockquote><p><img src="image-20231204161547150.png" alt="image-20231204161547150"></p><p><img src="image-20231204161612641.png" alt="image-20231204161612641"></p><h2 id="3-重定向程序输出与出错信息">3.重定向程序输出与出错信息</h2><p><img src="image-20231204161657044.png" alt="image-20231204161657044"></p><p><img src="image-20231204161829042.png" alt="image-20231204161829042"></p><h2 id="4-make工具-u-看不懂原理-u">4.make工具（<u>看不懂原理</u>）</h2><blockquote><p>make工具 ： GNU工程化编译工具，用于编译众多相互关联的源代码文件</p></blockquote><p><img src="image-20231204161934418.png" alt="image-20231204161934418"></p><p><img src="image-20231204161949121.png" alt="image-20231204161949121"></p><p><img src="image-20231204162001606.png" alt="image-20231204162001606"></p><p><img src="image-20231204162333300.png" alt="image-20231204162333300"></p><h1 id="八-shell编程">八、shell编程</h1><h2 id="1-unix-shell编程语言简介">1.UNIX shell编程语言简介</h2><p><img src="image-20231204163613672.png" alt="image-20231204163613672"></p><p><img src="image-20231204163747359.png" alt="image-20231204163747359"></p><p><img src="image-20231204163848400.png" alt="image-20231204163848400"></p><p><strong>前提条件：</strong></p><ol><li><strong>对于使用sh命令的方法：脚本中的命令要与使用的shell兼容</strong></li><li><strong>对于第二种方法：要先使文件对于用户或所有者具有可执行权限</strong></li></ol><p><img src="image-20231204164023952.png" alt="image-20231204164023952"></p><p><img src="image-20231204164102844.png" alt="image-20231204164102844"></p><p><img src="image-20231204164242380.png" alt="image-20231204164242380"></p><p><img src="image-20231204164437159.png" alt="image-20231204164437159"></p><h3 id="退出shell的方法">「退出shell的方法」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br><span class="line">Ctrl -d</span><br></pre></td></tr></table></figure><h3 id="执行脚本">「执行脚本」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh program  <span class="comment">#不需要执行权限，在子shell中进行，脚本文件需要与所用shell兼容</span></span><br><span class="line">./program   <span class="comment">#要具有可执行的权限，在子shell中进行</span></span><br><span class="line">. program   <span class="comment">#不需要可执行权限，在当前shell中执行</span></span><br></pre></td></tr></table></figure><p><img src="image-20231205100059587.png" alt="image-20231205100059587"></p><h2 id="2-编程基础">2.编程基础</h2><h3 id="命令置换-命令">「命令置换 ``命令」</h3><blockquote><p>将一个命令的输出作为另一个命令的参数(重音符号)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="built_in">command</span>`</span><br></pre></td></tr></table></figure><p><img src="image-20231205100259221.png" alt="image-20231205100259221"></p><h3 id="读取输入-read命令">「读取输入 read命令」</h3><blockquote><p>从标准输入设备读入字符串存入变量中</p></blockquote><p><strong>多变量输入</strong>：输入中第1个字符串存入第1个变量，第2个字符串存入第2个变量，…，字符串数多于变量数，所有剩余字符存入最后一个变量</p><p><img src="image-20231205100411909.png" alt="image-20231205100411909"></p><h3 id="自定义变量">「自定义变量」</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名=变量值</span><br></pre></td></tr></table></figure><ul><li><p><strong>shell不支持数据类型，赋给变量的值解释成字符串</strong></p></li><li><p><strong>变量名遵守与文件命名同样的语法规则</strong></p></li><li><p><strong>变量可以在shell提示符下定义并使用</strong></p></li></ul><p>生存周期：变量保存在内存中，直到脚本结束或终止</p><h3 id="清除变量-："><strong>「清除变量」：</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> 变量名</span><br></pre></td></tr></table></figure><h3 id="显示变量值-：">「显示变量值」：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $变量名</span><br></pre></td></tr></table></figure><h3 id="命令行参数-：">「命令行参数」：</h3><blockquote><p>又称位置变量，用户输入命令时后面跟的数据项，空格分隔</p></blockquote><ol><li><strong>参数传递给程序，可以改变程序行为或执行顺序</strong></li><li><strong>按顺序命令行参数被命名为$0、$1、…$9</strong></li><li>*<em>命令行参数多于9个，第9个之后的被忽略，但可通过$<em>获得</em></em></li></ol><p><img src="image-20231205100834762.png" alt="image-20231205100834762"></p><h3 id="set-命令">「set 命令」</h3><blockquote><p>给位置变量赋值，set参数依次赋值给位置变量</p></blockquote><p><img src="image-20231205100950854.png" alt="image-20231205100950854"></p><h3 id="exit">「exit」</h3><blockquote><p>shell内部命令，立即终止程序运行</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span> n</span><br></pre></td></tr></table></figure><ul><li><strong>n是退出状态，也称返回码</strong></li><li><strong>没有提供返回码，使用shell执行最后一条命令的退出值</strong></li><li><strong>为与其他UNIX程序/命令完成时返回一个退出状态，保持一致，编写shell脚本，返回给父进程一个退出状态</strong></li></ul><h2 id="3-条件与测试语句">3.条件与测试语句</h2><h3 id="if-then">「if-then」</h3><p><img src="image-20231205101350833.png" alt="image-20231205101350833"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><img src="image-20231205101431498.png" alt="image-20231205101431498"></p><h3 id="if-then-else">「if-then-else」</h3><p><img src="image-20231205101530279.png" alt="image-20231205101530279"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><img src="image-20231205101603297.png" alt="image-20231205101603297"></p><p>「if -then-eif」</p><p><img src="image-20231205101637201.png" alt="image-20231205101603297"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition1 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> [ condition2 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> [condition3 ]</span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="test">「test」</h3><blockquote><p>内部命令，它计算作为其参数的表达式的真假</p></blockquote><ul><li>**<em>真返回0，<em>假返回非0值</em></em></li><li><strong>[ condition ]是test命令的一种特殊写法</strong></li></ul><p><img src="image-20231205103608624.png" alt="image-20231205103608624"></p><p><img src="image-20231205103641272.png" alt="image-20231205103641272"></p><p><strong>判断数值：</strong></p><p><img src="image-20231205103654191.png" alt="image-20231205103654191"></p><p><strong>判断字符串：</strong></p><p><img src="image-20231205103707192.png" alt="image-20231205103707192"></p><p><img src="image-20231205103733801.png" alt="image-20231205103733801"></p><p><img src="image-20231205103751538.png" alt="image-20231205103751538"></p><p><strong>文件检测：</strong></p><p><img src="image-20231205103934119.png" alt="image-20231205103934119"></p><p><img src="image-20231205104022879.png" alt="image-20231205104022879"></p><h2 id="4-算术运算">4.算术运算</h2><h3 id="expr">「expr 」</h3><p><img src="image-20231205104139324.png" alt="image-20231205104139324"></p><p><img src="image-20231205104225736.png" alt="image-20231205104225736"></p><p><img src="image-20231205104242409.png" alt="image-20231205104242409"></p><h3 id="let">「let」</h3><p><img src="image-20231205104313227.png" alt="image-20231205104313227"></p><h2 id="5-循环">5.循环</h2><h3 id="for">「for」</h3><p><img src="image-20231205104412482.png" alt="image-20231205104412482"></p><p><img src="image-20231205104428159.png" alt="image-20231205104428159"></p><h3 id="while循环">「while循环」</h3><h1 id="九-系统管理">九、系统管理</h1><h2 id="1-文件系统管理">1.文件系统管理</h2><p><img src="image-20231205104731672.png" alt="image-20231205104731672"></p><h3 id="fdisk-命令">「fdisk 命令」</h3><p><img src="image-20231205104812741.png" alt="image-20231205104812741"></p><h3 id="mkfs">「mkfs」</h3><p><img src="image-20231205104853625.png" alt="image-20231205104853625"></p><h3 id="mount">「mount」</h3><p><img src="image-20231205104922676.png" alt="image-20231205104922676"></p><p><img src="image-20231205104945923.png" alt="image-20231205104945923"></p><h3 id="df">「df」</h3><p><img src="image-20231205105013868.png" alt="image-20231205105013868"></p><h3 id="du">「du」</h3><p><img src="image-20231205105036834.png" alt="image-20231205105036834"></p><h2 id="2-存档和压缩文件">2.存档和压缩文件</h2><h3 id="tar">「tar」</h3><p><img src="image-20231205105131143.png" alt="image-20231205105131143"></p><p><img src="image-20231205105225215.png" alt="image-20231205105225215"></p><p><img src="image-20231205105302202.png" alt="image-20231205105302202"></p><p><img src="image-20231205105317906.png" alt="image-20231205105317906"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;声明：本篇文章参考和引用了2023下半年吉林大学郭东老师的PPT，如有侵权，请联系我，我将会立马删除&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;一-unix操作系统&quot;&gt;一、UNIX操作系统&lt;/h1&gt;
&lt;h2 id=&quot;1-历史简介&quot;&gt;1.历史简介&lt;/h2&gt;
&lt;</summary>
      
    
    
    
    <category term="class record" scheme="https://comeupklklkl.gitee.io/jluloser.github.io/categories/class-record/"/>
    
    
    <category term="Linux" scheme="https://comeupklklkl.gitee.io/jluloser.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>学习生活随记</title>
    <link href="https://comeupklklkl.gitee.io/jluloser.github.io/2023/07/28/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    <id>https://comeupklklkl.gitee.io/jluloser.github.io/2023/07/28/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</id>
    <published>2023-07-28T07:43:29.000Z</published>
    <updated>2024-03-18T09:15:50.156Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大一上学期">大一上学期</h2><p>c语言</p><p>蓝桥杯省三</p><h2 id="大一下学期">大一下学期</h2><p>c++面向对象程序设计</p><p>初识CTF REVERSE</p><h2 id="大一暑假">大一暑假</h2><p>CTF REVERSE</p><p>数据结构</p><p>matlab</p><p>python</p><p>hexo搭建博客</p><p>微积分</p><p>暑假过得稀碎，啥也不是，好像学了又好像没学。</p><h2 id="大二上学期">大二上学期</h2><p>课程： 计算机组成原理  数据结构 离散2  微积分3  c++设计</p><p>参加数学建模比赛，真的很难绷，选c题做的稀烂。</p><p>加了百度菁英班，算法题全是数论相关，欧拉函数真的很迷，做完全都忘记了。</p><p>计组原理和数据结构全是硬菜，前者与数电紧密相联，并且内容很多，后者则是需要实践与学习相结合 。离散数学也不好过 ，概念很多，逻辑关系很强，老师讲课也很赶（虽然不是老师的错）——2023.9.26</p><p>今天中午尝试了中午提前到教室，在阶梯教室睡午觉然后继续学习，感觉梦回高三睡在合堂，不知道什么时候能轻松一点。上周六的CTF校赛没有参加，还是好好学习准备期末考试吧。</p><p>——2023/10/24</p><p>​离散数学和面向对象程序设计都是4/4，蛮开心的 ，继续前进吧。——2023/11/13</p><p>期末考试还可以，总算拯救了绩点，得了一千奖学金和数模省三等奖（水），以及六级没过（悲）——2024/2/28</p><h2 id="大二暑假">大二暑假</h2><p>美赛</p><p>python pandas</p><p>很摆烂</p><h2 id="大二下">大二下</h2><p>专业课很多的一个学期</p><p>完蛋啦，今天上午那个数据结构(1.5学分)上机《手撕sort进阶版》一个点都没答对，上周的红黑树也是,有一个点没过,又一次想死了，悲。下午上完毛概冲去蜜雪冰城买了一杯饮料喝了喝,好喝,但还是难受,≧ ﹏ ≦,自己是不是不适合这个专业呢?——2024/03/18</p>]]></content>
    
    
    <summary type="html">一些关于学习的简单记录</summary>
    
    
    
    <category term="life" scheme="https://comeupklklkl.gitee.io/jluloser.github.io/categories/life/"/>
    
    
    <category term="随记" scheme="https://comeupklklkl.gitee.io/jluloser.github.io/tags/%E9%9A%8F%E8%AE%B0/"/>
    
  </entry>
  
</feed>
