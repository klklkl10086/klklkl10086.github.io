<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>《计算机网络》复习笔记 | klklkl's blogs</title><meta name="author" content="klklkl"><meta name="copyright" content="klklkl"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="计算机网络概述 计算机网络:简称网络，由若干节点(node，计算机、集线器、交换机、路由器)和连接这些节点的链路(link)组成 互联网：网络间通过路由器连接起来，组成覆盖范围更大 的计算机网络，也称为“网络的网络 network of networks ” 因特网：特指当前全球最大的、开放的、由众多网络相互 连接而成的互联网，采用TCP&#x2F;IP协议族作为通信规则，前身是美国的APARNET">
<meta property="og:type" content="article">
<meta property="og:title" content="《计算机网络》复习笔记">
<meta property="og:url" content="https://klklkl10086.github.io/klklkl10086.github.io/2024/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="klklkl&#39;s blogs">
<meta property="og:description" content="计算机网络概述 计算机网络:简称网络，由若干节点(node，计算机、集线器、交换机、路由器)和连接这些节点的链路(link)组成 互联网：网络间通过路由器连接起来，组成覆盖范围更大 的计算机网络，也称为“网络的网络 network of networks ” 因特网：特指当前全球最大的、开放的、由众多网络相互 连接而成的互联网，采用TCP&#x2F;IP协议族作为通信规则，前身是美国的APARNET">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic2.zhimg.com/v2-f9b32b95385eedbdb58389bbbce5de39_r.jpg">
<meta property="article:published_time" content="2024-12-09T02:07:01.000Z">
<meta property="article:modified_time" content="2024-12-25T02:37:49.213Z">
<meta property="article:author" content="klklkl">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic2.zhimg.com/v2-f9b32b95385eedbdb58389bbbce5de39_r.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://klklkl10086.github.io/klklkl10086.github.io/2024/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《计算机网络》复习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-12-25 10:37:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="klklkl's blogs" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pic2.zhimg.com/v2-f9b32b95385eedbdb58389bbbce5de39_r.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pic1.zhimg.com/80/v2-908b61a41ec4bebe17a04468dcf5d834_720w.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="klklkl's blogs"><img class="site-icon" src="https://pic2.zhimg.com/v2-f9b32b95385eedbdb58389bbbce5de39_r.jpg# image"/><span class="site-name">klklkl's blogs</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《计算机网络》复习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-09T02:07:01.000Z" title="发表于 2024-12-09 10:07:01">2024-12-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-25T02:37:49.213Z" title="更新于 2024-12-25 10:37:49">2024-12-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/class/">class</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《计算机网络》复习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="计算机网络概述">计算机网络概述</h1>
<p><strong>计算机网络</strong>:简称网络，由若干节点(node，计算机、集线器、交换机、路由器)和连接这些节点的链路(link)组成</p>
<p><strong>互联网</strong>：网络间通过路由器连接起来，组成覆盖范围更大 的计算机网络，也称为“网络的网络 network of networks ”</p>
<p><strong>因特网</strong>：特指当前全球最大的、开放的、由众多网络相互 连接而成的互联网，采用TCP/IP协议族作为通信规则，前身是美国的APARNET</p>
<p><strong>两种描述“因特网”的方式</strong>：</p>
<ol type="1">
<li>描述构成因特网的<strong>具体构成</strong>，基本硬件和软件组件；</li>
<li>描述为基础设施向分布式应用程序提供的<strong>服务</strong>。</li>
</ol>
<h2 id="具体构成">具体构成</h2>
<p>计算设备统称为 <strong>主机(端系统)</strong> 如:传统的桌面PC、 工作站、 服务器 • 非传统的因特网设备如便携机、智 能手机、平板电脑、电视、游戏机、 温度调节装置、家用电器、手表、眼 镜、汽车、运输控制系统.</p>
<h3 id="通信链路">通信链路</h3>
<p>有多种不同类型的<strong>物理媒体</strong>： Fiber光纤, copper同轴电缆, radio 无线电频谱, satellite卫星</p>
<p><strong>衡量链路性能的指标</strong>:</p>
<ul>
<li>传输速率 transmission rate: 比特/秒、bit/s、bps</li>
<li>带宽 bandwidth</li>
</ul>
<h3 id="分组交换机">分组交换机</h3>
<p><strong>分组 packet</strong>： 当一台端系统向另 一台端系统发送数据时，发送端系统将数据分段，每段加上首部 字节。</p>
<p><strong>路径 path 或 route</strong>：一个分组所经历的一系列<strong>通信链路</strong>和<strong>分组交换机</strong>。</p>
<p>两种最主要类型的分组交换机</p>
<ul>
<li><strong>路由器</strong> routers，用于核心网；</li>
<li><strong>链路层交换机</strong> switches，用于 接入网</li>
</ul>
<h3 id="因特网服务提供商-isp">因特网服务提供商 ISP</h3>
<ul>
<li>住宅区ISP、公司ISP、大学ISP、 WiFi ISP、蜂窝数据ISP</li>
<li>提供不同种类的网络接入，住宅宽带接入DSL、高速局域网接入、 移动无线接入</li>
</ul>
<ol type="1">
<li>较高层ISP通过高速光纤链路和高速路由器组成；</li>
<li>较低层ISP通过国家的、国际的较 高层ISP互联到因特网</li>
<li>无论高层还是低层ISP都独立管理</li>
</ol>
<h3 id="协议protocols">协议protocols</h3>
<p>在网络上控制信息的发送 接收</p>
<p>e.g. TCP, IP, HTTP, Skype, 802.1</p>
<h2 id="服务描述">服务描述</h2>
<p>从为应用程序提供服务的基础设施的角度描述因特网。</p>
<h3 id="套接字接口-socket-interface">套接字接口 socket interface</h3>
<p>一 套发送程序必须遵循的规则集合， 规定了运行在一个<strong>端系统上的应用程</strong>序请求因特网基础设施向 行在另一个<strong>端系统上的特定目的程序</strong>交付数据的方式</p>
<h3 id="网络协议-network-protocols">网络协议 network protocols</h3>
<p>协议定义了在两个或多个通信实体之间交换的<strong>报文格式和顺序</strong>，以及报文发送和/或 接收及其他事件所采取的<strong>动作</strong></p>
<ul>
<li>通信双方交换报文，而不是语句</li>
<li>通信实体是设备</li>
</ul>
<h2 id="网络结构">网络结构</h2>
<p>网络结构可以分为:</p>
<ul>
<li>网络边缘:主机/端系统,应用程序</li>
<li>接入网络:有线或者无线通信链路</li>
<li>网络核心:互连着的路由器 , 网络的网络</li>
</ul>
<h2 id="接入网络">接入网络</h2>
<p><strong>接入网 Access networks</strong>：将端系统物理连接到其边缘路由器的网络。</p>
<p><strong>边缘路由器</strong>:是端系统到任何远程端系统的路径上的第一台路由器</p>
<p><strong>怎样将端系统和边缘路由器连接？</strong></p>
<ul>
<li>住宅接入网络</li>
<li>单位接入网络 （学校、公 司）</li>
<li>无线接入网络</li>
</ul>
<h3 id="家庭接入网">家庭接入网</h3>
<p>宽带住宅接入有两种流行方式：数字用户线 DSL和电缆。</p>
<p><strong>数字用户线 DSL</strong>:双绞线</p>
<p><strong>电缆</strong>:</p>
<ul>
<li>由于外层屏蔽层 的作用，具有很 好的抗干扰性， 适于高速率传输</li>
<li>利用现有的有线电视基础设施</li>
</ul>
<p><strong>光纤入户:</strong></p>
<p><strong>其他方式:</strong></p>
<ul>
<li>卫星接入光纤到户:超过1Mbps的速率接入。</li>
<li>传统电话线的拨号接入： 与DSL类似，56Kbps的速率</li>
</ul>
<h3 id="企业接入网">企业接入网</h3>
<p>使用局域网LAN将多个端接系统连接到边缘路由器，用户设备 位于几十米范围内</p>
<p>多使用基于IEEE802.11技术的无线LAN接入，也称Wifi</p>
<p>企业网接入方式广泛应用于家庭，设备价格低廉</p>
<h3 id="广域无线接入网">广域无线接入网</h3>
<p>Iphone、安卓等智能手机使用蜂窝网络的无线基础设施（基 站）来接入因特网，发送和接收分组。</p>
<h3 id="物理媒介">物理媒介</h3>
<p><strong>physical medium 物理媒体</strong>：通过传播电信号或光脉冲来发送bit</p>
<p><strong>guided media 引导型媒体</strong>: signals propagate in solid media: copper, fiber, coax</p>
<p><strong>unguided media 非引导型媒体</strong>: signals propagate freely, e.g. radio</p>
<p><strong>物理链路的实际成本与组网的其它成本相比是比较小的,特别是安装物理链路的劳动力成本</strong></p>
<p><strong>双绞线:</strong></p>
<ul>
<li>两根绝缘的铜线以规则的螺旋状绞合起来，为减少临近类似 的双绞线的电气干扰</li>
<li>大多数情况下，使用无屏蔽双绞线 UTP，广泛用于计算机网 络局域网组网中，灵活易布线，性价比高</li>
</ul>
<p><strong>同轴电缆</strong></p>
<ul>
<li>由于外层屏蔽层的作用，具有很好的抗干扰性，适于高速 率传输</li>
</ul>
<p><strong>光纤</strong></p>
<p><strong>光脉冲</strong></p>
<ul>
<li>高传输速率</li>
<li>长距离传输，100km，光缆信号衰减极低，很难窃听</li>
<li>低误码率,不受电磁干扰</li>
<li>这些特性使其适用于长途引导型媒体，特别是跨海链路。</li>
</ul>
<p><strong>无线电信道</strong></p>
<p>优点：穿墙、长距离、移动 连接 缺点：性能依赖于传播环境 和传播距离</p>
<h2 id="网络核心">网络核心</h2>
<p>因特网核心是由分组交换机和链路构成的网状网络。</p>
<p>端系统彼此间想要交换的是报 文(message)，包含控制信息和 数据，但其长度往往超出因特 网转发的长度限制。</p>
<p><strong>数据怎样通过网络进行传输？</strong></p>
<ul>
<li><strong>电路交换</strong>：为每个呼叫预留一条 <strong>专有电路</strong>：如电话网</li>
<li><strong>分组交换</strong>：将要传送的数据分成一个个单位(分组)
<ul>
<li>将分组从一个路由器传到相邻路由器（hop），一段段最终从源端传到目标端</li>
<li>每段：采用链路的最大传输能力（ 带宽 )</li>
</ul></li>
</ul>
<h3 id="分组交换">分组交换</h3>
<ul>
<li>以分组为单位<strong>存储-转发</strong>方式</li>
<li>存储转发传输(store-and-forward transmission): 是指在分组交换机能够开始向输出链路传输该分组的第一个比特之前，必须 接收到整个分组</li>
<li>$ = $,L是分组长度,R是传输速率</li>
</ul>
<blockquote>
<ol type="1">
<li><strong>通过由N条速率均为R的链路组成的路径（源和目的端之间有N-1台路由器），从源到目的地发送一个分组， 端到端的时延是</strong>$N  $</li>
<li><strong>P个分组经过N条链路序列的端到端时延</strong>: <span class="math inline">\((N+P-1) \cdot \frac{L}{R}\)</span></li>
</ol>
</blockquote>
<p><strong>排队时延</strong></p>
<p>每台分组交换机有多条链路与之相连，对于每条链路分组交 换机设置一个<strong>输出缓存</strong>output buffer，也称为输出队列</p>
<p>排队时延取决于队列长度，即网络的拥塞程度.</p>
<p>缓存空间大小有限，当分组到达时缓存已满，将出现分组丢 失(即丢包)packet loss的现象:或丢弃新到达的分组, 或丢弃队列中已排队的分组(通常是优先级低)</p>
<h3 id="电路交换">电路交换</h3>
<p>在端系统间通信过程中，创 建电路时就预留了端系统间沿路径通信所需要的全部资 源(缓存、链路传输速率)，并会话期间<strong>独占</strong>这些资源</p>
<p>分组交换网中资源不是预留的，会话期间需要的资源可 能需要等待</p>
<p>电路交换分配专用链路的两种方式: <strong>频分复用</strong>和<strong>时分复用</strong></p>
<p><strong>频分复用</strong>(FDM):链路的<strong>频谱</strong>由跨该链路的所有连接共享，为每条经过的电路分配一个划分的子频段</p>
<p>​ 频段的宽度称为带宽 bandwidth</p>
<p>​ <img src="image-20241210213849851.png" alt="image-20241210213849851" /></p>
<p><strong>时分复用</strong>（TDM）: 通信时间被划分为固定期间的帧，每个帧又被划分为固定数量的时隙，网络中 建立电路时在各段链路上的每个通信周期(时域)指定一个专用时隙，该时隙用于传输该电路连接的数据。</p>
<figure>
<img src="image-20241210213941677.png" alt="image-20241210213941677" /><figcaption aria-hidden="true">image-20241210213941677</figcaption>
</figure>
<p><strong>TDM中电路的传输速率等于帧速率乘以一个时隙的比特数.</strong></p>
<ul>
<li>例如，链路每秒传8000帧，每个时隙有8比特，则<strong>每条电路</strong>的传输速率为64Kbps</li>
</ul>
<p><strong>电路交换缺点</strong>:</p>
<ul>
<li>电路交换因为在静默期（slient period）专用电路空闲导致浪费。</li>
<li>创建端到端的电路和预留资源是复杂的，需要复杂的信令和协 调沿路径的交换机操作。 （RSVP资源预留协议</li>
</ul>
<figure>
<img src="image-20241210214210049.png" alt="image-20241210214210049" /><figcaption aria-hidden="true">image-20241210214210049</figcaption>
</figure>
<h3 id="分组交换-vs.-电路交">分组交换 vs. 电路交</h3>
<ul>
<li><p>分组交换网不适合实时服务(如电话和视频会议)，因为排队时 延导致端到端时延可变、不可预测。</p></li>
<li><p>分组交换网提供了比电路交换好的带宽共享,比电路交换更简单、 更有效、实现成本低</p></li>
<li><p>分组交换网适合于对突发式数据传输 :资源共享 , 简单，不必建立呼叫 但是过度使用会造成网络拥塞：分组延时和丢失,对可靠地数据传输需要协议来约束：拥塞控制</p></li>
</ul>
<h2 id="互联网络结构">互联网络结构</h2>
<p>松散的层次模型</p>
<p>中心：第一层ISP,国家/国际覆盖，速率极高 直接与其他第一层ISP相连 与大量的第二层ISP和其他客户网络相连</p>
<p>第二层ISP: 更小些的 (通常是区域性的) ISP 与一个或多个第一层ISPs，也可能与其他第二层ISP</p>
<p>第三层ISP与其他本地ISP 接入网 (与端系统最近)</p>
<h3 id="isp之间的连接">ISP之间的连接</h3>
<ul>
<li><strong>存在点PoP（Point of Presence）</strong>：存在于除底层（接入ISP）外的所有层次，是提供商网络中的一个或若干个路由器群组，客户网络通过提供商的租用高速链路将它的路由器之一连接到PoP的路由器之一。</li>
<li><strong>多宿（multi-home）</strong>：除第一层ISP外，任何ISP可以与两个或多 个提供商ISP连接。 当一个ISP多宿时，若提供商ISP之一故障时，仍能传输分组。</li>
<li>客户ISP根据与提供商ISP交换的通信流量来付费。</li>
<li><strong>对等</strong>：位于相同等级结构层次的临近一对ISP可以直接连接在 一起，它们之间的所有直接相互流量，不通过上游ISP转输， 彼此间互不付费。</li>
<li><strong>因特网交换点（Internet Exchange Point，IXP）</strong>:是一个汇合点， 多个ISP能够在这里一起对等，通常位于独立建筑物内。</li>
</ul>
<figure>
<img src="image-20241214214154806.png" alt="image-20241214214154806" /><figcaption aria-hidden="true">image-20241214214154806</figcaption>
</figure>
<h2 id="分组延时丢失和吞吐量">分组延时、丢失和吞吐量</h2>
<p><strong>产生时延和分组丢失的原因:</strong></p>
<ul>
<li>分组到达链路的速率超过了链路输出的能力</li>
<li>分组等待排到队头被传输</li>
</ul>
<p><strong>最大吞吐量</strong>:一台路由器能够转发分组的<strong>最大</strong>速率。</p>
<h3 id="时延构成">时延构成</h3>
<p><strong>时延类型</strong></p>
<figure>
<img src="image-20241214214649422.png" alt="时延类型" /><figcaption aria-hidden="true">时延类型</figcaption>
</figure>
<ul>
<li><strong>节点处理时延：</strong>
<ul>
<li>检查 bit级差错</li>
<li>检查分组首部和决定将分组导向何处</li>
</ul></li>
<li><strong>传输时延</strong> ：将分组所有比特发射到链路上所需的时间
<ul>
<li><span class="math inline">\(R\)</span>是链路带宽(bps) <span class="math inline">\(L\)</span>是分组长度(bits) ，将分组发送到链路上的时间为 <span class="math inline">\(L/R\)</span></li>
<li>存储转发延时</li>
</ul></li>
<li><strong>传播时延：</strong> 每个比特从链路起点到下一 路由器传播所需要的时间
<ul>
<li><span class="math inline">\(d\)</span> = 物理链路的长度, $ s$ = 在媒体上的传播速度 (<span class="math inline">\(~2 \cdot 10^8 m/sec\)</span>) 传播延时 = <span class="math inline">\(d/s\)</span></li>
<li>链路的传播速率取决于链路的物理媒体 （ 光纤、双绞线） ，略小于光速。</li>
</ul></li>
<li><strong>排队时延</strong>：在输出链路上等待传输的时间
<ul>
<li>依赖于路由器的拥塞程度</li>
</ul></li>
</ul>
<p><strong>节点时延</strong> <span class="math display">\[
d_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}
\]</span></p>
<ul>
<li><span class="math inline">\(d_{proc}\)</span> = 处理延时
<ul>
<li>通常是微秒数量级或更少</li>
</ul></li>
<li><span class="math inline">\(d_{queue}\)</span> = 排队延时
<ul>
<li>取决于拥塞程度</li>
</ul></li>
<li>$ d_{trans}$ = 传输延时
<ul>
<li>= <span class="math inline">\(L/R\)</span>, 对低速率的链路而言很大（如拨号），通常为微秒级 到毫秒级</li>
</ul></li>
<li>$ d_{prop} $= 传播延时
<ul>
<li>几微秒到几百毫秒</li>
</ul></li>
</ul>
<h3 id="排队时延和丢包">排队时延和丢包</h3>
<ul>
<li>节点时延的构成成分中，最复杂的是排队时延</li>
<li>与其它3种时延不同的是，排队时延对每个分组可能是不 同的，即每个分组需要的排队时间不同</li>
<li>表征排队时延时，通常使用<strong>统计量</strong>，如:
<ul>
<li>平均排队时延、排队时延的方差、排队时延超过某特定值的概率</li>
</ul></li>
<li>排队时延的大小取决于：</li>
<li>流量到达队列的速度、链路的传输速率、到达流量的性质（周期性的、突发的）</li>
</ul>
<figure>
<img src="image-20241214220005807.png" alt="流量强度" /><figcaption aria-hidden="true">流量强度</figcaption>
</figure>
<p><strong>丢包</strong></p>
<ul>
<li>通常路由器内的队列容量是有限的，不能容纳所有到达的分组排队。</li>
<li>队列容量取决于路由器的设计和成本。</li>
<li>因此：</li>
<li>随着流量强度接近于1，排队时延并不是真的趋于无穷大,只是量级发生了变化；</li>
<li>队列满了的时候，路由器将丢弃（drop）到达的分组或优先级低的分组，此时将产生丢包（lost）。</li>
<li><strong>分组的丢失比例随着流量强度增加而增加。</strong></li>
<li>丢失的分组可能由前一个节点重传，或基于端到端的重传 原则重传</li>
</ul>
<h3 id="端到端时延">端到端时延</h3>
<figure>
<img src="image-20241214220359892.png" alt="image-20241214220359892" /><figcaption aria-hidden="true">image-20241214220359892</figcaption>
</figure>
<h3 id="吞吐量">吞吐量</h3>
<blockquote>
<p>端到端单位时间内传输的数据量</p>
</blockquote>
<p>吞吐量是衡量计算机网络性能的另一个重要指标。</p>
<p><strong>瓶颈链路</strong>:端到端路径上，限制端到端吞吐的链路</p>
<figure>
<img src="image-20241214220531031.png" alt="image-20241214220531031" /><figcaption aria-hidden="true">image-20241214220531031</figcaption>
</figure>
<figure>
<img src="image-20241214220617499.png" alt="image-20241214220617499" /><figcaption aria-hidden="true">image-20241214220617499</figcaption>
</figure>
<h2 id="协议层次">协议层次</h2>
<ul>
<li>服务( Service)：低层实体向上层实体提供它们之间的通信的能力
<ul>
<li>服务用户(service user)</li>
<li>服务提供者(service provider )</li>
</ul></li>
<li>原语(primitive)：上层使用下层服务的形式，高层使用低层提供的服务，以及低层向高层提供服务都是通过服务访问原语来进行交互的---<strong>形式</strong></li>
<li>服务访问点 SAP (Services Access Point) ：上层使用下层提供的服务通过层间的接口—<strong>地点</strong>
<ul>
<li>例子:邮箱</li>
<li>地址(address)：下层的一个实体支撑着上层的多个实体， SAP有标志不同上层实体的作用</li>
<li>可以有不同的实现，队列</li>
<li>例子:传输层的SAP: 端口(port)</li>
</ul></li>
</ul>
<p><strong>服务与协议的区别</strong> :</p>
<ul>
<li>服务(Service)：低层实体向上层实体提供它们之间的通信的能力，是通过原语(primitive)来操作的，垂直</li>
<li>协议(protocol) ：<strong>对等层实体</strong>(peer entity)之间在相互通信的过程中，需要遵循的规则的集合，水平</li>
</ul>
<p><strong>服务与协议的联系 :</strong></p>
<ul>
<li>本层协议的实现要靠下层提供的服务来实现</li>
<li>本层实体通过协议为上层提供更高级的服务</li>
</ul>
<h3 id="分层的体系结构">分层的体系结构</h3>
<ul>
<li>网络设计者以<strong>分层</strong>的方式<strong>组织协议</strong>，以及<strong>实现协议</strong>的网络硬件和软件:</li>
<li>每一层向它的上一层提供服务（service）。</li>
<li>每层通过执行该层的某些动作或直接使用下层服务来提供服务。</li>
<li>一个协议层能够使用软件、硬件或两者的结合来实现。
<ul>
<li>应用层协议几乎用软件实现；</li>
<li>物理层、数据链路层协议通常在网络接口卡(硬件)实现;</li>
<li>网络层协议通常由软、硬件混合实现.</li>
</ul></li>
<li>第n层协议分布在网络的端系统、分组交换机和其它组件</li>
</ul>
<p><strong>分层的原因:</strong></p>
<ul>
<li>结构化分层易于定义和实现</li>
<li>模块化,易于维护和升级</li>
</ul>
<p><strong>分层的潜在缺点</strong>：</p>
<ul>
<li>功能可能在多层冗余，如差错检验；</li>
<li>某层功能可能调用其它层提供的信息，分层不彻底.</li>
</ul>
<h3 id="internet-协议栈">Internet 协议栈</h3>
<p>协议栈：各层所有协议的集合</p>
<figure>
<img src="image-20241214221427100.png" alt="image-20241214221427100" /><figcaption aria-hidden="true">image-20241214221427100</figcaption>
</figure>
<figure>
<img src="image-20241214221445098.png" alt="image-20241214221445098" /><figcaption aria-hidden="true">image-20241214221445098</figcaption>
</figure>
<table>
<thead>
<tr class="header">
<th></th>
<th>协议</th>
<th>任务</th>
<th>信息单位</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>应用层</td>
<td>HTTP SMTP FTP DNS</td>
<td><strong>端系统</strong>之间</td>
<td>报文</td>
</tr>
<tr class="even">
<td>传输层</td>
<td>TCP UDP</td>
<td><strong>应用程序端点</strong>之间传送应用层报文</td>
<td>报文段</td>
</tr>
<tr class="odd">
<td>网络层</td>
<td>IP 路由选择协议</td>
<td><strong>主机</strong>之间</td>
<td>数据报</td>
</tr>
<tr class="even">
<td>链路层</td>
<td>链路层协议 DOCSIS PPP</td>
<td>整个<strong>帧</strong>从一个<strong>节点</strong>到下一个节点</td>
<td>帧</td>
</tr>
<tr class="odd">
<td>物理层</td>
<td>与实际传输媒体相关</td>
<td>一个个<strong>比特</strong>从一个<strong>节点</strong>到下一个节点</td>
<td>比特</td>
</tr>
</tbody>
</table>
<h3 id="isoosi">ISO/OSI</h3>
<figure>
<img src="image-20241214221526455.png" alt="image-20241214221526455" /><figcaption aria-hidden="true">image-20241214221526455</figcaption>
</figure>
<p>TCP/IP协议栈中,将表示层放入了应用层,session放进了传输层</p>
<h1 id="应用层">应用层</h1>
<p>网络核心中没有应用层软件,<strong>网络核心没有应用层功能</strong>,<strong>网络应用只在端系统上存在</strong></p>
<h2 id="应用层协议原理">应用层协议原理</h2>
<h3 id="网络应用体系结构">网络应用体系结构</h3>
<ol type="1">
<li>从应用程序开发者的角度看，网络体系结构是固定的 ，并为应用程序提供了特定的服务集合。</li>
<li>应用程序体系结构由应用程序研发者设计，规定了如何在端系统上组织该应用程序</li>
</ol>
<p>当前主流的两种:</p>
<ul>
<li><strong>客户-服务器</strong>体系结构</li>
<li><strong>对等(P2P)</strong>体系结构</li>
</ul>
<p><strong>客户-服务器体系结构</strong></p>
<p><strong>服务器</strong>: 服务于来自许多其他称为客户的主机的请求。</p>
<ul>
<li>一直运行</li>
<li>固定的IP地址和周知的端口号（约定）</li>
<li>扩展性：服务器场
<ul>
<li>数据中心进行扩展</li>
<li>扩展性差</li>
</ul></li>
</ul>
<p><strong>客户端:</strong></p>
<ul>
<li>主动与服务器通信</li>
<li>与互联网有间歇性的连接</li>
<li>可能是动态IP 地址</li>
<li>不直接与其它客户端通信</li>
</ul>
<p>例如:Web FTP 电子邮件</p>
<p><strong>P2P结构</strong></p>
<ul>
<li>（几乎）没有一直运行的服务 器</li>
<li>任意端系统之间可以进行通信</li>
<li>每一个节点既是客户端又是服 务器</li>
<li>自扩展性-新peer节点带来新的服务能力，当然也带来新的服务请求</li>
<li>参与的主机间歇性连接且可以改变IP地址</li>
<li>难以管理</li>
<li>面临安全性、性能、可靠性挑 战</li>
</ul>
<p>例子: Gnutella，迅雷</p>
<p>适用于流量密集型应用,如文件共享,下载,视频会议</p>
<h3 id="进程通信">进程通信</h3>
<p>在构建网络应用程序前，还需要对运行在多个<strong>端系统上的程序</strong>是如何互相通信的情况有一个基本了解。</p>
<p>进行通信的实际上是<strong>进程(process)</strong>而不是程序。</p>
<ul>
<li>在同一个主机内，使用 <strong>进程间通信机制</strong> 通信（ 操作系统定义）</li>
<li>在两个不同端系统上的进程，通过跨越计算机网络交换报文（message）而相互通信。</li>
</ul>
<p><strong>[客户和服务器进程]</strong></p>
<p>对每对通信进程, 我们通常将这两个进程之一标识为<strong>客户</strong>（client）,而另一个进程标识为<strong>服务器</strong>（serve)。</p>
<p>在一对进程之间的通信会话场景中，发起通信（即在该会话开始时发起与其他进程的联系）的进程被标识为客户，在会话开始时等待联系的进程是服务器。</p>
<p>对于Web而言，浏览器是一个客户进程，Web服务器是一台服务器进程。对于P2P文件 共享，下载文件的对等方标识为客户，上载文件的对等方标识为服务器。</p>
<p>一个进程可能既是客户又是服务器</p>
<figure>
<img src="image-20241215195325691.png" alt="image-20241215195325691" /><figcaption aria-hidden="true">image-20241215195325691</figcaption>
</figure>
<p><strong>[套接字]</strong></p>
<p>进程通过一个称为套接字（socket）的软件接口向网络发送报文和从网络接收报文。</p>
<figure>
<img src="image-20241215195117150.png" alt="image-20241215195117150" /><figcaption aria-hidden="true">image-20241215195117150</figcaption>
</figure>
<p>套接字，是同一台主机内应用层与传输层之间的接口 ，也称为应用程序和网络之间的应用程序编程接口API。</p>
<p>应用程序开发者可以控制套接字在<strong>应用层端</strong>的一切， 对于套接字在<strong>传输层端</strong>的控制<strong>仅限于</strong>：</p>
<ol type="1">
<li>选择传输层协议；</li>
<li>设定几个传输层参数，如最大缓存和最大报文⻓度等</li>
</ol>
<h3 id="进程寻址">进程寻址</h3>
<p>在一台主机上运行的进程为了向在另一台主机上运行的进程发送分组，接收进程需要有一个地址。为了标识该接收进程，需要定义两种信息：</p>
<ul>
<li>主机的地址,主机由其<strong>IP地址(IP address)</strong>标识</li>
<li>在目的主机中指定接收进程的标识符:<strong>端口号</strong></li>
</ul>
<p>一个进程：用IP+port标示</p>
<p>本质上，一对主机进程之间的通信由2个端节点构成</p>
<h3 id="可供应用程序使用的运输服务">可供应用程序使用的运输服务</h3>
<p>当开发一个应用时，必须选择一种可用的<strong>运输层协议</strong></p>
<p>通过研究这些可用的 运输层协议所提供的服务，选择一个最能为你的应用需求提供恰当服务的协议。</p>
<p>大体能够从四个方面对应用程序服务要求进行分类：<strong>可靠数据传输(正确,不丢失)、吞吐量、定时和安全性</strong>。</p>
<figure>
<img src="image-20241215195908318.png" alt="image-20241215195908318" /><figcaption aria-hidden="true">image-20241215195908318</figcaption>
</figure>
<h3 id="因特网提供的运输服务">因特网提供的运输服务</h3>
<p>因特网为应用程序提供 两个运输层协议，即<strong>UDP和TCP</strong>。当你（作为一个软件开发者）为因特网创建一个新的应用时，首先要做出的决定是，<strong>选择UDP还是选择TCP</strong></p>
<p><strong>TCP服务:</strong></p>
<ul>
<li>面向连接服务</li>
<li>可靠数据传输服务:无差错 按序 无丢失 无冗余</li>
<li>拥塞控制机制</li>
<li>流量控制</li>
<li>但是不提供加密</li>
</ul>
<p><strong>UDP服务</strong>:UDP是一种不提供不必要服务的轻量级运输协议，它仅提供<strong>最小服务</strong></p>
<ul>
<li>不可靠数据传输</li>
<li>无连接服务</li>
<li>不提供可靠性 流量控制拥塞控制 定时 吞吐量保证 安全性</li>
</ul>
<figure>
<img src="image-20241215201516696.png" alt="image-20241215201516696" /><figcaption aria-hidden="true">image-20241215201516696</figcaption>
</figure>
<figure>
<img src="image-20241215201544812.png" alt="image-20241215201544812" /><figcaption aria-hidden="true">image-20241215201544812</figcaption>
</figure>
<figure>
<img src="image-20241215201342712.png" alt="image-20241215201342712" /><figcaption aria-hidden="true">image-20241215201342712</figcaption>
</figure>
<ul>
<li>因特网能够为时延敏感的应用提供满意的服务，但是并不提供任何定时或带宽的保证</li>
<li>因特网电话等容丢失应用喜欢UDP，但是防火墙经常配置成阻挡UDP流量，所以用TCP做备份</li>
</ul>
<h3 id="应用层协议">应用层协议</h3>
<p>应用层协议（application-layer protocol）定义了运行在不同端系统上的应用程序进程<strong>如何相互传递报文</strong>。特别是应用层协议定义了 ：</p>
<ul>
<li>交换的报文类型，例如请求报文和响应报文。</li>
<li>各种报文类型的语法，如报文中的各个字段及这些字段是如何描述的。</li>
<li>字段的语义，即这些字段中的信息的含义。</li>
<li>确定一个进程何时以及如何发送报文，对报文进行响应的规则</li>
</ul>
<p>可以分为:</p>
<ul>
<li>公域协议</li>
<li>专用协议</li>
</ul>
<h2 id="web和http">Web和HTTP</h2>
<p><strong>Web的基本介绍</strong></p>
<p>Web使用了客户 -服务器应用程序体系结构</p>
<figure>
<img src="image-20241215204314556.png" alt="image-20241215204314556" /><figcaption aria-hidden="true">image-20241215204314556</figcaption>
</figure>
<h3 id="http">HTTP</h3>
<blockquote>
<p>Web的应用层协议是超文本传输协议（HyperText Transfer Protocol, HTTP）,它是Web 的核心</p>
</blockquote>
<p>HTTP由两个程序实现：一个客户程序和一个服务器程序。客户程序和服务器程序运行在不同的端系统中，通过交换 HTTP报文进行会话。</p>
<p>Web 浏览器（Web browser）实现 了 HTTP 的客 户端,Web服 务器（Web server）实现了 HTTP的服务器端，它用于存储Web对象，每个对象由URL寻 址。</p>
<ul>
<li>HTTP使用TCP:
<ul>
<li>客户发起一个与服务器的 TCP连接 (建立套接字) ， 端口号为 80</li>
<li>服务器接受客户的TCP连接</li>
<li>在浏览器(HTTP客户端) 与 Web服务器(HTTP服 务器 server)交换HTTP报文 (应用层协议报文)</li>
<li>TCP连接关闭</li>
</ul></li>
<li>HTTP是无状态的,服务器并不维护关于客户的任何信息</li>
</ul>
<h3 id="http连接类型">HTTP连接类型</h3>
<p><strong>[往返时间]</strong></p>
<blockquote>
<p>该时间是指一个短分组从客户到服务器然后再返回客户所花费的时间。RTT包括<strong>分组传播时延</strong>、分组在中间路由器和交换机上的<strong>排队时延</strong>以及<strong>分组处理时延</strong></p>
</blockquote>
<ul>
<li><p>非持续连接</p>
<ul>
<li>最多只有一个对象在 TCP连接上发送</li>
<li>下载多个对象需要多个TCP连接</li>
<li>HTTP/1.0使用非持 久连接</li>
</ul>
<figure>
<img src="image-20241215205827065.png" alt="image-20241215205827065" /><figcaption aria-hidden="true">image-20241215205827065</figcaption>
</figure>
<figure>
<img src="image-20241215205845301.png" alt="image-20241215205845301" /><figcaption aria-hidden="true">image-20241215205845301</figcaption>
</figure>
<figure>
<img src="image-20241215205948191.png" alt="image-20241215205948191" /><figcaption aria-hidden="true">image-20241215205948191</figcaption>
</figure></li>
<li><p>持续连接</p>
<ul>
<li>多个对象可以在一个 （在客户端和服务器之间的）TCP连接上传输</li>
<li>HTTP/1.1 默认使用 持续连接</li>
</ul></li>
</ul>
<p>HTTP在<strong>默认方式下使用持续连接</strong>，如果需要也可以配置为非持续连接。</p>
<figure>
<img src="image-20241215210141066.png" alt="image-20241215210141066" /><figcaption aria-hidden="true">image-20241215210141066</figcaption>
</figure>
<h3 id="http报文格式">HTTP报文格式</h3>
<ul>
<li>请求报文</li>
<li>响应报文</li>
</ul>
<p><strong>[HTTP请求报文]</strong></p>
<p><strong>ASCII文本书写 人类可读的格式</strong></p>
<figure>
<img src="image-20241215210414715.png" alt="HTTP请求报文格式" /><figcaption aria-hidden="true">HTTP请求报文格式</figcaption>
</figure>
<p>例如:</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> /index.html HTTP/<span class="number">1.1</span>\r\n </span><br><span class="line">Host: www-net.cs.umass.edu\r\n              </span><br><span class="line">User-Agent: Firefox/<span class="number">3.6</span>.<span class="number">10</span>\r\n </span><br><span class="line">Accept: text/html,application/xhtml+xml\r\n </span><br><span class="line">Accept-Language: en-us,en;q=<span class="number">0.5</span>\r\n </span><br><span class="line">Accept-Encoding: gzip,deflate\r\n </span><br><span class="line">Accept-Charset: ISO-<span class="number">8859</span>-<span class="number">1</span>,utf-<span class="number">8</span>;q=<span class="number">0.7</span>\r\n </span><br><span class="line">Keep-Alive: <span class="number">115</span>\r\n </span><br><span class="line">Connection: keep-alive\r\n </span><br><span class="line">\r\n </span><br></pre></td></tr></table></figure>
<p><strong>提交表单输入的方式</strong>:</p>
<p>POST:包含在实体主体 (entity body )中的 输入被提交到服务器</p>
<p>URL:使用GET方法,输入通过请求行的 URL字段上载</p>
<p><strong>Method 类型:</strong></p>
<p><strong>HTTP/1.0:</strong></p>
<ul>
<li>GET:表单数据添加在URL末尾</li>
<li>POST:表单数据放在实体字段中</li>
<li>HEAD:只发送响应报文，而不返回请求对象，用 于应用程序的调试追踪。</li>
</ul>
<p><strong>HTTP/1.1:</strong></p>
<ul>
<li>GET</li>
<li>POST</li>
<li>HEAD</li>
<li>PUT:将实体主体中的文件上载到URL字段规定的路径</li>
<li>DELETE:删除URL字段规定的文件</li>
</ul>
<p><strong>[HTTP响应报文]</strong></p>
<figure>
<img src="image-20241215211202441.png" alt="HTTP响应报文" /><figcaption aria-hidden="true">HTTP响应报文</figcaption>
</figure>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK\r\n </span><br><span class="line">Date: Sun, <span class="number">26</span> Sep <span class="number">2010</span> <span class="number">20</span>:<span class="number">09</span>:<span class="number">20</span> GMT\r\n </span><br><span class="line">Server: Apache/<span class="number">2.0</span>.<span class="number">52</span> (CentOS)\r\n </span><br><span class="line">Last-Modified: Tue, <span class="number">30</span> Oct <span class="number">2007</span> <span class="number">17</span>:<span class="number">00</span>:<span class="number">02</span></span><br><span class="line"> GMT\r\n </span><br><span class="line">ETag: <span class="string">&quot;17dc6-a5c-bf716880&quot;</span>\r\n </span><br><span class="line">Accept-Ranges: bytes\r\n </span><br><span class="line">Content-Length: <span class="number">2652</span>\r\n </span><br><span class="line">Keep-Alive: timeout=<span class="number">10</span>, max=<span class="number">100</span>\r\n </span><br><span class="line">Connection: Keep-Alive\r\n </span><br><span class="line">Content-Type: text/html;</span><br><span class="line"> charset=ISO-<span class="number">8859</span>-<span class="number">1</span>\r\n </span><br><span class="line">\r\n </span><br><span class="line"><span class="keyword">data</span> <span class="keyword">data</span> <span class="keyword">data</span> <span class="keyword">data</span> <span class="keyword">data</span> ... </span><br></pre></td></tr></table></figure>
<figure>
<img src="image-20241215211135240.png" alt="响应状态码" /><figcaption aria-hidden="true">响应状态码</figcaption>
</figure>
<h3 id="用户-服务器状态cookies">用户-服务器状态：cookies</h3>
<p>HTTP是无状态的，但是很多应用中服务器希望识别用户身份进一步提供服务。</p>
<p><strong>[组成]</strong></p>
<ul>
<li>在HTTP<strong>响应报文</strong>中有 一个cookie的首部行</li>
<li>在HTTP<strong>请求报文</strong>含有 一个cookie的首部行</li>
<li>在<strong>用户</strong>端系统中保留有 一个cookie文件，由用户的浏览器管理</li>
<li>在<strong>Web站点</strong>有一个<strong>后端数据库</strong></li>
</ul>
<figure>
<img src="image-20241215211755501.png" alt="image-20241215211755501" /><figcaption aria-hidden="true">image-20241215211755501</figcaption>
</figure>
<figure>
<img src="image-20241215211836861.png" alt="image-20241215211836861" /><figcaption aria-hidden="true">image-20241215211836861</figcaption>
</figure>
<h3 id="web缓存代理服务器">Web缓存(代理服务器)</h3>
<p>Web缓存的存储空间中保存最近请求过的对象的副本,不访问原始服务器，就满足客户的请求</p>
<figure>
<img src="image-20241215212031137.png" alt="image-20241215212031137" /><figcaption aria-hidden="true">image-20241215212031137</figcaption>
</figure>
<p>为什么要使用Web缓存 ？</p>
<ul>
<li>降低客户端的请求响应时间</li>
<li>可以大大减少一个机构内部网络与Internent接入链路上的流量</li>
<li>互联网大量采用了缓存： 可以使较弱的ICP也能够 有效提供内容</li>
</ul>
<h3 id="条件get方法">条件GET方法</h3>
<p>如果缓存器中的对象拷贝是最新的，就不要发送对象(由缓存器通过发送一个条件GET执行最新检查)</p>
<figure>
<img src="image-20241215212543651.png" alt="image-20241215212543651" /><figcaption aria-hidden="true">image-20241215212543651</figcaption>
</figure>
<h2 id="电子邮件">电子邮件</h2>
<p>主要组成部分：用户代理（user agent）、邮件服务器（mail server）和简单邮件传输协议（Simple Mail Transfer Protocol, SMTP）</p>
<figure>
<img src="image-20241215214930367.png" alt="image-20241215214930367" /><figcaption aria-hidden="true">image-20241215214930367</figcaption>
</figure>
<p><strong>邮件服务器:邮件服务器形成了电子邮件体系结构的核心</strong></p>
<ul>
<li><strong>邮箱</strong>中管理和维护发送给用户的邮件</li>
<li><strong>输出报文队列</strong>保持待发送邮件报文</li>
</ul>
<p><strong>邮件服务器之间的SMTP协议</strong> ：发送email报文</p>
<ul>
<li>客户：发送方邮件服务器</li>
<li>服务器：接收端邮件服务器</li>
</ul>
<p>SMTP是因特网电子邮件中<strong>主要</strong>的应用层协议。它使用TCP可靠数据传输服务</p>
<h3 id="smtp简单邮件传输协议">SMTP简单邮件传输协议</h3>
<ul>
<li>使用<strong>TCP</strong>在客户端和服务器之间传送报文，端口号为25</li>
<li><strong>直接传输</strong>：从发送方服务器到接收方服务器(无论多远都是直接传输,SMTP 一般不使用中间邮件服务器发送邮件，即使这两个 邮件服务器位于地球的两端也是这样。邮件并不在中间的某个邮件服务器存留。)</li>
<li>传输的3个阶段
<ul>
<li>握手</li>
<li>传输报文</li>
<li>关闭</li>
</ul></li>
<li>命令/响应交互
<ul>
<li>命令：ASCII文本</li>
<li>响应：状态码和状态信息</li>
</ul></li>
<li><strong>报文必须为7位ASCII码</strong></li>
<li>SMTP使用<strong>持久连接</strong></li>
</ul>
<figure>
<img src="image-20241215215436959.png" alt="image-20241215215436959" /><figcaption aria-hidden="true">image-20241215215436959</figcaption>
</figure>
<p><strong>vs. HTTP</strong></p>
<ul>
<li>HTTP：拉（pull）</li>
<li>SMTP：推（push）</li>
<li>二者都是ASCII形式的命令/ 响应交互、状态码</li>
<li>HTTP：每个对象封装在各自的响应报文中</li>
<li>SMTP：多个对象包含在一个报文中</li>
</ul>
<p><strong>邮件报文格式</strong></p>
<figure>
<img src="image-20241215215624390.png" alt="image-20241215215624390" /><figcaption aria-hidden="true">image-20241215215624390</figcaption>
</figure>
<h3 id="邮件访问协议">邮件访问协议</h3>
<blockquote>
<p><strong>从服务器访问邮件</strong></p>
</blockquote>
<blockquote>
<p>典型的用户通常在本地PC上运行一个用户代理程序，而它访问存储在总是保持开机的共享邮件服务器上的邮箱。该邮件服务器与其他用户共享，并且通常由用户的ISP进行维护 （如大学或公司）。</p>
</blockquote>
<figure>
<img src="image-20241215215917387.png" alt="image-20241215215917387" /><figcaption aria-hidden="true">image-20241215215917387</figcaption>
</figure>
<ul>
<li>POP:邮局访问协议
<ul>
<li>用户身份确认 (代理&lt;--&gt;服务器) 并下载</li>
</ul></li>
<li>IMAP :Internet邮件访问协议
<ul>
<li>更多特性 (更复杂)</li>
<li>在服务器上处理存储的报文</li>
</ul></li>
<li>HTTP:
<ul>
<li>方便</li>
</ul></li>
</ul>
<p><strong>[POP协议]</strong></p>
<p>POP3按照三个阶段进行工作：特许（authorization）、事务处理以及更新</p>
<figure>
<img src="image-20241215220250939.png" alt="image-20241215220250939" /><figcaption aria-hidden="true">image-20241215220250939</figcaption>
</figure>
<p><strong>上述过程中的dele是标记删除,只有执行quit退出后才会真正删除</strong></p>
<figure>
<img src="image-20241215220447769.png" alt="image-20241215220447769" /><figcaption aria-hidden="true">image-20241215220447769</figcaption>
</figure>
<h2 id="dns域名系统">DNS:域名系统</h2>
<p>识别主机有两种方式，通过<strong>主机名</strong>或者<strong>IP地址</strong>,我们需要一种能进行<strong>主机名到IP地址转换</strong>的目录服务,即域名系统</p>
<blockquote>
<p>DNS是：</p>
<ol type="1">
<li>一个由分层的DNS服务器（DNS server）实现的<strong>分布式数据库</strong>；</li>
<li>一个使得主机能够查询分布式数据库的<strong>应用层协议</strong>。</li>
</ol>
</blockquote>
<p>DNS协议运行在UDP之上,使用53号端口</p>
<h3 id="dns服务">DNS服务</h3>
<ul>
<li>主机名到IP地址的转换</li>
<li>主机别名（host aliasing）:调用DNS获得alias names（更好记）对应的规范主机名或IP</li>
<li>邮件服务器别名（mail server aliasing） :电子邮件应用程序调用DNS获得邮件服务器别名对应的规范主机名或IP地址</li>
<li>负载均衡（load distribution）:当用户发出对某繁忙站点域名的DNS请求时，DNS服务器用整个IP集合响应并每次都循环这个集合，用户向集合里IP地址排在前面的服务器发送请求。</li>
</ul>
<h3 id="dns工作机理">DNS工作机理</h3>
<p><strong>转换过程:</strong></p>
<ol type="1">
<li>用户主机上的应用程序需要将一个主机名转换为IP地址；</li>
<li>用户主机调用DNS客户端，并指明需要转换的主机名；</li>
<li>用户主机DNS客户端向网络发送一个DNS查询报文；</li>
<li>经过若干秒到若干毫秒的时延，用户主机DNS客户端收到一 个回答报文，回答报文中保护映射结果；</li>
<li>DNS客户端将映射结果传递到调用DNS的应用程序。</li>
</ol>
<p><strong>为什么DNS不设计为一个服务器这样的集中式设计,而采用分布式的设计?</strong></p>
<ul>
<li>单点故障，集中服务器坏因特网瘫痪</li>
<li>通信容量，单个DNS服务器不能处理所有DNS查询</li>
<li>远距离通信，存在严重的时延，拥塞、 低速</li>
<li>维护，中央数据库将过于庞大，而且它还不得不为解决每个新添加的主机而频繁更新</li>
</ul>
<p>因此,DNS设计为<strong>分布式的层次数据库</strong></p>
<figure>
<img src="image-20241216202121549.png" alt="image-20241216202121549" /><figcaption aria-hidden="true">image-20241216202121549</figcaption>
</figure>
<ul>
<li><strong>根服务器</strong>:根名字服务器提供TLD服务器的IP地址</li>
<li><strong>顶级域(TLD)DNS服务器</strong>: TLD服务器提供了权威DNS服务器的IP地址</li>
<li><strong>权威DNS服务器</strong>:因特网上具有公共可访问主机的组织机构必须提供公共可访问的DNS记录，将公共可访问主机名映射为IP</li>
</ul>
<p><strong>[本地DNS服务器]</strong></p>
<p>严格说来，一个 本地DNS服务器并<strong>不属于</strong>该服务器的层次结构</p>
<p>每个ISP都有一台本地DNS服务器（也叫默认名字服务器）,主机的本地DNS服务器通常“邻近”本主机。</p>
<p>当主机发岀 DNS请求时，该请求被发往本地DNS服务器，它起着代理的作用，并将该请求转发到DNS服务器层次结构中</p>
<p><strong>[名字解析过程]</strong></p>
<ul>
<li>迭代查询</li>
<li>递归查询</li>
</ul>
<p><strong>迭代查询</strong>:</p>
<figure>
<img src="image-20241216204655119.png" alt="image-20241216204655119" /><figcaption aria-hidden="true">image-20241216204655119</figcaption>
</figure>
<p><strong>递归查询:</strong> <img src="image-20241216204719639.png" alt="image-20241216204719639" /></p>
<h3 id="dns缓存">DNS缓存</h3>
<blockquote>
<p>在一个请求链中，当某DNS 服务器接收一个DNS回答(例如，包含某主机名到IP地址的映射)时，它能将映射缓存在本地存储器中</p>
</blockquote>
<p>由于主机和主机名与IP地址间的映射并不是永久的，DNS服务器在一段时间后(通常设置为两天)将丢弃缓存的信息。</p>
<p>TLD servers IP address typically cached in local name servers thus root name servers not often visited</p>
<h3 id="dns记录">DNS记录</h3>
<blockquote>
<p>共同实现DNS分布式数据库的所有DNS服务器存储了资源记录(Resource Record, RR), RR提供了主机名到IP地址的映射。每个DNS回答报文包含了一条或多条资源记 录。</p>
</blockquote>
<p>RR是四元组:</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RR format: (<span class="keyword">name</span>, value, type, ttl)</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><strong>TTL:该记录的生存时间，它决定了资源记录应当从缓存中删除的时间。</strong></li>
<li><strong>Name和Value的值取决于Type</strong>:</li>
</ol>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Type取值</th>
<th style="text-align: center;">Name取值</th>
<th style="text-align: center;">Value取值</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">A</td>
<td style="text-align: center;">主机</td>
<td style="text-align: center;">IP地址</td>
<td>(Tayl. bar. foo. com, 145. 37.93. 126, A)</td>
</tr>
<tr class="even">
<td style="text-align: center;">CNAME</td>
<td style="text-align: center;">规范名字的别名</td>
<td style="text-align: center;">规范名字</td>
<td>(foo.com, relay1. bar. foo. com, CNAME)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">NS</td>
<td style="text-align: center;">域名</td>
<td style="text-align: center;">该域名的权威服务器的域名</td>
<td>(foo.com, dns.foo.com, NS)</td>
</tr>
<tr class="even">
<td style="text-align: center;">MX</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">name对应的邮件服务器的名字</td>
<td>(foo.com, mail. bar. foo. com, MX)</td>
</tr>
</tbody>
</table>
<p>值得注意的是，通过使用MX记录，<strong>一个公司的邮件服务器和其他服务器(如它的Web服务器)可以使用相同的别名</strong>。为了获得邮件服务器的规范主机名，DNS客户应当请求一条MX记录；而为了获得其他服务器的规范主机名，DNS客户应当请求CNAME记录。</p>
<ul>
<li>如果当前DNS是收到的请求中所请求主机名的权威DNS服务器，或者缓存中有所请求主机名的A记录，则返回一条A记录；</li>
<li>如果当前DNS服务器不是所请求主机名的权威DNS服务器， 则返回一条NS记录提供所请求主机的域及其权威DNS服务器主机名，同时再返回一条A记录包含该权威DNS服务器的IP地址</li>
</ul>
<h3 id="dns报文">DNS报文</h3>
<p>只有查询和回答报文,并且格式相同</p>
<figure>
<img src="image-20241216210203915.png" alt="image-20241216210203915" /><figcaption aria-hidden="true">image-20241216210203915</figcaption>
</figure>
<p>标识符:16位数,用于标识该查询。</p>
<p>flag标志:查询/应答 希望递归 递归可用 应答为权威</p>
<h3 id="在dns数据库中插入记录">在DNS数据库中插入记录</h3>
<figure>
<img src="image-20241216210652604.png" alt="image-20241216210652604" /><figcaption aria-hidden="true">image-20241216210652604</figcaption>
</figure>
<figure>
<img src="image-20241216210811952.png" alt="image-20241216210811952" /><figcaption aria-hidden="true">image-20241216210811952</figcaption>
</figure>
<h1 id="传输层">传输层</h1>
<ul>
<li>传输层为运行在<strong>不同主机</strong>上的<strong>应用进程</strong>提供直接的通信服务。</li>
<li>将网络层在两个端系统之间的交付服务扩展到运行在 两个<strong>不同端系统上的应用层进程</strong>之间的交付服务。</li>
<li>并解决两个对等通信实体如何在尽力而为（会丢失或 损坏数据）的因特网上进行<strong>可靠的通信</strong>。</li>
<li>控制运输层实体的传输速率以避免网络中的拥塞，或从拥塞中恢复过来</li>
</ul>
<h2 id="概述和传输层服务">概述和传输层服务</h2>
<p>传输层为运行在不同主机上的应用进程提供<strong>逻辑通信</strong></p>
<blockquote>
<p>逻辑通信:应用进程使用传输层提供的逻辑通信功能发送报文,无需考虑承载这些报文的物理基础设施</p>
</blockquote>
<p>传输协议运行<strong>在端系统</strong>:</p>
<ul>
<li>发送方：将应用层的报文分成报文段，然后传递给网络层</li>
<li>接收方：将报文段重组成报文，然后传递给应用层</li>
</ul>
<p>有多个传输层协议可供应用选择 如Internet: TCP和UDP</p>
<figure>
<img src="image-20241218092357878.png" alt="image-20241218092357878" /><figcaption aria-hidden="true">image-20241218092357878</figcaption>
</figure>
<h3 id="传输层-vs.-网络层">传输层 vs. 网络层</h3>
<ul>
<li>网络层服务：<strong>主机</strong>之间的<strong>逻辑通信</strong></li>
<li>传输层服务：<strong>进程</strong>间的<strong>逻辑通信</strong>
<ul>
<li>依赖于网络层的服务(延时、带宽)</li>
<li>并对网络层的服务进行增强 (数据丢失、顺序混乱、 加密)</li>
</ul></li>
</ul>
<p>有些服务是可以加强的：不可靠 -&gt; 可靠,安全 . 但有些服务是不可以被加强的：带宽，延迟</p>
<h3 id="多路分解与多路复用">多路分解与多路复用</h3>
<blockquote>
<p>多路分解与多路复用 : 将由网络层提供的<strong>主机到主机</strong>的交付服务延伸到运行在主机上的<strong>应用程序</strong>,提供<strong>进程到进程</strong>的交付服务</p>
</blockquote>
<ul>
<li><p>通过套接字实现,一个进程有一个或多个套接字,相当于从网络向进程传递数据或者从进程向网络传递数据的门户</p></li>
<li><p>每个传输层报文段中都包含套接字的标识符字段(端口号),在发送端填入源和目的端口号,在接收端提取</p>
<ul>
<li><p>在<strong>发送方</strong>主机<strong>多路复用</strong>:从多个套接字接收来自多个进程的报文，根据套接字对应的IP地址和端口号等信息对报文段用头部加以封装 (该头部信息用于以后的解复用)</p></li>
<li><p>在<strong>接收方</strong>主机<strong>多路解复用</strong>:根据报文段的头部信息中的IP地址和端口号将接收到的报文段发给正确的套接字(和对应的应用进程)</p></li>
</ul></li>
</ul>
<p><strong>多路复用工作原理</strong></p>
<ul>
<li>主机收到<strong>IP数据报</strong>
<ul>
<li>每个数据报有<strong>源IP地址</strong>和<strong>目标IP地址</strong></li>
<li>每个<strong>数据报</strong>承载一个<strong>传输层报文段</strong></li>
<li>每个<strong>报文段</strong>有一个<strong>源端口号</strong>和 <strong>目标端口号</strong> (特定应用有著名的端口号)</li>
</ul></li>
<li>主机联合使用<strong>IP地址和端口号</strong>将报 文段发送给合适的<strong>套接字</strong></li>
</ul>
<figure>
<img src="image-20241218094342788.png" alt="image-20241218094342788" /><figcaption aria-hidden="true">image-20241218094342788</figcaption>
</figure>
<p><strong>端口号</strong></p>
<blockquote>
<p>16位二进制数,范围:0~65535</p>
<ul>
<li>0~1023是众所周知端口号；</li>
<li>1024~5000是临时端口号，分给客户端;</li>
<li>大于5000的服务器端留用，支持并发。</li>
</ul>
</blockquote>
<p><strong>如何标识一对网络通信进程</strong></p>
<p>用<strong>五元组</strong>来标识因特网上彼此通信的<strong>一对网络通信</strong>进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;TCP or UDP，源端口号，源IP地址，目的端口号，目的IP地址&gt;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>TCP还是UDP？在开发网络应用程序时就已由程序人员确定</li>
<li>客户端发起通信时，要创建套接字，并指明创建TCP套接字还是UDP套接字，并请求分配<strong>源端口号</strong>。</li>
<li>套接字在形成报文段时，要封装<strong>源端口号</strong>和<strong>目的端口号</strong>，然后调用TCP或UDP服务，完成传输层功能，并将报文段传给网络层。</li>
<li>报文段到达<strong>网络层</strong>后，添加<strong>源IP地址</strong>、<strong>目的IP地址</strong>等字段，形成分组</li>
</ol>
<h3 id="无连接udp的多路复用">无连接(UDP)的多路复用</h3>
<p>在<strong>接收端</strong>，<strong>UDP套接字用二元组标识</strong> (目标IP地址、目标端口号)</p>
<p>主机收到UDP报文段： 检查报文段的目标端口号 , 用该端口号将报文段定位给套接字</p>
<p>如果两个不同源IP地址/源端口号的数据报，但是有相同的目标IP地址和端口号，则被定位到相同的套接字</p>
<figure>
<img src="image-20241218100059270.png" alt="image-20241218100059270" /><figcaption aria-hidden="true">image-20241218100059270</figcaption>
</figure>
<h3 id="面向连接tcp的多路复用">面向连接(TCP)的多路复用</h3>
<ul>
<li>接收端TCP套接字:四元组本地标识： <strong>源IP地址 源端口号 目的IP地址 目的端口号</strong> , 接收主机用这四个值来将数据报定位到合适的套接字</li>
<li>服务器能够在<strong>一个TCP 端口</strong>上同时支持<strong>多个 TCP套接字</strong>: 每个套接字由其四元组标识（有不同的源IP和源 PORT）</li>
</ul>
<p>Web服务器对每个连接客户端有不同的套接字, 非持久连接对每个请求有不同的套接字</p>
<figure>
<img src="image-20241218100046626.png" alt="image-20241218100046626" /><figcaption aria-hidden="true">image-20241218100046626</figcaption>
</figure>
<h2 id="无连接传输udp">无连接传输:UDP</h2>
<p>UDP只提供了<strong>复用/分解</strong> 和<strong>少量差错检验</strong>功能。(除了复用/分解功能及少量的差错检测外，它几乎没有对IP增加别的东西。)</p>
<p>UDP是尽力而为的服务,报文段可能会<strong>丢失 、乱序</strong></p>
<p><strong>无连接:</strong></p>
<ul>
<li>UDP发送端和接收端之间没有握手</li>
<li>每个UDP报文段都被独立地处理(每个UDP报文段都独立存在，发送方不会等待接收方的确认，也不跟踪连接状态。接收方接收到数据后，不会知道这些数据是由同一源发送的、也不会了解这些数据是属于同一应用会话的。)</li>
</ul>
<p>TCP服务由于拥塞控制限速、建立连接的时延开销、维护连接状态需要缓存参数等资源、首部开销大等原因并不适合所有应用。</p>
<p>UDP被用于: 流媒体（丢失不敏感， 速率敏感、应用可控制 、传输速率）, DNS , SNMP</p>
<h3 id="udp报文">UDP报文</h3>
<figure>
<img src="image-20241218102933247.png" alt="image-20241218102933247" /><figcaption aria-hidden="true">image-20241218102933247</figcaption>
</figure>
<p><strong>为什么要有UDP?</strong></p>
<ul>
<li>不建立连接 （会增加延时 ）</li>
<li>简单：在发送端和接收端没有连接状态</li>
<li>报文段的头部很小(开销小)</li>
<li>无拥塞控制和流量控制： UDP可以尽可能快的发送报文段</li>
<li>应用-&gt;传输的速率= 主机-&gt;网络的速率</li>
</ul>
<p><strong>UDP校验和</strong></p>
<blockquote>
<p>检测在被传输报文段中的差错 (如比特反转)</p>
</blockquote>
<p>发送方:</p>
<ul>
<li>将报文段的内容视为16 比特的整数</li>
<li>校验和：报文段的加法和取反 （1的补运算）</li>
<li>发送方将校验和放在 UDP的校验和字段</li>
</ul>
<p>接收方:</p>
<ul>
<li>计算接收到的报文段的校验和</li>
<li>检查计算出的校验和与校验和字段的内容是否相等：
<ul>
<li>不相等–--检测到差错</li>
<li>相等–--没有检测到差错 ，但也许还是有差错 • 残存错误</li>
</ul></li>
</ul>
<figure>
<img src="image-20241218103324060.png" alt="image-20241218103324060" /><figcaption aria-hidden="true">image-20241218103324060</figcaption>
</figure>
<p><strong>为什么UDP提供了差错检验，而有些链路层协议也提供了差错检验功能？</strong></p>
<ul>
<li>不能确保源端和目的端之间所有的链路都提供差错检验。</li>
<li>不能确保报文段在某个路由器内存中存储时不出错。</li>
<li>UDP提供差错检验，但对差错没有恢复功能。</li>
</ul>
<h2 id="可靠数据传输rdt原理">可靠数据传输(rdt)原理</h2>
<h3 id="rdt1.0在可靠信道上的可靠数据传输">Rdt1.0:在可靠信道上的可靠数据传输</h3>
<blockquote>
<p>前提:</p>
<p>下层的信道是完全可靠的:</p>
<ul>
<li>没有比特出错</li>
<li>没有分组丢失</li>
</ul>
</blockquote>
<figure>
<img src="image-20241218104519486.png" alt="image-20241218104519486" /><figcaption aria-hidden="true">image-20241218104519486</figcaption>
</figure>
<figure>
<img src="image-20241218104946106.png" alt="image-20241218104946106" /><figcaption aria-hidden="true">image-20241218104946106</figcaption>
</figure>
<h3 id="rdt2.0具有比特差错的信道">Rdt2.0:具有比特差错的信道</h3>
<blockquote>
<p>下层信道可能会出错：将分组中的比特翻转 : 用校验和来检测比特差错</p>
<p>会出现比特差错， 但报文段不丢失、不乱序</p>
</blockquote>
<p><strong>怎样从差错中恢复:</strong></p>
<ul>
<li>确认(ACK)：接收方显式地告诉发送方分组已被正确接收</li>
<li>否定确认( NAK): 接收方显式地告诉发送方分组发生了差错
<ul>
<li>发送方收到NAK后，发送方重传分组</li>
</ul></li>
</ul>
<figure>
<img src="image-20241218105442915.png" alt="image-20241218105442915" /><figcaption aria-hidden="true">image-20241218105442915</figcaption>
</figure>
<p><strong>rdt2.0称为停等协议</strong>:发送方发送一个分组， 然后等待接收方的应答</p>
<p>rdt2.0新机制:</p>
<ul>
<li>差错检测</li>
<li>从接收方到发送方的控制信息(ACK,NAK)</li>
</ul>
<figure>
<img src="image-20241218105657205.png" alt="image-20241218105657205" /><figcaption aria-hidden="true">image-20241218105657205</figcaption>
</figure>
<p><strong>缺陷:</strong></p>
<p>如果ACK/NAK出错,发送方却不知道发生了什么,发送方若重传会造成冗余,若什么都不做会造成死锁</p>
<p><strong>应对重复的措施</strong>:----&gt;<strong>rdt2.1</strong></p>
<ul>
<li>发送方在每个分组中加 入序号</li>
<li>如果ACK/NAK出错，发送方重传当前分组</li>
<li>接收方丢弃（不发给上层）重复分组</li>
</ul>
<h3 id="rdt2.1">Rdt2.1</h3>
<blockquote>
<p>在2.0的基础上给分组加入了序号</p>
</blockquote>
<p><strong>发送方：</strong></p>
<ul>
<li>在分组中加入序列号</li>
<li>两个序列号（0，1）就 足够了</li>
<li>一次只发送一个未经确认的分组</li>
<li>必须检测ACK/NAK是否出错（需要EDC : Error Detection Code错误检测码）</li>
<li>状态数变成了两倍</li>
<li>必须记住当前分组的序列号为0还是1</li>
</ul>
<p><strong>接收方：</strong></p>
<ul>
<li>必须检测接收到的分组是否是<strong>重复</strong>的</li>
<li>状态会指示希望接收到的分组的序号为0还是1</li>
<li>接收方并不知道发送方是否正确接受到ACK/NAK,不会继续设计确认的确认,不然就没完没了</li>
</ul>
<figure>
<img src="image-20241218110037342.png" alt="image-20241218110037342" /><figcaption aria-hidden="true">image-20241218110037342</figcaption>
</figure>
<figure>
<img src="image-20241218110128306.png" alt="image-20241218110128306" /><figcaption aria-hidden="true">image-20241218110128306</figcaption>
</figure>
<figure>
<img src="image-20241218110144763.png" alt="image-20241218110144763" /><figcaption aria-hidden="true">image-20241218110144763</figcaption>
</figure>
<h3 id="rdt2.2无nak的协议">Rdt2.2:无NAK的协议</h3>
<blockquote>
<ul>
<li>功能同rdt2.1，但只使用ACK(ack 要编号）</li>
<li>接收方对<strong>最后正确接收</strong>的分组发ACK，以替代NAK
<ul>
<li>接收方必须<strong>显式地</strong>包含被正确接收分组的序号</li>
</ul></li>
<li>当收到<strong>重复的ACK</strong>（如：再次收到ack0）时，发送方与收到NAK采取相同的动作：<strong>重传当前分组</strong></li>
<li>为后面的一次发送多个数据单位做一个准备
<ul>
<li>一次能够发送多个</li>
<li>每一个的应答都有：ACK，NAK；麻烦</li>
<li>使用对前一个数据单位的ACK，代替本数据单位的NAK</li>
<li>确认信息减少一半，协议处理简单</li>
</ul></li>
</ul>
</blockquote>
<figure>
<img src="image-20241218111223662.png" alt="image-20241218111223662" /><figcaption aria-hidden="true">image-20241218111223662</figcaption>
</figure>
<figure>
<img src="image-20241218111245711.png" alt="image-20241218111245711" /><figcaption aria-hidden="true">image-20241218111245711</figcaption>
</figure>
<figure>
<img src="image-20241218111313677.png" alt="image-20241218111313677" /><figcaption aria-hidden="true">image-20241218111313677</figcaption>
</figure>
<h3 id="rdt3.0具有比特差错和分组丢失的信道">Rdt3.0:具有比特差错和分组丢失的信道</h3>
<blockquote>
<p>假设:</p>
<p>下层信道可能会丢失分组（数据 或ACK）</p>
<p>方法:</p>
<p>发送方等待ACK一段合理的时间,发送端超时重传：如果到时没有收到ACK-&gt;重传</p>
<p>需要一个倒计数定时器</p>
<p>方法存在的问题:</p>
<p>如果分组（或ACK ）只是被延迟了, 重传将会导致数据重复，但利用序列号已经可以处理这 个问题 ,那么接收方必须指明被正确接收的序列号</p>
</blockquote>
<figure>
<img src="image-20241218111710449.png" alt="image-20241218111710449" /><figcaption aria-hidden="true">image-20241218111710449</figcaption>
</figure>
<figure>
<img src="image-20241218111757806.png" alt="image-20241218111757806" /><figcaption aria-hidden="true">image-20241218111757806</figcaption>
</figure>
<ul>
<li>过早超时（延迟的ACK）也能够正常工作；但是效率较低，一半 的分组和确认是重复的；</li>
<li>设置一个合理的超时时间也是比较重要的；</li>
</ul>
<p><strong>性能</strong></p>
<figure>
<img src="image-20241218112151691.png" alt="image-20241218112151691" /><figcaption aria-hidden="true">image-20241218112151691</figcaption>
</figure>
<figure>
<img src="image-20241218112217273.png" alt="image-20241218112217273" /><figcaption aria-hidden="true">image-20241218112217273</figcaption>
</figure>
<figure>
<img src="image-20241218112327914.png" alt="image-20241218112327914" /><figcaption aria-hidden="true">image-20241218112327914</figcaption>
</figure>
<h3 id="流水线可靠传输协议">流水线可靠传输协议</h3>
<blockquote>
<p>流水线：允许发送方在未得到对方确认的情况下一次发送多个</p>
<ul>
<li>必须增加序号的范围:用多个bit表示分组的序号</li>
<li>在发送方/接收方要有缓冲区
<ul>
<li>发送方缓冲：未得到确认，可能需要重传；</li>
<li>接收方缓存：
<ul>
<li>上层用户取用数据的速率 ≠ 接收到的数据速率；</li>
<li>接收到的数据可能乱序，排序交付（可靠）</li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<p>通用的流水线协议,根据差错的恢复方式不同:</p>
<p>回退N步(GBN):全部重传 累计确认</p>
<p>选择重传(SR): 选择重传 单独确认</p>
<h3 id="gbn滑动窗口协议">GBN:滑动窗口协议</h3>
<p><strong>发送缓冲区</strong></p>
<ul>
<li>形式：内存中的一个区域，落入缓冲区的分组<strong>可以发送</strong></li>
<li>功能：用于存放已发送，但是没有得到确认的分组(<strong>滑动窗口</strong>)</li>
<li>必要性：需要重发时可用</li>
</ul>
<p><strong>发送缓冲区的大小</strong>：一次最多可以发送多少个未经确认的分组</p>
<ul>
<li>停止等待协议=1</li>
<li>流水线协议&gt;1，合理的值，不能很大，链路利用率不能够超100%</li>
</ul>
<p><strong>发送缓冲区中的分组</strong></p>
<ul>
<li>未发送的：落入发送缓冲区的分组，可以连续发送出去；</li>
<li>已经发送出去的、等待对方确认的分组：发送缓冲区的分组只有得到确认才能删除</li>
</ul>
<p><strong>发送方:</strong></p>
<figure>
<img src="image-20241218162004733.png" alt="image-20241218162004733" /><figcaption aria-hidden="true">image-20241218162004733</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">［0, base - 1 ］段内的序号对应于已经发送并被确认的分组。</span><br><span class="line">［base, nextseqnum - 1 ］段内对应已经发送但未被确认的分组。</span><br><span class="line">［nextseqnum, base +N- 1 ］段内的序号能用于那些要被立即发送的分组</span><br><span class="line">大于或等于base + N的序号是不能使用的，直到当前流水线中未被确认的分组（特别是序号为base的分组）已得到确认为止</span><br></pre></td></tr></table></figure>
<ul>
<li>序号：k-bit seq # in pkt header。 k比特长度二进制数。</li>
<li>序号空间：可使用的序号范围，为<span class="math inline">\([0, 2^k-1]\)</span> 序号循环使用。</li>
<li>基序号(base)：最早已发送但未确认的数据片的序号。</li>
<li>下一个待发送序号(nextseqnum)：也称为<strong>最小未使用</strong>的序号。</li>
<li>窗口“ window ” ：发送缓冲区的一个范围,<strong>能被发送但还未确认的分组</strong>的许可序号范围。发送窗口的最大值&lt;=发送缓冲区的值</li>
<li>窗口长度N：窗口内序号的个数。 窗口尺寸:<span class="math inline">\((1,2^k-1]\)</span> ,k为序号的位数</li>
<li>GBN协议也被称为滑动窗口协议</li>
</ul>
<figure>
<img src="image-20241218163501491.png" alt="image-20241218163501491" /><figcaption aria-hidden="true">image-20241218163501491</figcaption>
</figure>
<p><strong>发送窗口的移动</strong>:</p>
<p>base移动向后移动:</p>
<ul>
<li>条件：收到老分组的确认</li>
<li>移动的极限：不能够超过nextsqnum</li>
</ul>
<p><strong>接收窗口</strong></p>
<ul>
<li>接收窗口用于控制哪些分组可以接收</li>
<li>只有收到的分组序号落入接收窗口内才允许接收 ,若序号在接收窗口之外，则丢弃；</li>
<li>GBN协议的接收窗口尺寸Wr=1，则只能顺序接收</li>
</ul>
<p><strong>滑动</strong>：</p>
<ul>
<li>只有接受窗口内要求的数据包到来才移动</li>
</ul>
<p><strong>发送确认</strong>：</p>
<ul>
<li>接收窗口尺寸=1 ； 发送连续收到的最大的分组确认（累计确认） （GBN）</li>
<li>接收窗口尺寸&gt;1 ； 收到分组，发送那个分组的确认（非累计确认)（SR协议）</li>
</ul>
<figure>
<img src="image-20241218164113789.png" alt="image-20241218164113789" /><figcaption aria-hidden="true">image-20241218164113789</figcaption>
</figure>
<p><strong>优缺点</strong></p>
<p>优点:</p>
<ul>
<li>接收方简单，不需要缓存任何失序的数据片，不需 要设置缓存。</li>
</ul>
<p>缺点：</p>
<ul>
<li>发送方需要设置缓存已发送但未确认的数据片，并维护 窗口的上下边界和nextseqnum。</li>
<li>由于失序而丢弃一个正确的数据片后，随后可能需要更 多的重传，包括之前删除的正确的失序数据片。</li>
<li>当窗口长度和带宽时延积很大时，单个数据片的错误就 能引起GBN重传大量数据片！导致传输效率大大降低。</li>
</ul>
<h3 id="选择重传sr">选择重传（SR）</h3>
<p><strong>发送窗口：</strong></p>
<figure>
<img src="image-20241218165254370.png" alt="image-20241218165254370" /><figcaption aria-hidden="true">image-20241218165254370</figcaption>
</figure>
<p><strong>发送窗口长度:范围在<span class="math inline">\((1,2^{k-1}]\)</span></strong></p>
<p><strong>发送窗口的移动</strong>:</p>
<p>base移动向后移动:</p>
<ul>
<li>条件：收到老分组的确认</li>
<li>移动的极限：不能够超过nextsqnum</li>
</ul>
<figure>
<img src="image-20241218170430234.png" alt="image-20241218170430234" /><figcaption aria-hidden="true">image-20241218170430234</figcaption>
</figure>
<p><strong>接受窗口:</strong></p>
<figure>
<img src="image-20241218170321635.png" alt="image-20241218170321635" /><figcaption aria-hidden="true">image-20241218170321635</figcaption>
</figure>
<ul>
<li>接收窗口用于控制哪些分组可以接收</li>
<li>只有收到的分组序号落入接收窗口内才允许接收 ,若序号在接收窗口之外，则丢弃；</li>
<li>SR的接受窗口尺寸&gt;1可以乱序接受</li>
</ul>
<p><strong>接受窗口滑动</strong>：</p>
<ul>
<li>低序号的分组到来，接收窗口移动</li>
<li>只有接受窗口内要求的数据包到来才移动</li>
<li>高序号分组乱序到，缓存但不交付（因为要实现rdt，不允许失序），不滑动</li>
</ul>
<figure>
<img src="image-20241218170649125.png" alt="image-20241218170649125" /><figcaption aria-hidden="true">image-20241218170649125</figcaption>
</figure>
<p>接收方<strong>发送确认</strong>：</p>
<ul>
<li>接收窗口尺寸&gt;1 ； 收到分组，发送那个分组的确认（非累计确认)</li>
</ul>
<figure>
<img src="image-20241218170851213.png" alt="image-20241218170851213" /><figcaption aria-hidden="true">image-20241218170851213</figcaption>
</figure>
<h3 id="gbn-vs.-sr">GBN vs. SR</h3>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 45%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">GBN</th>
<th style="text-align: center;">SR</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">发送窗口大小</td>
<td style="text-align: center;">$(1,2^k- 1] $</td>
<td style="text-align: center;"><span class="math inline">\((1,2^{k-1}]\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">接收窗口大小</td>
<td style="text-align: center;"><strong>=1</strong>,接收方只能顺序接收<br />发送方:一旦一个分组没有发成功，<br />如：0,1,2,3,4 ; 假如1未成功，234都发送出去 <br />了，要返回1再发送；GB1</td>
<td style="text-align: center;"><strong>&gt;1</strong>,接收方可以乱序接收<br />发送方发送0,1,2,3,4，<br />一旦1未成功，2,3,4,已发送，<br />无需重 发，选择性发送1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">确认</td>
<td style="text-align: center;">累计确认</td>
<td style="text-align: center;">选择确认</td>
</tr>
<tr class="even">
<td style="text-align: center;">定时器</td>
<td style="text-align: center;">发送端拥有对最老的未确认分组的定时器<br />当定时器到时时，重 传所有未确认分组</td>
<td style="text-align: center;">发送方为每个未确认的分组保持一个定时器<br />当超时定时器到时，只是 重发到时的未确认分组</td>
</tr>
</tbody>
</table>
<h2 id="面向连接的传输tcp">面向连接的传输:TCP</h2>
<ul>
<li>点对点：一个发送方、一个接收方</li>
<li>可靠的、按顺序的<strong>字节流</strong>，没有报文边界</li>
<li>管道化（流水线），TCP拥塞控制和流量控制设置窗口大小</li>
<li>有发送和接收缓存</li>
<li>全双工数据</li>
<li>面向连接</li>
<li>有流量控制，发送方不会淹没接收</li>
<li>逻辑连接，其共同状态仅保留在两个通信端系统的TCP程序中，TCP协议只在端系统中运行</li>
<li><strong>累计确认</strong></li>
</ul>
<p><strong>TCP建立连接的过程称为三次握手</strong></p>
<ol type="1">
<li>客户端首先发出一个建立TCP连接的特殊TCP报文段；</li>
<li>服务器用另一个特殊的TCP报文段来响应；</li>
<li>客户端再用第三个特殊TCP报文段作为对服务器响应报文的响应 ，同时可以承载有效载荷（即应用层数据）。</li>
</ol>
<p><strong>TCP传输数据的过程：</strong> 客户进程将要传输的数据流交给发送端套接字，然后数据流将开始由TCP控制，TCP将数据流引导到连接的发送缓存（三次握手时设置）里。 然后TCP将不时地从发送缓存里取出一块数据递交到网络层传输，每次从缓存取出放入报文段的<strong>数据量</strong>受<strong>最大报文段长度MSS</strong>限制注意到MSS是 指在报文段里<strong>应用层数据的最大长度</strong>，而不是指包括首部的TCP报文段的最大长度。</p>
<blockquote>
<p>MSS通常根据最初确定的由本地发送主机发送的<strong>最大链路层帧长度</strong>（即所谓的最大传输单元(MTU））来设置。设置该MSS要保证<strong>一个TCP 报文段（当封装在一个IP数据报中）加上TCP/IP首部长度（通常40字节）将适合单个链路层帧</strong>。以太网和PPP链路层协议都具有1500字节的MTU,因此MSS的<strong>典型值为1460 字节</strong>。</p>
</blockquote>
<p>TCP为每块客户数据配上一个TCP首部，从而形成多个TCP报文段（TCP segment）。 这些报文段被下传给网络层，网络层将其分别封装在网络层IP数据报中。然后这些IP数据报被发送到网络中。</p>
<p><strong>TCP接受数据过程：</strong></p>
<p>当TCP在另一端接收到一个报文段后，该报文段的数据就被放入该 TCP连接的接收缓存中，应用程序从此缓存中读取数据流。</p>
<h3 id="报文段">报文段</h3>
<figure>
<img src="image-20241218195546375.png" alt="image-20241218195546375" /><figcaption aria-hidden="true">image-20241218195546375</figcaption>
</figure>
<p><strong>序号和确认号</strong></p>
<p>TCP把数据看成一个无结构的、有序的字节流。序号是建立在<strong>传送的字节流</strong>之上，而不是建立在传送的报文段的序列之上。—个报文段的序号是该<strong>报文段首字节</strong>的<strong>字节流编号</strong></p>
<blockquote>
<p>如：假设主机A上的一个进程想通过一条TCP连接向主机B上的一个进程发送一 个数据流。主机A中的TCP将隐式地对数据流中的每一个字节编号。假定数据流由一个 包含500 000字节的文件组成，其MSS为1000字节，数据流的首字节编号是0。该TCP将为该数据流构建500个报文段。给第一个报文段分配序号0,第二个报文 段分配序号1000,第三个报文段分配序号2000,以此类推。每一个序号被填入到相应TCP 报文段首部的序号字段中。</p>
</blockquote>
<figure>
<img src="image-20241218195739741.png" alt="image-20241218195739741" /><figcaption aria-hidden="true">image-20241218195739741</figcaption>
</figure>
<p>TCP是全双工的, 因此主机A在向主机B发送数据的同时，也接收来自主机B的数据,从主机B到达的每个报文段中都有一个序号用于从B流向A的数据。主机A填充进报文段的<strong>确认号是主机A期望从主机B收到的下一字节的序号</strong>。</p>
<blockquote>
<p>假设主机A已收到了来自主机B的编号为0 ~535的所有字节，同时假设它打算发送一个报文段给主机B。主机A等待主机B的数据流中字节536及之后的所有 字节。所以主机A就会在它发往主机B的报文段的确认号字段中填上536。累计确认,</p>
</blockquote>
<ul>
<li>TCP采用累计确认的方式</li>
<li>TCP采取捎带应答：TCP对客户到服务器的数据的确认，被装载在一个服务器到客户的数据报文段中， 即使最后一个报文段里没有数据仍然有序号，报文格式需要</li>
<li>接收方如何处理乱序的报文段：没有规定</li>
</ul>
<h3 id="tcp往返延时和超时">TCP往返延时和超时</h3>
<blockquote>
<p>TCP采用超时/重传机制来处理报文段的丢失问题。</p>
<p>显然，超时间隔必须大于该连接的往返时间（RTT）否则会造成不 必要的重传,太长：对报文段丢失反应太慢，消极</p>
</blockquote>
<p><strong>估计往返时间RTT</strong></p>
<blockquote>
<p>在任意时刻，仅为一个<strong>已发送的但目前尚未被确认</strong>的报文段估计SampleRTT,从而产生一个接近每个RTT的新SampleRTT值。另外，TCP决不为<strong>已被重传的报文段</strong>计算SampleRTT；它仅为传输一次的报文段测量SampleRTT</p>
</blockquote>
<p>为了估计一个典型的RTT,自然要采取某种对SampleRTT取平均的办法。TCP维持一个SampleRTT均值 （称为EstimatedRTT）一旦获得一个新SampleRTT时，TCP就会根据下列公式来更新<code>EstimatedRTT</code> <span class="math display">\[
EstimatedRTT = (1 - a) * EstimatedRTT + a * SampleRTT ，a 一般取 0.125
\]</span> EstimatedRTT是一个SampleRTT值的加权平均值,这种平均被称为<strong>指数加权移动平均</strong></p>
<p><code>RTT偏差(DevRTT)</code> <strong>用于估算SampleRTT 一般会偏离EstimatedRTT的程度：</strong> <span class="math display">\[
DevRTT = (1 - \beta) * DevRTT + \beta* |SampleRTT - EstimatedRTT|，\beta 一般取 0.25
\]</span></p>
<p><code>设置超时TimeoutInterval</code></p>
<p>EstimtedRTT + 安全边界时间,若EstimatedRTT变化大 (方差大)那就采用 较大的安全边界时间 <span class="math display">\[
TimeoutInterval = EstimatedRTT + 4 * DevRTT
\]</span> 推荐的初始Timeoutinterval值为1秒</p>
<h3 id="tcp可靠数据传输">TCP:可靠数据传输</h3>
<ul>
<li>TCP在IP不可靠服务的基础上 建立了可靠数据传输:无损坏、 无间隙、非冗余、按序
<ul>
<li>管道化的报文段</li>
<li>累计确认</li>
<li>单个重传定时器,定时器管理的开销很大</li>
<li>没有规定是否可以接受乱序</li>
</ul></li>
<li>通过以下事件触发<strong>重传</strong>
<ul>
<li>超时（<strong>只重发那个最早的未确认段</strong>：SR)</li>
<li>重复的确认,连续3个冗余ACK</li>
</ul></li>
</ul>
<figure>
<img src="image-20241218202351615.png" alt="image-20241218202351615" /><figcaption aria-hidden="true">image-20241218202351615</figcaption>
</figure>
<figure>
<img src="image-20241218203617974.png" alt="image-20241218203617974" /><figcaption aria-hidden="true">image-20241218203617974</figcaption>
</figure>
<ul>
<li>对于右图:当超时事件发生时，主机A重传序号92的第一个报文段，并重启定时器。只要第二个报文段的ACK在新的超时发生以前到达，则第二个报文段将不会被重传。</li>
<li>对顺序收到的最高字节确认</li>
</ul>
<figure>
<img src="image-20241218203821356.png" alt="image-20241218203821356" /><figcaption aria-hidden="true">image-20241218203821356</figcaption>
</figure>
<figure>
<img src="image-20241218204153435.png" alt="image-20241218204153435" /><figcaption aria-hidden="true">image-20241218204153435</figcaption>
</figure>
<h3 id="tcp快速重传">TCP快速重传</h3>
<blockquote>
<p>超时触发重传存在的问题之一是超时周期可能相对较长。当一个报文段丢失时, 这种长超时周期迫使发送方延迟重传丢失的分组，因而增加了端到端时延。<strong>解决方法便是快速重传</strong></p>
</blockquote>
<figure>
<img src="image-20241218203951089.png" alt="image-20241218203951089" /><figcaption aria-hidden="true">image-20241218203951089</figcaption>
</figure>
<p>如果TCP发送方接收到对相同数据的<strong>3个冗余ACK</strong>,它 把这当作一种指示，说明跟在这个已被确认过3次的报文段之后的报文段已经丢失。一旦收到3个冗余ACK, TCP就执行快速重传,即 在该报文段的<strong>定时器过期</strong>之前<strong>重传</strong>丢失的报文段。</p>
<h3 id="流量控制">流量控制</h3>
<blockquote>
<p>流量控制：是一个<strong>速度匹配</strong>服务，使得<strong>发送方速率与接收方速率</strong>向匹配， 不至于导致接收方缓存溢出</p>
<p>拥塞控制：因IP网络拥塞而限制发送方的发送速率。</p>
</blockquote>
<figure>
<img src="image-20241218205254802.png" alt="image-20241218205254802" /><figcaption aria-hidden="true">image-20241218205254802</figcaption>
</figure>
<figure>
<img src="image-20241218205435689.png" alt="image-20241218205435689" /><figcaption aria-hidden="true">image-20241218205435689</figcaption>
</figure>
<ul>
<li>主机 B 把当前 <code>rwnd</code> 值放入它发送给主机 A 的报文段接收窗口字段中，通知主机 A 它在该连接的缓存中还有多少可用空间</li>
<li>主机 A 需要保证 <code>LastByteSend - LastByteAcked &lt;= rwnd</code>，控制主机 A 已发送未确认的数据量在 <code>rwnd</code> 之内</li>
<li>特殊情况：当主机 B <code>rwnd = 0</code> ，且通知主机 A 之后，假设主机 B 之后没有任何数据发送给主机 A，则主机 A 被阻塞，它认为主机 B 的 <code>rwnd</code> 一直为 0，即主机 B <code>rwnd</code> 非 0 的信息无法通知给主机 A。为了解决这个问题， TCP 规范中要求 当主机 B 的接收窗口为 0 时，主机 A 继续发送只有一个字节数据的报文段。这些报文段将会被接收方确认。最终缓存将开始清空，并且确认报文里将包含一个非 0 的 <code>rwnd</code> 值。</li>
</ul>
<h3 id="tcp连接管理">TCP连接管理</h3>
<p>在正式交换数据之前，发送方和接收方握手建立通信关系:</p>
<ul>
<li>同意建立连接（每一方都知道对方愿意建立连接）</li>
<li>同意连接参数</li>
</ul>
<figure>
<img src="image-20241218205550448.png" alt="image-20241218205550448" /><figcaption aria-hidden="true">image-20241218205550448</figcaption>
</figure>
<figure>
<img src="image-20241218205825927.png" alt="image-20241218205825927" /><figcaption aria-hidden="true">image-20241218205825927</figcaption>
</figure>
<p><strong>三次握手建立连接</strong></p>
<figure>
<img src="image-20241218210123442.png" alt="image-20241218210123442" /><figcaption aria-hidden="true">image-20241218210123442</figcaption>
</figure>
<ol type="1">
<li>客户端的TCP首先向服务器端的TCP发送一个特殊的TCP报文段。该报文段中不包含应用层数据.报文段的首部中的一个标志位 （即SYN比特）被置为1,并且客户端会随机地选择一个初始序号,并将此编号放置于该起始的TCP SYN 报文段的序号字段中,这个特殊报文段被称为SYN报文段</li>
<li>服务器会从该数据报中提取出TCP SYN报文段，为该TCP连接分配<strong>TCP缓存和变量</strong>，并向该客户TCP发送<strong>允许连接</strong>的报文段。这个允许连接的报文段也不包含应用层数据,SYN比特被置为1,该TCP报文段 首部的确认号字段被置为client _ isn + 1,服务器选择自己的初始序号,并将其放置到TCP报文段首部的序号字段中。该允许连接的报 文段被称为SYNACK报文段</li>
<li>在收到SYNACK报文段后，客户也要给该连接分配缓存和变量。客户主机则向服务器发送另外一个报文段；这最后一个报文段对服务器的允许连接的报文段进行了确认（该客户通过将值server_isn + 1放置到TCP报文段首部的确认字段中来完成此项工作）。因为连接已经建立了，所以该SYN比特被置为0。该三次 握手的第三个阶段可以在报文段负载中携带客户到服务器的数据。</li>
</ol>
<p><strong>四次挥手关闭连接</strong></p>
<figure>
<img src="image-20241218210729991.png" alt="image-20241218210729991" /><figcaption aria-hidden="true">image-20241218210729991</figcaption>
</figure>
<ul>
<li>第一步：客户 TCP 向服务器进程发送一个特殊 TCP 报文段，在首部中设置 <code>FIN</code> 标志 为 <code>1</code></li>
<li>第二步：服务器发送回一个确认报文段</li>
<li>第三步：服务器发送终止报文段，在首部中设置 <code>FIN</code> 标志 为 <code>1</code></li>
<li>第四步：客户对服务器的终止报文段进行确认</li>
</ul>
<h3 id="拥塞控制原理">拥塞控制原理</h3>
<p>原因：发送方发送速度过快，网络来不及处理</p>
<p>拥塞的表现:</p>
<ul>
<li>分组丢失 (路由器缓冲区溢出)</li>
<li>分组经历比较长的延迟(在路由器的队列中排队)</li>
</ul>
<p>代价:</p>
<ul>
<li>为了达到一个有效输出，网络需要做更多的工作（重传）</li>
<li>没有必要的重传，链路中包括了多个分组的拷贝</li>
<li>当分组丢失时，任何“关于这个分组的上游传输能力” 都被浪费了</li>
</ul>
<p>拥塞控制方法:</p>
<figure>
<img src="image-20241218211714742.png" alt="image-20241218211714742" /><figcaption aria-hidden="true">image-20241218211714742</figcaption>
</figure>
<h1 id="网络层数据平面">网络层:数据平面</h1>
<figure>
<img src="image-20241219103014047.png" alt="image-20241219103014047" /><figcaption aria-hidden="true">image-20241219103014047</figcaption>
</figure>
<figure>
<img src="image-20241219113403807.png" alt="image-20241219113403807" /><figcaption aria-hidden="true">image-20241219113403807</figcaption>
</figure>
<h2 id="概述">概述</h2>
<ul>
<li>因特网中所有主机和交换设备都有网络层功能。</li>
<li>网络层解决如何实现<strong>主机到主机</strong>的通信,在发送主机和接收主机对之间传送段（segment）。</li>
<li>将网络层分为<strong>数据平面</strong>和<strong>控制平面</strong>:
<ul>
<li><strong>数据平面</strong>，<strong>每台路由器</strong>的功能，决定达到路由器输入链路的数据报如何<strong>转发</strong>到该路由器的输出链路之一。<strong>硬件完成,纳秒级</strong>
<ul>
<li>IP转发，基于数据报携带的目的地址；</li>
<li>通用转发，使用数据报首部的几个不同域值执行转发</li>
</ul></li>
<li>控制平面，也是<strong>每台路由器或集中服务器</strong>的功能，控制数据报沿着源主机到目的主机的端到端路径中路由器之间的<strong>路由方式</strong>,<strong>软件完成,毫秒级</strong>
<ul>
<li>传统方法:路由选择算法，<strong>OSPF</strong>、<strong>BGP</strong></li>
<li>软件定义的网络SDN，控制平面置于一台远程控制器</li>
</ul></li>
</ul></li>
<li>网络层的功能就是转发和路由</li>
</ul>
<h3 id="网络服务模型">网络服务模型</h3>
<blockquote>
<p>定义了分组在发送与接收端之间的端到端传输特性</p>
</blockquote>
<p>因特网的网络层只提供了单一的服务，称为<strong>尽力而为</strong>服务,即:传送的分组既不能保证以它们发送的顺序被接收，也不能保证它们最终交付；既不能保证端到端时延，也不能保证有最小的带宽</p>
<h2 id="路由器组成">路由器组成</h2>
<blockquote>
<ul>
<li><strong>分组交换机</strong>：指一台通用分组交换设备，根据分组首部字段中的值，从输入链路接口到输出链路接口转移分组，是<strong>第三层设备</strong>。</li>
<li><strong>路由器</strong>：基于网络层数据报（分组）的首部字段做 出转发决定，是第<strong>三层设备</strong>。</li>
<li><strong>链路层交换机</strong>：基于<strong>链路层</strong>帧的首部字段做出转发决定，是<strong>第二层设备</strong>。</li>
</ul>
</blockquote>
<p><strong>通用路由器的体系结构包含四个组件：输入端口、交换结构、输出端口、路由选择处理器</strong></p>
<figure>
<img src="image-20241219104147119.png" alt="image-20241219104147119" /><figcaption aria-hidden="true">image-20241219104147119</figcaption>
</figure>
<h3 id="输入端口">输入端口</h3>
<figure>
<img src="image-20241219104537377.png" alt="image-20241219104537377" /><figcaption aria-hidden="true">image-20241219104537377</figcaption>
</figure>
<ul>
<li>绿色框完成物理层功能，接收比特流信号；</li>
<li>蓝色框完成数据链路层功能，CRC校验、解封帧；</li>
<li>红色框完成网络层功能，查找转发表决定转发的路由器输出端口。</li>
<li>路由器支持的端口数量范围较大，几个到ISP的几百个10Gbp</li>
</ul>
<p><strong>[基于目标的转发/基于目的地的转发]</strong></p>
<blockquote>
<p><strong>最长前缀匹配规则</strong>:当给定目标地址查找转发表时，采用<strong>最长地址前缀匹配</strong>的目标地址表项</p>
</blockquote>
<figure>
<img src="image-20241219105520950.png" alt="image-20241219105520950" /><figcaption aria-hidden="true">image-20241219105520950</figcaption>
</figure>
<p><strong>在路由器中经常采用TCAMs<code>硬件</code>来完成</strong></p>
<p><strong>[输入端口缓存]</strong></p>
<ul>
<li>当交换机构的速率小于输入端口的汇聚速率时,在输入端口可能要排队</li>
<li><code>Head-of-the-Line (HOL) blocking</code>: 排在队头的数据报 阻止了队列中其他数据报向前移动</li>
</ul>
<h3 id="交换结构">交换结构</h3>
<blockquote>
<p>作用: 将路由器的<strong>输入端口连接到输出端口</strong>，根据<strong>查询转发表</strong>的结果将到达的分组通过路由器的交换结构<strong>转发</strong>到输出端口</p>
</blockquote>
<p><code>交换速率</code>：分组可以按照该速率从输入传输到输 出</p>
<ul>
<li>运行速度经常是输入/输出链路速率的若干倍</li>
<li>如果有N 个输入端口那么交换机构的交换速度是输入线路速度的<strong>N倍</strong>比较理想，才不会成为瓶颈</li>
</ul>
<p><strong>三种典型的交换机构</strong>:</p>
<figure>
<img src="image-20241219110021471.png" alt="交换机构" /><figcaption aria-hidden="true">交换机构</figcaption>
</figure>
<p><strong>[通过内存交换]</strong></p>
<figure>
<img src="image-20241219111255929.png" alt="image-20241219111255929" /><figcaption aria-hidden="true">image-20241219111255929</figcaption>
</figure>
<p><strong>[通过总线交换]</strong></p>
<figure>
<img src="image-20241219111335065.png" alt="image-20241219111335065" /><figcaption aria-hidden="true">image-20241219111335065</figcaption>
</figure>
<p><strong>[通过互联网络的交换]</strong></p>
<figure>
<img src="image-20241219111410219.png" alt="image-20241219111410219" /><figcaption aria-hidden="true">image-20241219111410219</figcaption>
</figure>
<p><code>纵横式交换机</code>就是一种由2N条总线组成的互联网络，它连接N个输入端口 与N个输岀端口,每条垂直的总线在交叉点与每条水平的总线交叉, <code>交叉点</code>通过<code>交换结构控制器</code>（其逻辑是交换结构自身的一部分）能够在任何时候开启和闭合,纵横式网络能够<code>并行</code>转发多个分组。纵横式交换机是<code>非阻塞</code>的</p>
<p>然而，如果来自两个不同输入端口的两个 分组其<code>目的地</code>为<code>相同输出端口</code>，则一个分组必须在输入端等待，因为在某个时刻经给定总线仅能够发送一个分组</p>
<h3 id="输出端口">输出端口</h3>
<ul>
<li>从交换结构接收分组，并执行必要的链路层和物理层功能，然后在输出链路上发送出去这些分组。</li>
<li>取出已经存放在输出端口内存中的分组并将其发送到输出链路上,涉及到<code>选择</code></li>
<li>当一条链路是双向传输数据时，输入端口与输出端口成对出现在同一线路卡上</li>
</ul>
<figure>
<img src="image-20241219111639029.png" alt="image-20241219111639029" /><figcaption aria-hidden="true">image-20241219111639029</figcaption>
</figure>
<ul>
<li>当数据报从交换机构的<strong>到达速度</strong>比<strong>传输速率</strong>快 就需要<strong>输出端口缓存</strong></li>
<li>由<strong>调度规则</strong>选择排队的数据报进行传</li>
</ul>
<figure>
<img src="image-20241219112836002.png" alt="image-20241219112836002" /><figcaption aria-hidden="true">image-20241219112836002</figcaption>
</figure>
<p><strong>[调度规则]</strong></p>
<p><code>调度</code>: 选择下一个要通过链路传输的分组</p>
<p><strong>FIFP:</strong>按照分组到来的次序发送,</p>
<p>丢弃策略: 如果分组到达一个满的队列，哪个分组将会 被抛弃? tail drop: 丢弃刚到达的分组 priority: 根据优先权丢失/移除分组 random: 随机地丢弃/移除</p>
<figure>
<img src="image-20241219113128679.png" alt="image-20241219113128679" /><figcaption aria-hidden="true">image-20241219113128679</figcaption>
</figure>
<p><strong>优先权排队(非抢占):</strong>发送最高优先权的分组</p>
<p>多类，不同类别有不同的 优先权</p>
<p>类别可能依赖于标记或者其 他的头部字段,</p>
<p>先传高优先级的队列中的分 组，除非没有</p>
<p>高（低）优先权中的分组传 输次序：FIFO</p>
<figure>
<img src="image-20241219113116939.png" alt="image-20241219113116939" /><figcaption aria-hidden="true">image-20241219113116939</figcaption>
</figure>
<p><strong>循环排队RR</strong>: 多类  循环扫描不同类型的队列, 发送完一类的一个分组 ，再发送下一个类的一个分组，循环所有类</p>
<p><strong>加权公平排队</strong></p>
<figure>
<img src="image-20241219113105857.png" alt="image-20241219113105857" /><figcaption aria-hidden="true">image-20241219113105857</figcaption>
</figure>
<ul>
<li>循环排队：分组分类，每个类循环传输，任何时间间隔收到相同数量的服务</li>
<li>加权公平排队：每个类在任何时间间隔内可能收到不同数量的服务</li>
</ul>
<h3 id="路由选择处理器">路由选择处理器</h3>
<ul>
<li><strong>维护路由选择表与关联链路状态信息</strong>，为该路由器<strong>计算转发表（</strong>或者在SDN路由器中负责与远程控制器通信），并在路由器是输入端口红框中<strong>下发计算结果</strong>即转发表</li>
<li>路由器的<strong>输入/输出端口</strong>和<strong>交换结构</strong>都是由<strong>硬件</strong>实现的</li>
</ul>
<h2 id="ip">IP</h2>
<h3 id="ipv4数据报格式">IPV4数据报格式</h3>
<figure>
<img src="image-20241219113502648.png" alt="image-20241219113502648" /><figcaption aria-hidden="true">image-20241219113502648</figcaption>
</figure>
<ul>
<li>版本:IP协议版本号</li>
<li>首部长度：一般的 IP 数据报具有 <strong>20 字节的首部</strong>。</li>
<li>服务类型：使不同类型的 IP 数据报能相互区分开。</li>
<li>数据报长度：IP 数据报总长度（首部 + 数据），字节为单位。</li>
<li>标识，标志，片偏移：与 IP 分片有关。</li>
<li>上层协议：指示了一个到达的 IP 数据报的数据部分应该交给哪个<strong>特定的运输层协议</strong>。例如，<code>6</code> 表明给 <code>TCP</code>，<code>17</code> 表明给 <code>UDP</code></li>
<li>首部校验和：用于帮助路由器检测收到的 IP 数据报中的比特错误</li>
<li>选项：扩展首部，IPv4 首部大小可变，不定长</li>
<li>一个 IP 数据报具有总长为 20 字节的首部，如果数据报承载了一个 TCP 报文段，则每个数据报共承载了总长 40 字节的首部以及应用层报文</li>
</ul>
<p><strong>IP数据包传输TCP段时的头部有40字节:TCP(20字节)+IP(20字节)</strong></p>
<h3 id="ip数据报分片与装配">IP数据报分片与装配</h3>
<ul>
<li><code>最大传输单元MTU</code>:一个<strong>链路层</strong>的帧能承载的最大数据量</li>
<li><strong>链路层</strong>MTU<strong>限制IP分组</strong>长度</li>
<li>不同的链路层协议具有不同的 MTUs，例如以太网是1500字节，某些广域网链路是576字节。</li>
</ul>
<p>因此,大的IP数据报在网络上被<strong>分片</strong>:</p>
<blockquote>
<ul>
<li><strong>一个数据报被分割成若干个小的数据报:相同的ID 不同的偏移量 最后一个分片标记为0</strong></li>
<li>“重组”只在<strong>最终的目标主机</strong>进行</li>
<li>IP头部的信息被用于标识，排序相关分片</li>
</ul>
</blockquote>
<figure>
<img src="image-20241219143210876.png" alt="image-20241219143210876" /><figcaption aria-hidden="true">image-20241219143210876</figcaption>
</figure>
<p>源主机发送分组时给<strong>每个分组</strong>添加<strong>标识</strong>，标识号依次+1。</p>
<p>当中间某个路由器需要分片时，<strong>按8个字节的倍数</strong>分片：同一个分组 的每个分片具有相同的号；标志位置为1/最后一个置0；偏移量指明分片在分组的起始位置</p>
<h3 id="ipv4编址">IPv4编址</h3>
<p>主机与物理链路之间的边界叫作<code>接口</code>。</p>
<ul>
<li>一台路由器有多个接口,主机也有可能有多个接口</li>
<li>IP要求每台主机和路由器接口拥有自己的IP地址</li>
<li><strong>一个IP 地址与一个接口相关联</strong></li>
</ul>
<p><code>IP地址</code>:32位,对主机或者路由器的接口编址,用点分十进制表示</p>
<ul>
<li><p>子网部分(高位bits)</p></li>
<li><p>主机部分(低位bits)</p></li>
</ul>
<p><code>子网</code>: 每个互相隔离的网络成为 一个子网 subnet</p>
<ul>
<li>一个子网内的节点（主机或者路由器）它们的IP地址的<strong>高位部分</strong>相同 ，这些节点构成的网络 的一部分叫做子网</li>
<li>无需路由器介入，子网内各主机可以在物理上相互直接到达</li>
</ul>
<p><code>子网号</code>223.1.1.0/24为一个子网号</p>
<p><code>子网掩码</code> 通常指示了IP地址中哪些位是子网号，可以用/24， 也可以表示为255.255.255.0 = 11111111 11111111 11111111 00000000</p>
<h3 id="cidr无类别域间路由选择">CIDR无类别域间路由选择</h3>
<p>因特网的<strong>IP地址分配</strong>策略称为<strong>无类别域间路由策略</strong></p>
<ul>
<li>32位的IP地址被划分为两部分</li>
<li>a.b.c.d/x, x指示了IP地址的子网部分的比特数，即IP地址中前x位为子网号，也称为IP地址的前缀， 或网络前缀,剩余 <code>32 - x</code> 比特是用于区分子网内部设备的主机地址。</li>
<li>一个接入因特网的组织通常被分配一块连续的地址，即具有相同前缀的一块地址</li>
<li>路由器的转发表，在搜索时也是匹配网络号</li>
</ul>
<p><strong>分类编址</strong>：在 CIDR 被采用之前， IP 地址的网络部分被限制为长度为 8、16 或 24 比特。具有 8、16、24 比特子网地址的子网分别被称为 A、B、C 类网络。</p>
<figure>
<img src="image-20241219223145187.png" alt="image-20241219223145187" /><figcaption aria-hidden="true">image-20241219223145187</figcaption>
</figure>
<ul>
<li>当一台主机发出一个目的地址为<code>255. 255. 255. 255</code>的数据报时，该报文会交付给同一个网络中的所有主机</li>
<li>子网部分: 全为 0---本网络 主机部分: 全为0---本主机</li>
</ul>
<figure>
<img src="image-20241219144810360.png" alt="image-20241219144810360" /><figcaption aria-hidden="true">image-20241219144810360</figcaption>
</figure>
<figure>
<img src="image-20241219144834223.png" alt="image-20241219144834223" /><figcaption aria-hidden="true">image-20241219144834223</figcaption>
</figure>
<figure>
<img src="image-20241219145012828.png" alt="image-20241219145012828" /><figcaption aria-hidden="true">image-20241219145012828</figcaption>
</figure>
<h3 id="dhcp动态主机配置协议">DHCP:动态主机配置协议</h3>
<p><strong>目标: 允许主机在加入网络的时候，动态地从服务器那里获得IP地址</strong></p>
<ul>
<li>可以更新对主机在用IP地址的租用期-租期快到了</li>
<li>重新启动时，允许重新使用以前用过的IP地址</li>
<li>支持移动用户加入到该网络（短期在网）</li>
<li>即插即用、零配置，自动工作</li>
<li>是一个客户-服务器协议,使用DHCP协议分配IP地址的子网 内通常有一台DHCP服务器；如果没有服务器则需要一个 DCHP中继代理（通常也是一台路由器），代理知道该子网的DHCP服务器的地址</li>
</ul>
<p><strong>DHCP的4个步骤:</strong></p>
<ul>
<li><strong>DHCP 服务器发现</strong>：新到达的主机向子网<strong>广播</strong> 即 “DHCP discover ” msg [optional]来发现一个DHCP服务器，客户主机在<strong>UDP分组</strong>中向<strong>端口67</strong>发送该<strong>发现报文</strong>，使用 广播<strong>目的地址255.255.255.255和源地址0.0.0.0</strong></li>
<li><strong>DHCP 服务器提供</strong>：DHCP 服务器<strong>广播</strong> <strong>DHCP 提供报文</strong>,该报文向该子网的所有节点广播，仍然使用<strong>IP广播地址255. 255. 255. 255</strong>,每台服务器提供的报文包含有收到的<strong>发现报文的事务ID</strong>、向客户推荐的<strong>IP地址</strong>、<strong>网络掩码</strong>以及<strong>IP地址租用期</strong> , 即IP地址有效的时间量。服务器租用期通常设置为几小时或几 天</li>
<li><strong>DHCP 请求</strong>：客户选择一个服务器提供，<strong>广播</strong> <strong>DHCP 请求报文</strong>，指定选择的 DHCP 服务器 ID</li>
<li><strong>DHCP ACK</strong>：服务器使用 <code>DHCP ACK 报文</code>对 DHCP 请求报文进行响应，<strong>广播</strong></li>
</ul>
<figure>
<img src="image-20241219150921894.png" alt="image-20241219150921894" /><figcaption aria-hidden="true">image-20241219150921894</figcaption>
</figure>
<p><strong>DHCP 返回:</strong></p>
<ul>
<li>IP 地址</li>
<li>第一跳路由器的IP地址（默认网关）</li>
<li>DNS服务器的域名和IP地址</li>
<li>子网掩码 (指示地址部分的网络号和主机号)</li>
</ul>
<figure>
<img src="image-20241219151102178.png" alt="image-20241219151102178" /><figcaption aria-hidden="true">image-20241219151102178</figcaption>
</figure>
<figure>
<img src="image-20241219151119687.png" alt="image-20241219151119687" /><figcaption aria-hidden="true">image-20241219151119687</figcaption>
</figure>
<h3 id="nat-网络地址转换">NAT: 网络地址转换</h3>
<figure>
<img src="image-20241219151327710.png" alt="image-20241219151327710" /><figcaption aria-hidden="true">image-20241219151327710</figcaption>
</figure>
<p><strong>动机: 本地网络只有一个有效IP地址:</strong></p>
<ul>
<li>不需要从ISP分配一块地址，可用一个IP地址用于所有的（局域网）设备--省钱</li>
<li>可以在局域网改变设备的地址情况下而无须通知外界</li>
<li>可以改变ISP（地址变化）而不需要改变内部的设备地址</li>
<li>局域网内部的设备没有明确的地址，对外是不可见的--安全</li>
</ul>
<figure>
<img src="image-20241219153435835.png" alt="image-20241219153435835" /><figcaption aria-hidden="true">image-20241219153435835</figcaption>
</figure>
<figure>
<img src="image-20241219153511388.png" alt="image-20241219153511388" /><figcaption aria-hidden="true">image-20241219153511388</figcaption>
</figure>
<figure>
<img src="image-20241219153708111.png" alt="image-20241219153708111" /><figcaption aria-hidden="true">image-20241219153708111</figcaption>
</figure>
<h3 id="ipv6">IPv6</h3>
<p><strong>初始动机: 32-bit地址空间将会被很快用完</strong></p>
<p>另外的动机:</p>
<ul>
<li>头部格式改变帮助加速处理和转发</li>
<li>TTL-1</li>
<li>头部checksum</li>
<li>分片</li>
<li>头部格式改变帮助QoS</li>
</ul>
<figure>
<img src="image-20241219153945792.png" alt="image-20241219153945792" /><figcaption aria-hidden="true">image-20241219153945792</figcaption>
</figure>
<p>相对于IPv4主要的变化:</p>
<ul>
<li><strong>扩大的地址容量</strong>。IPv6将IP地址长度 从32比特增加到128比特</li>
<li>简化高效的40字节首部,<strong>40字节定长首部</strong>允许路由器更快地处理IP数据报</li>
<li>流标签</li>
<li><strong>不允许分片</strong>,中间路由器不允许对分组进行分片，如果收 到了过大的分组不能转发到输出链路上只需要将其<strong>丢弃</strong>，<strong>分组的分片和重新装配只能在源/目的端进行</strong></li>
<li><strong>取消校验和</strong> checksum: 传输层和数据链路层都有这个功能，而且由于TTL字段的存在导致校验和在每个路由器需要重新计算再 写入，影响了路由器的快速转发</li>
<li>选项 options: 没有完全取消，如果需要可在“下一个首部”字段 中指出</li>
<li>ICMPv6: ICMP的新版本
<ul>
<li>附加了报文类型, e.g. “Packet Too Big”</li>
<li>多播组管理功能</li>
</ul></li>
</ul>
<p><strong>IPv4迁移到IPv6</strong></p>
<p><strong>IPv6向后兼容</strong>，在IPv6系统里可以转发IPv4分组；但<strong>IPv4系统里却不可以转发IPv6分组</strong></p>
<p><code>隧道</code>: 在<strong>IPv4路由器之间</strong>传输的<strong>IPv4数据报中携带IPv6数据报</strong></p>
<figure>
<img src="image-20241219154503178.png" alt="image-20241219154503178" /><figcaption aria-hidden="true">image-20241219154503178</figcaption>
</figure>
<figure>
<img src="image-20241219154539737.png" alt="image-20241219154539737" /><figcaption aria-hidden="true">image-20241219154539737</figcaption>
</figure>
<h1 id="网络层控制平面">网络层:控制平面</h1>
<p>2种构建网络控制平面功能的方法:</p>
<ul>
<li>每个路由器控制功能实现（传统）</li>
<li>逻辑上集中的控制功能实现(SDN)</li>
</ul>
<h2 id="路由选择算法">路由选择算法</h2>
<p><code>路由</code>:按照<strong>某种指标</strong>(传输延迟,所经过的站点数目等)找到一条从源节点到目标节点的<strong>较好路径</strong></p>
<p>以<strong>网络</strong>为单位进行路由（路由信息通告+路由计算）</p>
<p><strong>分类:</strong></p>
<ol type="1">
<li>算法是集中式还是分散式来划分
<ul>
<li>集中式路由选择算法: 所有的路由器拥有完整的拓扑和边的代价的信息 eg : “link state”</li>
<li>分散式路由选择算法:
<ul>
<li>路由器只知道与它有<strong>物理连接关系</strong>的<strong>邻居路由器</strong>，和到相应邻居路由器的代价值</li>
<li>迭代式地与邻居交换路由信息、 计算路由信息 “distance vector”</li>
</ul></li>
</ul></li>
<li>静态或者动态
<ul>
<li>静态路由选择算法:路由随时间变化缓慢,通常是人工-进行调整（如人为手工编辑一条链路开销）</li>
<li>动态路由选择算法:路由变化很快,周期性更新,响应拓扑和开销变化</li>
</ul></li>
</ol>
<h3 id="链路状态路由算法link-state">链路状态路由算法(link state)</h3>
<ul>
<li>各点通过各种渠道获得<strong>整个网络拓扑</strong>, 网络中<strong>所有链路</strong>代价等信息</li>
<li>使用LS路由算法,计算本站点到其它站点的最优路径,得到路由表</li>
</ul>
<figure>
<img src="image-20241220114632817.png" alt="image-20241220114632817" /><figcaption aria-hidden="true">image-20241220114632817</figcaption>
</figure>
<p><strong>[Dijsktra算法]</strong></p>
<p>链路状态路由选择算法的其中一种</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   Initialization:</span><br><span class="line">	N<span class="comment">&#x27; = &#123;u&#125;</span></span><br><span class="line">	<span class="keyword">for</span> all nodes v</span><br><span class="line">	<span class="keyword">if</span> v is a neighbor of u</span><br><span class="line">		<span class="keyword">then</span> D(v) = c(u,v)</span><br><span class="line">		<span class="keyword">else</span> D(v) = INF</span><br><span class="line"></span><br><span class="line">   Loop</span><br><span class="line">	find w <span class="keyword">not</span> in N<span class="comment">&#x27; such that D (w) is a minimum</span></span><br><span class="line">	add w <span class="keyword">to</span> N<span class="comment">&#x27;</span></span><br><span class="line">	update D(v) <span class="keyword">for</span> each neighbor v of w <span class="keyword">and</span> <span class="keyword">not</span> in N<span class="comment">&#x27;</span></span><br><span class="line">		D (v) = min (D (v) , D (w) + c (w , v))</span><br><span class="line">/* <span class="keyword">new</span> cost <span class="keyword">to</span> v is either old cost <span class="keyword">to</span> v <span class="keyword">or</span> known</span><br><span class="line">least path cost <span class="keyword">to</span> w plus cost from w <span class="keyword">to</span> v */</span><br><span class="line">	</span><br><span class="line">    until N<span class="comment">&#x27;= N</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="image-20241220115134276.png" alt="image-20241220115134276" /><figcaption aria-hidden="true">image-20241220115134276</figcaption>
</figure>
<figure>
<img src="image-20241220115150513.png" alt="image-20241220115150513" /><figcaption aria-hidden="true">image-20241220115150513</figcaption>
</figure>
<p><strong>算法复杂度:</strong> <span class="math inline">\(O(n^2 )\)</span>可以降到<span class="math inline">\(O(n\log n)\)</span></p>
<p><strong>存在路由震荡问题</strong></p>
<h3 id="距离向量dv路由选择算法">距离向量DV路由选择算法</h3>
<ul>
<li>迭代的,交换信息并重新计算的过程要一直持续到邻居之间 无更多信息要交换位置（链路状态稳定后自停止）</li>
<li>异步的,不要求所有节点相互之间步伐一致地操作。</li>
<li>分布式,每个节点要从一个或多个直接相连的邻居交换某 些信息，并执行计算</li>
</ul>
<p><strong>Bellman- Ford方程:</strong></p>
<p>令<span class="math inline">\(d_x(y)\)</span>是从节点x到节点y的最低开销路径的开销 <span class="math display">\[
d_x(y) = \min_v\{c(x,v) + d_v(y) \}
\]</span> 方程中的<span class="math inline">\(\min_v\)</span>是对于x的所有邻居的</p>
<figure>
<img src="image-20241220134105143.png" alt="image-20241220134105143" /><figcaption aria-hidden="true">image-20241220134105143</figcaption>
</figure>
<figure>
<img src="image-20241220134226740.png" alt="image-20241220134226740" /><figcaption aria-hidden="true">image-20241220134226740</figcaption>
</figure>
<p>节点x真正需要知道的不是到y的最短路径距离，而是沿着最短路径到y的 下一跳路由器邻居节点<span class="math inline">\(v^*(y)\)</span>。</p>
<figure>
<img src="image-20241220134533654.png" alt="image-20241220134533654" /><figcaption aria-hidden="true">image-20241220134533654</figcaption>
</figure>
<p><strong>DV的无穷计数问题</strong></p>
<blockquote>
<p>遇到<strong>路由选择环路</strong>，当某链路开销突变，节点计算新的最低开销需要之前其他节点计算得出的链路开销信息，而该信息可能已经无效了，因为链路开销发生了突变，相当于在错误的开销上更新开销，一错再错。</p>
</blockquote>
<p>坏消息的传播速度非常慢,好消息传得快</p>
<p>毒性逆转解决</p>
<figure>
<img src="image-20241220134941881.png" alt="image-20241220134941881" /><figcaption aria-hidden="true">image-20241220134941881</figcaption>
</figure>
<figure>
<img src="image-20241220135051006.png" alt="image-20241220135051006" /><figcaption aria-hidden="true">image-20241220135051006</figcaption>
</figure>
<h2 id="因特网中自治系统内部的路由选择intra-as">因特网中自治系统内部的路由选择(intra-AS)</h2>
<p>在相同AS中的路由器都运行相同的路由选择算法并且有彼此的信息。在一个自治系统内运行的路由选择算法叫作自治系统内部路由选择协议</p>
<h3 id="开放最短路优先ospf">开放最短路优先OSPF</h3>
<p>“open”: 标准可公开获得</p>
<p>OSPF是一种链路状态协议，它使用洪泛链路状态信息和Dijkstra最低开销路径算法。</p>
<p>使用 <code>OSPF</code> ，一台路由器构建了一幅关于整个自治系统的完整拓扑图。于是，每台路由器在本地运行 <code>Dijkstra</code> 的最短路径算法，以确定一个以自身为根节点到所有子网的最短路径树。各条路径开销是由<strong>网络管理员</strong>配置的。使用 <code>OSPF</code> 时，路由器向自治系统内所有其他路由器广播路由选择信息，而不仅仅是向其相邻路由器广播。每当一条链路的状态发生变化时，路由器就会广播链路状态信息。即使链路状态未发生变化，它也要<strong>周期性地广播链路状态</strong>。</p>
<figure>
<img src="image-20241220141527468.png" alt="image-20241220141527468" /><figcaption aria-hidden="true">image-20241220141527468</figcaption>
</figure>
<figure>
<img src="image-20241220141546911.png" alt="image-20241220141546911" /><figcaption aria-hidden="true">image-20241220141546911</figcaption>
</figure>
<figure>
<img src="image-20241220141600512.png" alt="image-20241220141600512" /><figcaption aria-hidden="true">image-20241220141600512</figcaption>
</figure>
<h2 id="isp之间的路由选择">ISP之间的路由选择</h2>
<h3 id="bgp">BGP</h3>
<p>AS间路由选择协议涉及多个AS之间的协调，所以AS通信必须运行相同的AS间路由选择协议。在因特网中，所有的AS运行相同的AS间路由选择协议，称为<code>边界网关协议（Broder Gateway Protocol, BGP）</code></p>
<p><strong>分布式的 异步的路由选择协议</strong></p>
<p>胶水协议</p>
<p>对于位于<strong>相同AS中</strong>的目的地而言，在路由器转发表中的表项由AS内部路由选择协议所决定。而对于位于<strong>该AS外部的目的地</strong>而言情况如何 呢？这正是BGP用武之地</p>
<ul>
<li>BGP 提供给每个AS以以下方法：
<ul>
<li><code>eBGP</code>: 从<strong>相邻</strong>的ASes那里<strong>获得</strong>子网可达信息</li>
<li><code>iBGP</code>: 将获得的子网可达信息传遍到AS内部的所有路由器 ,<strong>逻辑的非物理链路的</strong></li>
<li>根据子网可达信息和策略来决定到达子网的“好”路径</li>
</ul></li>
<li>允许子网向互联网其他网络通告“我在这里”</li>
<li>基于<code>距离矢量算法（路径矢量）</code>,不仅仅是距离矢量，还包括到达各个目标网络的<code>详细路径</code>（AS 序号的列表）能够<strong>避免简单DV算法的路由环路问题</strong></li>
</ul>
<figure>
<img src="image-20241220142423610.png" alt="image-20241220142423610" /><figcaption aria-hidden="true">image-20241220142423610</figcaption>
</figure>
<p><code>BGP 会话</code>: 2个BGP路由器(“peers”)在一个<strong>半永久</strong>的TCP连接上 交换BGP报文:通告向不同目标子网前缀的“路径”（BGP是一个“路径矢量”协议）</p>
<p><strong>重要的BGP 属性</strong></p>
<ul>
<li><code>AS-PATH</code>：包含了通告已经通过的 AS 的列表，当一个前缀通过某 AS 时，该 AS 将其 ASN 加入 <code>AS-PATH</code> 中的现有列表。检测环路；多路径选择</li>
<li><code>NEXT-HOP</code>：<code>NEXT-HOP</code> 是 <code>AS-PATH</code> 起始的路由器接口的 IP 地址。例如，如图 所指示的那样，对于从 AS1 通过 AS2 到 x 的路由 <code>"AS2 AS3 x"</code>，其属性 <code>NEXT-HOP</code> 是路由器 2a 左边接口的 IP 地址；对于从 AS1 绕过 AS2 到 x 的路由 <code>"AS3 x"</code>，<code>NEXT-HOP</code> 属性是路由器 3d 最左边接口 IP 地址。</li>
</ul>
<figure>
<img src="image-20241220143029257.png" alt="image-20241220143029257" /><figcaption aria-hidden="true">image-20241220143029257</figcaption>
</figure>
<p><strong>路由表项是由AS内和 AS间的路由共同决定的</strong></p>
<figure>
<img src="image-20241220143341091.png" alt="image-20241220143341091" /><figcaption aria-hidden="true">image-20241220143341091</figcaption>
</figure>
<figure>
<img src="image-20241220143420749.png" alt="image-20241220143420749" /><figcaption aria-hidden="true">image-20241220143420749</figcaption>
</figure>
<figure>
<img src="image-20241220143443826.png" alt="image-20241220143443826" /><figcaption aria-hidden="true">image-20241220143443826</figcaption>
</figure>
<figure>
<img src="image-20241220143838053.png" alt="image-20241220143838053" /><figcaption aria-hidden="true">image-20241220143838053</figcaption>
</figure>
<figure>
<img src="image-20241220143931331.png" alt="image-20241220143931331" /><figcaption aria-hidden="true">image-20241220143931331</figcaption>
</figure>
<figure>
<img src="image-20241220144030914.png" alt="image-20241220144030914" /><figcaption aria-hidden="true">image-20241220144030914</figcaption>
</figure>
<h2 id="icmp因特网控制报文协议">ICMP:因特网控制报文协议</h2>
<ul>
<li>被<strong>主机</strong>和<strong>路由器</strong>用来彼此沟通<strong>网络层</strong>的信息。</li>
<li>最典型的用途是<strong>差错报告</strong>。</li>
<li>从体系结构上位于 IP 之上，处于网络层 , 承载在 IP 分组中，作为 IP 有效载荷承载。</li>
<li>IP协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是ICMP协议。当传送IP数据包发生错误比如主机不可达，路由不可达等等，ICMP协议将会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会</li>
<li>主要功能
<ul>
<li>侦测远端主机是否存在</li>
<li>建立及维护路由资料</li>
<li>重导数据传送路径</li>
<li>数据流量控制</li>
</ul></li>
</ul>
<figure>
<img src="image-20241220144329323.png" alt="image-20241220144329323" /><figcaption aria-hidden="true">image-20241220144329323</figcaption>
</figure>
<h1 id="链路层和局域网">链路层和局域网</h1>
<h2 id="引论和服务">引论和服务</h2>
<p>在一个<strong>网络内部</strong>如何由一个节点（主机或者路由器）到达另外一个相邻节点:链路层的<strong>点到点</strong>传输层功能</p>
<p><strong>两种类型的链路层信道</strong>：</p>
<ul>
<li><strong>广播信道</strong>，用于局域网，以广播方式通信，需要媒体访问控制。</li>
<li><strong>点对点信道</strong>，用于核心网里路由器之间长距离连接，控制较简单。</li>
</ul>
<p>子网的若干节点的连接方式:</p>
<ul>
<li>点到点连接</li>
<li>多点连接:
<ul>
<li>共享型介质</li>
<li>通过网络交换机</li>
</ul></li>
</ul>
<p>WAN：网络形式采用点到点链路</p>
<p>LAN：一般采用多点连接方式</p>
<blockquote>
<ul>
<li>数据链路层负责从一个节点通过<strong>链路</strong>将 （帧中的）数据报发送到<strong>相邻的物理节点</strong> （一个子网内部的2节点）</li>
<li>数据报（分组）在不同的链路上以不同的链路协议传送</li>
<li>不同的链路协议提供不同的服务</li>
</ul>
</blockquote>
<h3 id="链路层提供的服务">链路层提供的服务</h3>
<p>可能的服务如下:</p>
<ul>
<li>成帧</li>
<li>链路接入:<code>MAC(媒体访问控制)协议</code>:规定了帧在链路上传输的规则</li>
<li>相邻节点的可靠交付:通常用于易产生高差错率的链路</li>
<li>流量控制</li>
<li>错误检测和差错纠正</li>
<li>半双工和全双工</li>
</ul>
<blockquote>
<p>为什么在链路层和传输层都实现了可靠性:</p>
<p>一般化的链路层服务，不是所有的链路层都提供这些服务 一个特定的链路层只是提供其中一部分的服务</p>
</blockquote>
<blockquote>
<p>为什么要在采用无线链路的网络上，链路层做可靠数据传输工作 ；还要在传输层做端到端的可靠性工作？</p>
<p>原因：出错率高，如果在链路层不做差错控制工作，漏出去的错误比较高；到了上层如果需要可靠控制的数据传输代价会很大</p>
</blockquote>
<p><strong>链路层工作在每一个网络设备上</strong></p>
<p><strong>链路层的主体部分是在网络适配器中实现的，</strong>网络适配器有时也称为网络接口卡，位于网络适配器核心的是链路层控制器，该控制器通常是一个实现了许多链路层服务（成 帧、链路接入、差错检测等）的专用芯片。因此，链路层控制器的<strong>许多功能</strong>是用<strong>硬件</strong>实现。<strong>链路层主要由硬件实现，也有部分功能用软件如链路层寻址、响应中断。</strong></p>
<figure>
<img src="image-20241221103456292.png" alt="image-20241221103456292" /><figcaption aria-hidden="true">image-20241221103456292</figcaption>
</figure>
<figure>
<img src="image-20241221103711011.png" alt="image-20241221103711011" /><figcaption aria-hidden="true">image-20241221103711011</figcaption>
</figure>
<h2 id="差错检测和纠正">差错检测和纠正</h2>
<p><code>比特级差错检测和纠正</code> ,即对从一个节点发送到另一个物理上连接的邻近节点的链路层帧中的比特损伤进行<code>检测和纠正</code>，它们通常是<code>链路层</code>提供的两种服务。</p>
<h3 id="奇偶校验">奇偶校验</h3>
<p><strong>[一维奇偶校验]</strong></p>
<figure>
<img src="image-20241221104225811.png" alt="image-20241221104225811" /><figcaption aria-hidden="true">image-20241221104225811</figcaption>
</figure>
<ul>
<li>偶校验：发送方保证 <code>d + 1</code> 比特数据中 <code>1</code> 的个数是偶数，如果接收方发现 <code>1</code> 的个数是奇数，则出现了奇数个比特差错</li>
<li>奇校验:发送方保证 <code>d + 1</code> 比特数据中 <code>1</code> 的个数是奇数，如果接收方发现 <code>1</code> 的个数是偶数，则出现了奇数个比特差错</li>
<li>差错往往是突发的，而非独立的，检错率50%</li>
</ul>
<p><strong>[二维奇偶校验]</strong></p>
<figure>
<img src="image-20241221104450246.png" alt="image-20241221104450246" /><figcaption aria-hidden="true">image-20241221104450246</figcaption>
</figure>
<p>接收方不仅可以检测到出现了单个比特差错的事实，而且还可以利用存在奇偶校验差错的列和行的索引来实际识别发生差错的比特并<strong>纠正</strong>它。</p>
<p>接收方检测和纠正差错的能力被称为<strong>前向纠错（FEC）</strong>。</p>
<h3 id="internet校验和">Internet校验和</h3>
<p>检测在传输报文段时的错误（如位翻转），（注： 仅仅用在<code>传输层</code>）,相对于CRC码来讲检错能力弱</p>
<figure>
<img src="image-20241221104744707.png" alt="image-20241221104744707" /><figcaption aria-hidden="true">image-20241221104744707</figcaption>
</figure>
<blockquote>
<p>为什么运输层使用检验和而链路层使用CRC呢？</p>
<p>前面讲过运输层常是在主机中作为用户操作系统的一部分用软件实现的。因为运输层差错检测用软件实现，采用简单而快速如检验和这样的差错检测方案是重要的。</p>
<p>在另一方面，链路层的差错检测在适配器中用专用的硬件实现，它能够快速执行更复杂的CRC操作。</p>
</blockquote>
<h3 id="检验和crc循环冗余校验">检验和:CRC(循环冗余校验)</h3>
<p>强大的差错检测码</p>
<p><strong>[思想]</strong></p>
<ul>
<li>将要发送的二进制数看做是0或1为系数的一个多项式 D。</li>
<li>发送方和接收方事先协商一个r+1比特的生成多项式 G</li>
<li>选择r位CRC附加位R，使得:
<ul>
<li>正好被 G整除 (模2运算)</li>
<li>接收方知道 G, 将 除以 G. 如果非0余数: 检查出错误!</li>
<li>能检出所有少于r+1位的突发错误</li>
</ul></li>
</ul>
<figure>
<img src="image-20241221105808649.png" alt="image-20241221105808649" /><figcaption aria-hidden="true">image-20241221105808649</figcaption>
</figure>
<p><strong>模2算数前提下,加法和减法相同且等价于按位异或</strong></p>
<p>如何选择R:</p>
<p>R满足:$D ^r  XOR  R =nG $</p>
<p>则: $D ^r = nG XOR R $</p>
<p><strong>由于位模2运算,异或等价于加减法,那么我们用左边除以<span class="math inline">\(G\)</span>余数即为<span class="math inline">\(R\)</span></strong></p>
<figure>
<img src="image-20241221110659877.png" alt="image-20241221110659877" /><figcaption aria-hidden="true">image-20241221110659877</figcaption>
</figure>
<figure>
<img src="image-20241221110825599.png" alt="image-20241221110825599" /><figcaption aria-hidden="true">image-20241221110825599</figcaption>
</figure>
<h2 id="多路访问链路和协议">多路访问链路和协议</h2>
<p>两种类型的链路（一个子网内部链路连接形式）：</p>
<ul>
<li>点对点</li>
<li>拨号访问的PPP</li>
<li>以太网交换机和主机之间的点对点链路 (以太网是是一种广泛使用的局域网（LAN）技术)</li>
<li>广播 (<code>共享</code>线路或媒体)</li>
<li>传统以太网</li>
<li>HFC上行链路</li>
<li>802.11无线局域</li>
</ul>
<p>在<code>共享广播信道</code>里</p>
<ul>
<li>2个或更多站点同时传送: 碰撞</li>
<li>当发生碰撞时，没有一个接收节点能有效的获得传输的帧；</li>
<li>碰撞的帧重叠在一起，所有涉及的帧传输都失败了；</li>
<li>如果许多节点要频繁的传输帧会加剧碰撞浪费带宽</li>
</ul>
<p>如何协调多个发送和接收节点对一个<code>共享广播信道</code>的访问，这就是<code>多路访问问题</code></p>
<p><code>多路访问协议</code>:用于控制<code>共享广播信道</code>里的节点如何传输帧的<code>分布式算法</code></p>
<figure>
<img src="image-20241221111953017.png" alt="image-20241221111953017" /><figcaption aria-hidden="true">image-20241221111953017</figcaption>
</figure>
<p><strong>多路访问(MAC)协议划分为3种类型:</strong></p>
<ul>
<li>信道划分协议
<ul>
<li>把信道划分成小片（时间、频率、编码）</li>
<li>分配片给每个节点专用</li>
</ul></li>
<li>随机接入协议
<ul>
<li>信道不划分，允许碰撞</li>
<li>碰撞后恢复</li>
</ul></li>
<li>轮流协议
<ul>
<li>节点依次轮流</li>
<li>但是有很多数据传输的节点可以获得较长的信道使用权</li>
</ul></li>
</ul>
<h3 id="信道划分mac协议">信道划分MAC协议</h3>
<p><code>时分多路复用（TDM）</code>：TDM 将时间划分为时间帧，并进一步划分每个时间帧为 N 个时隙，然后把每个时隙分配给 N 个节点中的一个。无论何时某个节点在有分组要发送的时候，它在循环的 TDM 帧中指派给它的时隙内传输分组比特。通常，选择的时隙长度应使一个时隙内能够传输单个分组。</p>
<p>如果站点无帧传输，时隙空闲-》浪费</p>
<p><code>频分多路复用（FDM）</code>：FDM 将 R bps 信道划分为不同的频段（每个频段具有 R/N 带宽），并把每个频率分配给 N 个节点中的一个。因此 FDM 在单个较大的 R bps 信道中创建了 N 个较小的 R/N bps 信道</p>
<p>分配给站点的频段如果没有被使用，则空闲</p>
<figure>
<img src="image-20241221112423891.png" alt="image-20241221112423891" /><figcaption aria-hidden="true">image-20241221112423891</figcaption>
</figure>
<p><code>码分多路访问CDMA</code>:</p>
<ul>
<li>所有站点在整个频段上同时进行传输, 采用编码原理加以区分</li>
<li>完全无冲突</li>
<li>假定:信号同步很好,线性叠加</li>
</ul>
<h3 id="随机访问协议">随机访问协议</h3>
<blockquote>
<p>一个传输节点总是以信道的<code>全部速率</code>（即Kbps）进行发送。当有碰撞时，涉及碰撞的每个节点<code>反复地重发</code>它 的帧（也就是分组），到该帧<code>无碰撞地</code>通过为止。但是当一个节点经历一次碰撞时，它<code>不必立刻重发</code>该帧。相反，它在重发该帧之前<code>等待一个随机时延</code>。涉及碰撞的每个节点 <code>独立地</code>选择随机时延。</p>
</blockquote>
<p>随机访问协议要解决/规定:</p>
<ul>
<li>如何检测碰撞</li>
<li>如何从碰撞中恢复</li>
</ul>
<p><strong>常见的随机访问协议</strong>:</p>
<ul>
<li>时隙ALOHA</li>
<li>ALOHA(纯ALOHA)</li>
<li>CSMA,CSMA/CD,CSMA/CA (载波监听多路访问)</li>
</ul>
<p><strong>时隙ALOHA</strong></p>
<blockquote>
<p>假设:</p>
<ol type="1">
<li>所有帧由L比特组成。</li>
<li>时间被划分成长度为L/R秒的时隙（这就是说，一个时隙等于传输一帧的时间）。</li>
<li>节点只在时隙起点开始传输帧。</li>
<li>节点是同步的，每个节点都知道时隙何时开始。</li>
<li>如果在一个时隙中有两个或者更多个帧碰撞，则所有节点在该时隙结束之前检测到该碰撞事件。</li>
</ol>
</blockquote>
<p>在每个节点中，时隙ALOHA的<code>操作:</code></p>
<ul>
<li>当节点获取新的帧，在下一 个时隙传输</li>
<li>传输时没有检测到冲突，成功
<ul>
<li>节点能够在下一时隙发送新帧</li>
</ul></li>
<li>检测时如果检测到冲突，失败
<ul>
<li>节点在每一个随后的时隙以概率p重传帧直到成功</li>
</ul></li>
</ul>
<p><code>优点</code>:</p>
<ul>
<li>节点可以以信道带宽全速连续传输</li>
<li>高度分散：仅需要节点之间在时隙上的同步,每个节点检测碰撞并独立地决定什么时候重传</li>
<li>简单</li>
</ul>
<p><code>缺点:</code></p>
<ul>
<li>存在冲突，浪费时隙</li>
<li>即使有帧要发送，仍然有可能存在空闲的时隙</li>
<li>节点检测冲突的时间&lt;帧传输的时间
<ul>
<li>必须传完</li>
</ul></li>
<li>需要时钟上同步</li>
</ul>
<figure>
<img src="image-20241221144558625.png" alt="image-20241221144558625" /><figcaption aria-hidden="true">image-20241221144558625</figcaption>
</figure>
<figure>
<img src="image-20241221144714528.png" alt="image-20241221144714528" /><figcaption aria-hidden="true">image-20241221144714528</figcaption>
</figure>
<p><strong>ALOHA/纯ALOHA(非时隙)</strong></p>
<blockquote>
<p>在<code>纯 ALOHA中</code>，当一帧首次到达（即一个网络层数据报在发送节点从网络层传递下来），节点 <code>立刻</code>将该帧完整地传输进广播信道。如果一个传输的帧与一个或多个传输经历了碰撞，这个节点将<code>立即</code>（<strong>在完全传输完它的碰撞帧之后</strong>）以概率p重传该帧。否则，该节点等待一个帧传输时间。在此等待之后，它则以概率p传输该帧，或者以概率1-p在另一个帧时间等待（保持空闲）。</p>
</blockquote>
<ul>
<li><p>简单、无须节点间在时间上同步</p></li>
<li><p>当有帧需要传输：马上传输</p></li>
<li><p>冲突的概率增加:</p>
<ul>
<li>帧在t0 发送，和其它在[t0 -1, t0 +1]区间内开始发送的帧冲突</li>
<li>和当前帧冲突的区间（其他帧在此区间开始传输）增大了一倍</li>
</ul>
<figure>
<img src="image-20241221145158341.png" alt="image-20241221145158341" /><figcaption aria-hidden="true">image-20241221145158341</figcaption>
</figure></li>
</ul>
<figure>
<img src="image-20241221145052473.png" alt="image-20241221145052473" /><figcaption aria-hidden="true">image-20241221145052473</figcaption>
</figure>
<p><strong>CSMA(载波侦听多路访问)</strong></p>
<blockquote>
<p>在时隙和纯ALOHA中，一个节点传输的决定独立于连接到这个广播信道上的其他节 点的活动。特别是，<strong>一个节点不关心在它开始传输时是否有其他节点碰巧在传输</strong>，而且即使有另一个节点开始干扰它的传输也不会停止传输。</p>
</blockquote>
<p><code>载波侦听(carrier sensing)</code>,即一个节点在<strong>传输前先听信道</strong>。如果来自另一 个节点的帧正向信道上发送，节点则等待直到<strong>检测到一小段时间没有传输，然后开始传输</strong>。</p>
<p><code>碰撞检测(collision detection)</code>,即当一个传输节点在<strong>传输时一直在侦听此信道</strong>。如果它检测到另 一个节点正在传输干扰帧，它就停止传输，在重复“<strong>侦听-当空闲时传输</strong>”循环之前<strong>等待一段随机时间</strong>。</p>
<p>CSMA: <strong>在传输前先侦听信道</strong>:</p>
<ul>
<li>如果侦听到信道空闲，传送整个帧</li>
<li>如果侦听到信道忙，推迟传送</li>
</ul>
<p>但仍然会发生碰撞,由于<code>端到端信道传播延迟</code>造成两个节点可能侦听不到正在进行的传输,并且该传播时延越长，载波侦听节点不能侦听到网络中另一个节点已经开始传输的机会就越大</p>
<p>例如:在时刻<span class="math inline">\(t_0\)</span>,节点B侦听到信道是空闲的，因为当前没有其他节点在传输。因此节点B开始传输，沿着广播媒体在两个方向上传播它的比特。图中B的比特随着时间的增加向下传播，这表明B的比特沿着广播媒体传播所实际需要的时间不是零（虽然以接近光 的速度）。在时刻<span class="math inline">\(t_1(t_1&gt;t_0)\)</span>,节点D有一个帧要发送。尽管节点B在时刻<span class="math inline">\(t_1\)</span>正在传输, 但B传输的比特还没有到达D,因此D在<span class="math inline">\(t_1\)</span>侦听到信道空闲。根据CSMA协议，从而D开始传输它的帧。一个短暂的时间之后，B的传输开始在D干扰D的传输</p>
<figure>
<img src="image-20241221150109348.png" alt="image-20241221150109348" /><figcaption aria-hidden="true">image-20241221150109348</figcaption>
</figure>
<p><strong>CSMA/CD(具有<u>碰撞检测</u>的载波侦听多路访问)</strong></p>
<p><code>碰撞检测(collision detection)</code>,即当一个传输节点在<strong>传输时一直在侦听此信道</strong>。如果它检测到另 一个节点正在传输干扰帧，它就停止传输，在重复“<strong>侦听-当空闲时传输</strong>”循环之前<strong>等待一段随机时间</strong>。</p>
<p>CSMA/CD:</p>
<ul>
<li>载波侦听CSMA：和在CSMA中一样发送前侦听信道</li>
<li>没有传完一个帧就可以在短时间内检测到冲突</li>
<li>冲突发生时则传输终止，减少对信道的浪费</li>
</ul>
<p>碰撞检测(CD)技术，<strong>有线局域网中容易实现</strong>:检测信号强度，比较传输与接收到的信号是否相同 或者 通过周期的过零点检测,<strong>无线局域网中较难实现</strong></p>
<figure>
<img src="image-20241221150843794.png" alt="image-20241221150843794" /><figcaption aria-hidden="true">image-20241221150843794</figcaption>
</figure>
<blockquote>
<p>在从与广播信道相连的适配器（在节点中）的角 度总结它的运行：</p>
<ol type="1">
<li>适配器从网络层一条获得数据报，准备链路层帧，并将其放入帧适配器缓存中。</li>
<li>如果适配器侦听到信道空闲（即无信号能量从信道进入适配器），它开始传输帧。在另一方面，如果适配器侦听到信道正在忙，它将等待，直到侦听到没有信号能量时才开始传输帧。</li>
<li>在传输过程中，适配器监视来自其他使用该广播信道的适配器的信号能量的存在。</li>
<li>如果适配器传输整个帧而未检测到来自其他适配器的信号能量，该适配器就完成了该帧。在另一方面，如果适配器在传输时检测到来自其他适配器的信号能量，它中止传输（即它停止了传输帧）。 除放弃外，还发送一个Jam 信号，所有听到冲突的适配器也是如此 强化冲突：让所有站点都知道冲突</li>
<li>中止传输后，适配器等待一个<u>随机时间量</u>，然后返回步骤2。</li>
</ol>
</blockquote>
<p><strong>如何确认退避时间？</strong></p>
<ul>
<li>退避时间长，信道空闲浪费</li>
<li>退避时间短，会发生再次碰撞造成反复重传</li>
</ul>
<p><code>二进制指数退避算法</code>:在第<span class="math inline">\(m\)</span>次失败后，适配器从$ { 0，1，2， ， 2^m-1 } <span class="math inline">\(中随机选择一个\)</span>K<span class="math inline">\(，等待\)</span>K*512<span class="math inline">\(比特时间(即发送512比特进入以太网所需时间量的K倍)时 ，然后转到上述的步骤2 ,\)</span>m$的最大值在10以内</p>
<blockquote>
<p>假设一个适配器首次尝试传输一个帧，并在传输中它检测到碰撞。然后该节点以概率0.5选择<span class="math inline">\(K=0\)</span>,以概率0.5选择<span class="math inline">\(K = 1\)</span> , 如果该节点选择<span class="math inline">\(K=0\)</span>,则它立即开始侦听信道。如果这个适配器选择$K = 1 $,它在开始“侦听-当空闲时传输” 。周期前等待512比特时间（例如对于100Mbps以太网来说为5. 12ms）。在第2次碰撞之后，从 <span class="math inline">\((0, 1, 2, 3]\)</span>中等概率地选择<span class="math inline">\(K\)</span>。在第3次碰撞之后，从<span class="math inline">\((0, 1, 2, 3, 4, 5, 6, 7]\)</span> 中等概率地选择<span class="math inline">\(K\)</span>。在10次或更多次碰撞之后，从<span class="math inline">\(\{0, 1, 2,\cdots ,1023\}\)</span>中等概率地选择<span class="math inline">\(K\)</span>。因此从中选择K的集合长度随着碰撞次数呈<code>指数增长</code>；正是由于这个原因，该算法被称为<code>二进制指数后退</code>。</p>
</blockquote>
<figure>
<img src="image-20241221152104889.png" alt="image-20241221152104889" /><figcaption aria-hidden="true">image-20241221152104889</figcaption>
</figure>
<h3 id="轮流协议">轮流协议</h3>
<figure>
<img src="image-20241221153354829.png" alt="image-20241221153354829" /><figcaption aria-hidden="true">image-20241221153354829</figcaption>
</figure>
<p><strong>轮询</strong></p>
<figure>
<img src="image-20241221153425319.png" alt="image-20241221153425319" /><figcaption aria-hidden="true">image-20241221153425319</figcaption>
</figure>
<p><strong>令牌传递</strong></p>
<figure>
<img src="image-20241221153513815.png" alt="image-20241221153513815" /><figcaption aria-hidden="true">image-20241221153513815</figcaption>
</figure>
<figure>
<img src="image-20241221153616037.png" alt="image-20241221153616037" /><figcaption aria-hidden="true">image-20241221153616037</figcaption>
</figure>
<h2 id="局域网">局域网</h2>
<h3 id="链路层寻址和arp">链路层寻址和ARP</h3>
<p><strong>MAC地址/LAN地址/物理地址</strong></p>
<p>事实上，并不是主机或路由器具有链路层地址，而是它们的适配器（即网络接口）具有链路层地址,因此，具有多个网络接口的主机或路由器将具有与之相关联的多个链路层 地址，就像它也具有与之相关联的多个IP地址一样。</p>
<p>链路层交换机并不具有与它们的接口（这些接口是与主机和路由器相连的）相关联的链路层地址</p>
<figure>
<img src="image-20241221155357264.png" alt="image-20241221155357264" /><figcaption aria-hidden="true">image-20241221155357264</figcaption>
</figure>
<figure>
<img src="image-20241221155524292.png" alt="image-20241221155524292" /><figcaption aria-hidden="true">image-20241221155524292</figcaption>
</figure>
<figure>
<img src="image-20241221155550093.png" alt="image-20241221155550093" /><figcaption aria-hidden="true">image-20241221155550093</figcaption>
</figure>
<p>局域网上每个适配器都有一个唯一的LAN地址</p>
<figure>
<img src="image-20241221155610756.png" alt="image-20241221155610756" /><figcaption aria-hidden="true">image-20241221155610756</figcaption>
</figure>
<p><strong>ARP协议(地址解析协议)</strong></p>
<p>因为存在网络层地址（例如，因特网的IP地址）和链路层地址（即MAC地址），所 以需要在它们之间进行转换。对于因特网而言，这是地址解析协议。</p>
<ul>
<li>在LAN上的每个IP节点都有一个ARP表</li>
<li>ARP表：包括一些 LAN节点IP/MAC地 址的映射</li>
<li>&lt; IP address; MAC address; TTL&gt;
<ul>
<li>TTL时间是指地址映射失效的时间</li>
<li>典型是20mi</li>
</ul></li>
<li><strong>查询 ARP 报文是在广播帧中发送的，而响应 ARP 报文是在一个标准帧中发送</strong></li>
<li><strong>只为在一个子网上的主机和路由器接口解析 IP 地址</strong></li>
</ul>
<figure>
<img src="image-20241221160210877.png" alt="image-20241221160210877" /><figcaption aria-hidden="true">image-20241221160210877</figcaption>
</figure>
<figure>
<img src="image-20241221160348096.png" alt="image-20241221160348096" /><figcaption aria-hidden="true">image-20241221160348096</figcaption>
</figure>
<figure>
<img src="image-20241221160422000.png" alt="image-20241221160422000" /><figcaption aria-hidden="true">image-20241221160422000</figcaption>
</figure>
<figure>
<img src="image-20241221160442811.png" alt="image-20241221160442811" /><figcaption aria-hidden="true">image-20241221160442811</figcaption>
</figure>
<figure>
<img src="image-20241221160524817.png" alt="image-20241221160524817" /><figcaption aria-hidden="true">image-20241221160524817</figcaption>
</figure>
<figure>
<img src="image-20241221160649760.png" alt="image-20241221160649760" /><figcaption aria-hidden="true">image-20241221160649760</figcaption>
</figure>
<h3 id="以太网">以太网</h3>
<p>以太网几乎占领着现有的<code>有线局域网市场</code></p>
<figure>
<img src="image-20241221160807454.png" alt="image-20241221160807454" /><figcaption aria-hidden="true">image-20241221160807454</figcaption>
</figure>
<h3 id="物理拓扑">物理拓扑</h3>
<figure>
<img src="image-20241221161318609.png" alt="image-20241221161318609" /><figcaption aria-hidden="true">image-20241221161318609</figcaption>
</figure>
<h3 id="以太帧结构">以太帧结构</h3>
<figure>
<img src="image-20241221161403558.png" alt="image-20241221161403558" /><figcaption aria-hidden="true">image-20241221161403558</figcaption>
</figure>
<p><strong>前同步码(8Byte):</strong></p>
<ul>
<li>7Byte 10101010 + 1Byte 10101011</li>
<li>用来同步接收方和发送方的时钟速率
<ul>
<li>使得接收方将自己的时钟调到发送端的时钟</li>
<li>从而可以按照发送端的时钟来接收所发送的帧</li>
</ul></li>
</ul>
<p><strong>目的地址/源地址:6字节</strong></p>
<ul>
<li>如果帧目标地址与本站MAC地址相同，或者目标地址为广播地址那就接收，递交帧中的数据到网络层</li>
<li>否则，适配器忽略该帧</li>
</ul>
<p><strong>类型</strong>:指出高层协议(大多情况下是IP，但也支持其它网络层协议)</p>
<p><strong>CRC：</strong>在<strong>接收方校验</strong></p>
<ul>
<li>如果没有通过校验，丢弃错误帧</li>
</ul>
<p>所有以太网技术都向网络层提供<strong>无连接服务</strong>和<strong>不可靠服务</strong>。</p>
<ul>
<li>无连接：帧传输前，发送方和接收方之间没有握手</li>
<li>不可靠：接收方适配器不发送ACKs或NAKs给发送方
<ul>
<li>递交给网络层的数据报流可能有间隙</li>
<li>如上层使用像传输层TCP协议这样的rdt，间隙会被补上( 源主机，TCP实体)</li>
<li>否则，应用层就会看到gap</li>
</ul></li>
<li>以太网的MAC协议：采用二进制退避的CSMA/CD 介质访问控制形式</li>
</ul>
<figure>
<img src="image-20241221162109771.png" alt="image-20241221162109771" /><figcaption aria-hidden="true">image-20241221162109771</figcaption>
</figure>
<h2 id="交换机">交换机</h2>
<ul>
<li><p>任务：接收入链路层帧并将它们转发到出链路。</p></li>
<li><p>链路层设备：扮演主动角色（端口执行以太网协议）</p>
<ul>
<li>对帧进行存储和转发</li>
<li>对于到来的帧，检查帧头，根据目标MAC地址进行选择性 转发</li>
<li>当帧需要向某个（些）网段进行转发，需要使用 CSMA/CD进行接入控制</li>
<li>通常一个交换机端口一个独立网段</li>
</ul></li>
<li><p>透明：主机对交换机的存在可以不关心</p>
<ul>
<li>通过交换机相联的各节点好像这些站点是直接相联的一样</li>
<li>有MAC地址；无IP地址</li>
</ul></li>
<li><p>即插即用，自学习</p>
<ul>
<li>交换机无需配置</li>
</ul></li>
</ul>
<figure>
<img src="image-20241221162645075.png" alt="image-20241221162645075" /><figcaption aria-hidden="true">image-20241221162645075</figcaption>
</figure>
<figure>
<img src="image-20241221162806138.png" alt="image-20241221162806138" /><figcaption aria-hidden="true">image-20241221162806138</figcaption>
</figure>
<figure>
<img src="image-20241221162824613.png" alt="image-20241221162824613" /><figcaption aria-hidden="true">image-20241221162824613</figcaption>
</figure>
<figure>
<img src="image-20241221163045040.png" alt="image-20241221163045040" /><figcaption aria-hidden="true">image-20241221163045040</figcaption>
</figure>
<p><code>过滤（filtering）</code>是决定一个帧应该转发到某个接口还是应当将其丢弃的交换机功能。</p>
<p><code>转发（forwarding）</code>是决定一个帧应该被导向哪个接口，并把该帧移动到那些接口的交换机功能。交换机的过滤和转发借助于<strong>交换机表（switch table）</strong>完成。</p>
<figure>
<img src="image-20241221163228796.png" alt="image-20241221163228796" /><figcaption aria-hidden="true">image-20241221163228796</figcaption>
</figure>
<figure>
<img src="image-20241221163318394.png" alt="image-20241221163318394" /><figcaption aria-hidden="true">image-20241221163318394</figcaption>
</figure>
<figure>
<img src="image-20241221163416878.png" alt="image-20241221163416878" /><figcaption aria-hidden="true">image-20241221163416878</figcaption>
</figure>
<figure>
<img src="image-20241221163424668.png" alt="image-20241221163424668" /><figcaption aria-hidden="true">image-20241221163424668</figcaption>
</figure>
<h3 id="vlan虚拟局域网">VLAN(虚拟局域网)</h3>
<p>支持 VLAN 的交换机允许经一个单一的物理局域网基础设施定义多个虚拟局域网。</p>
<figure>
<img src="image-20241221163650382.png" alt="image-20241221163650382" /><figcaption aria-hidden="true">image-20241221163650382</figcaption>
</figure>
<figure>
<img src="image-20241221163743913.png" alt="image-20241221163743913" /><figcaption aria-hidden="true">image-20241221163743913</figcaption>
</figure>
<figure>
<img src="image-20241221163851470.png" alt="image-20241221163851470" /><figcaption aria-hidden="true">image-20241221163851470</figcaption>
</figure>
<figure>
<img src="image-20241221163902257.png" alt="image-20241221163902257" /><figcaption aria-hidden="true">image-20241221163902257</figcaption>
</figure>
<h1 id="无线网络和移动网络">无线网络和移动网络</h1>
<h2 id="无线链路特征">无线链路、特征</h2>
<figure>
<img src="image-20241222101338352.png" alt="image-20241222101338352" /><figcaption aria-hidden="true">image-20241222101338352</figcaption>
</figure>
<p><strong>无线网络的构件</strong></p>
<ul>
<li><p><strong>无线主机</strong>：运行应用程序的端系统设备。可以是便携机、掌上机、智能手机或者桌面计算机。主机本身可以移动，也可能不移动。</p></li>
<li><p><strong>无线链路</strong>：主机通过无线通信链路连接到一个基站或者另一个无线主机。不同的无线链路技术具有不同的传输速率和能够传输不同的距离。</p></li>
<li><p><strong>基站</strong>：无线网络基础设施的一个关键部分。与无线主机和无线链路不同，基站在有线网络中没有明确的对应设备。它<strong>负责向与之关联的无线主机发送数据和从主机那里接收数据</strong>。基站通常<strong>负责协调与之相关联的多个无线主机的传输</strong>。</p>
<ul>
<li>一台无线主机与某基站“相关联”：1️⃣ 该主机位于该基站的无线通信覆盖范围内；2️⃣ 该主机使用该基站中继它和更大网络之间的数据</li>
</ul></li>
<li><p><strong>切换</strong>：当一台移动主机的移动超出一个基站的覆盖范围而到达另一个基站的覆盖范围后，它将改变其接入到更大的网络的连接点（即改变与之相关联的基站）。</p></li>
<li><p>与基站关联的主机通常被称为以<strong>基础设施模式</strong>运行。因为所有传统的网络服务（如地址分配和路由选择）都由网络向通过基站相连的主机提供。</p></li>
<li><p>在<strong>自组织网络</strong>中，无线主机没有这样的基础设施与之相连。在没有这样的基础设施的情况下，主机本身必须提供诸如路由选择、地址分配、类似于 DNS 的名字转换等服务。</p></li>
</ul>
<hr />
<p><strong>无线网络分类</strong></p>
<ul>
<li>单跳，基于基础设施
<ul>
<li>具有与较大的有线网络连接的基站。该基站与无线主机之间的所有通信都经过一个无线跳。</li>
<li><code>802.11</code>网络、<code>4G LTE</code> 数据网络。</li>
</ul></li>
<li>单跳，无基础设施
<ul>
<li>不存在与无线网络相连的基站。单跳网络中的一个节点可以协调其他节点的传输。</li>
<li>蓝牙网络、具有自组织模式的 <code>802.11</code> 网络。</li>
</ul></li>
<li>多跳，基于基础设施
<ul>
<li>一个基站表现为以有线方式与较大网络相连。某种无线节点为了经该基站通信，可能不得不通过其他无线节点中继它们的通信。</li>
<li>无线传感网络、无线网状网络</li>
</ul></li>
<li>多跳，无基础设施
<ul>
<li>网络中没有基站，并且节点为了到达目的地可能必须在几个其他无线节点之间中继报文。</li>
<li>移动自组织网络（MANET）、车载自组织网络（VANET）</li>
</ul></li>
</ul>
<hr />
<p><strong>无线链路和网络特征</strong></p>
<ul>
<li><strong>路径损耗</strong>：电磁波在穿过物体时强度将减弱。即使在自由空间中，信号仍将扩散，这使得信号强度随着发送方和接收方距离的增加而减弱。</li>
<li><strong>多径传播</strong>：当电磁波的一部分受物体和地面反射，在发送方和接收方之间走了不同长度的路径，则会出现多径传播。这使得接收方收到的信号变得模糊。位于发送方和接收方之间的移动物体可导致多径传播随时间而改变。</li>
<li><strong>来自其他源的干扰</strong>：在同一个频段发送信号的电波源将相互干扰</li>
</ul>
<figure>
<img src="image-20241222101654545.png" alt="image-20241222101654545" /><figcaption aria-hidden="true">image-20241222101654545</figcaption>
</figure>
<ul>
<li><p><strong>信噪比（SNR）</strong>：所收到的信号和噪声强度的相对测量。单位是分贝（dB）。</p></li>
<li><p><strong>比特差错率（BER）</strong>：在接收方收到的有错传输比特的概率</p></li>
<li><p><strong>对于给定的调制方案，SNR越高，BER 越低</strong>,由于发送方通过增加它的传输功率就能够增加SNR,因此发送方能够通过增加它的传输功率来降低接收到差错帧的概率 ,当该功率超过某个阈值时，,可证明几乎不会有实际增益.也会伴随着一些缺点：发送方必须消耗更多的能量（对于用电池供电的移动用户，这一点非常重要），并且发送方的传输更可能干扰另一个发送方的传输</p></li>
<li><p><strong>对于给定的SNR , 具有较高比特传输率的调制技术将具有较高的BER</strong></p></li>
<li><p><strong>物理层调制技术的动态选择能用于适配对信道条件的调制技术。</strong></p></li>
</ul>
<hr />
<p><strong>接收方无法检测到碰撞的两种情况：</strong></p>
<ul>
<li><strong>隐藏终端问题</strong>：即使 <code>A</code> 和 <code>C</code> 的传输确实是在目的地 <code>B</code> 发生干扰，环境的物理阻拦（大山、建筑）也可能会妨碍 <code>A</code> 和<code>C</code> 互相听到对方的传输。</li>
<li><strong>衰减</strong>：<code>A</code> 和 <code>C</code> 所处的位置使得它们的信号强度不足以使它们相互检测到对方的传输，然而它们的传输足以强到在站点 B 处相互干扰。 <img src="2288178-20230210172501873-1026101834.png" alt="img" /></li>
</ul>
<hr />
<h3 id="cdma码分多址">CDMA(码分多址)</h3>
<p>码分多址(Code Division Multiple Access, CDMA)属于<code>信道划分协议族</code>。它在无线LAN和蜂窝技术中应用很广泛。</p>
<p>要发送的每个<code>比特</code>都通过乘以一个信号（编码）的比特来进行编码，这个信号的变化速率（通常称为<strong>码片速率</strong>， chipping rate) 比初始数据比特序列的变化速率快得多。</p>
<figure>
<img src="image-20241222102223846.png" alt="image-20241222102223846" /><figcaption aria-hidden="true">image-20241222102223846</figcaption>
</figure>
<ul>
<li><span class="math inline">\(d_i\)</span>：第<span class="math inline">\(i\)</span> 个比特时隙中的数据比特值。</li>
<li>$Z_{i,m}=d_i⋅c_m $：对于 <span class="math inline">\(d_i\)</span> 比特传输时间的第 <span class="math inline">\(m\)</span> 个微时隙,CDMA 编码器的输出 <span class="math inline">\(Z_{i,m}\)</span>,是 <span class="math inline">\(d_i\)</span> 乘以分配的 $CDMA $编码的第 <span class="math inline">\(m\)</span> 比特 <span class="math inline">\(c_m\)</span>。</li>
<li><span class="math inline">\(d_i=\frac{∑_{m=1}^{M}Z_{i,m}⋅c_m}{M}\)</span> ：接收方恢复初始的数据比特。</li>
<li>当有多个发送方干扰目标发送方时，CDMA 假设对干扰的传输比特信号是<strong>加性的</strong>；接收方收到的值是在那个微时隙中从所有 N 个发送方传输的比特的总和，使用目标发送方的 CDMA 编码可以提取出目标发送方的初始数据比特。</li>
</ul>
<figure>
<img src="image-20241222102356703.png" alt="image-20241222102356703" /><figcaption aria-hidden="true">image-20241222102356703</figcaption>
</figure>
<h2 id="ieee-802.11-无线局域网">IEEE 802.11 无线局域网</h2>
<ul>
<li><code>IEEE 802.11 无线 LAN（WiFi）协议族</code>：无线 <code>LAN</code> 标准。</li>
</ul>
<figure>
<img src="image-20241222113829336.png" alt="image-20241222113829336" /><figcaption aria-hidden="true">image-20241222113829336</figcaption>
</figure>
<p>上述协议都</p>
<ul>
<li>采用CSMA/CA媒体访问协议</li>
<li>使用相同的链路层帧结构</li>
<li>都向后兼容</li>
</ul>
<h3 id="体系结构">802.11体系结构</h3>
<figure>
<img src="image-20241222113911297.png" alt="image-20241222113911297" /><figcaption aria-hidden="true">image-20241222113911297</figcaption>
</figure>
<ul>
<li>802.11体系结构的<code>基本构件模块</code>是基本服务集（Basic Service Set, BSS）</li>
<li>一个BSS包含一个或多个<code>无线站点</code>和一个在 802. 11术语中称为<strong><code>接入点</code>（ AP）的中央基站</strong></li>
<li><strong>每个802. 11无线站点都具有一个6字节的MAC地址</strong>，该地址 储在该站适配器（即802. 11网络接口卡）的固件中,<strong>每个AP的无线接口也具有一个 MAC地址</strong>。与以太网类似，这些MAC地址由IEEE管理，理论上是全球唯一的。</li>
<li>配置AP的无线LAN经常被称作<code>基础设施无线LAN</code>,其中的“基础设施”是指AP连同互联AP和一台路由器的有线以太网</li>
</ul>
<h3 id="信道与关联">信道与关联</h3>
<ul>
<li>在802. 11中，每个<code>无线站点</code>在能够发送或者接收网络层数据之前，必须与一个AP相 <code>关联</code> , 关联意味 着这一无线站点在自身和该AP之间创建一个虚拟线路。</li>
<li>当网络管理员安装一个<code>AP</code>时，管理员为该接入点分配一个单字或双字的<code>服务集标识符(Service Set Identifier, SSID)</code>管理员还必须为该AP分配一个<code>信道号。</code></li>
<li><code>WiFi丛林(WiFi jungle)</code>是一个任意物理位置，在这里无线站点能从<code>两个或多个</code>AP中收到很强的信号。</li>
<li>802.11标准要求<code>每个AP周期性</code>地发送<code>信标帧(beacon frame)</code>,每个信标帧包括该AP 的<code>SSID和MAC地址</code></li>
<li><strong>被动扫描</strong>：扫描信道和监听信标帧的过程。</li>
<li><strong>主动扫描</strong>：通过向位于无线主机范围内的所有 <code>AP</code> 广播探测帧完成的。AP 用一个探测响应帧应答探测请求帧。无线主机则能够在响应的 AP 中选择某 AP 与之相关联。</li>
</ul>
<figure>
<img src="image-20241222114918980.png" alt="image-20241222114918980" /><figcaption aria-hidden="true">image-20241222114918980</figcaption>
</figure>
<h3 id="mac协议">802.11 MAC协议</h3>
<ul>
<li>我们将无线设备或AP称为站点（station）,它们共享<code>多个接入信道</code></li>
<li>802.11的设计者为802. 11无线LAN选择了一种<code>随机访问协议</code>。这个随机访问 协议称作<code>带碰撞避免的CSMA （ CSMA with collision avoidance）</code>,或简称为<code>CSMA/CA</code></li>
<li>尽管以太网 和802. 11都使用载波侦听随机接入，但这两种MAC协议<strong>有重要的区别</strong>:
<ul>
<li>首先，802. 11 使用<strong>碰撞避免</strong>而非碰撞检测。</li>
<li>其次，由于无线信道相对较高的误比特率，802. 11 使用<strong>链路层确认/重传（ARQ）方案</strong>,（不同于以太网)。</li>
</ul></li>
<li>802.11 MAC协议并未实现碰撞检测。这主要由两个重要的原因所致:
<ul>
<li>检测碰撞的能力要求站点具有同时发送（站点自己的信号）和接收（检测其他站 点是否也在发送）的能力。因为在802. 11适配器上，接收信号的强度通常远远小 于发送信号的强度，制造具有检测碰撞能力的硬件代价较大。</li>
<li>更重要的是，即使适配器可以同时发送和监听信号（并且假设它一旦侦听到信道 忙就放弃发送），适配器也会由于隐藏终端问题和衰减问题而无法检测到所有的碰 撞</li>
</ul></li>
</ul>
<p>由于802. 11无线局域网不使用碰撞检测，一旦站点开始发送一个帧，它就完全地发送该帧</p>
<p>802.11 使用<strong>链路层确认/重传</strong>（ARQ）</p>
<p>目的站点收到一个通过 CRC 校验的帧后，它等待一个被称为<strong>短帧间间隔（SIFS）</strong>的一小段时间，然后发挥一个确认帧。如果发送站点在给定的时间内未收到确认帧，它假定出现了错误并重传该帧，使用 <code>CSMA/CA</code> 协议访问该信道 。如果在若干固定次重传后仍未收到确认，发送站点将放弃发送并丢弃该帧。</p>
<figure>
<img src="image-20241222115409912.png" alt="image-20241222115409912" /><figcaption aria-hidden="true">image-20241222115409912</figcaption>
</figure>
<ol type="1">
<li>如果某站点最初监听到信道空闲，它将在一个被称为<strong>分布式帧间间隔（DIFS）</strong>的段时间段后发送该帧。</li>
<li>否则，该站点选取一个随机回退值并且在侦听信道<strong>空闲时递减该值</strong>。当侦听到信道忙时，计数值保持不变。</li>
<li>当计数值减为 0 时（只可能发生在信道被侦听为空闲时），该站点发送整个数据帧并等待确认。</li>
<li>如果收到确认，发送站点知道它的帧已被目的站正确接收了。如果该站点要发送另一个帧，它将从第二步开始 <code>CSMA/CA</code> 协议。如果未收到确认，发送站点将重新进入第二步中的回退阶段，并从一个更大的范围内选取随机值。</li>
</ol>
<p>在以太网的 CSMA/CD 的多路访问协议下，一旦侦听到信道空闲，站点开始发送。然而，使用 CSMA/CA, 该站点在倒计数时抑制传输，即使它侦听到该信道空闲也是如此。<strong>为什么 CSMA/CD 和 CSMA/CA 采用了不同的方法？</strong></p>
<ul>
<li>在 CSMA/CD 中碰撞不是一个严重的问题，因为两个站点检测到碰撞后等都会放弃它们的发送，从而避免了由于碰撞而造成的该帧剩余部分的无用发送。</li>
<li>在 802.11 中，并<strong>不检测碰撞和放弃发送</strong>，遭受碰撞的帧仍将被完全传输。因此要<strong>尽可能避免碰撞</strong>。如果两个站点侦听到信道忙，它们都将立即进入随机回退，希望选取一个不同的回退值。如果这些值的确不同，一旦信道空闲，其中的一个站点将在另一个之前发送，并且“失败站点”将会听到“胜利站点”的信号，冻结它的计数器，并且在胜利站点完成传输之前一直抑制传输，避免了高代价的碰撞。</li>
<li>使用 802.11 仍然可能出现碰撞的情况：1️⃣ 两个站点可能相互是隐藏的；2️⃣ 两者可能选择了非常靠近的随机回退值</li>
</ul>
<h3 id="处理隐藏终端">处理隐藏终端</h3>
<p>802.11 MAC协议也包括了一个极好（但为可选项）的预约方案，以帮助在出现<code>隐藏终端</code>的情 况下避免碰撞。</p>
<figure>
<img src="image-20241222151145124.png" alt="image-20241222151145124" /><figcaption aria-hidden="true">image-20241222151145124</figcaption>
</figure>
<p><strong>为什么隐藏终端会导致出现问题?</strong></p>
<p>假设站点H1正在传输一个帧，并且 在H1传输的中途，站点H2要向AP发送一个帧。由于H2未听到来自H1的传输，它将首先等待一个DIFS间隔，然后发送该帧，导致产生了一个碰撞。从而在H1和H2的整个发送阶段，信道都被浪费了。</p>
<p>为了避免这一问题，<code>IEEE 802.11协议</code>允许站点使用一个<code>短请求发送(Request to Send, RTS)控制帧</code>和一个<code>短允许发送 (Clear to Send, CTS)控制帧</code>来<code>预约</code>对信道的访问</p>
<figure>
<img src="image-20241222151315105.png" alt="image-20241222151315105" /><figcaption aria-hidden="true">image-20241222151315105</figcaption>
</figure>
<p>当发送方要发送一个data帧 时，它能够首先向AP发送一个RTS帧, 指示传输DATA帧和确认(ACK)帧需要的总时间。当AP收到RTS帧后，它<code>广播</code>一个<code>CTS帧</code>作为响应。该CTS帧有两个目的：给发送方明确的发送许可，也指示其 他站点在预约期内不要发送。</p>
<p>在上例中：</p>
<ul>
<li>传输 DATA 帧前，H1 首先<code>广播</code>一个 <strong>RTS 帧</strong>，指示传输 DATA 帧和确认（ACK）帧需要的总时间，该帧能被其范围内包括 AP 在内的所有站点听到。</li>
<li>AP 然后用一个 <strong>CTS 帧</strong> 进行<code>广播</code>响应，该帧也被其范围内的包括 H1 和 H2 在内的所有站点听到。<strong>目的是给发送方明确的发送许可，也指示其他站点在预约期内不要发送。</strong></li>
<li>站点 H2 听到 CTS 后，在CTS 帧中指明的时间内将<strong>抑制发送</strong>。</li>
</ul>
<p>RTS和CTS帧的使用能够<strong>在两个重要 方面提高性能</strong>：</p>
<ul>
<li>隐藏终端问题被缓解了，因为长DATA帧只有在信道预约后才被传输。</li>
<li>因为RTS和CTS帧较短，涉及RTS和CTS帧的碰撞将仅持续短RTS和CTS帧的持续期。一旦RTS和CTS帧被正确传输，后续的DATA和ACK帧应当能无碰撞地发送。</li>
</ul>
<hr />
<h3 id="帧结构">802.11 帧结构</h3>
<figure>
<img src="image-20241222153450347.png" alt="image-20241222153450347" /><figcaption aria-hidden="true">image-20241222153450347</figcaption>
</figure>
<ul>
<li>帧的核心是<code>有效载荷</code>，它通常是由一个IP数据报或者ARP分组组成。尽管这一字段 允许的最大长度为2312字节，但它通常小于1500字节，放置一个IP数据报或一个ARP 分组</li>
<li>802.11帧包括一个<code>循环冗余校验（CRC）</code>,从而接收方可以检 测所收到帧中的比特错误。</li>
<li>有4个<code>地址字段</code>，其中每个都可以包 含一个6字节的MAC地址：
<ul>
<li>地址2是传输该帧的站点的MAC地址</li>
<li>地址1是要接收该帧的无线站点的MAC地址</li>
<li>地址3：第一跳的MAC地址，接入点所连接的路由器的接口MAC地址</li>
</ul></li>
</ul>
<hr />
<h3 id="高级特色">高级特色</h3>
<ul>
<li><strong>802.11 速率适应</strong>：如果一个节点连续发送两个帧而没有收到确认，该传输速率降低到前一个较低的速率。如果 10 个帧连续得到确认，或如果用来跟踪自上次降速以来时间的定时器超时，该传输速率提高到上一个较高的速率。</li>
<li><strong>功率管理</strong>：一个节点能够明显地在睡眠和唤醒状态之间交替。</li>
</ul>
<hr />
<h2 id="移动管理">移动管理</h2>
<p>如果一个移动实体在移动过 程中能够保持其<code>IP地址不变</code>，从应用的角度，<code>移动性就变得不可见</code></p>
<p><strong>名词介绍：</strong></p>
<ul>
<li><strong>归属网络</strong>：在一个网络环境中，一个移动节点（智能手机）的永久居所被称为<strong>归属网络</strong>。</li>
<li><strong>归属代理</strong>：在归属网络中代表移动节点执行移动管理功能的实体叫<strong>归属代理</strong>。</li>
<li><strong>外部网络</strong>：移动节点当前所在网络叫作<strong>外部网络</strong>或<strong>被访网络</strong>。</li>
<li><strong>外部代理</strong>：在外部网络中帮助移动节点做移动管理功能的实体称为<strong>外部代理</strong>。<strong>外部代理的作用之一是为移动节点创建一个所谓的转交地址（COA），该 COA 的网络部分与外部网络的网络部分相匹配</strong> ，外部代理的<strong>第二个作用就是告诉归属代理，该移动节点在它的（外部代理的）网络中且具有给定的COA</strong></li>
<li><strong>通信者(</strong>correspondent)：就是希 望与该移动节点通信的实体</li>
</ul>
<figure>
<img src="image-20241222152004387.png" alt="image-20241222152004387" /><figcaption aria-hidden="true">image-20241222152004387</figcaption>
</figure>
<p>当某移动节点位于一个外部网络时，所有指向此节点<code>固定地址</code>的流量需要导向<code>外部网络</code></p>
<p>此一个<code>移动节点</code>可与两个地址相关联，即其<code>永久地址（permanent address）</code>（类比于流动青年的家 庭地址）与其COA,该COA有时又称为<code>外部地址（foreign address）</code>（类比于流动青年当前居 住的房屋地址）。</p>
<h3 id="间接路由选择">间接路由选择</h3>
<figure>
<img src="image-20241222152312902.png" alt="image-20241222152312902" /><figcaption aria-hidden="true">image-20241222152312902</figcaption>
</figure>
<p>通信者只是将数据报寻址到移动节点的固定地址，并将数据报发送到网络 中去，完全不知道移动节点是在归属网络中还是正在访问某个外部网络，因此<strong>移动性对于通信者来说是完全透明的</strong>。这些数据报就像平常一样首先导向移动节点的归属网络。</p>
<figure>
<img src="image-20241222152451449.png" alt="image-20241222152451449" /><figcaption aria-hidden="true">image-20241222152451449</figcaption>
</figure>
<h3 id="直接路由选择">直接路由选择</h3>
<p><code>三角路由选择问题 (triangle routing problem)</code>该问题是指即使在通信者与移动节点之间存在一条更有效的路由，发往移动节点的数据报也要先发给归属代理，然后再发送到外部网络。</p>
<ul>
<li><strong>间接路由选择会引起三角路由选择问题</strong></li>
<li>直接路由选择克服了三角路由选择的低效问题，但却是以增加复杂性为代价的。</li>
</ul>
<figure>
<img src="image-20241222152633038.png" alt="image-20241222152633038" /><figcaption aria-hidden="true">image-20241222152633038</figcaption>
</figure>
<ul>
<li>通信者所在网络中的一个<code>通信者代理</code>先知道该移动节点的COA,这可以通过让通信者代理向归属代理<strong>询问</strong>得知，这里假设与间接路由选择情况类似，移动节点具有一个在<strong>归属代理注册过的最新的 COA</strong>，与移动节点可以执行外部代理的功能相类似，通信者本身也可能执行通信者代理的功能。在图中显示为步骤1和步骤2。</li>
<li>通信者代理然后将数据报直接通过<code>隧道技术</code>发往移动节点的COA,这与归属代理使用的隧道技术相类似，参见图中步骤3 和步骤4。</li>
</ul>
<hr />
<p><strong>锚外部代理:</strong>我们将首次发现移动节点的外部网络中的外部代理标识为<code>锚外部代理</code></p>
<ul>
<li>当移动节点到达一个新外部网络后,移动节点向新的外部代理注册(步骤3)</li>
<li><strong>新外部代理向锚外部代理提供移动节点的新COA</strong> （步骤4）。</li>
<li>当锚外部代理收到一个发往已经离开的移动节点的封装数据报后，它可以使用新的COA重新封装数据报并将其转发给该移动节点（步骤5）。</li>
<li>如果移动节点其后又移到另一个外部网络中，在该被访网络中的外部代理随后将与锚外部代理联系，以便建立到该新外部网络的转发。</li>
</ul>
<figure>
<img src="image-20241222152902343.png" alt="image-20241222152902343" /><figcaption aria-hidden="true">image-20241222152902343</figcaption>
</figure>
<h2 id="移动ip">移动IP</h2>
<p>支持移动性的因特网体系结构与协议合起来称为<code>移动IP</code> ,当前的标准［RFC 5944］规定到移动节点使用<code>间接路由选择</code>的方法。</p>
<p><strong>移动IP标准由三部分组成：</strong></p>
<ul>
<li><strong>代理发现</strong>。移动IP定义了一个归属代理或外部代理用来向移动节点通告其服务的协议，以及移动节点请求一个外部代理或归属代理的服务所使用的协议。</li>
<li><strong>向归属代理注册</strong>。移动IP定义了移动节点和/或外部代理向一个移动节点的归属 代理注册或注销COA所使用的协议。</li>
<li><strong>数据报的间接路由选择</strong>。该标准也定义了数据报被一个归属代理转发给移动节点 的方式，包括转发数据报使用的规则、处理差错情况的规则和几种不同的封装形式</li>
</ul>
<figure>
<img src="image-20241222154150591.png" alt="image-20241222154150591" /><figcaption aria-hidden="true">image-20241222154150591</figcaption>
</figure>
<figure>
<img src="image-20241222154405926.png" alt="image-20241222154405926" /><figcaption aria-hidden="true">image-20241222154405926</figcaption>
</figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://klklkl10086.github.io/klklkl10086.github.io">klklkl</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://klklkl10086.github.io/klklkl10086.github.io/2024/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">https://klklkl10086.github.io/klklkl10086.github.io/2024/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://klklkl10086.github.io/klklkl10086.github.io" target="_blank">klklkl's blogs</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div><div class="post_share"><div class="social-share" data-image="https://pic2.zhimg.com/v2-f9b32b95385eedbdb58389bbbce5de39_r.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/12/23/%E8%AE%A1%E7%BD%91%E7%AE%80%E7%AD%94%E9%A2%98/" title="计网简答题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计网简答题</div></div></a></div><div class="next-post pull-right"><a href="/2024/11/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0B/" title="《机器学习B》课程复习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《机器学习B》课程复习笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/12/23/%E8%AE%A1%E7%BD%91%E7%AE%80%E7%AD%94%E9%A2%98/" title="计网简答题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-23</div><div class="title">计网简答题</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://pic2.zhimg.com/v2-f9b32b95385eedbdb58389bbbce5de39_r.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">klklkl</div><div class="author-info__description">student</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:2488926297@qq.com" target="_blank" title="Email"><i class="fa-regular fa-envelope" style="color: #000000;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Nice to meet you!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">计算机网络概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%9E%84%E6%88%90"><span class="toc-number">1.1.</span> <span class="toc-text">具体构成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF"><span class="toc-number">1.1.1.</span> <span class="toc-text">通信链路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">1.1.2.</span> <span class="toc-text">分组交换机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%A0%E7%89%B9%E7%BD%91%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E5%95%86-isp"><span class="toc-number">1.1.3.</span> <span class="toc-text">因特网服务提供商 ISP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AEprotocols"><span class="toc-number">1.1.4.</span> <span class="toc-text">协议protocols</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.2.</span> <span class="toc-text">服务描述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E6%8E%A5%E5%8F%A3-socket-interface"><span class="toc-number">1.2.1.</span> <span class="toc-text">套接字接口 socket interface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-network-protocols"><span class="toc-number">1.2.2.</span> <span class="toc-text">网络协议 network protocols</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">网络结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%9C"><span class="toc-number">1.4.</span> <span class="toc-text">接入网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B6%E5%BA%AD%E6%8E%A5%E5%85%A5%E7%BD%91"><span class="toc-number">1.4.1.</span> <span class="toc-text">家庭接入网</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%81%E4%B8%9A%E6%8E%A5%E5%85%A5%E7%BD%91"><span class="toc-number">1.4.2.</span> <span class="toc-text">企业接入网</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%9F%9F%E6%97%A0%E7%BA%BF%E6%8E%A5%E5%85%A5%E7%BD%91"><span class="toc-number">1.4.3.</span> <span class="toc-text">广域无线接入网</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%AA%92%E4%BB%8B"><span class="toc-number">1.4.4.</span> <span class="toc-text">物理媒介</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%A0%B8%E5%BF%83"><span class="toc-number">1.5.</span> <span class="toc-text">网络核心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2"><span class="toc-number">1.5.1.</span> <span class="toc-text">分组交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2"><span class="toc-number">1.5.2.</span> <span class="toc-text">电路交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2-vs.-%E7%94%B5%E8%B7%AF%E4%BA%A4"><span class="toc-number">1.5.3.</span> <span class="toc-text">分组交换 vs. 电路交</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E8%81%94%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.</span> <span class="toc-text">互联网络结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#isp%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.6.1.</span> <span class="toc-text">ISP之间的连接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E5%BB%B6%E6%97%B6%E4%B8%A2%E5%A4%B1%E5%92%8C%E5%90%9E%E5%90%90%E9%87%8F"><span class="toc-number">1.7.</span> <span class="toc-text">分组延时、丢失和吞吐量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E5%BB%B6%E6%9E%84%E6%88%90"><span class="toc-number">1.7.1.</span> <span class="toc-text">时延构成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E9%98%9F%E6%97%B6%E5%BB%B6%E5%92%8C%E4%B8%A2%E5%8C%85"><span class="toc-number">1.7.2.</span> <span class="toc-text">排队时延和丢包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%88%B0%E7%AB%AF%E6%97%B6%E5%BB%B6"><span class="toc-number">1.7.3.</span> <span class="toc-text">端到端时延</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F"><span class="toc-number">1.7.4.</span> <span class="toc-text">吞吐量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E5%B1%82%E6%AC%A1"><span class="toc-number">1.8.</span> <span class="toc-text">协议层次</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.8.1.</span> <span class="toc-text">分层的体系结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#internet-%E5%8D%8F%E8%AE%AE%E6%A0%88"><span class="toc-number">1.8.2.</span> <span class="toc-text">Internet 协议栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#isoosi"><span class="toc-number">1.8.3.</span> <span class="toc-text">ISO&#x2F;OSI</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">2.</span> <span class="toc-text">应用层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">应用层协议原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.1.</span> <span class="toc-text">网络应用体系结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">2.1.2.</span> <span class="toc-text">进程通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%AF%BB%E5%9D%80"><span class="toc-number">2.1.3.</span> <span class="toc-text">进程寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E4%BE%9B%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8%E7%9A%84%E8%BF%90%E8%BE%93%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.1.4.</span> <span class="toc-text">可供应用程序使用的运输服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%A0%E7%89%B9%E7%BD%91%E6%8F%90%E4%BE%9B%E7%9A%84%E8%BF%90%E8%BE%93%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.1.5.</span> <span class="toc-text">因特网提供的运输服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.1.6.</span> <span class="toc-text">应用层协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#web%E5%92%8Chttp"><span class="toc-number">2.2.</span> <span class="toc-text">Web和HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#http"><span class="toc-number">2.2.1.</span> <span class="toc-text">HTTP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http%E8%BF%9E%E6%8E%A5%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.2.</span> <span class="toc-text">HTTP连接类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.2.3.</span> <span class="toc-text">HTTP报文格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8A%B6%E6%80%81cookies"><span class="toc-number">2.2.4.</span> <span class="toc-text">用户-服务器状态：cookies</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#web%E7%BC%93%E5%AD%98%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">2.2.5.</span> <span class="toc-text">Web缓存(代理服务器)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6get%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.6.</span> <span class="toc-text">条件GET方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6"><span class="toc-number">2.3.</span> <span class="toc-text">电子邮件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#smtp%E7%AE%80%E5%8D%95%E9%82%AE%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.3.1.</span> <span class="toc-text">SMTP简单邮件传输协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%AE%E4%BB%B6%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.3.2.</span> <span class="toc-text">邮件访问协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dns%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.4.</span> <span class="toc-text">DNS:域名系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dns%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.4.1.</span> <span class="toc-text">DNS服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dns%E5%B7%A5%E4%BD%9C%E6%9C%BA%E7%90%86"><span class="toc-number">2.4.2.</span> <span class="toc-text">DNS工作机理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dns%E7%BC%93%E5%AD%98"><span class="toc-number">2.4.3.</span> <span class="toc-text">DNS缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dns%E8%AE%B0%E5%BD%95"><span class="toc-number">2.4.4.</span> <span class="toc-text">DNS记录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dns%E6%8A%A5%E6%96%87"><span class="toc-number">2.4.5.</span> <span class="toc-text">DNS报文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8dns%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%8F%92%E5%85%A5%E8%AE%B0%E5%BD%95"><span class="toc-number">2.4.6.</span> <span class="toc-text">在DNS数据库中插入记录</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-number">3.</span> <span class="toc-text">传输层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0%E5%92%8C%E4%BC%A0%E8%BE%93%E5%B1%82%E6%9C%8D%E5%8A%A1"><span class="toc-number">3.1.</span> <span class="toc-text">概述和传输层服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82-vs.-%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">3.1.1.</span> <span class="toc-text">传输层 vs. 网络层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3%E4%B8%8E%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">3.1.2.</span> <span class="toc-text">多路分解与多路复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E8%BF%9E%E6%8E%A5udp%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">3.1.3.</span> <span class="toc-text">无连接(UDP)的多路复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5tcp%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">3.1.4.</span> <span class="toc-text">面向连接(TCP)的多路复用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E8%BF%9E%E6%8E%A5%E4%BC%A0%E8%BE%93udp"><span class="toc-number">3.2.</span> <span class="toc-text">无连接传输:UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#udp%E6%8A%A5%E6%96%87"><span class="toc-number">3.2.1.</span> <span class="toc-text">UDP报文</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93rdt%E5%8E%9F%E7%90%86"><span class="toc-number">3.3.</span> <span class="toc-text">可靠数据传输(rdt)原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rdt1.0%E5%9C%A8%E5%8F%AF%E9%9D%A0%E4%BF%A1%E9%81%93%E4%B8%8A%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-number">3.3.1.</span> <span class="toc-text">Rdt1.0:在可靠信道上的可靠数据传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rdt2.0%E5%85%B7%E6%9C%89%E6%AF%94%E7%89%B9%E5%B7%AE%E9%94%99%E7%9A%84%E4%BF%A1%E9%81%93"><span class="toc-number">3.3.2.</span> <span class="toc-text">Rdt2.0:具有比特差错的信道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rdt2.1"><span class="toc-number">3.3.3.</span> <span class="toc-text">Rdt2.1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rdt2.2%E6%97%A0nak%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.3.4.</span> <span class="toc-text">Rdt2.2:无NAK的协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rdt3.0%E5%85%B7%E6%9C%89%E6%AF%94%E7%89%B9%E5%B7%AE%E9%94%99%E5%92%8C%E5%88%86%E7%BB%84%E4%B8%A2%E5%A4%B1%E7%9A%84%E4%BF%A1%E9%81%93"><span class="toc-number">3.3.5.</span> <span class="toc-text">Rdt3.0:具有比特差错和分组丢失的信道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.3.6.</span> <span class="toc-text">流水线可靠传输协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gbn%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.3.7.</span> <span class="toc-text">GBN:滑动窗口协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E9%87%8D%E4%BC%A0sr"><span class="toc-number">3.3.8.</span> <span class="toc-text">选择重传（SR）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gbn-vs.-sr"><span class="toc-number">3.3.9.</span> <span class="toc-text">GBN vs. SR</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93tcp"><span class="toc-number">3.4.</span> <span class="toc-text">面向连接的传输:TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%A5%E6%96%87%E6%AE%B5"><span class="toc-number">3.4.1.</span> <span class="toc-text">报文段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp%E5%BE%80%E8%BF%94%E5%BB%B6%E6%97%B6%E5%92%8C%E8%B6%85%E6%97%B6"><span class="toc-number">3.4.2.</span> <span class="toc-text">TCP往返延时和超时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-number">3.4.3.</span> <span class="toc-text">TCP:可靠数据传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0"><span class="toc-number">3.4.4.</span> <span class="toc-text">TCP快速重传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">3.4.5.</span> <span class="toc-text">流量控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="toc-number">3.4.6.</span> <span class="toc-text">TCP连接管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">3.4.7.</span> <span class="toc-text">拥塞控制原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2"><span class="toc-number">4.</span> <span class="toc-text">网络层:数据平面</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.1.1.</span> <span class="toc-text">网络服务模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BB%84%E6%88%90"><span class="toc-number">4.2.</span> <span class="toc-text">路由器组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E7%AB%AF%E5%8F%A3"><span class="toc-number">4.2.1.</span> <span class="toc-text">输入端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.2.</span> <span class="toc-text">交换结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E7%AB%AF%E5%8F%A3"><span class="toc-number">4.2.3.</span> <span class="toc-text">输出端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">4.2.4.</span> <span class="toc-text">路由选择处理器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ip"><span class="toc-number">4.3.</span> <span class="toc-text">IP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ipv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.3.1.</span> <span class="toc-text">IPV4数据报格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ip%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%88%86%E7%89%87%E4%B8%8E%E8%A3%85%E9%85%8D"><span class="toc-number">4.3.2.</span> <span class="toc-text">IP数据报分片与装配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ipv4%E7%BC%96%E5%9D%80"><span class="toc-number">4.3.3.</span> <span class="toc-text">IPv4编址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cidr%E6%97%A0%E7%B1%BB%E5%88%AB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9"><span class="toc-number">4.3.4.</span> <span class="toc-text">CIDR无类别域间路由选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dhcp%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.3.5.</span> <span class="toc-text">DHCP:动态主机配置协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nat-%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.3.6.</span> <span class="toc-text">NAT: 网络地址转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ipv6"><span class="toc-number">4.3.7.</span> <span class="toc-text">IPv6</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2"><span class="toc-number">5.</span> <span class="toc-text">网络层:控制平面</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95"><span class="toc-number">5.1.</span> <span class="toc-text">路由选择算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95link-state"><span class="toc-number">5.1.1.</span> <span class="toc-text">链路状态路由算法(link state)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8Fdv%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95"><span class="toc-number">5.1.2.</span> <span class="toc-text">距离向量DV路由选择算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%A0%E7%89%B9%E7%BD%91%E4%B8%AD%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F%E5%86%85%E9%83%A8%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9intra-as"><span class="toc-number">5.2.</span> <span class="toc-text">因特网中自治系统内部的路由选择(intra-AS)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E6%94%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E4%BC%98%E5%85%88ospf"><span class="toc-number">5.2.1.</span> <span class="toc-text">开放最短路优先OSPF</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#isp%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9"><span class="toc-number">5.3.</span> <span class="toc-text">ISP之间的路由选择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bgp"><span class="toc-number">5.3.1.</span> <span class="toc-text">BGP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#icmp%E5%9B%A0%E7%89%B9%E7%BD%91%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE"><span class="toc-number">5.4.</span> <span class="toc-text">ICMP:因特网控制报文协议</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91"><span class="toc-number">6.</span> <span class="toc-text">链路层和局域网</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%AE%BA%E5%92%8C%E6%9C%8D%E5%8A%A1"><span class="toc-number">6.1.</span> <span class="toc-text">引论和服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9C%8D%E5%8A%A1"><span class="toc-number">6.1.1.</span> <span class="toc-text">链路层提供的服务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B%E5%92%8C%E7%BA%A0%E6%AD%A3"><span class="toc-number">6.2.</span> <span class="toc-text">差错检测和纠正</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C"><span class="toc-number">6.2.1.</span> <span class="toc-text">奇偶校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#internet%E6%A0%A1%E9%AA%8C%E5%92%8C"><span class="toc-number">6.2.2.</span> <span class="toc-text">Internet校验和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E9%AA%8C%E5%92%8Ccrc%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C"><span class="toc-number">6.2.3.</span> <span class="toc-text">检验和:CRC(循环冗余校验)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E8%AE%BF%E9%97%AE%E9%93%BE%E8%B7%AF%E5%92%8C%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.3.</span> <span class="toc-text">多路访问链路和协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E9%81%93%E5%88%92%E5%88%86mac%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.3.1.</span> <span class="toc-text">信道划分MAC协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.3.2.</span> <span class="toc-text">随机访问协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AE%E6%B5%81%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.3.3.</span> <span class="toc-text">轮流协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E5%9F%9F%E7%BD%91"><span class="toc-number">6.4.</span> <span class="toc-text">局域网</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E5%B1%82%E5%AF%BB%E5%9D%80%E5%92%8Carp"><span class="toc-number">6.4.1.</span> <span class="toc-text">链路层寻址和ARP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91"><span class="toc-number">6.4.2.</span> <span class="toc-text">以太网</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E6%8B%93%E6%89%91"><span class="toc-number">6.4.3.</span> <span class="toc-text">物理拓扑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E5%B8%A7%E7%BB%93%E6%9E%84"><span class="toc-number">6.4.4.</span> <span class="toc-text">以太帧结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">6.5.</span> <span class="toc-text">交换机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vlan%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91"><span class="toc-number">6.5.1.</span> <span class="toc-text">VLAN(虚拟局域网)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C"><span class="toc-number">7.</span> <span class="toc-text">无线网络和移动网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E7%BA%BF%E9%93%BE%E8%B7%AF%E7%89%B9%E5%BE%81"><span class="toc-number">7.1.</span> <span class="toc-text">无线链路、特征</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cdma%E7%A0%81%E5%88%86%E5%A4%9A%E5%9D%80"><span class="toc-number">7.1.1.</span> <span class="toc-text">CDMA(码分多址)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ieee-802.11-%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91"><span class="toc-number">7.2.</span> <span class="toc-text">IEEE 802.11 无线局域网</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">7.2.1.</span> <span class="toc-text">802.11体系结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E9%81%93%E4%B8%8E%E5%85%B3%E8%81%94"><span class="toc-number">7.2.2.</span> <span class="toc-text">信道与关联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mac%E5%8D%8F%E8%AE%AE"><span class="toc-number">7.2.3.</span> <span class="toc-text">802.11 MAC协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E9%9A%90%E8%97%8F%E7%BB%88%E7%AB%AF"><span class="toc-number">7.2.4.</span> <span class="toc-text">处理隐藏终端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A7%E7%BB%93%E6%9E%84"><span class="toc-number">7.2.5.</span> <span class="toc-text">802.11 帧结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%89%B9%E8%89%B2"><span class="toc-number">7.2.6.</span> <span class="toc-text">高级特色</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%AE%A1%E7%90%86"><span class="toc-number">7.3.</span> <span class="toc-text">移动管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%B4%E6%8E%A5%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9"><span class="toc-number">7.3.1.</span> <span class="toc-text">间接路由选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9"><span class="toc-number">7.3.2.</span> <span class="toc-text">直接路由选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8ip"><span class="toc-number">7.4.</span> <span class="toc-text">移动IP</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/13/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="编译原理复习笔记">编译原理复习笔记</a><time datetime="2025-05-13T05:45:42.000Z" title="发表于 2025-05-13 13:45:42">2025-05-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/29/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E4%B9%8BManacher%E7%AE%97%E6%B3%95/" title="最长回文子串之Manacher算法">最长回文子串之Manacher算法</a><time datetime="2024-12-29T14:20:12.000Z" title="发表于 2024-12-29 22:20:12">2024-12-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/23/%E8%AE%A1%E7%BD%91%E7%AE%80%E7%AD%94%E9%A2%98/" title="计网简答题">计网简答题</a><time datetime="2024-12-23T07:53:14.000Z" title="发表于 2024-12-23 15:53:14">2024-12-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="《计算机网络》复习笔记">《计算机网络》复习笔记</a><time datetime="2024-12-09T02:07:01.000Z" title="发表于 2024-12-09 10:07:01">2024-12-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0B/" title="《机器学习B》课程复习笔记">《机器学习B》课程复习笔记</a><time datetime="2024-11-28T06:48:29.000Z" title="发表于 2024-11-28 14:48:29">2024-11-28</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://pic1.zhimg.com/80/v2-908b61a41ec4bebe17a04468dcf5d834_720w.webp')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By klklkl</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>