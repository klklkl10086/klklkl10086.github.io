<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>面向对象程序设计 | klklkl's blogs</title><meta name="author" content="klklkl"><meta name="copyright" content="klklkl"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="面向对象程序设计课程笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="面向对象程序设计">
<meta property="og:url" content="https://klklkl10086.github.io/klklkl10086.github.io/2024/10/13/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1_cpp/index.html">
<meta property="og:site_name" content="klklkl&#39;s blogs">
<meta property="og:description" content="面向对象程序设计课程笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic2.zhimg.com/v2-f9b32b95385eedbdb58389bbbce5de39_r.jpg">
<meta property="article:published_time" content="2024-10-13T01:53:10.000Z">
<meta property="article:modified_time" content="2024-10-13T11:29:10.767Z">
<meta property="article:author" content="klklkl">
<meta property="article:tag" content="oop">
<meta property="article:tag" content="cpp">
<meta property="article:tag" content="class">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic2.zhimg.com/v2-f9b32b95385eedbdb58389bbbce5de39_r.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://klklkl10086.github.io/klklkl10086.github.io/2024/10/13/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1_cpp/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面向对象程序设计',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-13 19:29:10'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="klklkl's blogs" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pic2.zhimg.com/v2-f9b32b95385eedbdb58389bbbce5de39_r.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pic1.zhimg.com/80/v2-908b61a41ec4bebe17a04468dcf5d834_720w.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="klklkl's blogs"><img class="site-icon" src="https://pic2.zhimg.com/v2-f9b32b95385eedbdb58389bbbce5de39_r.jpg# image"/><span class="site-name">klklkl's blogs</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面向对象程序设计</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-13T01:53:10.000Z" title="发表于 2024-10-13 09:53:10">2024-10-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-13T11:29:10.767Z" title="更新于 2024-10-13 19:29:10">2024-10-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/oop/">oop</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面向对象程序设计"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="面向对象程序设计">面向对象程序设计</h1>
<h1 id="引用（int-a-int-const-a）">引用（int &amp;a= int*const a）</h1>
<p><strong>tips：</strong></p>
<p><em><strong>1.引用是一个存储空间的别名，这就意味着引用初始化的时候必须要有一个已经存在的空间。</strong></em></p>
<p><em><strong>2.引用必须要初始化，并且在程序运行期间引用一旦初始化便不可修改。</strong></em></p>
<p><em><strong>3.引用的出现是为了让代码更简洁、易读，是一种语法糖。（主要是为了解决指针的可读性）</strong></em></p>
<p><em><strong>4.引用可以看做是指针常量，即只能通过引用更改所指空间内的内容，但不可更改引用所绑定的空间。</strong></em></p>
<p><strong>5.常引用const int &amp;a=const int*const a。</strong></p>
<p><em>一般类的名字首字母大写</em></p>
<h1 id="一、构造函数">一、构造函数</h1>
<p>构造函数是一种特殊的成员函数，名字与类的名字相同，无返回值（void也不写），可被重载。用户不写时则由编译器自动编写，但没有参数什么都不做，在对象生成时自动调用。一旦生成后就不会再执行构造函数。</p>
<h3 id="1-作用">1. 作用</h3>
<p>对对象进行初始化，如给成员变量赋初值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *m_name;</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">    <span class="type">float</span> m_score;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//声明构造函数</span></span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">char</span> *name, <span class="type">int</span> age, <span class="type">float</span> score);</span><br><span class="line">    <span class="comment">//声明普通成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义构造函数</span></span><br><span class="line">Student::<span class="built_in">Student</span>(<span class="type">char</span> *name, <span class="type">int</span> age, <span class="type">float</span> score)&#123;</span><br><span class="line">    m_name = name;</span><br><span class="line">    m_age = age;</span><br><span class="line">    m_score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义普通成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;m_name&lt;&lt;<span class="string">&quot;的年龄是&quot;</span>&lt;&lt;m_age&lt;&lt;<span class="string">&quot;，成绩是&quot;</span>&lt;&lt;m_score&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建对象时向构造函数传参</span></span><br><span class="line">    <span class="function">Student <span class="title">stu</span><span class="params">(<span class="string">&quot;小明&quot;</span>, <span class="number">15</span>, <span class="number">92.5f</span>)</span></span>;</span><br><span class="line">    stu.<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">//创建对象时向构造函数传参</span></span><br><span class="line">    Student *pstu = <span class="keyword">new</span> <span class="built_in">Student</span>(<span class="string">&quot;李华&quot;</span>, <span class="number">16</span>, <span class="number">96</span>);</span><br><span class="line">    pstu -&gt; <span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写成这样则是错的</span></span><br><span class="line">Student s1; <span class="comment">//Student没有声明一个无参数的构造函数</span></span><br><span class="line">Student *s2=<span class="keyword">new</span> Student;<span class="comment">//错误，Student没有默认的构造函数，没有参数传递则无法进行工作</span></span><br><span class="line"><span class="function">Student <span class="title">s2</span><span class="params">(<span class="string">&quot;张三&quot;</span>，<span class="number">18</span>，<span class="number">100</span>)</span>；<span class="comment">//则为正确</span></span></span><br><span class="line"><span class="function">Studnet *s2</span>=<span class="function">nwe <span class="title">Student</span><span class="params">(<span class="string">&quot;张三&quot;</span>，<span class="number">18</span>，<span class="number">99</span>)</span>；<span class="comment">//正确</span></span></span><br><span class="line"><span class="function"><span class="comment">//若构造函数的参数是这样的：</span></span></span><br><span class="line"><span class="function"><span class="title">Student::Student</span><span class="params">(<span class="type">char</span> *name, <span class="type">int</span> age=<span class="number">18</span>, <span class="type">float</span> score=<span class="number">60</span>)</span></span>&#123;</span><br><span class="line">    m_name = name;</span><br><span class="line">    m_age = age;</span><br><span class="line">    m_score = score;</span><br><span class="line">&#125;<span class="comment">//则可以缺省最右面的几位参数输入</span></span><br><span class="line"><span class="comment">//如</span></span><br><span class="line"><span class="function">Student <span class="title">s1</span><span class="params">(<span class="string">&quot;wangwu&quot;</span>)</span></span>;<span class="comment">//编译器会自动补齐age=18 score=60</span></span><br></pre></td></tr></table></figure>
<h3 id="2-构造函数在数组中的使用">2. 构造函数在数组中的使用</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//重载</span></span><br><span class="line">        <span class="built_in">Test</span>(<span class="type">int</span> n)&#123;&#125;  <span class="comment">//一个参数构造函数（1）</span></span><br><span class="line">        <span class="built_in">Test</span>(<span class="type">int</span> n,<span class="type">int</span> m)&#123;&#125;<span class="comment">//两个参数构造函数（2）</span></span><br><span class="line">        <span class="built_in">Test</span>()&#123;&#125;    <span class="comment">//无参数构造函数（3）</span></span><br><span class="line">&#125;;</span><br><span class="line">Test array1[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="built_in">Test</span>(<span class="number">1</span>,<span class="number">2</span>)&#125;;</span><br><span class="line"><span class="comment">//三个元素分别用（1），（2），（3）初始化</span></span><br><span class="line">Test *pArray[<span class="number">3</span>]=&#123;<span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">4</span>),<span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">1</span>,<span class="number">2</span>)&#125;;<span class="comment">//指针数组不会导致构造函数调用</span></span><br><span class="line"><span class="comment">//只生成了两个对象pArray[2]并没有指向任何地方只是一个未经初始化化的指针，前者用（1）构建后者用（2）构建，</span></span><br></pre></td></tr></table></figure>
<h1 id="二、-复制构造函数">二、 复制构造函数</h1>
<p>只有一个参数，即对同类对象的引用（常引用或者非常引用二者居其一）</p>
<p>形如X::X(X&amp;)   或  X::X(const X &amp;)  而后者可以常量对象作为参数</p>
<p>如果没有定义复制构造函数，编译器将生成默认的复制构造函数，其将完成复制功能。</p>
<p>*<strong>tips</strong>：无参构造函数（默认构造函数）不一定存在，复制构造函数一定存在。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">            <span class="type">double</span> real,imag;</span><br><span class="line">&#125;;</span><br><span class="line">Complex c1;<span class="comment">//调用缺省无参构造函数</span></span><br><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span><span class="comment">//调用缺省的复制构造函数将 c2 初始化和 c1一样</span></span></span><br></pre></td></tr></table></figure>
<p>也可以自己写复制构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;</span><br><span class="line">    piblic:</span><br><span class="line">            <span class="type">double</span> real,imag;</span><br><span class="line">    <span class="built_in">Complex</span>()&#123;&#125;<span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">const</span> Complex &amp; c)&#123;   <span class="comment">//复制构造函数</span></span><br><span class="line">            real=c.real;</span><br><span class="line">            imag=c.imag;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Copy Constructor called&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Complex c1;</span><br><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>; <span class="comment">//调用自写的复制构造函数将c1复制给c2 并输出Copy Constructor called</span></span><br></pre></td></tr></table></figure>
<p><strong>tips：不允许有形如 X::X(X)  的构造函数，必须为引用（&amp;）</strong></p>
<h3 id="1-复制构造函数起作用的情况">1.  复制构造函数起作用的情况</h3>
<h4 id="1-用一个对象去初始化同类的另一个对象时：">&lt;1&gt; 用一个对象去初始化同类的另一个对象时：</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>; <span class="comment">// 用c1初始化c1</span></span><br><span class="line">Complex c2=c1;<span class="comment">//初始化语句 非赋值，与上面等价</span></span><br></pre></td></tr></table></figure>
<h4 id="2-如果某函数有一个参数是类A的对象，那么调用该函数时，A的复制构造函数将被调用：">&lt;2&gt; 如果某函数有一个参数是类A的对象，那么调用该函数时，A的复制构造函数将被调用：</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>：</span><br><span class="line">     <span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">     <span class="built_in">A</span>(A&amp;a)&#123; <span class="comment">//复制构造函数但没有作复制工作   形参不一定是实参的拷贝</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Copy Constructor called&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(A a1)</span></span>&#123;&#125;  <span class="comment">// 所有对象一定会被初始化，此时a1就是调用复制构造函数进行初始化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a2;</span><br><span class="line">    <span class="built_in">Func</span>(a2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-函数返回值是类A的对象-时，则函数返回时，A的复制构造函数被调用：">&lt;3&gt; 函数返回值是类A的对象 时，则函数返回时，A的复制构造函数被调用：</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>：</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">     <span class="built_in">A</span>(<span class="type">int</span> n)&#123;v = n；&#125;<span class="comment">//构造函数</span></span><br><span class="line">     <span class="built_in">A</span>(<span class="type">const</span> A &amp; a)&#123; <span class="comment">//复制构造函数</span></span><br><span class="line">        v=a.v;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Copy Constructor called&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A <span class="title">Func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">b</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    retuen b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Func</span>().v &lt;&lt; endl; <span class="comment">//复制构造函数调用 输出b.v即4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em><strong>tips：对象间的赋值并不会导致复制构造函数被调用</strong></em></p>
<h4 id="4-例子">&lt; 4 &gt;例子</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">aa</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">aa</span>(<span class="type">int</span> a = <span class="number">1</span>) :<span class="built_in">id</span>(a) &#123; cout &lt;&lt; <span class="string">&quot;构造&quot;</span> &lt;&lt;id&lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">aa</span>(aa <span class="type">const</span>&amp; s) :<span class="built_in">id</span>(s.id) &#123; cout &lt;&lt; <span class="string">&quot;拷贝&quot;</span> &lt;&lt; id&lt;&lt;endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    aa m;<span class="comment">//构造1</span></span><br><span class="line">    <span class="function">aa <span class="title">n</span><span class="params">(m)</span></span>;<span class="comment">//拷贝1</span></span><br><span class="line">    aa o = m;<span class="comment">// 拷贝1</span></span><br><span class="line">    aa s = <span class="number">9</span>;<span class="comment">//构造9，赋值</span></span><br><span class="line">    aa t;<span class="comment">// 构造1</span></span><br><span class="line">    t = <span class="number">9</span>;<span class="comment">//构造9，赋值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<p>构造1<br>
拷贝1<br>
拷贝1<br>
构造9<br>
构造1<br>
构造9</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">aa</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">aa</span>(<span class="type">int</span> a = <span class="number">1</span>) :<span class="built_in">id</span>(a) &#123; cout &lt;&lt; <span class="string">&quot;构造&quot;</span> &lt;&lt;id&lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">aa</span>(aa <span class="type">const</span>&amp; s) :<span class="built_in">id</span>(s.id) &#123; cout &lt;&lt; <span class="string">&quot;拷贝&quot;</span> &lt;&lt; id&lt;&lt;endl; &#125;</span><br><span class="line">    ~<span class="built_in">aa</span>() &#123; cout &lt;&lt; <span class="string">&quot;析构&quot;</span> &lt;&lt; id &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    aa s;<span class="comment">//gouzao 1</span></span><br><span class="line">    aa t = s;<span class="comment">//kaobei 1</span></span><br><span class="line">    aa k = <span class="number">8</span>;<span class="comment">//gouzao 8</span></span><br><span class="line">    s = <span class="number">9</span>;<span class="comment">//gouzao9  赋值  xigou9</span></span><br><span class="line">    aa s1=<span class="number">99</span>;<span class="comment">//构造99</span></span><br><span class="line">    <span class="function">aa <span class="title">m</span><span class="params">(<span class="number">7</span>)</span></span>;<span class="comment">//gouzao 7</span></span><br><span class="line">    <span class="built_in">aa</span>(<span class="number">6</span>);<span class="comment">//gouzao 6 xigou 6</span></span><br><span class="line">    aa n = <span class="built_in">aa</span>(<span class="number">5</span>);<span class="comment">//gouzao 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p>构造1<br>
拷贝1<br>
构造8<br>
构造9<br>
析构9<br>
构造99<br>
构造7<br>
构造6<br>
析构6<br>
构造5</p>
<p>析构5<br>
析构7<br>
析构99<br>
析构8<br>
析构1<br>
析构9</p>
<h3 id="2-常量引用参数的使用">2.常量引用参数的使用</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(CMYclass obj_)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;fun&quot;</span>&lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em><strong>此函数调用时生成的形参会引发复制构造函数的调用，开销很大。因此可以考虑使用CMyclass&amp; 引用类型作为参数，如果希望确保实参的值在函数中不应被改变，那么可以加上const关键字。</strong></em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> CMYclass &amp;obj_)</span></span>&#123;  <span class="comment">//函数中任何试图改变obj的纸的语句都将是非法的</span></span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;fun&quot;</span>&lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-浅拷贝与深拷贝">3.浅拷贝与深拷贝</h2>
<p>浅拷贝：进行简单的赋值拷贝操作</p>
<p>深拷贝：在堆区申请内存空间，进行拷贝工作。</p>
<p>当只有默认的复制构造函数时，编译器默认浅拷贝。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="built_in">Student</span>();</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> m_age);</span><br><span class="line">    ~<span class="built_in">Student</span>();  </span><br><span class="line">&#125;;</span><br><span class="line">Student::<span class="built_in">Student</span>()&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;调用默认构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">Student::<span class="built_in">Student</span>(<span class="type">int</span> m_age)&#123;</span><br><span class="line">    age=m_age;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;调用有参构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">Student::~<span class="built_in">Student</span>()&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;调用析构函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">a</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a的年龄是：&quot;</span>&lt;&lt;a.age&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：调用有参构造函数</p>
<p>a的年龄是：18</p>
<p>调用析构函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span>* high;</span><br><span class="line">    <span class="built_in">Student</span>();</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> m_age,<span class="type">int</span> m_high);</span><br><span class="line">    ~<span class="built_in">Student</span>();  </span><br><span class="line">&#125;;</span><br><span class="line">Student::<span class="built_in">Student</span>()&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;调用默认构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">Student::<span class="built_in">Student</span>(<span class="type">int</span> m_age,<span class="type">int</span> m_high)&#123;</span><br><span class="line">    age=m_age;</span><br><span class="line">    high=<span class="keyword">new</span> <span class="built_in">int</span>(m_high);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;调用有参构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">Student::~<span class="built_in">Student</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span>(high!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">delete</span>(high);</span><br><span class="line">    high=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;调用析构函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">a</span><span class="params">(<span class="number">18</span>,<span class="number">170</span>)</span></span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a的年龄是：&quot;</span>&lt;&lt;a.age&lt;&lt;<span class="string">&quot;a的身高是：&quot;</span>&lt;&lt;*(a.high)&lt;&lt;endl;</span><br><span class="line">    <span class="function">Student <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;b的年龄是：&quot;</span>&lt;&lt;b.age&lt;&lt;<span class="string">&quot;b的身高是：&quot;</span>&lt;&lt;*(b.high)&lt;&lt;endl;</span><br><span class="line">    *(b.high) = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a的年龄是：&quot;</span> &lt;&lt; a.age &lt;&lt; <span class="string">&quot;a的身高是：&quot;</span> &lt;&lt; *(a.high) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b的年龄是：&quot;</span> &lt;&lt; b.age &lt;&lt; <span class="string">&quot;b的身高是：&quot;</span> &lt;&lt; *(b.high) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输 出：调用有参构造函数<br>
            a的年龄是：18a的身高是：170<br>
            b的年龄是：18b的身高是：170</p>
<p><mark> a的年龄是：18a的身高是：20<br>
            b的年龄是：18b的身高是：20</mark></p>
<p><mark>             调用析构函数 </mark></p>
<p>//<strong>由于a和b的指针指向同一个空间因此只释放了一次</strong></p>
<p><u><strong>此时为浅拷贝。</strong></u></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span>* high;</span><br><span class="line">    <span class="built_in">Student</span>();</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> m_age, <span class="type">int</span> m_high);</span><br><span class="line">    <span class="built_in">Student</span>(Student &amp; aa);</span><br><span class="line">    ~<span class="built_in">Student</span>();</span><br><span class="line">&#125;;</span><br><span class="line">Student::<span class="built_in">Student</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用默认构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Student::<span class="built_in">Student</span>(<span class="type">int</span> m_age, <span class="type">int</span> m_high) &#123;</span><br><span class="line">    age = m_age;</span><br><span class="line">    high = <span class="keyword">new</span> <span class="built_in">int</span>(m_high);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用有参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Student::<span class="built_in">Student</span>(Student&amp; aa) &#123;</span><br><span class="line">    high = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(*(aa.high)));</span><br><span class="line">    *high = *(aa.high);</span><br><span class="line">    age = aa.age;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用有参复制构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Student::~<span class="built_in">Student</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (high != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">delete</span>(high);</span><br><span class="line">        high = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">a</span><span class="params">(<span class="number">18</span>, <span class="number">170</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a的年龄是：&quot;</span> &lt;&lt; a.age &lt;&lt; <span class="string">&quot;a的身高是：&quot;</span> &lt;&lt; *(a.high) &lt;&lt; endl;</span><br><span class="line">    <span class="function">Student <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b的年龄是：&quot;</span> &lt;&lt; b.age &lt;&lt; <span class="string">&quot;b的身高是：&quot;</span> &lt;&lt; *(b.high) &lt;&lt; endl;</span><br><span class="line">    *(b.high) = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a的年龄是：&quot;</span> &lt;&lt; a.age &lt;&lt; <span class="string">&quot;a的身高是：&quot;</span> &lt;&lt; *(a.high) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b的年龄是：&quot;</span> &lt;&lt; b.age &lt;&lt; <span class="string">&quot;b的身高是：&quot;</span> &lt;&lt; *(b.high) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p>调用有参构造函数<br>
a的年龄是：18a的身高是：170<br>
调用有参复制构造函数<br>
b的年龄是：18b的身高是：170</p>
<p><mark><u>a的年龄是：18a的身高是：170<br>
b的年龄是：18b的身高是：20</u><br>
调用析构函数<br>
调用析构函数</mark></p>
<p><strong>此时为深拷贝</strong></p>
<h1 id="三、类型转换构造函数">三、类型转换构造函数</h1>
<p><em>目的：实现类型的自动转换</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">int</span> i) &#123;<span class="comment">// 类型转换构造函数</span></span><br><span class="line">        real = i;</span><br><span class="line">        imag = <span class="number">0</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;类型转换&quot;</span> &lt;&lt; i&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i) &#123;  <span class="comment">//构造函数</span></span><br><span class="line">        real = r;</span><br><span class="line">        imag = i;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;构造&quot;</span> &lt;&lt; r &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">7</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line">    Complex c2 = <span class="number">12</span>; <span class="comment">//调用类型转换构造函数</span></span><br><span class="line">    c1 = <span class="number">9</span>; <span class="comment">//类型转换构造函数  9自动转换为 临时Complex 对象，然后赋值运算把值赋给c1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p>构造78<br>
类型转换12<br>
类型转换9</p>
<h1 id="四、析构函数">四、析构函数</h1>
<p><em>在对象消亡时调用，做善后工作</em></p>
<p><em>名字与类名相同，在前面加 ~  无参数和返回值 一个类最多只能有一个析构函数</em></p>
<p><em>若没有定义析构函数则编译器会生成缺省析构函数，缺省析构函数什么也</em>不做</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">            <span class="type">char</span> *p;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">string</span>()&#123;</span><br><span class="line">            p=<span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span>];&#125;</span><br><span class="line">            ~<span class="built_in">string</span>(); <span class="comment">//析构函数</span></span><br><span class="line">&#125;；</span><br><span class="line">string :: ~<span class="built_in">string</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] p;   <span class="comment">//回收空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-析构函数和数组">1.析构函数和数组</h4>
<p><em>对象数组生命周期结束时，对象数组的每个元素的析构函数都会被调用</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ctest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ~ <span class="built_in">Ctest</span>()&#123; cout &lt;&lt; <span class="string">&quot;destructor called&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Ctest array[<span class="number">2</span>];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;END MAIN&quot;</span>&lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 数组 array中的元素会消亡调用析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br>
END MAIN</p>
<p>destructor called</p>
<p>destructor called</p>
<h4 id="2-析构函数和delete">2. 析构函数和delete</h4>
<p><em>delete 导致析构函数被调用 ，只有看见delete才会调用析构函数</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ctest *pTest;</span><br><span class="line">pTest = <span class="keyword">new</span> Ctest; <span class="comment">//构造函数调用</span></span><br><span class="line"><span class="keyword">delete</span> pTest;      <span class="comment">//析构函数调用</span></span><br><span class="line">----------------------------------------</span><br><span class="line">pTest = <span class="keyword">new</span> Ctest[<span class="number">3</span>]; <span class="comment">//构造函数调用三次</span></span><br><span class="line"><span class="keyword">delete</span> [] pTest;  <span class="comment">//    析构函数调用三次</span></span><br></pre></td></tr></table></figure>
<h4 id="3-析构函数在对象作为函数返回值返回时被调用">3.析构函数在对象作为函数返回值返回时被调用</h4>
<p>![3aa88fca-92b9-40cc-91c2-fc26e3ed2c34](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/3aa88fca-92b9-40cc-91c2-fc26e3ed2c34.png)</p>
<p>![f2d32e48-cb5c-4343-81ef-00370be7bd96](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/f2d32e48-cb5c-4343-81ef-00370be7bd96.png)</p>
<h1 id="五、构造函数和析构函数调用时机">五、构造函数和析构函数调用时机</h1>
<p>![f857f475-1043-46db-b281-afba54de22d6](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/f857f475-1043-46db-b281-afba54de22d6.png)</p>
<p><em><strong><u>例题</u></strong></em></p>
<p>（C）</p>
<p><strong>![f</strong>f3fa49d-631e-4477-b13c-b11b5d46b628](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/ff3fa49d-631e-4477-b13c-b11b5d46b628.png)</p>
<p><em>new出来的东西只有delete才会消亡  因此数组A[2]</em></p>
<p><em>a在程序结束后也会消亡</em></p>
<p><em><strong>1、静态局部变量只生成一次，生存期是整个程序运行时间。</strong></em></p>
<p><em><strong>2、当程序运行结束时，先析构主程序里的对象，再析构静态变量，最后析构全局变量。</strong></em></p>
<p><em><strong>3、先构造全局变量（main之前构造）（无论全局变量在哪个位置），再执行主函数，局部对象按文本顺序构造。</strong></em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> k) &#123; s = k; cout &lt;&lt; k &lt;&lt; <span class="string">&quot;A is constructing\n&quot;</span>; &#125;  <span class="comment">//构造函数</span></span><br><span class="line">    ~<span class="built_in">A</span>() &#123; cout &lt;&lt; s &lt;&lt;<span class="string">&quot;~A\n&quot;</span>; &#125; <span class="comment">//析构函数</span></span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A <span class="title">t</span><span class="params">(<span class="number">4</span>)</span></span>;<span class="comment">//全局变量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main is running\n&quot;</span>;</span><br><span class="line">    <span class="function">A <span class="title">s</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">//局部变量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">A <span class="title">ss</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;f is running&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="function">A <span class="title">s</span><span class="params">(<span class="number">2</span>)</span></span>;<span class="comment">//局部变量</span></span><br><span class="line">    <span class="function"><span class="type">static</span> A <span class="title">t</span><span class="params">(<span class="number">3</span>)</span></span>;<span class="comment">//静态局部变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">A <span class="title">k</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>![0f31ecce-1b4d-4a09-ad43-2f476daa0577](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/0f31ecce-1b4d-4a09-ad43-2f476daa0577.png)</p>
<p><em><strong>tips：不同的编译器对于同一段代码的结果不同</strong></em></p>
<p><em><strong>不同文件中的全局对象构造顺序随机</strong></em></p>
<h1 id="六、this指针">六、this指针</h1>
<p><em>一开始c++并没有专门的编译器，这时候会涉及到c++到c语言的翻译问题，因此会增加this指针</em></p>
<p><strong><u>作用：指向成员函数所作用的对象</u></strong></p>
<p><mark><em><strong>非静态成员函数中可以直接使用this来代表指向该函数作用的对象的指针</strong></em></mark></p>
<p><mark><em><strong>静态成员函数中不能使用this指针  因为静态成员函数并不具体作用于某个对象</strong></em></mark></p>
<p><mark><em><strong>因此 静态成员函数的真实的参数的个数就是程序中写出的参数个数</strong></em></mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> real,imag;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123; cout &lt;&lt; real &lt;&lt; <span class="string">&quot;,&quot;</span>  &lt;&lt; imag;&#125;</span><br><span class="line">    <span class="built_in">Complex</span>( <span class="type">double</span> r,<span class="type">double</span> i): <span class="built_in">real</span>(r),<span class="built_in">imag</span>(i)  <span class="comment">//构造函数：初始化列表冒号开始逗号分割，每个数据成员后面跟一个放在括号中的初始化式，本行的意思为 real=r  imag=i</span></span><br><span class="line">    &#123;      &#125;</span><br><span class="line">    <span class="function">Commplex <span class="title">AddOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;real ++; <span class="comment">// 等价于 real++；</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">Print</span>(); <span class="comment">// 等价于Print</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mian</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span>,<span class="title">c2</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    c2 = c1.<span class="built_in">AddOne</span>();   <span class="comment">//先将c1的 real++ 再打印real和imag 最后进行赋值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//输出 2，1</span></span><br></pre></td></tr></table></figure>
<h2 id="1-this指针的作用">1.this指针的作用</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i; <span class="comment">//private</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Hello</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;; 等价于 <span class="function"><span class="type">void</span> <span class="title">Hello</span><span class="params">(A *<span class="keyword">this</span>)</span></span>&#123;cout &lt;&lt; <span class="string">&quot;hello&quot;</span>&lt;&lt;endl;&#125;  <span class="comment">//未用到this</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *p= <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;<span class="built_in">Hello</span>(); <span class="comment">//结果会怎样？？？  答案是编译会出错吗？ 并不是  会输出hello</span></span><br><span class="line"> <span class="comment">// ---&gt; Hello(p) 调用了Hello函数但由于并没用到指针 则依旧会输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em><strong>但如果this在函数中有使用情况时则会出错</strong></em></p>
<h1 id="七、静态成员变量和静态成员函数">七、静态成员变量和静态成员函数</h1>
<p>tips：static修饰变量</p>
<p>a. 函数中局部变量：<br>
声明周期延长：该变量不随函数结束而结束<br>
初始化：只在第一次调用该函数时进行初始化<br>
记忆性：后序调用时，该变量使用前一次函数调用完成之后保存的值<br>
存储位置：不会存储在栈上，放在数据段</p>
<p>b. 全局变量<br>
改变该变量的链接属性，让该变量具有文件作用域，即只能在当前文件中使用</p>
<p>c. 修饰变量时，没有被初始化时会被自动初始化为0</p>
<ol start="2">
<li>static修饰函数<br>
改变该函数的链接属性，让该函数具有文件作用域，即只能在当前文件中使用</li>
</ol>
<h2 id="1-基本概念">1. 基本概念</h2>
<h3 id="1-静态成员">&lt;1&gt; 静态成员</h3>
<p><em><strong><u>在说明前面加了 static 关键字的成员。</u></strong></em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CRectangle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> w,h;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> nTotalArea;   <span class="comment">//静态成员变量  总面积</span></span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> nTotalNumber;  <span class="comment">//静态成员变量  总数目</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">CRectangle</span>(<span class="type">int</span> w_,<span class="type">int</span> h_);</span><br><span class="line">        ~<span class="built_in">CRectangle</span>();</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">PrintTotal</span><span class="params">()</span></span>;  <span class="comment">//静态成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> CRectangle:: nTotalArea=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> CRectangle:: nTotalNumber=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><mark>只能在类的外面被初始化。</mark></p>
<h3 id="2-差别">&lt;2&gt; 差别</h3>
<p><strong><u>普通成员变量每一个对象有各自的一份，但静态成员变量一共就一份，为所有对象共享。</u></strong></p>
<p><strong><u>sizeof运算符不会计算静态成员变量</u></strong></p>
<p><strong><u>普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用于某个对象</u></strong></p>
<p><strong><u>因此静态成员不需要通过对象就能访问也就意味着this对静态成员是毫无意义的不能出现this</u></strong></p>
<p><strong><u>静态成员可以被看作是类下面的“全局变量”</u></strong></p>
<h2 id="2-如何访问静态成员">2. 如何访问静态成员</h2>
<p><em>1.类名::成员名</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CRectangle::<span class="built_in">PrintTotal</span>();</span><br></pre></td></tr></table></figure>
<p><em>2.对象名.成员名</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CRectangle r;</span><br><span class="line">r.<span class="built_in">PrintTotal</span>()；<span class="comment">// PrintToal 并不作用于r这个对象上</span></span><br></pre></td></tr></table></figure>
<p>3.指针-&gt;成员名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CRtangle *p =&amp;r;</span><br><span class="line">p-&gt;<span class="built_in">PrintTotal</span>();<span class="comment">//PrintToal 并不作用于r这个对象上</span></span><br></pre></td></tr></table></figure>
<p>4.引用.成员名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CRtangle &amp;ref = r;</span><br><span class="line"><span class="type">int</span> n =ref.nTotalNumber;</span><br></pre></td></tr></table></figure>
<p><strong>静态成员变量本质上是类的全局变量，哪怕一个对象都不存在，类的静态成员变量也存在</strong></p>
<p><strong>静态成员函数本质上是类的全局函数</strong></p>
<p><strong>这种机制的目的是将和某些类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于理解和维护</strong></p>
<p><strong>静态成员变量必须要在程序运行前创建</strong></p>
<p>![08ab2cf1-255a-4a02-9498-897a72a4be4d](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/08ab2cf1-255a-4a02-9498-897a72a4be4d.png)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CRectangle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> w,h;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> nTotalArea;   <span class="comment">//静态成员变量  总面积</span></span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> nTotalNumber;  <span class="comment">//静态成员变量  总数目</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">CRectangle</span>(<span class="type">int</span> w_,<span class="type">int</span> h_);<span class="comment">//构造函数</span></span><br><span class="line">        <span class="built_in">CRectangle</span>(CRectangle &amp;r);<span class="comment">//复制构造函数</span></span><br><span class="line">        ~<span class="built_in">CRectangle</span>();<span class="comment">//析构函数</span></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">PrintTotal</span><span class="params">()</span></span>;  <span class="comment">//静态成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line">CRectangle::<span class="built_in">CRectangle</span>(<span class="type">int</span> w_,<span class="type">int</span> h_)  <span class="comment">//构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    w=w_;</span><br><span class="line">    h=h_;</span><br><span class="line">   nTotalArea+=w*h;</span><br><span class="line">    nTotalNumber++;</span><br><span class="line">&#125;</span><br><span class="line"> CRectangle::<span class="built_in">CRectangle</span>(CRectangle &amp;r)<span class="comment">// 复制构造函数！！！！</span></span><br><span class="line">&#123;</span><br><span class="line">    w=r.w;</span><br><span class="line">    h=r.h;</span><br><span class="line">    nTotalArea+=w*h;</span><br><span class="line">    nTotalNumber++;</span><br><span class="line">&#125;</span><br><span class="line">CRectangle::~<span class="built_in">CRectangle</span>()  <span class="comment">// 析构函数</span></span><br><span class="line">&#123;</span><br><span class="line">    nTotalNumber--;</span><br><span class="line">    nTotalArea-=w*h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CRectangle::PrintTotal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; nTotalNumber &lt;&lt; <span class="string">&quot;,&quot;</span>&lt;&lt; nTotalArea &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> CRectangle::nTotalNumber=<span class="number">0</span>;<span class="comment">//必需在定义类的文件中对静态成员变量进行一次说明或初始</span></span><br><span class="line"><span class="type">int</span> CRectangle::nTotalArea=<span class="number">0</span>;<span class="comment">//化。否则编译能通过，链接不能通过</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CRectangle <span class="title">r1</span><span class="params">(<span class="number">3</span>,<span class="number">3</span>)</span>,<span class="title">r2</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    CRectangle::<span class="built_in">PrintTotal</span>(); <span class="comment">//cout &lt;&lt; CRectangle::nTotalNumber;//wrong 面积和数量是私有的无法访问只能通过成员函数访问</span></span><br><span class="line">    r1.<span class="built_in">PrintTotal</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><u>必需在定义类的文件中对静态成员变量进行一次说明或初始化。否则编译能通过，链接不能通过</u></strong></p>
<p><strong>若静态成员在main之前构造则生命周期等同于全局对象</strong></p>
<p><em><strong>t<mark>ips:在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数</mark></strong></em></p>
<p>因为这两者是依赖于具体对象而实现的。</p>
<p>![b4193d37-16c0-481f-aa96-09b81ca739c6](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/b4193d37-16c0-481f-aa96-09b81ca739c6.png)</p>
<p><strong>无法判别w属于哪个对象</strong></p>
<p>![862202a2-d4e0-47a9-a93b-3f1ab4f9f827](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/862202a2-d4e0-47a9-a93b-3f1ab4f9f827.png)</p>
<h1 id="八、成员对象和封闭类">八、成员对象和封闭类</h1>
<h2 id="1-封闭类">1.封闭类</h2>
<p><em><strong>有成员对象的类（成员对象：作为其他类的成员的对象）</strong></em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CTyre</span>  <span class="comment">//轮胎类</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> radius;  <span class="comment">//半径  </span></span><br><span class="line">        <span class="type">int</span> width;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">CTyre</span>(<span class="type">int</span> r,<span class="type">int</span> w): <span class="built_in">radius</span>(r),<span class="built_in">width</span>(w)&#123;  &#125;   <span class="comment">//初始化列表   构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CEngine</span> <span class="comment">//引擎类</span></span><br><span class="line">&#123;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CCar</span>  <span class="comment">//封闭类</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> price;  <span class="comment">//价格</span></span><br><span class="line">        CTyre type;  <span class="comment">// 成员对象</span></span><br><span class="line">        CEngine engine;<span class="comment">// 成员对象</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">CCar</span>(<span class="type">int</span> p,<span class="type">int</span> tr,<span class="type">int</span> tw); <span class="comment">//构造函数声明</span></span><br><span class="line">&#125;;</span><br><span class="line">CCar::<span class="built_in">CCar</span>(<span class="type">int</span> p,<span class="type">int</span> tr,<span class="type">int</span> w): <span class="built_in">price</span>(p),<span class="built_in">tyre</span>(tr,w) <span class="comment">//初始化列表 构造函数定义</span></span><br><span class="line">&#123;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CCar <span class="title">car</span><span class="params">(<span class="number">20000</span>,<span class="number">17</span>,<span class="number">225</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em><strong>如果CCar不定义构造函数，“CCar car;” 会编译出错，因为编译器无法理解car.tyre该如何初始化但 car.engine的初始化没问题（因为它本身就是无参数），用默认的构造函数即可</strong></em></p>
<p>![9d39f11e-8bdc-4168-a557-c723b78f3e8e](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/9d39f11e-8bdc-4168-a557-c723b78f3e8e.png)</p>
<p>![76d57fcf-2519-405a-9508-f4865c856832](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/76d57fcf-2519-405a-9508-f4865c856832.png)</p>
<h2 id="2-封闭类构造函数和析构函数的执行顺序">2.封闭类构造函数和析构函数的执行顺序</h2>
<p><strong><u>1.封闭类对象生成时，先执行所有对象成员的构造函数，再执行封闭类的构造函数；</u></strong></p>
<p><strong><u>2.对象成员的构造函数调用次序和对象成员在类中的说明次序一致，与他们在成员初始化列表中出现的次序无关。</u></strong></p>
<p><strong><u>3.当封闭类的对象消亡时，先执行封闭类的析构函数，再执行成员对象的析构函数。次序和构造函数的调用次序相反。</u></strong></p>
<p><mark>先构造的后析构</mark></p>
<p>![9cc6f6a6-2d6b-4749-8d50-ae2ae631793f](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/9cc6f6a6-2d6b-4749-8d50-ae2ae631793f.png)![cd68750d-1ddc-47cd-8ebb-e36ac449788d](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/cd68750d-1ddc-47cd-8ebb-e36ac449788d.png)</p>
<h2 id="mark-3-封闭类的复制构造函数-mark"><mark>3.封闭类的复制构造函数</mark></h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>() &#123; cout&lt;&lt; <span class="string">&quot;default&quot;</span> &lt;&lt; endl; &#125;  <span class="comment">//构造函数</span></span><br><span class="line">        <span class="built_in">A</span>(A &amp; a) &#123; cout &lt;&lt;<span class="string">&quot; copy&quot;</span> &lt;&lt; endl;&#125;   <span class="comment">//复制构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;  A a;  &#125;;<span class="comment">// 编译器自动生成的构造函数和复制构造函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b1,<span class="built_in">b2</span>(b1);  <span class="comment">// b1.a使用A类的无参构造函数初始化，调用B类的复制构造函数将b1复制给b2，b2.a时用A的复制构造函数初始化，且调用复制构造函数的实参就是b1.a</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出： default</strong></p>
<p><strong>copy</strong></p>
<h1 id="九-、常量对象、常量成员函数和常引用">九 、常量对象、常量成员函数和常引用</h1>
<h2 id="1-常量对象（const）">1.常量对象（const）</h2>
<p><em><strong>如果不希望某个对象的值被改变，则定义该对象的时候可以在前面加const关键字</strong></em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">            <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">SetValue</span><span class="params">()</span></span>&#123;   &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> Demo Obj;<span class="comment">//常量对象  无法修改其值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><mark>常量对象只能调用常成员函数，防止常成员对象被修改。</mark></p>
<h2 id="2-常量成员函数">2.常量成员函数</h2>
<p><em><strong>在类的成员函数说明后面添加const关键字，则该成员函数成为常量成员函数。</strong></em></p>
<p>tips：</p>
<ol>
<li>常量成员函数在执行期间不应该修改其所作用的对象，因此，常量成员函数中不能修改成员变量的值（<strong>静态变量除外</strong>），也不能调用同类的非常量的成员函数（<strong>静态成员函数除外</strong>）。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">GetValue</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">//常量成员函数</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sample::GetValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        value=<span class="number">0</span>;<span class="comment">//wrong  不可修改成员变量的值</span></span><br><span class="line">        <span class="built_in">func</span>();<span class="comment">//wrong   不可调用非常量成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> Sample o;<span class="comment">//o为常量对象</span></span><br><span class="line">    o.value=<span class="number">100</span>;<span class="comment">//error 常量对象不能修改</span></span><br><span class="line">    o.<span class="built_in">func</span>()<span class="comment">//    error  常量对象上不可执行非常量成员函数</span></span><br><span class="line">    o.<span class="built_in">GetValue</span>();<span class="comment">//right 常量对象上可以执行常量成员函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tips:</p>
<p><u>两个成员函数，名字和参数列表都一样，但一个是const，一个不是，算重载。</u></p>
<h2 id="3-常引用">3.常引用</h2>
<p>引用见上面</p>
<p>![34dd962a-c7c3-4479-be2b-ebb6fa1e5ee0](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/34dd962a-c7c3-4479-be2b-ebb6fa1e5ee0.png)</p>
<p>使用常引用</p>
<h1 id="十、内存分类">十、内存分类</h1>
<h2 id="1-代码区（静态区）">1.代码区（静态区）</h2>
<p>可执行代码</p>
<p>只读常量</p>
<h2 id="2-数据区">2.数据区</h2>
<h3 id="1-全局数据区-date-area">&lt; 1 &gt; 全局数据区 (date area)</h3>
<p>全局数据</p>
<p>静态数据</p>
<p>程序结束后由系统释放</p>
<h3 id="2-栈区（stack-area）">&lt; 2 &gt;栈区（stack area）</h3>
<p>函数内部的局部变量、函数参数、返回数据、返回地址，函数结束时存储单元自动释放</p>
<h3 id="3-堆区（heap-area）">&lt; 3 &gt;堆区（heap area）</h3>
<p>一般由程序员分配释放 如： new ，如果程序员不释放程序结束后可能由os回收。</p>
<p>malloc free</p>
<p>new delete</p>
<h1 id="十一、友元">十一、友元</h1>
<p><strong>友元分为友元函数和友元类</strong></p>
<h2 id="1-友元函数">1.友元函数</h2>
<p><u>一个类的友元函数可以访问该类的私有成员</u></p>
<p><u>可以把一个类的成员函数说明为另一个类的友元</u></p>
<h2 id="2-友元类">2.友元类</h2>
<p><u>如果类A是B的友元类，那么A的所有成员函数可以访问B的私有成员</u></p>
<p>tips：<br>
<strong>友元类的关系不能传递，不能继承</strong></p>
<h1 id="十二、运算符重载">十二、运算符重载</h1>
<h3 id="1-格式-加号-等号操作符重载">1. 格式 加号 等号操作符重载</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="keyword">operator</span> +(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)<span class="comment">//运算符重载</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c=a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=b;i&gt;<span class="number">0</span>;i--) c++;</span><br><span class="line">    <span class="keyword">return</span> (c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="keyword">operator</span> +(<span class="type">double</span> &amp;a,<span class="type">double</span> &amp;b)&#123;<span class="comment">//运算符重载</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">9</span>,b=<span class="number">8</span>;</span><br><span class="line">    <span class="type">float</span> d=<span class="number">1.2</span>,c=<span class="number">3.4</span>;</span><br><span class="line">    <span class="type">int</span> c=a+b;<span class="comment">//int c=operator +(a,b);</span></span><br><span class="line">    <span class="type">float</span> f=d+e;<span class="comment">// float f=operator +(d,e);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>以非成员函数（友元函数）的形式进行重载</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">aa</span>&#123;</span><br><span class="line">    <span class="type">float</span> a;</span><br><span class="line">    <span class="type">float</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">float</span> &amp;<span class="title">aaa</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (a);&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> &amp;<span class="title">bbb</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (b);&#125;</span><br><span class="line"><span class="keyword">friend</span> aa <span class="keyword">operator</span> +(<span class="type">const</span> aa &amp;,<span class="type">const</span> aa &amp;);<span class="comment">//运算符重载  友元函数形式</span></span><br><span class="line">&#125;</span><br><span class="line">aa <span class="keyword">operator</span> +(<span class="type">const</span> aa &amp; a,<span class="type">const</span> aa&amp; b)&#123;</span><br><span class="line">    aa c;</span><br><span class="line">    c.a=a.a+b.a;</span><br><span class="line">    c.b=a.b+b.b;</span><br><span class="line">    <span class="keyword">return</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    aa a,b;</span><br><span class="line">    a.<span class="built_in">aaa</span>()=<span class="number">1</span>;a.<span class="built_in">bbb</span>()=<span class="number">2</span>;</span><br><span class="line">    b.<span class="built_in">aaa</span>()=<span class="number">3</span>;b.<span class="built_in">bbb</span>()=<span class="number">4</span>;</span><br><span class="line">    aa c=a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>也可以以成员函数的形式进行重载</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">aa</span>&#123;</span><br><span class="line">    <span class="type">float</span> a;</span><br><span class="line">    <span class="type">float</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">float</span> &amp;<span class="title">aaa</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (a);&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> &amp;<span class="title">bbb</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (b);&#125;</span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span>=(aa <span class="type">const</span> &amp;);<span class="comment">//运算符重载  成员函数形式</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> aa::<span class="keyword">operator</span> =(aa <span class="type">const</span> &amp; b)&#123;</span><br><span class="line">    a=b.a;</span><br><span class="line">    b=b.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    aa a,b;</span><br><span class="line">    a.<span class="built_in">aaa</span>()=<span class="number">1</span>;a.<span class="built_in">bbb</span>()=<span class="number">2</span>;</span><br><span class="line">    b.<span class="built_in">aaa</span>()=<span class="number">3</span>;b.<span class="built_in">bbb</span>()=<span class="number">4</span>;</span><br><span class="line">    aa c;</span><br><span class="line">    c=a;<span class="comment">//等价于c.operatpr=(a);//函数表示法   重载函数的返回值类型不能为空（c）。</span></span><br><span class="line">    cout&lt;&lt;c.<span class="built_in">aaa</span>()&lt;&lt;endl&lt;&lt;c.<span class="built_in">bbb</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>左侧是运算符表示法，运算符左侧的对象c是调用对象，右边是参数</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">aa</span>&#123;</span><br><span class="line">    <span class="type">float</span> a;</span><br><span class="line">    <span class="type">float</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">float</span> &amp;<span class="title">aaa</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (a);&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> &amp;<span class="title">bbb</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (b);&#125;</span><br><span class="line">aa &amp; <span class="keyword">operator</span> =( aa <span class="type">const</span> &amp;);<span class="comment">//参数为常引用</span></span><br><span class="line">&#125;;</span><br><span class="line">aa&amp; aa::<span class="keyword">operator</span> =(aa <span class="type">const</span> &amp; b)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;a=b.a;</span><br><span class="line">    <span class="keyword">this</span>-&gt;b=b.b;</span><br><span class="line"><span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    aa a,b;</span><br><span class="line">    a.<span class="built_in">aaa</span>()=<span class="number">1</span>;a.<span class="built_in">bbb</span>()=<span class="number">2</span>;</span><br><span class="line">    b.<span class="built_in">aaa</span>()=<span class="number">3</span>;b.<span class="built_in">bbb</span>()=<span class="number">4</span>;</span><br><span class="line">    aa c;</span><br><span class="line">    c=a;</span><br><span class="line">    c=a=b;<span class="comment">//即 （c=a）=b;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">aa</span>&#123;</span><br><span class="line">    <span class="type">float</span> a;</span><br><span class="line">    <span class="type">float</span> b;</span><br><span class="line">     <span class="type">int</span> *m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">aa</span>():<span class="built_in">a</span>(<span class="number">1</span>),<span class="built_in">b</span>(<span class="number">2</span>),<span class="built_in">m</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">9</span>))&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> &amp;<span class="title">aaa</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (a);&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> &amp;<span class="title">bbb</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (b);&#125;</span><br><span class="line">aa &amp; <span class="keyword">operator</span> =( aa <span class="type">const</span> &amp;);<span class="comment">//参数为常引用</span></span><br><span class="line">&#125;;</span><br><span class="line">aa&amp; aa::<span class="keyword">operator</span> =(aa <span class="type">const</span> &amp; b)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;a=b.a;</span><br><span class="line">    <span class="keyword">this</span>-&gt;b=b.b;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m=<span class="keyword">new</span> <span class="built_in">int</span>(*(b.m));<span class="comment">//深拷贝  </span></span><br><span class="line"><span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    aa a;</span><br><span class="line">    a.<span class="built_in">aaa</span>()=<span class="number">1</span>;a.<span class="built_in">bbb</span>()=<span class="number">2</span>;</span><br><span class="line">    aa c;</span><br><span class="line">    c=a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>问题</strong>：在创建a的时候已经给a.m开辟了一个空间存放9，但在=中又开了一个空间，这样会导致内存泄漏</p>
<p><strong>解决</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">aa</span>&#123;</span><br><span class="line">    <span class="type">float</span> a;</span><br><span class="line">    <span class="type">float</span> b;</span><br><span class="line">     <span class="type">int</span> *m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">aa</span>():<span class="built_in">a</span>(<span class="number">1</span>),<span class="built_in">b</span>(<span class="number">2</span>),<span class="built_in">m</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">9</span>))&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> &amp;<span class="title">aaa</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (a);&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> &amp;<span class="title">bbb</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (b);&#125;</span><br><span class="line">aa &amp; <span class="keyword">operator</span> =( aa <span class="type">const</span> &amp;);<span class="comment">//参数为常引用</span></span><br><span class="line">&#125;;</span><br><span class="line">aa&amp; aa::<span class="keyword">operator</span> =(aa <span class="type">const</span> &amp; b)&#123;</span><br><span class="line">    <span class="built_in">delete</span>(m);</span><br><span class="line">    <span class="keyword">this</span>-&gt;a=b.a;</span><br><span class="line">    <span class="keyword">this</span>-&gt;b=b.b;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m=<span class="keyword">new</span> <span class="built_in">int</span>(*(b.m));<span class="comment">//深拷贝  </span></span><br><span class="line"><span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    aa a;</span><br><span class="line">    a.<span class="built_in">aaa</span>()=<span class="number">1</span>;a.<span class="built_in">bbb</span>()=<span class="number">2</span>;</span><br><span class="line">    aa c;</span><br><span class="line">    c=a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>问题</strong>：虽然解决了内存泄漏的问题，但是当执行a=a这样的语句时会出问题。</p>
<p><strong>解决</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">aa</span>&#123;</span><br><span class="line">    <span class="type">float</span> a;</span><br><span class="line">    <span class="type">float</span> b;</span><br><span class="line">     <span class="type">int</span> *m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">aa</span>():<span class="built_in">a</span>(<span class="number">1</span>),<span class="built_in">b</span>(<span class="number">2</span>),<span class="built_in">m</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">9</span>))&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> &amp;<span class="title">aaa</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (a);&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> &amp;<span class="title">bbb</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (b);&#125;</span><br><span class="line">aa &amp; <span class="keyword">operator</span> =( aa <span class="type">const</span> &amp;);<span class="comment">//参数为常引用</span></span><br><span class="line">&#125;;</span><br><span class="line">aa&amp; aa::<span class="keyword">operator</span> =(aa <span class="type">const</span> &amp; b)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>==&amp;b) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="built_in">delete</span>(m);</span><br><span class="line">    <span class="keyword">this</span>-&gt;a=b.a;</span><br><span class="line">    <span class="keyword">this</span>-&gt;b=b.b;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m=<span class="keyword">new</span> <span class="built_in">int</span>(*(b.m));<span class="comment">//深拷贝  </span></span><br><span class="line"><span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    aa a;</span><br><span class="line">    a.<span class="built_in">aaa</span>()=<span class="number">1</span>;a.<span class="built_in">bbb</span>()=<span class="number">2</span>;</span><br><span class="line">    aa c;</span><br><span class="line">    c=a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完美解决！</p>
<h3 id="2-前自操作符、前自操作符重载">2 .前自操作符、前自操作符重载</h3>
<p>对于++p,p++这两种情况的操作符，前者为前自操作符，后者为后自操作符的重载格式如下 前者式子的值为加1之后，后者为加1之前</p>
<p><strong>前自操作符：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">aa</span>&#123;</span><br><span class="line">    <span class="type">float</span> a;</span><br><span class="line">    <span class="type">float</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">aa</span>():<span class="built_in">a</span>(<span class="number">1</span>),<span class="built_in">b</span>(<span class="number">2</span>)&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> &amp;<span class="title">aaa</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (a);&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> &amp;<span class="title">bbb</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (b);&#125;</span><br><span class="line">aa &amp; <span class="keyword">operator</span> ++();<span class="comment">//前自操作符返回引用</span></span><br><span class="line">&#125;;</span><br><span class="line">aa&amp; aa::<span class="keyword">operator</span> ++()&#123;</span><br><span class="line">    a=a+<span class="number">1</span>;</span><br><span class="line">    b=b+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    aa a;</span><br><span class="line">    a.<span class="built_in">aaa</span>()=<span class="number">1</span>;a.<span class="built_in">bbb</span>()=<span class="number">2</span>;</span><br><span class="line">    cout&lt;&lt;(++a).<span class="built_in">aaa</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;a.<span class="built_in">aaa</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：2</p>
<p>2</p>
<p><mark>前自操作符返回引用</mark></p>
<p><strong>后自操作符：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">aa</span>&#123;</span><br><span class="line">    <span class="type">float</span> a;</span><br><span class="line">    <span class="type">float</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">aa</span>():<span class="built_in">a</span>(<span class="number">1</span>),<span class="built_in">b</span>(<span class="number">2</span>)&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> &amp;<span class="title">aaa</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (a);&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> &amp;<span class="title">bbb</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (b);&#125;</span><br><span class="line">aa <span class="keyword">operator</span> ++(<span class="type">int</span>);<span class="comment">//后自操作符返回值 并且参数为int</span></span><br><span class="line">&#125;;</span><br><span class="line">aa  aa::<span class="keyword">operator</span> ++(<span class="type">int</span>)&#123;</span><br><span class="line">    <span class="function">aa <span class="title">m</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    a=a+<span class="number">1</span>;</span><br><span class="line">    b=b+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (m); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    aa a;</span><br><span class="line">    a.<span class="built_in">aaa</span>()=<span class="number">1</span>;a.<span class="built_in">bbb</span>()=<span class="number">2</span>;</span><br><span class="line">    cout&lt;&lt;(a++).<span class="built_in">aaa</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;a.<span class="built_in">aaa</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br>
    1</p>
<p>2</p>
<p><mark>后自操作符返回值</mark></p>
<h3 id="3-转换运算符重载">3.转换运算符重载</h3>
<p><strong>oprator typename();</strong></p>
<p><em>tips:<br>
1.转换函数必须是类方法。</em></p>
<p><em>2.转换函数不能指定返回类型。</em></p>
<p><em>3.转换函数不能有参数</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">aa</span>&#123;</span><br><span class="line">    <span class="type">float</span> a; <span class="type">float</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">float</span> &amp;<span class="title">aaa</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>(a);&#125;</span><br><span class="line"> <span class="function"><span class="type">float</span> &amp;<span class="title">bbb</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>(b);&#125;</span><br><span class="line"> <span class="function"><span class="keyword">operator</span> <span class="title">float</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">aa::<span class="keyword">operator</span> <span class="title">float</span><span class="params">()</span></span>&#123; <span class="keyword">return</span>(a);&#125;<span class="comment">//转换运算符重载</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    aa a,b;</span><br><span class="line">    a.<span class="built_in">aaa</span>()=<span class="number">1</span>; a.<span class="built_in">bbb</span>()=<span class="number">2</span>;</span><br><span class="line">    b.<span class="built_in">aaa</span>()=<span class="number">3</span>; b.<span class="built_in">bbb</span>()=<span class="number">4</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">float</span>(a)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="number">10</span>+a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>有的功能既可以用自定义的转换函数实现也可以用成员函数实现。</strong></p>
<p>![09e1390c-7472-40a8-9a91-89600eaa3c3b](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/09e1390c-7472-40a8-9a91-89600eaa3c3b.png)</p>
<h3 id="4-总结">4.总结</h3>
<ol>
<li>
<p>= 、（）、||、-&gt;  只能是成员函数进行重载</p>
</li>
<li>
<p>cout&lt;&lt; cin&gt;&gt;  只能是友元重载（cout 是其他类的对象）</p>
</li>
<li>
<p>+和=等既可以是友元也可以是成员</p>
</li>
<li>
<p>下列运算符不可以重载<br>
![346d249f-9525-4bf1-97c4-eef273318b3c](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/346d249f-9525-4bf1-97c4-eef273318b3c.png)</p>
</li>
</ol>
<h1 id="十三、继承">十三、继承</h1>
<h2 id="1-语法">1.语法</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>&lt;派生类名&gt;:&lt;继承方式&gt;&lt;基类名称&gt;,...</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>继承方式有三种：public、protec、private</strong></p>
<p><strong>若不写继承方式则默认为private</strong></p>
<p><strong>在public继承下，基类被称为父类，派生类为子类</strong></p>
<p><strong>一个基类为单继承，多个基类为多（重）继承</strong></p>
<p><strong>派生类可以是其他继承的基类，多层继承和继承树（最多7至9层）</strong></p>
<h2 id="2-派生类">2.派生类</h2>
<h4 id="1-派生类的成员">&lt; 1 &gt; 派生类的成员</h4>
<p>1.构造 析构 拷贝 赋值函数。</p>
<p>2.定义的成员函数、数据成员。</p>
<p>3.基类的所有成员（<u>除了基类的构造、析构、拷贝、赋值函数，自动转换函数</u>）。</p>
<p><strong>eg:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">AFunc1</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">AFunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">AFunc3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//以继承方式复用类A的实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">BFunc1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">        <span class="built_in">BFunc3</span>();</span><br><span class="line">        <span class="built_in">AFunc1</span>();</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">BFunc2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">BFunc3</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>![93745add-b3c7-4e25-978e-05fe14487c92](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/93745add-b3c7-4e25-978e-05fe14487c92.png)</p>
<h4 id="2-派生类对象的空间大小">&lt; 2 &gt;派生类对象的空间大小</h4>
<p>![8631faeb-2a0f-46a9-9f6b-f630ba641890](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/8631faeb-2a0f-46a9-9f6b-f630ba641890.png)</p>
<h4 id="3-派生类中成员的访问控制">&lt; 3 &gt;派生类中成员的访问控制</h4>
<p>![822726bb-122e-48ff-af44-90188a10ff97](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/822726bb-122e-48ff-af44-90188a10ff97.png)</p>
<p><strong>基类的私有成员在派生类里不可直接访问，但可通过成员函数间接访问，存在于派生类里</strong></p>
<p><strong>eg：</strong></p>
<p>![136e9237-e262-46fc-87f4-50623f4556e7](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/136e9237-e262-46fc-87f4-50623f4556e7.png)</p>
<p><strong>基类的保护成员在多个保护或公有的继承方式下依旧是保护成员</strong></p>
<p><strong>基类的私有成员只能本类访问，一经继承则无法访问</strong></p>
<h4 id="4-派生类的构造和析构">&lt; 4 &gt;派生类的构造和析构</h4>
<p><strong>基类的构造、析构、拷贝、赋值函数，自动转换函数不会在派生类的成员函数中</strong></p>
<h5 id="1-派生类的构造函数">1.派生类的构造函数</h5>
<p>构造顺序：先基类后派生类</p>
<p>初始化列表中可以指定基类的构造函数或拷贝函数</p>
<p>多重继承时，基类按先后顺序构造</p>
<h5 id="2-派生类的析构函数">2.派生类的析构函数</h5>
<p>先执行派生类的析构函数，再自动执行基类的析构</p>
<p><strong>eg</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> n):<span class="built_in">num</span>(n)&#123;<span class="comment">//构造函数</span></span><br><span class="line">        ++num;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base构造&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123;<span class="comment">//析构函数</span></span><br><span class="line">        --num;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base析构&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> :<span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> n1,<span class="type">int</span> n2):<span class="built_in">Base</span>(n1),<span class="built_in">val</span>(n2)</span><br><span class="line">    &#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;DERived构造&quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;DERived析构&quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">d</span><span class="params">(<span class="number">1</span>, <span class="number">99</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>![ea7aacc5-f41e-4106-9b8b-254017e34529](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/ea7aacc5-f41e-4106-9b8b-254017e34529.png)</p>
<h4 id="5-派生类的拷贝构造和赋值函数">&lt; 5 &gt;派生类的拷贝构造和赋值函数</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> num) :<span class="built_in">data</span>(num) &#123;&#125;<span class="comment">//构造函数 初始化列表</span></span><br><span class="line">    ~<span class="built_in">A</span>()&#123;&#125;                   <span class="comment">//析构函数</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; other)        <span class="comment">//拷贝构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        data = other.data;</span><br><span class="line">    &#125;</span><br><span class="line">    A&amp; <span class="keyword">operator</span> =(<span class="type">const</span> A&amp; rhs) <span class="comment">//赋值函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs) </span><br><span class="line">        &#123;</span><br><span class="line">            data = rhs.data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetData</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data; &#125;<span class="comment">//成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">float</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0.6</span> * data; &#125;<span class="comment">//转换</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> data;           <span class="comment">//由于只有一个数据int因此写不写赋值和拷贝构造无所谓，系统自带的便可满足要求</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> n1,<span class="type">int</span> n2):<span class="built_in">A</span>(n1),<span class="built_in">num</span>(n2)&#123;&#125;</span><br><span class="line">    ~<span class="built_in">B</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">const</span> B&amp; other):<span class="built_in">A</span>(other) <span class="comment">//A（oher）通过基类的拷贝构造函数构造基类部分</span></span><br><span class="line">    &#123;                            <span class="comment">//拷贝构造函数</span></span><br><span class="line">        num = other.num;</span><br><span class="line">        <span class="comment">//data = other.data;    //由于data为保护且为保护继承则可以访问但这样写有局限性</span></span><br><span class="line">    &#125;</span><br><span class="line">    B&amp; <span class="keyword">operator</span> =(<span class="type">const</span> B&amp; rhs) &#123;<span class="comment">//赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs)</span><br><span class="line">        &#123;</span><br><span class="line">            A::<span class="keyword">operator</span>=(rhs);<span class="comment">// 通过调用基类的赋值来实现派生类的</span></span><br><span class="line">            num = rhs.num;<span class="comment">//派生类自己的部分</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="6-继承的选择">&lt; 6 &gt;继承的选择</h4>
<p><strong>继承是一种代码复用的实现方式</strong></p>
<p>![6f3a0e4f-8516-425d-8239-4feb7d11d612](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/6f3a0e4f-8516-425d-8239-4feb7d11d612.png)</p>
<p><u>关联和依赖强调黑盒复用，即强调功能复用，而继承为白盒复用，强调代码的复用</u></p>
<h5 id="1-继承的含义">1.继承的含义</h5>
<p>强调代码复用，要了解基类的结构，无论使用哪一种继承方式，基类的源代码都要有。</p>
<h5 id="2-public继承">2.public继承</h5>
<p><u>表示“is a kind of” 、&quot;is a&quot;或 “like a” 的关系</u>，是一个<strong>分类</strong>的概念，即子类的功能比父类只多不少，例如动物和猫的关系、车与轿车的关系。</p>
<p><strong>好处</strong>：当我需要一个Car时，可以给我一个Car对象也可以给我MTCar、ATCar对象。</p>
<h5 id="3-private继承">3.private继承</h5>
<p>体现派生类实现要用基类的代码。</p>
<h5 id="4-protected继承">4.protected继承</h5>
<p>基类的公有和保护的都变成保护的，且使保护和公有的可以沿着继承树一直继承下去</p>
<p>例如：</p>
<p>![857f137a-c483-455a-888d-9c5429580473](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/857f137a-c483-455a-888d-9c5429580473.png)</p>
<h4 id="7-继承和组合的选择">&lt; 7 &gt;继承和组合的选择</h4>
<h5 id="1-组合与继承">1.组合与继承</h5>
<p><strong>组合：</strong></p>
<p>具有“has-a”或&quot;contain-a&quot;的关系。</p>
<p>子对象所属类的源代码可有可无。</p>
<p>类间使水平关系，相比继承可减少类的层次。</p>
<p><strong>继承：</strong></p>
<p>继承方式不同，目的不同。</p>
<p>基类源代码必须有。</p>
<p>public继承：表示is-a的关系。</p>
<p>private：表示“has-a”，“contain-a”，“implement of”的关系完全可以换成组合。</p>
<p>protected：同private，同时便于在多层继承关系中保持这种关系。</p>
<p>创建一个子类一定有完整基类的东西，同生共死，因此可以用组合而不是聚合</p>
<p><strong>真正需要公有继承的时候使用公有继承，对于其他的可以用组合水平关联代替，即是一种的关系时。</strong></p>
<p><u>多构建低矮的继承树，然后再通过水平关联的关系联系起来，不可以构建继承层数过多</u></p>
<h4 id="8-继承下的类型转换">&lt; 8 &gt;.继承下的类型转换</h4>
<h6 id="1-基类向派生类进行转换（向下转换）">1.基类向派生类进行转换（向下转换）</h6>
<p>private/protected下继承无实际意义（数据不全），但确实需要的话可以在派生类里定义构造函数。</p>
<p>public下从基类向派生类转换有时有意义（虚函数）有时没有。</p>
<h6 id="2-从派生类向基类转换">2.从派生类向基类转换</h6>
<p>保护和私有继承下由于数据不全没有实际意义但如果确实需要可通过强制类型转换。</p>
<p>eg：</p>
<p>![fac11426-1c4c-485e-b849-917b80130f52](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/fac11426-1c4c-485e-b849-917b80130f52.png)</p>
<p><u>Bike和Player的公有部分（接口）不同、转换无意义无法转换。</u></p>
<p>公有继承下：</p>
<p>此时向上转换有意义</p>
<p>逻辑上是类型泛化或一般化</p>
<p>语言上public行为被窄化</p>
<p>eg：</p>
<p>![6fff6333-284d-4770-ae37-f7a9213d2317](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/6fff6333-284d-4770-ae37-f7a9213d2317.png)</p>
<p>![5c7e006a-2fec-4141-8646-21a8c05e98bd](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/5c7e006a-2fec-4141-8646-21a8c05e98bd.png)</p>
<p>子类的指针转化为父类指针是安全的。</p>
<p>子类的对象转换为父类的引用（本质是指针）也是安全的。</p>
<p>子类对象转换为父类对象是一个新对象经过<u>剪裁，多余的丢失了</u>。即：</p>
<p>![cca84078-95e3-4625-a3cc-545d87fedb64](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/cca84078-95e3-4625-a3cc-545d87fedb64.png)</p>
<p><strong>sum</strong>：尽可能使用指针或引用进行向上转换。</p>
<p>![81e8c986-47ac-4730-97b1-20271ad65373](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/81e8c986-47ac-4730-97b1-20271ad65373.png)</p>
<h2 id="3-多重继承">3.多重继承</h2>
<h5 id="1-格式：">&lt; 1 &gt;格式：</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">public</span> B1,<span class="keyword">protected</span> B2<span class="comment">//有两个及两个以上的基类</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="2-派生类构造和析构顺序">&lt; 2 &gt;派生类构造和析构顺序</h5>
<p>构造时，严格按照继承顺序构造。（例子中先构造B1再构造B2）</p>
<p>析构时，正好与构造顺序相反。</p>
<h5 id="3-派生类对象的数据存放格式">&lt; 3 &gt;派生类对象的数据存放格式</h5>
<p>![fa8c1f6d-73ce-42c6-b1a2-e4152073e06a](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/fa8c1f6d-73ce-42c6-b1a2-e4152073e06a.png)</p>
<h5 id="4-名字冲突问题">&lt; 4 &gt;名字冲突问题</h5>
<p>例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() :<span class="built_in">num</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">55</span>; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() :<span class="built_in">num</span>(<span class="number">2</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">88</span>; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> :<span class="keyword">public</span>  A, <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">k</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; endl; <span class="comment">//模棱两可</span></span><br><span class="line">        cout &lt;&lt; num &lt;&lt; endl; <span class="comment">//模棱两可</span></span><br><span class="line">        cout &lt;&lt; B::<span class="built_in">f</span>() &lt;&lt; endl; <span class="comment">//correct！但不完美对复用不友好</span></span><br><span class="line">        cout &lt;&lt; A::num &lt;&lt; endl; <span class="comment">//correct！但不完美对复用不友好</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>解决方法一：</p>
<p>使用using解决名字冲突问题</p>
<p>![938708d8-ae9f-4cfe-b2c0-81ee61cb0141](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/938708d8-ae9f-4cfe-b2c0-81ee61cb0141.png)</p>
<p>缺点：本质上没有解决</p>
<p>那如果采用不同的名字呢？</p>
<p>例：</p>
<p>![89d4f89a-2ae9-4a27-b096-b3540a563a6e](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/89d4f89a-2ae9-4a27-b096-b3540a563a6e.png)</p>
<p>还是存在名字冲突</p>
<p>解决方法二：<strong>虚基类</strong></p>
<p>![a8fc0fc2-7249-4c59-a983-9c6e06f747ff](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/a8fc0fc2-7249-4c59-a983-9c6e06f747ff.png)</p>
<p>格式：在继承方式前面加virtual关键字</p>
<p>创建派生类时，先创建派生类，再创建基类，由于基类为虚基类所以把虚基类延后创建，产生一个指针指向最后创建的虚基类</p>
<h6 id="其他解决方案（其他语言）：">其他解决方案（其他语言）：</h6>
<p><strong>限定只能单继承</strong></p>
<p><strong>限定多个基类中至多有一个实例变量：</strong></p>
<p>避免了多重继承下的数据成员名字冲突</p>
<p>保留了多重继承的方便性</p>
<h5 id="5-虚基类">&lt; 5 &gt;虚基类</h5>
<p><u>延迟创建虚基类</u></p>
<p>对于派生类D的创建</p>
<p>![659c8cef-3c7b-41dd-96d6-98ab32e765b6](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/659c8cef-3c7b-41dd-96d6-98ab32e765b6.png)</p>
<p><strong>缺点</strong>：对成员提出更高的要求</p>
<p><u>类型向上转换困难（非虚基类的话在公有继承的继承方式下子类向上转化为基类永远是安全的）</u></p>
<p>如：在虚基类下将D类向上转化为B类得到的是</p>
<p>![a373efae-48c2-447e-a408-341136db086b](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/a373efae-48c2-447e-a408-341136db086b.png)</p>
<p>但实际上B应该是：</p>
<p>![fb671b48-1e84-4c96-a692-4a7ca2fb3890](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/fb671b48-1e84-4c96-a692-4a7ca2fb3890.png)</p>
<p>这种转换效率十分低下</p>
<h1 id="十四、虚机制">十四、虚机制</h1>
<h3 id="1-静态编联-动态编联">1.静态编联 动态编联</h3>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span><span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; 面积是：&quot;</span> &lt;&lt; <span class="built_in">Area</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">Area</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;          <span class="comment">//////</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> :<span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">float</span> w, <span class="type">float</span> h) &#123;</span><br><span class="line">        mWidth = w;</span><br><span class="line">        mHeight = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">Area</span><span class="params">()</span><span class="type">const</span> </span>&#123;                        <span class="comment">/////</span></span><br><span class="line">        <span class="keyword">return</span> mWidth * mHeight;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> mWidth, mHeight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> :<span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">float</span> r):<span class="built_in">mRadius</span>(r)&#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">Area</span><span class="params">()</span> <span class="type">const</span> </span>&#123;                         <span class="comment">///////</span></span><br><span class="line">        <span class="keyword">return</span> mRadius * mRadius * <span class="number">3.14</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> mRadius;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Rectangle <span class="title">rect</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Circle <span class="title">cir</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    Shape&amp; sp1 = rect;</span><br><span class="line">    Shape&amp; sp2 = cir;</span><br><span class="line">    sp1.<span class="built_in">Show</span>();</span><br><span class="line">    sp2.<span class="built_in">Show</span>();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br>
面积是：0<br>
面积是：0</p>
<p>问题：为什么输出为0？</p>
<p>回答：涉及到静态编联和动态编联，由于是静态编联则使用的Area（）函数永远是基类的函数</p>
<h5 id="1-区别">&lt; 1 &gt;区别</h5>
<p>![fb911503-72c4-4eb7-a95a-5898df1eb540](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/fb911503-72c4-4eb7-a95a-5898df1eb540.png)</p>
<h3 id="2-虚函数">2.虚函数</h3>
<h5 id="1-格式">&lt; 1 &gt;格式</h5>
<img title="" src="file:///D:/新建文件夹/Typedown/5b29e176-03ad-4acf-979f-0d66e04b599c.png" alt="loading-ag-3063" data-align="inline">
<p><strong>tips</strong>：若类中含有虚函数则析构函数一定是虚函数</p>
<p>![7e2925da-1d9c-4af9-b461-3593eebbff6f](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/7e2925da-1d9c-4af9-b461-3593eebbff6f.png)</p>
<p><strong>tips</strong>：</p>
<p>1.若基类的析构函数是虚的，则派生类的析构函数不管写不写virtual关键字，都默认为虚函数。</p>
<p>2.关于相同和相容：</p>
<p>![88ba8da9-7dd1-4564-841b-0a98537e526e](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/88ba8da9-7dd1-4564-841b-0a98537e526e.png)</p>
<p>对于F函数基类和子类的返回类型相同</p>
<p>对于G函数由于是公有继承则Child可以安全的转换为Parent，为相容</p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span><span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; 面积是：&quot;</span> &lt;&lt; <span class="built_in">Area</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">Area</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;          <span class="comment">//////  虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> :<span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">float</span> w, <span class="type">float</span> h) &#123;</span><br><span class="line">        mWidth = w;</span><br><span class="line">        mHeight = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span>  <span class="type">float</span> <span class="title">Area</span><span class="params">()</span><span class="type">const</span> </span>&#123;                        <span class="comment">/////虚函数</span></span><br><span class="line">        <span class="keyword">return</span> mWidth * mHeight;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> mWidth, mHeight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> :<span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">float</span> r):<span class="built_in">mRadius</span>(r)&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span>  <span class="type">float</span> <span class="title">Area</span><span class="params">()</span> <span class="type">const</span> </span>&#123;                         <span class="comment">///////虚函数</span></span><br><span class="line">        <span class="keyword">return</span> mRadius * mRadius * <span class="number">3.14</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> mRadius;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Rectangle <span class="title">rect</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Circle <span class="title">cir</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    Shape&amp; sp1 = rect;</span><br><span class="line">    Shape&amp; sp2 = cir;</span><br><span class="line">    sp1.<span class="built_in">Show</span>();</span><br><span class="line">    sp2.<span class="built_in">Show</span>();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br>
面积是：2<br>
面积是：3.14</p>
<p><strong>采用动态编联</strong></p>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Parent</span>()&#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">G</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">k</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> :<span class="keyword">public</span> Parent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Child</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Child</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Other</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">G</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">H</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Parent  类的3个虚函数：</p>
<p>1.Parent::~Parent()</p>
<p>2.Parent::G()</p>
<p>3.Parent::K()</p>
<p>Child 类的4个虚函数：</p>
<p>1.Child::~Child()</p>
<p>2.Child::G()//override</p>
<p>3.Parent::k()//继承父类</p>
<p>4.Child::H()//子类新定义的</p>
<p>其中由于基类里G就是虚函数则派生类的G不用写virtual关键字也是虚函数</p>
<h3 id="3-虚函数表（虚拟表、虚表、VTable）">3.虚函数表（虚拟表、虚表、VTable）</h3>
<h5 id="1-虚表">&lt; 1 &gt;虚表</h5>
<p>一个指针数组，各元素存放对应虚函数的入口地址</p>
<p>tips：</p>
<p>1.要求对应类中至少有一个虚函数</p>
<p>2.一个类至多有一个虚拟表，同一个类的不同对象共享该虚拟表</p>
<p>3.首次创建该类实例对象时，在内存中同时创建该类的虚拟表</p>
<p>4.按照函数顺序的序号依次存放</p>
<p>例子：</p>
<p>![aa169d95-d256-4d55-b639-2b11bde7b2d5](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/aa169d95-d256-4d55-b639-2b11bde7b2d5.png)</p>
<h5 id="2-顺序">&lt; 2 &gt;顺序</h5>
<p>基类：<br>
顺序按定义顺序</p>
<p>派生类：</p>
<p>前面的顺序和基类一一对应后面的便是按照定义顺序</p>
<h5 id="3-运行过程">&lt; 3 &gt;运行过程</h5>
<p>![483dd1e5-51f9-4bc1-82e4-1d069d0d3880](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/483dd1e5-51f9-4bc1-82e4-1d069d0d3880.png)</p>
<p>show函数加不加virtual关键字执行结果不受影响</p>
<h5 id="4-作用机制">&lt; 4 &gt;作用机制</h5>
<p><strong>1&gt;.变量的静态类型和动态类型</strong></p>
<p>静态类型：在编译期间可以确定的变量类型</p>
<p>![7cc72d9f-d30d-4b63-9498-5aa28012d1f4](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/7cc72d9f-d30d-4b63-9498-5aa28012d1f4.png)</p>
<p>上述静态类型例子中pObj类型静态类型为Parent* ，obj静态类型为Parent引用  ，obj静态类型和动态类型都是Parent</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span><span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; 面积是：&quot;</span> &lt;&lt; <span class="built_in">Area</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">Area</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;          <span class="comment">//////  虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> :<span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">float</span> w, <span class="type">float</span> h) &#123;</span><br><span class="line">        mWidth = w;</span><br><span class="line">        mHeight = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span>  <span class="type">float</span> <span class="title">Area</span><span class="params">()</span><span class="type">const</span> </span>&#123;                        <span class="comment">/////虚函数</span></span><br><span class="line">        <span class="keyword">return</span> mWidth * mHeight;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> mWidth, mHeight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> :<span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">float</span> r):<span class="built_in">mRadius</span>(r)&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span>  <span class="type">float</span> <span class="title">Area</span><span class="params">()</span> <span class="type">const</span> </span>&#123;                         <span class="comment">///////虚函数</span></span><br><span class="line">        <span class="keyword">return</span> mRadius * mRadius * <span class="number">3.14</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> mRadius;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mian</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Rectangle <span class="title">rect</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    Shape &amp; sh1=rect;<span class="comment">//向上类型转换 静态类型是Shape 动态类型是Retangle</span></span><br><span class="line">    Shape *psh2=<span class="keyword">new</span> <span class="built_in">Circle</span>(<span class="number">3</span>);<span class="comment">//静态类型是基类的指针动态类型是Circle的指针</span></span><br><span class="line">    rect.<span class="built_in">Show</span>();<span class="comment">//正确输出2   this-&gt;Show this指针的静态类型是Shape 动态类型是Retangle用矩形的求面积函数</span></span><br><span class="line">    sh1.<span class="built_in">Show</span>();<span class="comment">//this静态类型基类的指针 动态类型是Retangle的指针</span></span><br><span class="line">    psh2-&gt;<span class="built_in">Show</span>();<span class="comment">//this静态类型基类的指针 动态类型是Circle的指针</span></span><br><span class="line">    <span class="keyword">delete</span> psh2;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">userFunc</span><span class="params">(<span class="type">const</span> Shape &amp; )</span></span>;</span><br><span class="line">    <span class="built_in">userFunc</span>(rect);<span class="comment">//向上转换</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">userFunc</span><span class="params">(<span class="type">const</span> Shape &amp;sh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sh.<span class="built_in">show</span>();<span class="comment">//静态类型是Shape 动态类型是Retangle</span></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2&gt;函数调用的编译</strong></p>
<p>![0894850e-9470-4432-94af-b611b5af15b8](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/0894850e-9470-4432-94af-b611b5af15b8.png)</p>
<p>查询虚函数时对于c++这门语言是按序号查找，但对于有的语言是按照名字</p>
<p><strong>3&gt;虚函数的作用机制实例分析</strong></p>
<p>![427401a1-7ea4-4681-acb7-87e15d79b64d](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/427401a1-7ea4-4681-acb7-87e15d79b64d.png)</p>
<p><u>红色部分为编译出错</u></p>
<p><u>delete时先调用派生类（动态类型）的析构（虚函数）再自动调用基类的析构最后归还给系统空间</u></p>
<p>![0fe568bf-9447-4d44-b0e0-b5b85bca10c3](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/0fe568bf-9447-4d44-b0e0-b5b85bca10c3.png)</p>
<p><u>tips：Func函数（传入参数为基类）的意义在于正确地调用日期展示，便于以后创建新的派生类进行展示日期</u></p>
<p><strong>4&gt; 虚函数的访问</strong></p>
<ol>
<li>
<p>虚函数中访问的非虚函数<br>
静态编联 使用本地版本</p>
</li>
<li>
<p>非虚函数中访问的虚函数<br>
动态编联</p>
</li>
<li>
<p>虚函数中访问虚函数<br>
动态编联</p>
</li>
<li>
<p>构造函数和虚函数<br>
构造函数不能为虚函数<br>
调用的虚函数采用<strong>静态编联</strong></p>
</li>
<li>
<p>析构函数和虚函数</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">A</span>()&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">g</span>();&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;<span class="built_in">k</span>();&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">k</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">g</span>();<span class="built_in">k</span>();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">k</span><span class="params">()</span></span>&#123;<span class="built_in">h</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *p1=<span class="keyword">new</span> A;</span><br><span class="line">    p1-&gt;<span class="built_in">X</span>();</span><br><span class="line"><span class="comment">//X可以是f、g、k  f、g:基类 k：静态编联基类</span></span><br><span class="line">    <span class="function">A* <span class="title">p2</span><span class="params">()</span></span>=<span class="keyword">new</span> B;</span><br><span class="line">    p2-&gt;<span class="built_in">X</span>();<span class="comment">//X可以是f、g、k，f、g:基类 k：静态编联基类</span></span><br><span class="line"><span class="comment">//X为f时，p1-&gt;f();内容是this指针指向g函数k函数 this指针静态类型就是B类型，对于g函数执行的是A类里的g函数为虚函数</span></span><br><span class="line"><span class="comment">//采用动态编联最终通过执行基类的g函数，基类的g函数又调用了基类的k函数。 而f中的k函数则为派生类里继承下来的k函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>X为f、g、k，若为虚函数则为动态编联，若不是虚函数则为静态编联，<strong>不能是h函数，因为p1 p2静态类型都是基类因此只能在基类里寻找</strong></p>
<p>![c0598612-fa72-408a-bb8f-2e47e0911cb7](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/c0598612-fa72-408a-bb8f-2e47e0911cb7.png)</p>
<p>例子：<br>
![9951d6c5-71b7-4ee9-8980-bcbd995e6e4b](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/9951d6c5-71b7-4ee9-8980-bcbd995e6e4b.png)</p>
<p>总之对于虚函数套虚函数  虚函数套非虚函数  非虚函数中访问的虚函数   都会进行动态编联<strong>而对于析构和构造函数则用本地函数即静态编联</strong></p>
<h3 id="4-抽象类">4.抽象类</h3>
<h4 id="1-抽象类和具体类">&lt; 1 &gt;抽象类和具体类</h4>
<p>具体化：可以实例化</p>
<p>抽象类：为子类提供更高层次的抽象,本身不能实例化,但后裔类可以实例化</p>
<h4 id="2-定义">&lt; 2 &gt;定义</h4>
<p>1.含有一个或多个纯虚函数</p>
<p>2.纯虚函数格式(一定是成员函数):</p>
<p>virtual ReturnType Func(…) [const] <u><strong>=0</strong></u>;</p>
<p>一般不给具体实现但也可以给出纯虚定义</p>
<p>3.纯虚函数的访问控制可任意</p>
<p>4.具体类的子类可以是具体类或抽象类</p>
<p>5.抽象类的子类可以是具体类或抽象类</p>
<p>6.纯抽象类:除静态 构造 析构等函数均为纯虚函数</p>
<p>7.纯虚定义:对纯虚函数给出<u>缺省</u>实现</p>
<p>eg:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span>&#123;<span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;面积&quot;</span>&lt;&lt;<span class="built_in">Area</span>()&lt;&lt;endl;</span><br><span class="line">&#125;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">Area</span><span class="params">()</span> <span class="type">const</span> </span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>:<span class="keyword">public</span> Shape&#123;<span class="comment">//具体类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Rectangle</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">Area</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> w*h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> w,h;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span>:<span class="keyword">public</span> Shape&#123;<span class="comment">//具体类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Line</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">Area</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>由于对于每个无法求面积的图形都要定义一个返回0的面积函数,实属麻烦,于是我们可以在Shape.cpp直接写纯虚定义,<mark>要在类外给出定义且Shape还是抽象类</mark></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Shape.cpp 中给出纯虚定义</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Shape::Area</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>则Line类里不用给出Area定义</strong></p>
<p>补:</p>
<p>接口类(c++语言中不存在此概念):</p>
<p>所有虚函数都为公有,且为纯抽象类,为子类提供公共接口</p>
<p>如:                              ![5624dff5-3be8-43b4-9521-37bfc4fc5379](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/5624dff5-3be8-43b4-9521-37bfc4fc5379.png)</p>
<p>可以派生</p>
<h1 id="十五、多态">十五、多态</h1>
<h2 id="1-多态性">1.多态性</h2>
<h3 id="1-静态多态">&lt; 1 &gt;静态多态</h3>
<p>根据目标对象的<strong>静态类型</strong>和参数表中参数的<strong>静态类型</strong>确定目标代码体</p>
<p>实现方法：</p>
<p>1.模板——不同的模板参数</p>
<p>2.函数重载</p>
<p>例子：</p>
<p>模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">My</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp; t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">typeid</span>(t).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    My &lt;<span class="type">int</span>&gt; obj1;</span><br><span class="line">    My &lt;<span class="type">float</span>&gt; obj2;</span><br><span class="line">    obj1.<span class="built_in">f</span>(<span class="number">2</span>);</span><br><span class="line">    obj2.<span class="built_in">f</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p>int<br>
float</p>
<p>重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">My</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Int&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Char&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    My obj;</span><br><span class="line">    obj.<span class="built_in">f</span>(<span class="number">2</span>);</span><br><span class="line">    obj.<span class="built_in">f</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p>Int<br>
Char</p>
<h3 id="2-动态多态">&lt; 2 &gt;动态多态</h3>
<p>根据目标对象的<strong>动态类型</strong>和<mark>参数表中参数的<strong>静态类型</strong></mark>确定目标代码体。（<strong>虚机制</strong>）</p>
<p>根据目标对象的<strong>动态类型</strong>和参数表中参数的<strong>动态类型</strong>确定目标代码体。（<strong>c++不支持</strong>）</p>
<p>例：</p>
<p>![563783b1-0345-43d4-a5e3-57aa0ae94ff6](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/563783b1-0345-43d4-a5e3-57aa0ae94ff6.png)</p>
<p>b为动态，pa为静态</p>
<p>若是pa-&gt;f(pa);输出为3</p>
<p>若是pa-&gt;f(&amp;b);输出为4</p>
<h2 id="2-虚机制的作用">2.虚机制的作用</h2>
<p>虚机制是实现动态多态的一种方法</p>
<p>意义：在保持客户端访问接口不变的前提下可以变更类的实现</p>
<p>本质：子类型化和适应变化</p>
<p>![c15164bd-37eb-41cd-bc37-7b4a245c3d20](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/c15164bd-37eb-41cd-bc37-7b4a245c3d20.png)</p>
<h2 id="3-虚机制的应用">3.虚机制的应用</h2>
<p>例1：</p>
<h4 id="1-父类提供接口，子类提供具体实现">&lt; 1 &gt;父类提供接口，子类提供具体实现</h4>
<p>![a26b98cc-8f7c-4667-bcbe-74ac538a9fc1](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/a26b98cc-8f7c-4667-bcbe-74ac538a9fc1.png)</p>
<h4 id="2-父类提供框架，子类提供细节">&lt; 2 &gt;父类提供框架，子类提供细节</h4>
<p>![aba06b0c-063a-4bf1-96ab-c2a4dec8f2a6](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/aba06b0c-063a-4bf1-96ab-c2a4dec8f2a6.png)</p>
<h4 id="3-虚拟的拷贝构造">&lt; 3 &gt;虚拟的拷贝构造</h4>
<p>![7fbac864-0906-4372-90f2-d7729a7f4ef0](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/7fbac864-0906-4372-90f2-d7729a7f4ef0.png)</p>
<p>右侧的这种十分繁琐需要一直修改，由于构造函数不能为虚函数，拷贝函数是构造函数的特殊情况，因此无法使用动态多态来实现。</p>
<p>我们可以通过先建一个具有拷贝构造功能的虚函数来实现拷贝构造的多态：</p>
<p>![c587a4c5-91e7-4edf-9bf6-2b978d0a3c1d](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/c587a4c5-91e7-4edf-9bf6-2b978d0a3c1d.png)</p>
<h2 id="4-虚机制的意义和不足">4.虚机制的意义和不足</h2>
<p>使用的情况:1关联2.依赖</p>
<p>![ec455296-ee96-4e52-83b8-02ba7e7d2582](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/ec455296-ee96-4e52-83b8-02ba7e7d2582.png)</p>
<p>复用性好,无论右侧继承树怎么变化左侧依旧适用</p>
<p>![869fbfaa-16ba-4e07-8d3e-d0c0a090b51f](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/869fbfaa-16ba-4e07-8d3e-d0c0a090b51f.png)</p>
<p><strong>虚机制只适应单个方面的变化,而对于多个方向的变化方向无法适应</strong></p>
<p>解决方案:</p>
<p>使用关联、依赖+继承解决子类过多问题</p>
<p>![03f66c4d-9399-4517-8eb7-0705929efc80](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/03f66c4d-9399-4517-8eb7-0705929efc80.png)</p>
<h1 id="十六、关系">十六、关系</h1>
<p>![228b0730-74e9-4454-8a6b-18c26d8caba6](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/228b0730-74e9-4454-8a6b-18c26d8caba6.png)</p>
<h4 id="1-水平关系">&lt; 1 &gt;水平关系</h4>
<p>1.依赖</p>
<p>2.聚集关系（整体/部分）</p>
<p>组合</p>
<p>聚合</p>
<p>3.一般关联</p>
<p>双向关联</p>
<p>单向关联</p>
<h4 id="2-垂直关系">&lt; 2 &gt; 垂直关系</h4>
<p>1.公有继承</p>
<h4 id="3-基本组合">&lt; 3 &gt;基本组合</h4>
<h5 id="1-依赖-继承（基本型）">1.依赖+继承（基本型）</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Fruit</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">Weight</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">Precent</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Orange</span> :<span class="keyword">public</span> Fruit &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Orange</span>(<span class="type">int</span> w1,<span class="type">int</span> w2):<span class="built_in">weight1</span>(w1),<span class="built_in">weight2</span>(w2)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">Weight</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">Precent</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.7</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> weight1;</span><br><span class="line">    <span class="type">int</span> weight2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> :<span class="keyword">public</span> Fruit &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Apple</span>(<span class="type">int</span> w):<span class="built_in">weight</span>(w)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">Weight</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">Precent</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.8</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mouse</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Mouse</span>(<span class="type">float</span> w) :<span class="built_in">weight</span>(w) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Eat</span><span class="params">(Fruit&amp; fruit)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        weight += fruit.<span class="built_in">Weight</span>() * fruit.<span class="built_in">Precent</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getWeight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> weight; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">float</span> weight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>![fc9c95b1-2dae-4f3d-ae0f-0765ec9c9eb8](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/fc9c95b1-2dae-4f3d-ae0f-0765ec9c9eb8.png)</p>
<p>老鼠类同样可以派生类新的子类</p>
<p>![0ddfbf0f-f0e2-4d9f-8856-2603a0e4d280](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/0ddfbf0f-f0e2-4d9f-8856-2603a0e4d280.png)</p>
<p>水果的继承树和老鼠的继承树之间互不影响</p>
<p>把factor抽象出来</p>
<p>![9612fcda-0b73-4433-8262-54ec9352aa37](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/9612fcda-0b73-4433-8262-54ec9352aa37.png)</p>
<p>老鼠吃水果为单向依赖，也可以有双向依赖</p>
<p>![90867ff8-d8ec-4a8a-8b09-4db03f5d4007](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/90867ff8-d8ec-4a8a-8b09-4db03f5d4007.png)</p>
<h4 id="2-关联和继承">&lt; 2 &gt;关联和继承</h4>
<p>…</p>
<h1 id="十七、六大设计原则">十七、六大设计原则</h1>
<p>![52231ef0-6232-43ee-8896-c828a5db97f9](file:///D:/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Typedown/52231ef0-6232-43ee-8896-c828a5db97f9.png)</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/110130347">六大设计原则超详细介绍（再不理解你打我） - 知乎 (zhihu.com)</a></p>
<p>当然，我可以为你提供每个设计原则的符合和不符合原则的示例代码，并详细解释它们的应用。以下是每个原则的示例代码和解释：</p>
<ol>
<li>单一职责原则（Single Responsibility Principle，SRP）：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">符合原则的示例代码：</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">FileManager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">readFile</span><span class="params">(std::string filename)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">writeFile</span><span class="params">(std::string filename)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">FileEncryptor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">encryptFile</span><span class="params">(std::string filename)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">FileCompressor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">compressFile</span><span class="params">(std::string filename)</span></span>;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，每个类都只负责一个具体的职责，<code>FileManager</code> 类负责文件的读写操作，<code>FileEncryptor</code> 类负责文件的加密操作，<code>FileCompressor</code> 类负责文件的压缩操作。每个类都符合单一职责原则。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">不符合原则的示例代码：</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">FileManager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">readFile</span><span class="params">(std::string filename)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">writeFile</span><span class="params">(std::string filename)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">encryptFile</span><span class="params">(std::string filename)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">compressFile</span><span class="params">(std::string filename)</span></span>;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，<code>FileManager</code> 类负责多个职责，包括文件的读写、加密和压缩。这违反了单一职责原则，因为一个类应该只负责一项任务或功能。</p>
<ol start="2">
<li>开放封闭原则（Open-Closed Principle，OCP）：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">符合原则的示例代码：</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">calculateArea</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">double</span> length;</span><br><span class="line">        <span class="type">double</span> width;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Rectangle</span>(<span class="type">double</span> l, <span class="type">double</span> w) : <span class="built_in">length</span>(l), <span class="built_in">width</span>(w) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">calculateArea</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> length * width;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">double</span> radius;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Circle</span>(<span class="type">double</span> r) : <span class="built_in">radius</span>(r) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">calculateArea</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3.1415</span> * radius * radius;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，<code>Shape</code> 是一个抽象基类，定义了一个纯虚函数 <code>calculateArea()</code>。通过这种设计，我们可以轻松地扩展不同的形状类，如 <code>Rectangle</code> 和 <code>Circle</code>，而无需修改现有的代码。这符合开放封闭原则，因为我们对扩展开放（可以添加新的形状类），但对修改封闭（不需要修改现有的抽象基类和其他形状类）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">不符合原则的示例代码：</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">calculateArea</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 代码实现计算不同形状的面积</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，<code>Shape</code> 类实现了一个计算不同形状面积的方法。如果需要添加新的形状，就需要修改 <code>Shape</code> 类的代码。这违反了开放封闭原则，因为对于扩展（添加新的形状）需要修改现有的代码。</p>
<ol start="3">
<li>里氏替换原则（Liskov Substitution Principle，LSP）：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">符合原则的示例代码：</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">calculateArea</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">double</span> length;</span><br><span class="line">        <span class="type">double</span> width;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Rectangle</span>(<span class="type">double</span> l, <span class="type">double</span> w) : <span class="built_in">length</span>(l), <span class="built_in">width</span>(w) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">calculateArea</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> length * width;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">double</span> side;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Square</span>(<span class="type">double</span> s) : <span class="built_in">side</span>(s) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">calculateArea</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> side * side;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，<code>Rectangle</code> 是一个派生类，继承自抽象基类 <code>Shape</code>。根据里氏替换原则，子类型（<code>Square</code>）必须能够替换其基类型（<code>Rectangle</code>），而不会破坏程序的正确性。在这个例子中，<code>Square</code> 类可以完全替代 <code>Rectangle</code> 类，因为它们都可以计算面积，而不会引起错误或异常。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">不符合原则的示例代码：</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">double</span> length;</span><br><span class="line">        <span class="type">double</span> width;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Rectangle</span>(<span class="type">double</span> l, <span class="type">double</span> w) : <span class="built_in">length</span>(l), <span class="built_in">width</span>(w) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">calculateArea</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> length * width;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> Rectangle &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Square</span>(<span class="type">double</span> s) : <span class="built_in">Rectangle</span>(s, s) &#123;&#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，<code>Square</code> 类继承自 <code>Rectangle</code> 类，并且使用相同的计算面积的方法。然而，一个正方形的特性是四边相等，而矩形的特性是两对相等的边。因此，当我们将一个 <code>Square</code> 对象传递给期望一个 <code>Rectangle</code> 对象的代码时，可能会导致错误的行为。这违反了里氏替换原则。</p>
<ol start="4">
<li>接口隔离原则（Interface Segregation Principle，ISP）：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">符合原则的示例代码：</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Scanner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">scan</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">LaserPrinter</span> : <span class="keyword">public</span> Printer &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 执行激光打印操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InkjetPrinter</span> : <span class="keyword">public</span> Printer, <span class="keyword">public</span> Scanner &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 执行喷墨打印操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">scan</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 执行扫描操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，我们将打印机的功能分解为打印和扫描两个接口，分别由 <code>Printer</code> 和 <code>Scanner</code> 定义。具体的打印机类（如 <code>LaserPrinter</code> 和 <code>InkjetPrinter</code>）根据实际需要实现相应的接口。这样，客户端代码可以根据需要依赖于不同的接口，遵循接口隔离原则。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">不符合原则的示例代码：</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">scan</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">LaserPrinter</span> : <span class="keyword">public</span> Printer &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 执行激光打印操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">scan</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 不支持扫描操作，空实现</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InkjetPrinter</span> : <span class="keyword">public</span> Printer &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 执行喷墨打印操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">scan</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 执行扫描操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，<code>Printer</code> 接口定义了打印和扫描两个方法，而具体的打印机类（如 <code>LaserPrinter</code> 和 <code>InkjetPrinter</code>）都必须实现这两个方法。然而，某些打印机（如激光打印机）可能不支持扫描操作。这违反了接口隔离原则，因为客户端代码不应该依赖于不需要的方法。</p>
<ol start="5">
<li>依赖倒置原则（Dependency Inversion Principle，DIP）：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">符合原则的示例代码：</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Database</span> &#123;<span class="comment">//抽象类</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">saveData</span><span class="params">(std::string data)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MySQLDatabase</span> : <span class="keyword">public</span> Database &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">saveData</span><span class="params">(std::string data)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 保存数据到MySQL数据库</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">FileDatabase</span> : <span class="keyword">public</span> Database &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">saveData</span><span class="params">(std::string data)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 保存数据到文件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DataManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Database&amp; database;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">DataManager</span>(Database&amp; db) : <span class="built_in">database</span>(db) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">processData</span><span class="params">(std::string data)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 处理数据</span></span><br><span class="line">            database.<span class="built_in">saveData</span>(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，<code>DataManager</code> 类依赖于抽象的 <code>Database</code> 接口，而不是具体的数据库实现。这符合依赖倒置原则，因为高层模块（<code>DataManager</code>）不依赖于低层模块（<code>MySQLDatabase</code>、<code>FileDatabase</code>），而是两者都依赖于抽象（<code>Database</code>）。这样的设计使得我们可以更轻松地切换不同的数据库实现，而不需要修改 <code>DataManager</code> 类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">不符合原则的示例代码：</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MySQLDatabase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">saveData</span><span class="params">(std::string data)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 保存数据到MySQL数据库</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">FileDatabase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">saveData</span><span class="params">(std::string data)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 保存数据到文件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DataManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        MySQLDatabase mysqlDatabase;</span><br><span class="line">        FileDatabase fileDatabase;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">processData</span><span class="params">(std::string data, <span class="type">bool</span> useMySQL)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 处理数据</span></span><br><span class="line">            <span class="keyword">if</span> (useMySQL) &#123;</span><br><span class="line">                mysqlDatabase.<span class="built_in">saveData</span>(data);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fileDatabase.<span class="built_in">saveData</span>(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，<code>DataManager</code> 类直接依赖于具体的数据库实现类 <code>MySQLDatabase</code> 和 <code>FileDatabase</code>。这违反了依赖倒置原则，因为高层模块（<code>DataManager</code>）依赖于低层模块（具体的数据库实现），</p>
<p>而且对于不同的数据库类型，需要在 <code>DataManager</code> 类中进行条件判断和选择。这样的设计导致代码的耦合性增加，并且不易扩展和维护。</p>
<ol start="6">
<li>迪米特法则（Law of Demeter，LoD）：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">符合原则的示例代码：</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::string name;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Teacher</span>(<span class="type">const</span> std::string&amp; n) : <span class="built_in">name</span>(n) &#123;&#125;</span><br><span class="line">        <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Department</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::vector&lt;Teacher&gt; teachers;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">addTeacher</span><span class="params">(<span class="type">const</span> Teacher&amp; teacher)</span> </span>&#123;</span><br><span class="line">            teachers.<span class="built_in">push_back</span>(teacher);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">listTeachers</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; teacher : teachers) &#123;</span><br><span class="line">                std::cout &lt;&lt; teacher.<span class="built_in">getName</span>() &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，<code>Department</code> 类与 <code>Teacher</code> 类合作来管理教师信息。根据迪米特法则，一个对象应该对其他对象有尽可能少的了解。在这个例子中，<code>Department</code> 类只与 <code>Teacher</code> 类的公共接口（<code>getName()</code>）进行交互，而不需要直接访问 <code>Teacher</code> 类的内部。这样的设计可以减少对象之间的依赖关系，提高代码的灵活性和可维护性。</p>
<p>不符合原则</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">迪米特法则（Law of Demeter，LoD）要求对象之间的耦合要尽可能地降低，一个对象应该尽量少地了解其他对象的内部结构。以下是一个违反迪米特法则的反例：</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::string name;</span><br><span class="line">        Wallet wallet;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; n) : <span class="built_in">name</span>(n), <span class="built_in">wallet</span>(<span class="built_in">Wallet</span>()) &#123;&#125;</span><br><span class="line">        <span class="function">Wallet&amp; <span class="title">getWallet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> wallet;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Wallet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::vector&lt;CreditCard&gt; creditCards;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">addCreditCard</span><span class="params">(<span class="type">const</span> CreditCard&amp; card)</span> </span>&#123;</span><br><span class="line">            creditCards.<span class="built_in">push_back</span>(card);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">std::vector&lt;CreditCard&gt;&amp; <span class="title">getCreditCards</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> creditCards;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CreditCard</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::string number;</span><br><span class="line">        std::string expirationDate;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">CreditCard</span>(<span class="type">const</span> std::string&amp; num, <span class="type">const</span> std::string&amp; exp) : <span class="built_in">number</span>(num), <span class="built_in">expirationDate</span>(exp) &#123;&#125;</span><br><span class="line">        <span class="function">std::string <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">std::string <span class="title">getExpirationDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> expirationDate;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">Person <span class="title">person</span><span class="params">(<span class="string">&quot;John&quot;</span>)</span></span>;</span><br><span class="line">        Wallet&amp; wallet = person.<span class="built_in">getWallet</span>();</span><br><span class="line">        std::vector&lt;CreditCard&gt;&amp; creditCards = wallet.<span class="built_in">getCreditCards</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 creditCards 进行一些操作</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，<code>Person</code> 类持有一个 <code>Wallet</code> 对象，并通过 <code>getWallet()</code> 方法返回该对象的引用。然后，在 <code>main()</code> 函数中，我们通过 <code>getCreditCards()</code> 方法获取 <code>Wallet</code> 对象内部的信用卡列表，并进行一些操作。</p>
<p>这段代码违反了迪米特法则，因为 <code>Person</code> 类和 <code>main()</code> 函数直接访问了 <code>Wallet</code> 类的内部结构，即信用卡列表。这导致了过多的耦合，违背了对象之间的最小知识原则。</p>
<p>这种设计会导致以下问题：</p>
<ol>
<li>
<p>破坏了封装性：<code>Person</code> 类和 <code>main()</code> 函数需要了解 <code>Wallet</code> 类的内部结构，直接操作其中的信用卡列表。这使得 <code>Wallet</code> 类的实现细节对外暴露，破坏了封装性和信息隐藏的原则。</p>
</li>
<li>
<p>增加了代码的依赖性：<code>Person</code> 类和 <code>main()</code> 函数依赖于 <code>Wallet</code> 类的内部结构，任何对 <code>Wallet</code> 类的修改都可能导致这两个类的代码需要进行相应的调整。</p>
</li>
</ol>
<p>为了遵循迪米特法则，可以修改代码，将对 <code>CreditCard</code> 的操作放在 <code>Wallet</code> 类内部，而不是让外部的类直接操作 <code>Wallet</code> 类的内部结构。这样可以降低对象之间的耦合性，提高代码的可维护性和扩展性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">以下是修改后的代码，符合迪米特法则：</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::string name;</span><br><span class="line">        Wallet wallet;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; n) : <span class="built_in">name</span>(n), <span class="built_in">wallet</span>(<span class="built_in">Wallet</span>()) &#123;&#125;</span><br><span class="line">        <span class="function">Wallet&amp; <span class="title">getWallet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> wallet;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Wallet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::vector&lt;CreditCard&gt; creditCards;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">addCreditCard</span><span class="params">(<span class="type">const</span> CreditCard&amp; card)</span> </span>&#123;</span><br><span class="line">            creditCards.<span class="built_in">push_back</span>(card);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">processCreditCards</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; card : creditCards) &#123;</span><br><span class="line">                <span class="comment">// 处理信用卡</span></span><br><span class="line">                std::string number = card.<span class="built_in">getNumber</span>();</span><br><span class="line">                std::string expirationDate = card.<span class="built_in">getExpirationDate</span>();</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CreditCard</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::string number;</span><br><span class="line">        std::string expirationDate;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">CreditCard</span>(<span class="type">const</span> std::string&amp; num, <span class="type">const</span> std::string&amp; exp) : <span class="built_in">number</span>(num), <span class="built_in">expirationDate</span>(exp) &#123;&#125;</span><br><span class="line">        <span class="function">std::string <span class="title">getNumber</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">std::string <span class="title">getExpirationDate</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> expirationDate;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">Person <span class="title">person</span><span class="params">(<span class="string">&quot;John&quot;</span>)</span></span>;</span><br><span class="line">        Wallet&amp; wallet = person.<span class="built_in">getWallet</span>();</span><br><span class="line">        wallet.<span class="built_in">addCreditCard</span>(<span class="built_in">CreditCard</span>(<span class="string">&quot;1234567890&quot;</span>, <span class="string">&quot;12/2025&quot;</span>));</span><br><span class="line">        wallet.<span class="built_in">addCreditCard</span>(<span class="built_in">CreditCard</span>(<span class="string">&quot;9876543210&quot;</span>, <span class="string">&quot;06/2024&quot;</span>));</span><br><span class="line">        wallet.<span class="built_in">processCreditCards</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在修改后的代码中，将信用卡的处理逻辑移至 <code>Wallet</code> 类内部的 <code>processCreditCards()</code> 方法中。<code>Person</code> 类和 <code>main()</code> 函数不再直接访问 <code>Wallet</code> 类的信用卡列表，而是通过调用 <code>Wallet</code> 类的方法来处理信用卡。</p>
<p>这样做的好处是：</p>
<ol>
<li>
<p>提高了封装性：<code>Person</code> 类和 <code>main()</code> 函数不再需要了解 <code>Wallet</code> 类的内部结构，无法直接操作信用卡列表，而是通过调用 <code>Wallet</code> 类的公共方法来处理信用卡。</p>
</li>
<li>
<p>减少了代码的依赖性：<code>Person</code> 类和 <code>main()</code> 函数只需要依赖 <code>Wallet</code> 类的公共接口，而不需要了解其内部实现。这使得 <code>Wallet</code> 类可以自由地修改内部结构，而不会影响到使用它的其他类。</p>
</li>
</ol>
<p>通过这样的修改，代码遵循了迪米特法则，减少了对象之间的耦合，提高了代码的可维护性和扩展性。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://klklkl10086.github.io/klklkl10086.github.io">klklkl</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://klklkl10086.github.io/klklkl10086.github.io/2024/10/13/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1_cpp/">https://klklkl10086.github.io/klklkl10086.github.io/2024/10/13/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1_cpp/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://klklkl10086.github.io/klklkl10086.github.io" target="_blank">klklkl's blogs</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/oop/">oop</a><a class="post-meta__tags" href="/tags/cpp/">cpp</a><a class="post-meta__tags" href="/tags/class/">class</a></div><div class="post_share"><div class="social-share" data-image="https://pic2.zhimg.com/v2-f9b32b95385eedbdb58389bbbce5de39_r.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%8D%E4%B9%A0/" title="设计模式复习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">设计模式复习</div></div></a></div><div class="next-post pull-right"><a href="/2024/10/07/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="&lt;算法竞赛进阶指南&gt;读书笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">&lt;算法竞赛进阶指南&gt;读书笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://pic2.zhimg.com/v2-f9b32b95385eedbdb58389bbbce5de39_r.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">klklkl</div><div class="author-info__description">student</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/98983857"><i class="fa-brands fa-bilibili"></i><span>bilibili</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:2488926297@qq.com" target="_blank" title="Email"><i class="fa-regular fa-envelope" style="color: #000000;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Nice to meet you!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.</span> <span class="toc-text">面向对象程序设计</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%EF%BC%88int-a-int-const-a%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">引用（int &amp;a&#x3D; int*const a）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">一、构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%9C%E7%94%A8"><span class="toc-number">3.0.1.</span> <span class="toc-text">1. 作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.0.2.</span> <span class="toc-text">2. 构造函数在数组中的使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">二、 复制构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B5%B7%E4%BD%9C%E7%94%A8%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">4.0.1.</span> <span class="toc-text">1.  复制构造函数起作用的情况</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%94%A8%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%8E%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E5%90%8C%E7%B1%BB%E7%9A%84%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%9A"><span class="toc-number">4.0.1.1.</span> <span class="toc-text">&lt;1&gt; 用一个对象去初始化同类的另一个对象时：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A6%82%E6%9E%9C%E6%9F%90%E5%87%BD%E6%95%B0%E6%9C%89%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E6%98%AF%E7%B1%BBA%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%8C%E9%82%A3%E4%B9%88%E8%B0%83%E7%94%A8%E8%AF%A5%E5%87%BD%E6%95%B0%E6%97%B6%EF%BC%8CA%E7%9A%84%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%B0%86%E8%A2%AB%E8%B0%83%E7%94%A8%EF%BC%9A"><span class="toc-number">4.0.1.2.</span> <span class="toc-text">&lt;2&gt; 如果某函数有一个参数是类A的对象，那么调用该函数时，A的复制构造函数将被调用：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%AF%E7%B1%BBA%E7%9A%84%E5%AF%B9%E8%B1%A1-%E6%97%B6%EF%BC%8C%E5%88%99%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E6%97%B6%EF%BC%8CA%E7%9A%84%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%A2%AB%E8%B0%83%E7%94%A8%EF%BC%9A"><span class="toc-number">4.0.1.3.</span> <span class="toc-text">&lt;3&gt; 函数返回值是类A的对象 时，则函数返回时，A的复制构造函数被调用：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BE%8B%E5%AD%90"><span class="toc-number">4.0.1.4.</span> <span class="toc-text">&lt; 4 &gt;例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.0.2.</span> <span class="toc-text">2.常量引用参数的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">4.1.</span> <span class="toc-text">3.浅拷贝与深拷贝</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">三、类型转换构造函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">6.</span> <span class="toc-text">四、析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">6.0.0.1.</span> <span class="toc-text">1.析构函数和数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%92%8Cdelete"><span class="toc-number">6.0.0.2.</span> <span class="toc-text">2. 析构函数和delete</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%9C%A8%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BF%94%E5%9B%9E%E6%97%B6%E8%A2%AB%E8%B0%83%E7%94%A8"><span class="toc-number">6.0.0.3.</span> <span class="toc-text">3.析构函数在对象作为函数返回值返回时被调用</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA"><span class="toc-number">7.</span> <span class="toc-text">五、构造函数和析构函数调用时机</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81this%E6%8C%87%E9%92%88"><span class="toc-number">8.</span> <span class="toc-text">六、this指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-this%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">8.1.</span> <span class="toc-text">1.this指针的作用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">9.</span> <span class="toc-text">七、静态成员变量和静态成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">9.1.</span> <span class="toc-text">1. 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">9.1.1.</span> <span class="toc-text">&lt;1&gt; 静态成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B7%AE%E5%88%AB"><span class="toc-number">9.1.2.</span> <span class="toc-text">&lt;2&gt; 差别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">9.2.</span> <span class="toc-text">2. 如何访问静态成员</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%88%90%E5%91%98%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B0%81%E9%97%AD%E7%B1%BB"><span class="toc-number">10.</span> <span class="toc-text">八、成员对象和封闭类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%B0%81%E9%97%AD%E7%B1%BB"><span class="toc-number">10.1.</span> <span class="toc-text">1.封闭类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B0%81%E9%97%AD%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">10.2.</span> <span class="toc-text">2.封闭类构造函数和析构函数的执行顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mark-3-%E5%B0%81%E9%97%AD%E7%B1%BB%E7%9A%84%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-mark"><span class="toc-number">10.3.</span> <span class="toc-text">3.封闭类的复制构造函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D-%E3%80%81%E5%B8%B8%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%92%8C%E5%B8%B8%E5%BC%95%E7%94%A8"><span class="toc-number">11.</span> <span class="toc-text">九 、常量对象、常量成员函数和常引用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%B8%B8%E9%87%8F%E5%AF%B9%E8%B1%A1%EF%BC%88const%EF%BC%89"><span class="toc-number">11.1.</span> <span class="toc-text">1.常量对象（const）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">11.2.</span> <span class="toc-text">2.常量成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B8%B8%E5%BC%95%E7%94%A8"><span class="toc-number">11.3.</span> <span class="toc-text">3.常引用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E5%86%85%E5%AD%98%E5%88%86%E7%B1%BB"><span class="toc-number">12.</span> <span class="toc-text">十、内存分类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%A3%E7%A0%81%E5%8C%BA%EF%BC%88%E9%9D%99%E6%80%81%E5%8C%BA%EF%BC%89"><span class="toc-number">12.1.</span> <span class="toc-text">1.代码区（静态区）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="toc-number">12.2.</span> <span class="toc-text">2.数据区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%A8%E5%B1%80%E6%95%B0%E6%8D%AE%E5%8C%BA-date-area"><span class="toc-number">12.2.1.</span> <span class="toc-text">&lt; 1 &gt; 全局数据区 (date area)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A0%88%E5%8C%BA%EF%BC%88stack-area%EF%BC%89"><span class="toc-number">12.2.2.</span> <span class="toc-text">&lt; 2 &gt;栈区（stack area）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A0%86%E5%8C%BA%EF%BC%88heap-area%EF%BC%89"><span class="toc-number">12.2.3.</span> <span class="toc-text">&lt; 3 &gt;堆区（heap area）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E5%8F%8B%E5%85%83"><span class="toc-number">13.</span> <span class="toc-text">十一、友元</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">13.1.</span> <span class="toc-text">1.友元函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-number">13.2.</span> <span class="toc-text">2.友元类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">14.</span> <span class="toc-text">十二、运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%BC%E5%BC%8F-%E5%8A%A0%E5%8F%B7-%E7%AD%89%E5%8F%B7%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">14.0.1.</span> <span class="toc-text">1. 格式 加号 等号操作符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%89%8D%E8%87%AA%E6%93%8D%E4%BD%9C%E7%AC%A6%E3%80%81%E5%89%8D%E8%87%AA%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">14.0.2.</span> <span class="toc-text">2 .前自操作符、前自操作符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">14.0.3.</span> <span class="toc-text">3.转换运算符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%80%BB%E7%BB%93"><span class="toc-number">14.0.4.</span> <span class="toc-text">4.总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81%E7%BB%A7%E6%89%BF"><span class="toc-number">15.</span> <span class="toc-text">十三、继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%AF%AD%E6%B3%95"><span class="toc-number">15.1.</span> <span class="toc-text">1.语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-number">15.2.</span> <span class="toc-text">2.派生类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">15.2.0.1.</span> <span class="toc-text">&lt; 1 &gt; 派生类的成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F"><span class="toc-number">15.2.0.2.</span> <span class="toc-text">&lt; 2 &gt;派生类对象的空间大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B8%AD%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">15.2.0.3.</span> <span class="toc-text">&lt; 3 &gt;派生类中成员的访问控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84"><span class="toc-number">15.2.0.4.</span> <span class="toc-text">&lt; 4 &gt;派生类的构造和析构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">15.2.0.4.1.</span> <span class="toc-text">1.派生类的构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">15.2.0.4.2.</span> <span class="toc-text">2.派生类的析构函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E8%B5%8B%E5%80%BC%E5%87%BD%E6%95%B0"><span class="toc-number">15.2.0.5.</span> <span class="toc-text">&lt; 5 &gt;派生类的拷贝构造和赋值函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E7%BB%A7%E6%89%BF%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">15.2.0.6.</span> <span class="toc-text">&lt; 6 &gt;继承的选择</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">15.2.0.6.1.</span> <span class="toc-text">1.继承的含义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-public%E7%BB%A7%E6%89%BF"><span class="toc-number">15.2.0.6.2.</span> <span class="toc-text">2.public继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-private%E7%BB%A7%E6%89%BF"><span class="toc-number">15.2.0.6.3.</span> <span class="toc-text">3.private继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-protected%E7%BB%A7%E6%89%BF"><span class="toc-number">15.2.0.6.4.</span> <span class="toc-text">4.protected继承</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E7%BB%A7%E6%89%BF%E5%92%8C%E7%BB%84%E5%90%88%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">15.2.0.7.</span> <span class="toc-text">&lt; 7 &gt;继承和组合的选择</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">15.2.0.7.1.</span> <span class="toc-text">1.组合与继承</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E7%BB%A7%E6%89%BF%E4%B8%8B%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">15.2.0.8.</span> <span class="toc-text">&lt; 8 &gt;.继承下的类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%9F%BA%E7%B1%BB%E5%90%91%E6%B4%BE%E7%94%9F%E7%B1%BB%E8%BF%9B%E8%A1%8C%E8%BD%AC%E6%8D%A2%EF%BC%88%E5%90%91%E4%B8%8B%E8%BD%AC%E6%8D%A2%EF%BC%89"><span class="toc-number">15.2.0.8.0.1.</span> <span class="toc-text">1.基类向派生类进行转换（向下转换）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E4%BB%8E%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%90%91%E5%9F%BA%E7%B1%BB%E8%BD%AC%E6%8D%A2"><span class="toc-number">15.2.0.8.0.2.</span> <span class="toc-text">2.从派生类向基类转换</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">15.3.</span> <span class="toc-text">3.多重继承</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%A0%BC%E5%BC%8F%EF%BC%9A"><span class="toc-number">15.3.0.0.1.</span> <span class="toc-text">&lt; 1 &gt;格式：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">15.3.0.0.2.</span> <span class="toc-text">&lt; 2 &gt;派生类构造和析构顺序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E6%94%BE%E6%A0%BC%E5%BC%8F"><span class="toc-number">15.3.0.0.3.</span> <span class="toc-text">&lt; 3 &gt;派生类对象的数据存放格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%90%8D%E5%AD%97%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98"><span class="toc-number">15.3.0.0.4.</span> <span class="toc-text">&lt; 4 &gt;名字冲突问题</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%88%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%EF%BC%89%EF%BC%9A"><span class="toc-number">15.3.0.0.4.1.</span> <span class="toc-text">其他解决方案（其他语言）：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E8%99%9A%E5%9F%BA%E7%B1%BB"><span class="toc-number">15.3.0.0.5.</span> <span class="toc-text">&lt; 5 &gt;虚基类</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81%E8%99%9A%E6%9C%BA%E5%88%B6"><span class="toc-number">16.</span> <span class="toc-text">十四、虚机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9D%99%E6%80%81%E7%BC%96%E8%81%94-%E5%8A%A8%E6%80%81%E7%BC%96%E8%81%94"><span class="toc-number">16.0.1.</span> <span class="toc-text">1.静态编联 动态编联</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8C%BA%E5%88%AB"><span class="toc-number">16.0.1.0.1.</span> <span class="toc-text">&lt; 1 &gt;区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">16.0.2.</span> <span class="toc-text">2.虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%A0%BC%E5%BC%8F"><span class="toc-number">16.0.2.0.1.</span> <span class="toc-text">&lt; 1 &gt;格式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%EF%BC%88%E8%99%9A%E6%8B%9F%E8%A1%A8%E3%80%81%E8%99%9A%E8%A1%A8%E3%80%81VTable%EF%BC%89"><span class="toc-number">16.0.3.</span> <span class="toc-text">3.虚函数表（虚拟表、虚表、VTable）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%99%9A%E8%A1%A8"><span class="toc-number">16.0.3.0.1.</span> <span class="toc-text">&lt; 1 &gt;虚表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E9%A1%BA%E5%BA%8F"><span class="toc-number">16.0.3.0.2.</span> <span class="toc-text">&lt; 2 &gt;顺序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">16.0.3.0.3.</span> <span class="toc-text">&lt; 3 &gt;运行过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E4%BD%9C%E7%94%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">16.0.3.0.4.</span> <span class="toc-text">&lt; 4 &gt;作用机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">16.0.4.</span> <span class="toc-text">4.抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E5%85%B7%E4%BD%93%E7%B1%BB"><span class="toc-number">16.0.4.1.</span> <span class="toc-text">&lt; 1 &gt;抽象类和具体类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%9A%E4%B9%89"><span class="toc-number">16.0.4.2.</span> <span class="toc-text">&lt; 2 &gt;定义</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%94%E3%80%81%E5%A4%9A%E6%80%81"><span class="toc-number">17.</span> <span class="toc-text">十五、多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-number">17.1.</span> <span class="toc-text">1.多态性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81"><span class="toc-number">17.1.1.</span> <span class="toc-text">&lt; 1 &gt;静态多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81"><span class="toc-number">17.1.2.</span> <span class="toc-text">&lt; 2 &gt;动态多态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%99%9A%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">17.2.</span> <span class="toc-text">2.虚机制的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%99%9A%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">17.3.</span> <span class="toc-text">3.虚机制的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%88%B6%E7%B1%BB%E6%8F%90%E4%BE%9B%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%AD%90%E7%B1%BB%E6%8F%90%E4%BE%9B%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">17.3.0.1.</span> <span class="toc-text">&lt; 1 &gt;父类提供接口，子类提供具体实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%88%B6%E7%B1%BB%E6%8F%90%E4%BE%9B%E6%A1%86%E6%9E%B6%EF%BC%8C%E5%AD%90%E7%B1%BB%E6%8F%90%E4%BE%9B%E7%BB%86%E8%8A%82"><span class="toc-number">17.3.0.2.</span> <span class="toc-text">&lt; 2 &gt;父类提供框架，子类提供细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%99%9A%E6%8B%9F%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0"><span class="toc-number">17.3.0.3.</span> <span class="toc-text">&lt; 3 &gt;虚拟的拷贝构造</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%99%9A%E6%9C%BA%E5%88%B6%E7%9A%84%E6%84%8F%E4%B9%89%E5%92%8C%E4%B8%8D%E8%B6%B3"><span class="toc-number">17.4.</span> <span class="toc-text">4.虚机制的意义和不足</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%85%AD%E3%80%81%E5%85%B3%E7%B3%BB"><span class="toc-number">18.</span> <span class="toc-text">十六、关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%B0%B4%E5%B9%B3%E5%85%B3%E7%B3%BB"><span class="toc-number">18.0.0.1.</span> <span class="toc-text">&lt; 1 &gt;水平关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9E%82%E7%9B%B4%E5%85%B3%E7%B3%BB"><span class="toc-number">18.0.0.2.</span> <span class="toc-text">&lt; 2 &gt; 垂直关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9F%BA%E6%9C%AC%E7%BB%84%E5%90%88"><span class="toc-number">18.0.0.3.</span> <span class="toc-text">&lt; 3 &gt;基本组合</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BE%9D%E8%B5%96-%E7%BB%A7%E6%89%BF%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%9E%8B%EF%BC%89"><span class="toc-number">18.0.0.3.1.</span> <span class="toc-text">1.依赖+继承（基本型）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%85%B3%E8%81%94%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="toc-number">18.0.0.4.</span> <span class="toc-text">&lt; 2 &gt;关联和继承</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%83%E3%80%81%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">19.</span> <span class="toc-text">十七、六大设计原则</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/30/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" title="软件工程">软件工程</a><time datetime="2024-10-30T02:05:51.000Z" title="发表于 2024-10-30 10:05:51">2024-10-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%8D%E4%B9%A0/" title="设计模式复习">设计模式复习</a><time datetime="2024-10-28T12:54:46.000Z" title="发表于 2024-10-28 20:54:46">2024-10-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/13/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1_cpp/" title="面向对象程序设计">面向对象程序设计</a><time datetime="2024-10-13T01:53:10.000Z" title="发表于 2024-10-13 09:53:10">2024-10-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/07/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="&lt;算法竞赛进阶指南&gt;读书笔记">&lt;算法竞赛进阶指南&gt;读书笔记</a><time datetime="2024-10-07T03:40:48.000Z" title="发表于 2024-10-07 11:40:48">2024-10-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/02/cf/" title="题解--Codeforces Round 680 [C. Division]">题解--Codeforces Round 680 [C. Division]</a><time datetime="2024-10-02T14:44:09.000Z" title="发表于 2024-10-02 22:44:09">2024-10-02</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://pic1.zhimg.com/80/v2-908b61a41ec4bebe17a04468dcf5d834_720w.webp')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By klklkl</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>